<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="InnoDB存储引擎"><meta name="keywords" content="MySQL"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>InnoDB存储引擎 | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB存储引擎"><span class="toc-number">1.</span> <span class="toc-text">InnoDB存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#后台线程"><span class="toc-number">1.1.</span> <span class="toc-text">后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Master-Thread"><span class="toc-number">1.1.1.</span> <span class="toc-text">Master Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-Thread"><span class="toc-number">1.1.2.</span> <span class="toc-text">IO Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Purge-Thread"><span class="toc-number">1.1.3.</span> <span class="toc-text">Purge Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Cleaner-Thread"><span class="toc-number">1.1.4.</span> <span class="toc-text">Page Cleaner Thread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB内存"><span class="toc-number">1.2.</span> <span class="toc-text">InnoDB内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存池"><span class="toc-number">1.2.1.</span> <span class="toc-text">缓存池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU-List、Free-List-和-Flush-List"><span class="toc-number">1.2.2.</span> <span class="toc-text">LRU List、Free List 和 Flush List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重做日志缓冲"><span class="toc-number">1.2.3.</span> <span class="toc-text">重做日志缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#额外的内存池"><span class="toc-number">1.2.4.</span> <span class="toc-text">额外的内存池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB存储引擎三大特性"><span class="toc-number">1.3.</span> <span class="toc-text">InnoDB存储引擎三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#插入缓冲"><span class="toc-number">1.3.1.</span> <span class="toc-text">插入缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#聚簇索引与非聚簇索引的区别"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">聚簇索引与非聚簇索引的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#高并发后的insert会发生什么？"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">高并发后的insert会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插入缓冲的实现"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">插入缓冲的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-buffer内部实现原理"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">insert buffer内部实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓冲的限制条件"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">缓冲的限制条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插入缓冲性能影响"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">插入缓冲性能影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#观察"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">观察</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二次写（double-write）"><span class="toc-number">1.3.2.</span> <span class="toc-text">二次写（double write）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基本概念"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#页断裂（partial-write）"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">页断裂（partial write）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据库日志的三种格式"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">数据库日志的三种格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#页断裂和数据一致性"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">页断裂和数据一致性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo格式与数据一致性"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">redo格式与数据一致性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doubleWrite的实现"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">doubleWrite的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doubleWrite的保护机制"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">doubleWrite的保护机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doubleWrite对性能的影响"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">doubleWrite对性能的影响</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自适应哈希索引"><span class="toc-number">1.3.3.</span> <span class="toc-text">自适应哈希索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#状态监控"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">状态监控</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#限制"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自适应哈希索引的控制"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">自适应哈希索引的控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他关键特性"><span class="toc-number">1.3.4.</span> <span class="toc-text">其他关键特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#异步IO"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">异步IO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#刷新邻接页"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">刷新邻接页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#启动、关闭和恢复"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">启动、关闭和恢复</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">104</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">70</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">InnoDB存储引擎</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-29</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p>
<h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>Master Thread是一个非常核心的后台线程,主要负责将缓冲池的数据异步刷新到磁盘,保证数据的一致性,包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</p>
<h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>在InnoDB存储引擎使用大量的AIO（Async IO） 来处理IO请求，这样可以极大提高数据库的性能。<br>在Linux平台下 IO Thread的数量不能进行调整，在windows平台1.0.x版本开始 分别使用 innodb_read_io_threads 和 innodb_write_io_theads参数进行设置,如:</p>
<p>mysql&gt;SHOW VARIABLES LIKE ‘innodb_version’\G;</p>
<p>mysql&gt; SHOW VARIABLES LIKE ‘innodb_%io_threads’\G;</p>
<p>通过SHOW ENGINE INNODB STATUS\G; 观察 InnoDB 中的IO Thread。</p>
<h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>事务被提交后,其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。<br>在InnoDB 1.1 版本中 innodb_purge_rgreads设为大于1,存储启动将其设为1,并报错。</p>
<p>在InnoDB1.2版本开始 InnoDB 支持多个Purge Thread。</p>
<h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>Page Cleaner Thread在InnoDB 1.2.x版本中引入的。其作用是将之前版本中的脏页的刷新操作放入到单独的线程中完成。</p>
<h3 id="InnoDB内存"><a href="#InnoDB内存" class="headerlink" title="InnoDB内存"></a>InnoDB内存</h3><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>InnoDB存储引擎是基于磁盘存储的,并将其中的记录按照页的方式进行管理。<br>缓存池简单来说就是一块内存区域。</p>
<p>通过参数innodb_buffer_pool_size配置缓存池: show variables like ‘innodb_buffer_pool_size’\G</p>
<p>内存结构：</p>
<p><img src="https://box.kancloud.cn/4cd2284ff4362e47710ebe90aa9fc9d4_794x299.png" alt=""></p>
<p>具体来看缓冲池中缓存的数据页类型有:<br>索引页: 缓存数据表索引<br>数据页: 缓存数据页，占缓冲池的绝大部分<br>undo页: undo页是保存事务，为回滚做准备的。<br>插入缓冲(Insert buffer): 上面提到的插入数据时要先插入到缓存池中。<br>自适应哈希索引(adaptive hash index): 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。<br>InnoDB存储的锁信息(lock info):<br>数据字典(data dictionary):<br>内存中除了缓冲池外外还有:<br>重做日志缓冲redo log: 为了避免数据丢失的问题，当前数据库系统普遍采用了write ahead log策略，既当事务提交时先写重做日志，再修改写页。当由于发生宕机而导致数据丢失时，可以通过重做日志进行恢复。InnoDB先将重做日志放到这个缓冲区，然后按照一定的频率更新到重做日志文件中。重做日志一般在下列情况下会刷新内容到文件:</p>
<p>1.Master Thread每一秒将重做日志缓冲刷新到重做日志文件<br>2.每个事务提交时会将重做日志缓冲刷新到重做日志文件<br>3.当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件<br>额外内存池: InnoDB存储引擎中，对内存的管理师通过一种称为内存堆的方式进行的，在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。<br>缓冲池是一个很大的内存区域，InnoDB是如何对这些内存进行管理的呢。答案就使用LRU list。<br>LRU(Latest Recent Used, 最近最少使用)算法默认的是最近使用的放到表头，最早使用的放到表尾，依次排列。当有LRU填满时有新的进来就把最早的淘汰掉。InnoDB则是在这个基础上进行了修改:</p>
<p>最近使用的不放到表头，而是根据配置放到一定比例处，这个地方叫做midpoint, midpoint之前的成为new列表，之后的成为old列表。淘汰的同样是表尾的页。<br>为了保证new列表的不经常使用时能够淘汰，设置了一个超时时间:innodb_old_blocks_time，当数据在midpoint(我理解应该是在old列表中，不然这个点的页就一个，变化也比较频繁)的时间超过找个时间时就会被提升到表头，new列表的表尾页则被置换到old列表中。<br>这么做的原因主要是因为常见的索引或数据的扫描操作会连续读取大量的页，甚至是全表扫描。如果采用原来的LRU算法就会更新全部的缓冲池，其他查询需要的热点数据就会被冲走，导致更多的磁盘读取操作，降低数据库的性能。<br>LRU是用来管理已经读取的页，当数据库启动时LRU是空列表,既只有表头，没有内容。这时页都放在Free List中。当需要有数据读写时要进行需要获取分页，这时要从Free List中删除分页，然后添加到LRU list中。到一定时间Free List中的分页就会被分配完毕，这时候就正常使用上面的LRU策略。<br>LRU列表中的页被修改后，称该页为脏页(dirty page),既缓冲池中的数据和磁盘上的数据产生了不一致，这时脏页会被加入到一个Flush 列表中(注意，同时存在两个列表中)。然后根据刷新的机制定时的刷新到磁盘中。</p>
<p>InnoDB 1.0.x开始允许多个缓存实例。</p>
<p>参数innodb_buffer_pool_instances来进行配置 默认唯一。</p>
<p><img src="https://box.kancloud.cn/3908739be0890daefa25489ed6c4d488_700x94.png" alt=""></p>
<p>参数innodb_buffer_pool_instances可以设置大于1的值就可以得到多个缓冲池实例。</p>
<p>再通过命令SHOW ENGINE INNODB STATUS\G; 观察内容</p>
<p>mysql5.6开始:<br>SELECT POOL_ID POOL_SIZE, FREE_BUFFERS,DATABASE_PAGES FROM INNODB_BUFFER_POOL_STATS\G<br>查看缓冲状态。</p>
<h4 id="LRU-List、Free-List-和-Flush-List"><a href="#LRU-List、Free-List-和-Flush-List" class="headerlink" title="LRU List、Free List 和 Flush List"></a>LRU List、Free List 和 Flush List</h4><p>缓存池默认页大小16kB，同样使用LRU算法进行缓冲池进行管理。</p>
<p><img src="https://box.kancloud.cn/8b5de1bc2ab5e5df499a92cdd1e15757_802x363.png" alt=""></p>
<p>通过information_schema架构下的表观察unzip_LRU列表中的页:SELECT TABLE_NAME,SPACE,PAGE_NUMBER,COMPRESSED_SIZE FROM INNODB_BUFFER_PAGE_LRU WHERE C OMPRSSED_SIZE &lt;&gt; 0;</p>
<p>Flush List为脏页列表;</p>
<p><img src="https://box.kancloud.cn/0a771448997c98db048fddca47971938_792x154.png" alt=""></p>
<h4 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h4><p><img src="https://box.kancloud.cn/f75f7e4ec65857de30137f676e37cc77_841x328.png" alt=""></p>
<h4 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h4><p>在对一些数据结构本身的内存进行分配时,需要从额外的内存池中进行申请,当该区域的内存不够的时候,会从缓冲池进行申请。</p>
<h3 id="InnoDB存储引擎三大特性"><a href="#InnoDB存储引擎三大特性" class="headerlink" title="InnoDB存储引擎三大特性"></a>InnoDB存储引擎三大特性</h3><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><p>innodb使用insert buffer”欺骗”数据库:对于为非唯一索引，辅助索引的修改操作并非实时更新索引的叶子页,而是把若干对同一页面的更新缓存起来做合并为一次性更新操作,转化随机IO 为顺序IO,这样可以避免随机IO带来性能损耗，提高数据库的写性能。</p>
<p><img src="https://box.kancloud.cn/d68efa9ed3220fc7016e36450b2a534e_826x388.png" alt=""></p>
<p>IBUF_POOL_SIZE_PER_MAX_SIZE参数修改默认为2 即为最大缓存为1/2 如果将其改为3 这最大能够使用1/3的缓存池内存。</p>
<h5 id="聚簇索引与非聚簇索引的区别"><a href="#聚簇索引与非聚簇索引的区别" class="headerlink" title="聚簇索引与非聚簇索引的区别"></a>聚簇索引与非聚簇索引的区别</h5><p>聚集索引的叶子节点存储的是数据，而且是按照物理顺序存储的;非聚集索引叶子节点是地址(也就是聚集索引键地址)，是按照逻辑顺序存储的(以上言论是从网上了解到的，但是，聚集索引也不是按照物理地址连续的，而是逻辑上连续的)。</p>
<h5 id="高并发后的insert会发生什么？"><a href="#高并发后的insert会发生什么？" class="headerlink" title="高并发后的insert会发生什么？"></a>高并发后的insert会发生什么？</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t ( id int auto_increment, </span><br><span class="line">name varchar(30),primary key (id),key(name));  </span><br><span class="line">Query OK, 0 rows affected (0.21 sec)</span><br></pre></td></tr></table></figure>

<p>我们知道，主键是行唯一的标识符，在应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要磁盘的随机读取，速度会很快，但是我们看到上一个表还有一个叫做name的索引字段，这样的情况下产生了一个非聚集的并且不是唯一的索引。在进行插入操作时，数据页的存放还是按主键id的执行顺序存放，但是对于非聚集索引，叶子节点的插入不再是顺序的了。这时就需要离散地访问非聚集索引页，插入性能在这里变低了。然而这并不是这个name字段上索引的错误，是因为B+树的特性决定了非聚集索引插入的离散性</p>
<h5 id="插入缓冲的实现"><a href="#插入缓冲的实现" class="headerlink" title="插入缓冲的实现"></a>插入缓冲的实现</h5><p><img src="http://www.plantuml.com/plantuml/svg/LKvB2e906DxFAMPfLz1TkuuHD98G5iwqQ5U14j6Bx06zo22em5wOA5YdyH_r5WtOfc_vlIah6mp9V3m5yyXx2xxs-EAk84t5KhRTfPrLjhOIxm3HF7DUi3abaGtMap_sSU0MCAiI7KijGWi82yY9Y8-EUPk2I8qIBEdrdyXd7q77GJiEBYMT4eFXObDLYG6tC7queb39ZN1TyQN_RvaEqey9_NF-1SO-k9Eqtqsw8Knw4FhS7iRlZTZKAvgAAAitlW00" alt=""></p>
<p>在innodb的1.0x版本开始，引入了change buffer，可以把它看成insert buffer的升级版，innodb可以对DML操作-INSERT/DELETE/UPDATE都进行缓冲。<br>1.将一个辅助索引插入到页(space,offset)<br>2.检查这个页是否在缓冲池中<br>在:直接插入<br>不在:继续<br>3.缓存进入insert buffer<br>4.构造一个search key<br>5.查询insert buffer树<br>6.生成逻辑记录并插入树中</p>
<h5 id="insert-buffer内部实现原理"><a href="#insert-buffer内部实现原理" class="headerlink" title="insert buffer内部实现原理"></a>insert buffer内部实现原理</h5><p>在mysql4.1版本之后，insert buffer是通过一全局唯一的一个B+树进行管理所有表的辅助索引。而这颗树存放在共享表空间中，格式为ibdata1，所以如果试图通过独立表空间idb文件恢复表中数据的时候，往往会导致CHECK TABLE失败，这是因为表的辅助索引中的数据可能还在INSERT BUFFER中，也就是共享表空间中，所以通过ibd文件进行恢复后，还需要进行REPAIR TABLE 操作来重建表上所有的辅助索引。</p>
<p>insert buffer的b+树的非叶子节点存放的是查询的search key（键值），其构造如图：</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/8.png" alt=""></p>
<ul>
<li>space为表空间id</li>
<li>marker用来兼容老版本</li>
<li>offset表示页所在偏移量</li>
</ul>
<p>叶子节点会比非叶子节点多俩数据，一个是metadata，一个是secondary index record。</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/7.png" alt=""></p>
<ul>
<li>metadata 记录的每一列的类型,长度</li>
<li>secondary index record 记录的具体值</li>
</ul>
<p>为了保证每个辅助索引页Merge Insert Buffer的B+树必须成功，还需要有一个特殊的页用来标记每个辅助索引页（space，page_no）的可用空间。这个页的类型为Insert Buffer Bitmap。它会标记16385个辅助索引页，每个辅助索引页会在其中占用4bit的位置来记录信息，具体信息如下：</p>
<p>Merge Insert Buffer的操作可能发生在以下几种情况下：</p>
<ul>
<li>辅助索引页被读取到缓冲池时；</li>
<li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；</li>
<li>Master Thread。</li>
</ul>
<p>第一种情况为当辅助索引页被读取到缓冲池中时，例如这在执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中。若有，则将Insert Buffer B+树中该页的记录插入到该辅助索引页中。可以看到对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。<br>Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间。若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。这就是上述所说的第二种情况。<br>还有一种情况，之前在分析Master Thread时曾讲到，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。</p>
<h5 id="缓冲的限制条件"><a href="#缓冲的限制条件" class="headerlink" title="缓冲的限制条件"></a>缓冲的限制条件</h5><p>插入缓冲的启用需要满足一下两个条件：<br>1）索引是辅助索引（secondary index）<br>2）索引不适合唯一的<br>原因是因为插入缓冲本身就是为了解决二级索引离散插入的问题，所以建立一个缓冲区将部分离散的索引数据合并，使用一次大的IO操作统一刷到磁盘，如果索引是唯一的，那这么做将失去意义，而且每次还需要去询问数据页是否已经存在，还会增加额外的IO操作。</p>
<h5 id="插入缓冲性能影响"><a href="#插入缓冲性能影响" class="headerlink" title="插入缓冲性能影响"></a>插入缓冲性能影响</h5><p>任何一项技术在带来好处的同时，必然也带来坏处。插入缓冲主要带来如下两个坏处：<br>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p>
<h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\g;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">2</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="number">0.00</span> <span class="keyword">hash</span> searches/s, <span class="number">0.00</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>从上面可以看到其中有一部分叫做INSERT BUFFER AND ADAPTIVE HASH INDEX，其中的seg size指的就是当前insert buffer的大小，具体计算方式为seg_size*16KB =32KB，free list len表示空闲列表的长度，size表示已经合并记录页的数量。</p>
<h4 id="二次写（double-write）"><a href="#二次写（double-write）" class="headerlink" title="二次写（double write）"></a>二次写（double write）</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>doublewrite由两部分组成,一部分是内存的doublewrite buffer,大小为2MB,另一部分是物理磁盘上共享表空间中联系的128个页,即2个区(extent),大小同样为2MB。<br>脏读刷新先复制到内存中的doublewrite buffer，之后doublewrite buffer再分两次，每次1MB写入共享表空间的物理磁盘，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。如图：</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/12.png" alt=""></p>
<p>通过命令SHOW GLOBAL STATUS LIKE ‘innodb dblwr%’\G观察doublewrite运行的情况。</p>
<h5 id="页断裂（partial-write）"><a href="#页断裂（partial-write）" class="headerlink" title="页断裂（partial write）"></a>页断裂（partial write）</h5><p>所谓页断裂是数据库宕机时(OS重启，或主机掉电重启)，数据库页面只有部分写入磁盘，导致页面出现不一致的情况。那么为什么会不一样呢？因为数据库，OS和磁盘读写的基本单位是块，也可以称之为(page size)block size。我们知道数据库的块一般为8K，16K；而OS的块则一般为4K；IO块则更小，linux内核要求IO block size&lt;=OS block size。磁盘IO除了IO block size，还有一个概念是扇区(IO sector)，扇区是磁盘物理操作的基本单位，而IO 块是磁盘操作的逻辑单位，一个IO块对应一个或多个扇区，扇区大小一般为512个字节。所以各个块大小的关系可以梳理如下：<br>DB block &gt; OS block &gt;= IO block &gt; 磁盘 sector，而且他们之间保持了整数倍的关系。所以说当数据库突然宕机，就会造成部分DB block的数据实际上并未写入到磁盘的sector中，出现了页断裂的情况，进而导致数据不一致的现象。</p>
<h5 id="数据库日志的三种格式"><a href="#数据库日志的三种格式" class="headerlink" title="数据库日志的三种格式"></a>数据库日志的三种格式</h5><p>数据库系统实现日志主要有三种格式，逻辑日志(logical logging)，物理日志(physical logging)，物理逻辑日志(physiological logging)，逻辑日志，记录一个个逻辑操作，不涉及物理存储位置信息，比如mysql的binlog；物理日志，则是记录一个个具体物理位置的操作，比如在2号表空间，1号文件，48页的233这个offset地方写入了8个字节的数据，通过(group_id,file_id,page_no,offset)4元组，就能唯一确定数据存储在磁盘的物理位置；物理逻辑日志是物理日志和逻辑日志的混合，如果一个数据库操作(DDL，DML，DCL)产生的日志跨越了多个页面，那么会产生多个物理页面的日志，但对于每个物理页面日志，里面记录则是逻辑信息。这里我举一个简单的INSERT操作来说明几种日志形式。<br>比如innodb表T(c1,c2, key key_c1(c1)),插入记录row1(1,’abc’)<br>逻辑日志：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert OP, T, 1,’abc’&gt;</span><br></pre></td></tr></table></figure>

<p>逻辑物理日志：因为表T含有索引key_c1, 一次插入操作至少涉及两次B树操作，二次B树必然涉及至少两个物理页面,因此至少有两条日志</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert OP, page_no_1, log_body&gt;</span><br><span class="line">&lt;insert OP, page_no_2, log_body&gt;</span><br></pre></td></tr></table></figure>

<p>物理理日志：由于一次INSERT操作，物理上来说要修改页头信息(如,页内的记录数要加1)，要修改相邻记录里的链表指针，要修改Slot属性等，因此对应逻辑物理日志的每一条日志，都会有N条物理日志产生。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; group_id,file_id,page_no,offset1, value1&gt;</span><br><span class="line">&lt; group_id,file_id,page_no,offset2, value2&gt;</span><br><span class="line">……</span><br><span class="line">&lt; group_id,file_id,page_no,offsetN, valueN&gt;</span><br></pre></td></tr></table></figure>

<p>因此对于上述一个INSERT操作，会产生一条逻辑日志，二条逻辑物理日志，2*N条物理日志。从上面简单的分析可以看出，逻辑日志的日志量最小，而物理日志的日志量最大；物理日志是纯物理的；而逻辑物理日志则页间物理，页内逻辑，所谓physical-to-a-page, logical-within-a-page。</p>
<h5 id="页断裂和数据一致性"><a href="#页断裂和数据一致性" class="headerlink" title="页断裂和数据一致性"></a>页断裂和数据一致性</h5><p>前面我们分析了异常重启导致页断裂的原因，而页断裂就意味着数据库页面不完整，那么数据库页面不完整就意味着数据库不一致。我们知道，数据库异常重启时，自身有异常恢复机制，主流数据库基本原理类似：第一阶段重做redo日志，恢复数据页和undo页到异常crash时的状态；第二阶段，根据undo页的内容，回滚没有提交事务的修改。通过两个阶段保证了数据库的一致性。对于mysql而言，在第一阶段，若出现页断裂问题，则无法通过重做redo日志恢复，进而导致恢复中断，数据库不一致。这里大家可能会有疑问，数据库的redo不是记录了所有的变更，并且是物理的吗？理论上来说，无论页面是否断裂，从上一个检查点对应的redo位置开始，一直重做redo，页面自然能恢复到正常状态。对吗？</p>
<h5 id="redo格式与数据一致性"><a href="#redo格式与数据一致性" class="headerlink" title="redo格式与数据一致性"></a>redo格式与数据一致性</h5><p>回到“发生页断裂后，是否会影响数据库一致性”的问题，发生页断裂后，对于利用纯物理日志实现redo的数据库不受影响，因为每一条redo日志完全不依赖物理页的状态，并且是幂等的(执行一次与N次，结果是一样的)，而逻辑物理日志则不行，比如修改页头信息，页内记录数加1，slot信息修改等都依赖于页面处于一个一致状态，否则就无法正确重做redo。而mysql正是采用这种日志类型，另外要说明一点，redo日志的页大小一般设计为512个字节，因此redo日志页本身不会发生页断裂。所以发生页面断裂时，异常恢复就会出现问题，需要借助于double write技术来辅助处理。</p>
<h5 id="doubleWrite的实现"><a href="#doubleWrite的实现" class="headerlink" title="doubleWrite的实现"></a>doubleWrite的实现</h5><p>在InnoDB将BP中的Dirty Page刷（flush）到磁盘上时，首先会将（memcpy函数）Page刷到InnoDB tablespace的一个区域中，我们称该区域为Double write Buffer（大小为2MB，每次写入1MB，128个页，每个页16k,其中120个页为后台线程的批量刷Dirty Page，还有8个也是为了前台起的sigle Page Flash线程，用户可以主动请求，并且能迅速的提供空余的空间）。在向Double write Buffer写入成功后，第二步、再将数据分别刷到一个共享空间和真正应该存在的位置。具体的流程如下图所示：<br><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/9.png" alt=""></p>
<h5 id="doubleWrite的保护机制"><a href="#doubleWrite的保护机制" class="headerlink" title="doubleWrite的保护机制"></a>doubleWrite的保护机制</h5><p>下面来看下在不同的写入阶段，操作系统crash后，double write带来的保护机制：</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/10.png" alt=""></p>
<p>阶段一：copy过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可阶段二：write到共享表空间过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可阶段三：write到独立表空间过程中，操作系统crash，重启之后，发现：（1）数据文件内的页损坏：头尾checksum值不匹配（即出现了partial page write的问题）。从共享表空间中的doublewrite segment内恢复该页的一个副本到数据文件，再应用redo log；（2）若页自身的checksum匹配，但与doublewrite segment中对应页的checksum不匹配，则统一可以通过apply redo log来恢复。）阶段X：recover过程中，操作系统crash，重启之后，innodb面对的情况同阶段三一样（数据文件损坏，但共享表空间内有副本），再次应用redo log即可。</p>
<h5 id="doubleWrite对性能的影响"><a href="#doubleWrite对性能的影响" class="headerlink" title="doubleWrite对性能的影响"></a>doubleWrite对性能的影响</h5><p>系统需要将数据写两份，一般认为，Double Write是会降低系统性能的。peter猜测可能会有5-10%的性能损失，但是因为实现了数据的一致，是值得的。Mark Callaghan认为这应该是存储层面应该解决的问题，放在数据库层面无疑是牺牲了很多性能的。事实上，Double Write对性能影响并没有你想象（写两遍性能应该降低了50%吧？）的那么大。在BP中一次性往往会有很多的Dirty Page同时被flush，Double Write则把这些写操作，由随机写转化为了顺序写。而在Double Write的第二个阶段，因为Double Write Buffer中积累了很多Dirty Page，所以向真正的数据文件中写数据的时候，可能有很多写操作可以合并，这样有可能会降低Fsync的调用次数。基于上面的原因，Double Write并没有想象的那么糟。最后发现打开和关闭Double Write对效率的影响并不大。</p>
<h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>哈希索引只有Memory, NDB两种引擎支持，Memory引擎默认支持哈希索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储。但是，Memory引擎表只对能够适合机器的内存切实有限的数据集。要使InnoDB或MyISAM支持哈希索引，可以通过伪哈希索引来实现，但是innodb还实现了一种叫做自适应哈希索引来达到目的。<br>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>
<h5 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">……</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br></pre></td></tr></table></figure>

<p>1、34673：字节为单位，占用内存空间总量</p>
<p>2、通过hash searches、non-hash searches计算自适应hash索引带来的收益以及付出，确定是否开启自适应hash索引</p>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>　　1、只能用于等值比较，例如=， &lt;=&gt;，in<br>　　2、无法用于排序<br>　　3、有冲突可能<br>　　4、MySQL自动管理，人为无法干预。</p>
<h5 id="自适应哈希索引的控制"><a href="#自适应哈希索引的控制" class="headerlink" title="自适应哈希索引的控制"></a>自适应哈希索引的控制</h5><p>由于innodb不支持hash索引，但是在某些情况下hash索引的效率很高，于是出现了adaptive hash index功能，但是通过上面的状态监控，可以计算其收益以及付出，控制该功能开启与否。</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/11.png" alt=""></p>
<h4 id="其他关键特性"><a href="#其他关键特性" class="headerlink" title="其他关键特性"></a>其他关键特性</h4><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO,AIO）的方式来处理磁盘操作。<br>与AIO对应的是 Sync IO，Sync IO每次进行IO操作 需要等到改操作结束才能继续接下来的操作。但是如果用户是一条索引扫描的查询，那么需要扫描索引页，也就是需要进行多次的IO操作。如果是这样的话就没有必要了。</p>
<p>用户发送一个IO请求就可以发送另一个IO请求，当全部发送完毕，等待所有的IO操作的完成，这就是AIO。<br>AIO的另一个优势 可以进行IO Merge操作，也就是将多个IO何必为一个IO。<br>若通过Linux操作系统下的iostat 命令 可以观察 rrqm/s和wrqm/s。<br>InnoDB 1.1.x 开始（InnoDB Plugin 不支持）提供了内核级别AIO的支持，称为 NatIve AIO。因此编译或者运行该版本MySQL时需要libaio的支持。若没有则会出现如下的提示：</p>
<p><img src="https://box.kancloud.cn/caa0fef240a025c16fbe4d9d842f0009_846x84.png" alt=""></p>
<p>Native AIO只有windows 和linux系统支持。Mac OSX不支持。参数innodb_use_native_aio 控制师傅启动 liunx默认不启动。</p>
<p>SHOW VARIABLES LIKE ‘innodb_use_native_aio’\G</p>
<p><img src="https://box.kancloud.cn/18a374770ed2be0874341ccf079c9cf2_677x117.png" alt=""></p>
<p>官方显示，启用NatIve AIO，恢复速度可以提高75%。<br>read ahead方式读取都是通过AIO完成，脏页的刷新和磁盘写入操作则全部由AIO完成。</p>
<h5 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h5><p>InnoDB存储引擎还提供了Flush Neighbor Page(刷新邻接页)的特性。工作原理：当刷新脏页时，InnoDB存储引擎会检测所在区的所有页，如果是脏页，那么一起进行刷新。<br>参数innodb_flush_neighbors 控制是否启用改特性.如果是机械硬盘建议启用，如果是固态硬盘就不建议使用 IOPS性能的磁盘 则建议设置为0，关闭此特性。</p>
<h5 id="启动、关闭和恢复"><a href="#启动、关闭和恢复" class="headerlink" title="启动、关闭和恢复"></a>启动、关闭和恢复</h5><p>关闭时参数innodb_fast_shutdown影响着表存储引擎InnoDB的行为。该参数可取值为0、1、2，默认为1</p>
<p><img src="https://box.kancloud.cn/fc3c79f738da0285b045df30098e7257_824x319.png" alt=""></p>
<p>当正常关闭MySQL数据库时，下次的启动应该会非常“正常”。但是没有正常关闭 如用kill命令关闭数据库，在MySQL 数据库运行中重启服务器，或者关闭数据库时，将参数innodb_fast_shuidown设为了2时,下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p>
<p>参数innodb_force_recovery影响了正规InnoDB存储引擎恢复的状况。默认为0，代表当发生需要恢复时，进行所有恢复的操作，当不能进行有效恢复时，如数据页发送了corruption，MySQL数据库可能发送宕机（crash），并把错误写入错误日志中去。</p>
<p>如果用户知道怎么进行恢复 比如进行alter table操作是发生意外了，数据库重启会对InnoDB进行回滚操作，对于大表涞水需要很长时间，所以可以把表删除，从备份中导入数据到表。速度就会比回滚操作快。</p>
<p><img src="https://box.kancloud.cn/9b3c7309d263250656fdfb9387f8fbf9_804x237.png" alt=""></p>
<p>如果innodb_force_recovery 设置为3 则不需要回滚,因此数据库很快就启动完成了。 但是需要仔细确认是否需要回滚事务操作。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/01/error1/"><i class="fa fa-chevron-left">  </i><span>排错：mybatis报错：Invalid bound statement (not found)</span></a></div><div class="next-post pull-right"><a href="/2020/01/28/mysql2/"><span>事务的特性和隔离级别</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2025 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>