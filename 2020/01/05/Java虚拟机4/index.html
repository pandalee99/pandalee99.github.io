<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java虚拟机（四）垃圾回收的机制和算法"><meta name="keywords" content="Java虚拟机"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>Java虚拟机（四）垃圾回收的机制和算法 | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-number">1.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收机制"><span class="toc-number">1.1.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数算法"><span class="toc-number">1.1.1.</span> <span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可达分析算法"><span class="toc-number">1.1.2.</span> <span class="toc-text">可达分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用的状态"><span class="toc-number">1.1.3.</span> <span class="toc-text">引用的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的自救"><span class="toc-number">1.1.4.</span> <span class="toc-text">对象的自救</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回收方法区"><span class="toc-number">1.1.5.</span> <span class="toc-text">回收方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集算法"><span class="toc-number">1.2.</span> <span class="toc-text">垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分代收集算法"><span class="toc-number">1.2.1.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记—清除算法"><span class="toc-number">1.2.2.</span> <span class="toc-text">标记—清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-复制算法"><span class="toc-number">1.2.3.</span> <span class="toc-text">标记-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-整理算法"><span class="toc-number">1.2.4.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HotSpot算法的细节实现"><span class="toc-number">1.2.5.</span> <span class="toc-text">HotSpot算法的细节实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#枚举根节点"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">枚举根节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#安全点"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">安全点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#安全区域"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">安全区域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#记忆集与卡表"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">记忆集与卡表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#写屏障"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">写屏障</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发的可达性分析"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">并发的可达性分析</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/tou.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">83</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">57</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="http://antarctica.gitee.io/blog/" target="_blank" rel="noopener">码云的Blog</a><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gitee.com/antarctica/img_sotre/raw/img/img/xingkong2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Java虚拟机（四）垃圾回收的机制和算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>Java虚拟机除了支持了Java的跨平台性之外，最重要的就是虚拟机能够自动进行内存的回收，它不像C++那样，需要析构函数之类的去分配和管理内存，同样的也没有指针这个神奇的玩意，在处理不会再被使用的对象时，Java虚拟机会自动帮我们完成内存的回收。而所谓的内存回收，就叫做GC，也可以叫做垃圾收集，了解如何去完成Java的内存回收，对于我们使用Java，是一件非常重要的事情。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>我想从最简单的开始去描述这一个事物，假如，你需要去判断一个对象是否要被回收，判断的依据是什么呢？一般来说，那就是以后都不会再去使用它了，所以它需要被回收，那么对于这种方式，是使用着什么的计算方法去测试呢？我们可以从synchronized的重入上找思路，是不是可以做出一个计数器，当对象存在引用的时候，就计数器加一，直到对象不被引用，计数器就减一，当对象的计数器归零了，是不是就可以被回收了呢？我们可以做出一个例子看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">//JDK6</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[GC [DefNew: <span class="number">2546</span>K-&gt;<span class="number">173</span>K(<span class="number">4928</span>K), <span class="number">0.0029877</span> secs] <span class="number">2546</span>K-&gt;<span class="number">2221</span>K(<span class="number">15872</span>K), <span class="number">0.0030177</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System)</span> [Tenured: 2048K-&gt;173<span class="title">K</span><span class="params">(<span class="number">10944</span>K)</span>, 0.0106634 secs] 4403K-&gt;173<span class="title">K</span><span class="params">(<span class="number">15872</span>K)</span>, [Perm : 424K-&gt;424<span class="title">K</span><span class="params">(<span class="number">12288</span>K)</span>], 0.0107119 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">4992</span>K, used <span class="number">91</span>K [<span class="number">0x24450000</span>, <span class="number">0x249b0000</span>, <span class="number">0x299a0000</span>)</span><br><span class="line">  eden space <span class="number">4480</span>K,   <span class="number">2</span>% used [<span class="number">0x24450000</span>, <span class="number">0x24466d20</span>, <span class="number">0x248b0000</span>)</span><br><span class="line">  from space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x248b0000</span>, <span class="number">0x248b0000</span>, <span class="number">0x24930000</span>)</span><br><span class="line">  to   space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x24930000</span>, <span class="number">0x24930000</span>, <span class="number">0x249b0000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10944</span>K, used <span class="number">173</span>K [<span class="number">0x299a0000</span>, <span class="number">0x2a450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10944</span>K,   <span class="number">1</span>% used [<span class="number">0x299a0000</span>, <span class="number">0x299cb588</span>, <span class="number">0x299cb600</span>, <span class="number">0x2a450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">428</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb1a0</span>, <span class="number">0x344bb200</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码使得两个对象互相引用对方，这样的话就似乎永久不会被销毁了<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm5.jpg" alt="jvm5"></p>
<p>但接下来的GC日志告诉我们，事情并不是这样的，在进行自主选择的full GC(充分GC)当中，出现了4403K-&gt;173K(15872K)，可见的，就算互相引用，最终也会被销毁的，所以GC所使用的的算法，并不是这样。但也许你会说，它们都是变量，变量之间互相引用本来就是可以随意变换的，可能GC在对引用一个常量的时候，才会做出存活判断，而对变量都进行销毁。</p>
<h4 id="可达分析算法"><a href="#可达分析算法" class="headerlink" title="可达分析算法"></a>可达分析算法</h4><p>那么我们就使用一种是否引用常量的可达分析算法去判断他们吧</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm6.jpg" alt="jvm6"></p>
<p>这种方法，可以把一个GC roots作为不可被回收的引用池，所有连接在GC roots的都会是一直存活的对象，直到他们不引用任何GC Roots时，才去判断回收。可作为 GC Roots 的对象：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li>
</ul>
<h4 id="引用的状态"><a href="#引用的状态" class="headerlink" title="引用的状态"></a>引用的状态</h4><p>这样的算法很纯粹，但是太过狭隘，一个对象可否存活，直接用处引用还是未引用的状态去判断。虽然很科学，但是未必会贴合实际，我们更希望当内存空间还足够时，保留它们，而内存空间在进行一次垃圾回收后，仍然未够的话，就放弃它们。而之后，Java对这个对象的引用状态，又增加了很多概念：</p>
<ul>
<li>强引用：类似于 Object obj = new Object();`创建的，只要强引用在就不回收</li>
<li>软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li>
<li>弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h4 id="对象的自救"><a href="#对象的自救" class="headerlink" title="对象的自救"></a>对象的自救</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，就好像判了刑并不会立即处死一样，还有缓刑这个概念，这个倒是挺人性化的。在虚拟机中，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。那么我们来看看，对象如何自救：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">// * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> test SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize mehtod executed!"</span>);</span><br><span class="line">        test.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finalize mehtod executed!</span><br><span class="line">yes, i am still alive </span><br><span class="line">no, i am dead</span><br></pre></td></tr></table></figure>

<p>可以看到，被测试的对象，在覆盖了Finalizer方法之后，就有了一次暂时不死的机会，让其自救，而在使用了这个方法之后，对象仍然不知死活，那就真的要死了。但是Finalizer方法用系统的开销极大，后面也被废弃了，这里仅仅是谈谈而已。</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区之前被称之为永久代，这是一个误解，但事实也和所谓的永久代差不多。一般方法区是很少出现回收这个事件，如果出现回收，那么不外乎有两种情况：废弃的常量和无用的类。废弃的常量判断比较简单，那就是这个常量，比如“qwe”，它在堆中不会在有任何实例去引用它，那么它就暂时失去价值了，所以会被销毁。而无用的类的判断方法更为复杂一点，一般要满足一下三点：</p>
<ul>
<li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li>
<li>加载该类的 ClassLoader 已经被回收</li>
<li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>可达分析算法准确来说是一个判断垃圾是否需要被回收的一种机制，而我们的Jvm，对垃圾的收集，也有着不同的算法。这些算法建立在两个假说身上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生熄灭的。</li>
<li>强分代假说：熬过多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两种假说奠定了垃圾收集器一致性的原则。从而也有了“minor GC”，“MajorGC“，”Full GC“这样不同的回收类型。不同的回收类型对应的不同的分代，在内存块中，也会给对象标明是新生代还是老年代，以此做出区分，这样在每次进行内存回收的时候，能够大大的提高效率。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>现在的虚拟机多是使用这样的机制，把Java堆分成为新生代和老年代，根据各个代的特点，使用不同的算法，比如新生代每次GC，都会有70%~90%的对象被回收，所以使用的是复制算法，而在经历15次回收后，该对象就会进入到老年代。老年代使用的是标记清理或者标记整理算法来进行回收。</p>
<h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>最早诞生的垃圾收集算法叫做标记清楚算法。</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf1.jpg" alt="bjqc"></p>
<p>这种算法就是把需要被回收的空间标记出来，然后在进行回收，整体而言比较好理解，但是这样的算法有两个不足，一是效率不高，如果内存空间极大，就要进行大量的标记动作，二是空间上会产生大量的碎片。</p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>接着就是复制算法，它是为了解决标记清除算法面对大量可回收对象的时候，效率低下的问题。</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf2.jpg" alt="fzsf"></p>
<p>这种算法是把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。解决前一种方法的不足，但是会造成空间利用率低下。</p>
<p>因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。</p>
<p>当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>这种算法的标记过程和标记清除算法一样，只不过后面的步骤不是直接进行清除，而是让所有存活的对象都向内存空间的一段移动。</p>
<p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf3.jpg" alt="bjzlsf"></p>
<p>这种算法也是把需要回收的内存打标记，之后再进行整理，把所有存活的对象内存移动至一端，然后直接清理掉边界以外的内存。</p>
<h4 id="HotSpot算法的细节实现"><a href="#HotSpot算法的细节实现" class="headerlink" title="HotSpot算法的细节实现"></a>HotSpot算法的细节实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>前面说到使用的是可达分析算法去判断是否存在引用，而在判断的过程中，需要进行枚举根节点操作，去根节点寻找引用链。但是在应用越来越大的时候，可能仅仅方法区就有将近几百兆，要逐个检查他们的是否存在引用。另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为每次要进行枚举根节点的时候，为了线程之间不出错，也为了能够准确的找出所有的引用，会把所有的线程停顿下来，等待所有线程的停顿想必需要大量的时间。</p>
<p>在停顿下来的时候，其实并不需要一个不漏的检查完所有执行上下文和全局的引用位置。在寻找引用的时候，HotSpot还会用到一种名为OopMap的数据结构，一旦类加载动作完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译中，也会在特定的位置记录下栈里和寄存器里是哪里的引用。这样，收集器在扫描的时候，就可以直接得知这些信息，并不需要一个不漏地从方法区等GC Roots开始查找。</p>
<h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>因为OopMap的内容变化指令非常多，如果为每一条指令都生成对应的OopMap，将会需要大量的额外空间。但实际上，HotSpot也没有为每一条指令都生成OopMap，而是在程序执行到达Safepoint(安全点)的时候，才暂停下来，准备GC。那如何去判断程序是否到达安全点呢？HotSpot使用主动式中断的思想，当GC需要中断线程的时候，会设置一个标志，各个线程会主动去轮询这个标志，当满足安全中断的条件后，才会停下来进行GC</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>Safe Region(安全区域)，可以看作为是扩展了的安全点，当线程执行到安全区域时，会自行标识自己，在这段时候内，如果JVM需要GC，就会自行的进行暂停线程开始GC。</p>
<h5 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h5><p>在进行分代收集的时候，新生代和老年代都不是一个独立的个体，它们之间或多或少存在着一些互相引用的问题。如果要对老年代全部进行一次GC Roots，但是老年代却很少有内存是能够回收的，想必开销是非常大的。所以，为了避免这种情况，就在新生代中多了一个名为记忆集的数据结构。</p>
<p>记忆集是一种用于记录从非收集区域指向收集其余的指针集合的抽象数据结构，它也可以选择很多不同记忆精度面对不同的情况。一般选择的是<strong>卡精度</strong>，也被称为卡表，卡表最简单的形式可以只是一个字节数组，这个数组的每个key都有对应的卡页，一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象的字段存在跨代指针，就将key值标记为1，并称这个元素变脏了。在GC的时候，只会选择变脏的元素的对应区域进行GCRoots。</p>
<h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>有其他分代区域中对象的引用了本区域对象时，其对应的元素就会变脏。但这个过程只靠什么去维持的呢？这里可以引入类似于Synchronized的思想，去锁住它，于是便有了写屏障。在更改记忆集的时候，为了原子性得到保障，会使用这个写屏障去维护记忆集，但写屏障不仅仅这有这些作用，它还做到了类似于try-fianlly的操作，只不过这些都被封装起来了，就像Spring里面的AOP一样。</p>
<h5 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h5><p>当堆越来越大的时候，试图去进行根节点遍历就会变的困难起来。所以面对这种情况，就引入了多线程里面的概念，我们不将所有的线程都暂停后才进行GC，而是直接随着线程的执行而进行根节点遍历。</p>
<p>但这也引入了新的问题，那就是在多线程情况下的不确定性，比如把新生代要回收的内存区域错误标记成了老年代，这个是可以容忍的，但如果错误的把老年代标记为要被销毁的新生代，那可能会使程序崩溃，为了解决这种事务端，也诞生了两种解决方案：<strong>增量更新和原始快照</strong>。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java虚拟机</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/01/09/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/"><i class="fa fa-chevron-left">  </i><span>AQS队列同步器</span></a></div><div class="next-post pull-right"><a href="/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA3/"><span>Java虚拟机（三）虚拟机中的内存溢出</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://gitee.com/antarctica/img_sotre/raw/img/img/xingkong2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>