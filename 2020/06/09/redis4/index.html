<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入理解Redis（二）"><meta name="keywords" content="Redis"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>深入理解Redis（二） | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis的数据库"><span class="toc-number">1.</span> <span class="toc-text">Redis的数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器中的数据库"><span class="toc-number">1.0.1.</span> <span class="toc-text">服务器中的数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切换数据库"><span class="toc-number">1.0.2.</span> <span class="toc-text">切换数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#谨慎处理多数据库程序"><span class="toc-number">1.0.3.</span> <span class="toc-text">谨慎处理多数据库程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库键空间"><span class="toc-number">1.0.4.</span> <span class="toc-text">数据库键空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#添加新键"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">添加新键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除键"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">删除键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#更新键"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">更新键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对键取值"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">对键取值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其他键空间操作"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">其他键空间操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#读写键空间时的维护操作"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">读写键空间时的维护操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置键的生存时间或过期时间"><span class="toc-number">1.0.5.</span> <span class="toc-text">设置键的生存时间或过期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#设置过期时间"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">设置过期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#保存过期时间"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">保存过期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#移除过期时间"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">移除过期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#计算并返回剩余生存时间"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">计算并返回剩余生存时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#过期键的判定"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">过期键的判定</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#过期键删除策略"><span class="toc-number">1.0.6.</span> <span class="toc-text">过期键删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定时删除"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#惰性删除"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定期删除"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">定期删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis的过期键删除策略"><span class="toc-number">1.0.7.</span> <span class="toc-text">Redis的过期键删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#惰性删除策略的实现"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">惰性删除策略的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定期删除策略的实现"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">定期删除策略的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF、RDB和复制功能对过期键的处理"><span class="toc-number">1.0.8.</span> <span class="toc-text">AOF、RDB和复制功能对过期键的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#生成RDB文件"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">生成RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#载入RDB文件"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">载入RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF文件写入"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">AOF文件写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF重写"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">AOF重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#复制"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库通知"><span class="toc-number">1.0.9.</span> <span class="toc-text">数据库通知</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#发送通知"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">发送通知</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#发送通知的实现"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">发送通知的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重点回顾"><span class="toc-number">1.0.10.</span> <span class="toc-text">重点回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB持久化"><span class="toc-number">1.0.11.</span> <span class="toc-text">RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB文件的创建与载入"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">RDB文件的创建与载入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SAVE命令执行时的服务器状态"><span class="toc-number">1.0.11.2.</span> <span class="toc-text">SAVE命令执行时的服务器状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BGSAVE命令执行时的服务器状态"><span class="toc-number">1.0.11.3.</span> <span class="toc-text">BGSAVE命令执行时的服务器状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB文件载入时的服务器状态"><span class="toc-number">1.0.11.4.</span> <span class="toc-text">RDB文件载入时的服务器状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自动间隔性保存"><span class="toc-number">1.0.11.5.</span> <span class="toc-text">自动间隔性保存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置保存条件"><span class="toc-number">1.0.11.6.</span> <span class="toc-text">设置保存条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dirty计数器和lastsave属性"><span class="toc-number">1.0.11.7.</span> <span class="toc-text">dirty计数器和lastsave属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检查保存条件是否满足"><span class="toc-number">1.0.11.8.</span> <span class="toc-text">检查保存条件是否满足</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB文件结构"><span class="toc-number">1.0.12.</span> <span class="toc-text">RDB文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#databases部分"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">databases部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#key-value-pairs部分"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">key_value_pairs部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Value的编码"><span class="toc-number">1.0.12.3.</span> <span class="toc-text">Value的编码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析RDB文件"><span class="toc-number">1.0.13.</span> <span class="toc-text">分析RDB文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#不包含任何键值对的RDB文件"><span class="toc-number">1.0.13.1.</span> <span class="toc-text">不包含任何键值对的RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#包含字符串键的RDB文件"><span class="toc-number">1.0.13.2.</span> <span class="toc-text">包含字符串键的RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#包含带有过期时间的字符串键的RDB文件"><span class="toc-number">1.0.13.3.</span> <span class="toc-text">包含带有过期时间的字符串键的RDB文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#包含一个集合键的RDB文件"><span class="toc-number">1.0.13.4.</span> <span class="toc-text">包含一个集合键的RDB文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重点回顾-1"><span class="toc-number">1.0.14.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF持久化"><span class="toc-number">1.1.</span> <span class="toc-text">AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF持久化的实现"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">AOF持久化的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令追加"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">命令追加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF文件的写入与同步"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">AOF文件的写入与同步</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF文件的载入与数据还原"><span class="toc-number">1.1.1.</span> <span class="toc-text">AOF文件的载入与数据还原</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF重写-1"><span class="toc-number">1.1.2.</span> <span class="toc-text">AOF重写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF文件重写的实现"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">AOF文件重写的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF后台重写"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">AOF后台重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重点回顾-2"><span class="toc-number">1.1.3.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">1.2.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件事件"><span class="toc-number">1.2.1.</span> <span class="toc-text">文件事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#文件事件处理器的构成"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">文件事件处理器的构成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I-O多路复用程序的实现"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">I&#x2F;O多路复用程序的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件的类型"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">事件的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文件事件的处理器"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">文件事件的处理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-1"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#时间事件应用实例：serverCron函数"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">时间事件应用实例：serverCron函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件的调度与执行"><span class="toc-number">1.2.2.</span> <span class="toc-text">事件的调度与执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重点回顾-3"><span class="toc-number">1.2.3.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端"><span class="toc-number">1.3.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端属性"><span class="toc-number">1.3.1.</span> <span class="toc-text">客户端属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#套接字描述符"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">套接字描述符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#名字"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">名字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#标志"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">标志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输入缓冲区"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">输入缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令与命令参数"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">命令与命令参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令的实现函数"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">命令的实现函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出缓冲区"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">输出缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#身份验证"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">身份验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#时间"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">时间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端的创建与关闭"><span class="toc-number">1.3.2.</span> <span class="toc-text">客户端的创建与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建普通客户端"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">创建普通客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关闭普通客户端"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">关闭普通客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lua脚本的伪客户端"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Lua脚本的伪客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF文件的伪客户端"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">AOF文件的伪客户端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重点回顾-4"><span class="toc-number">1.3.3.</span> <span class="toc-text">重点回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器"><span class="toc-number">1.3.4.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令请求的执行过程"><span class="toc-number">1.3.5.</span> <span class="toc-text">命令请求的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#发送命令请求"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">发送命令请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#读取命令请求"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">读取命令请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令执行器（1）：查找命令实现"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">命令执行器（1）：查找命令实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令执行器（2）：执行预备操作"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">命令执行器（2）：执行预备操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令执行器（3）：调用命令的实现函数"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">命令执行器（3）：调用命令的实现函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令执行器（4）：执行后续工作"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">命令执行器（4）：执行后续工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#将命令回复发送给客户端"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">将命令回复发送给客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#客户端接收并打印命令回复"><span class="toc-number">1.3.5.8.</span> <span class="toc-text">客户端接收并打印命令回复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serverCron函数"><span class="toc-number">1.3.5.9.</span> <span class="toc-text">serverCron函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#更新服务器时间缓存"><span class="toc-number">1.3.5.10.</span> <span class="toc-text">更新服务器时间缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#更新LRU时钟"><span class="toc-number">1.3.5.11.</span> <span class="toc-text">更新LRU时钟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#更新服务器每秒执行命令次数"><span class="toc-number">1.3.5.12.</span> <span class="toc-text">更新服务器每秒执行命令次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#更新服务器内存峰值记录"><span class="toc-number">1.3.5.13.</span> <span class="toc-text">更新服务器内存峰值记录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#处理SIGTERM信号"><span class="toc-number">1.3.5.14.</span> <span class="toc-text">处理SIGTERM信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管理客户端资源"><span class="toc-number">1.3.5.15.</span> <span class="toc-text">管理客户端资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管理数据库资源"><span class="toc-number">1.3.5.16.</span> <span class="toc-text">管理数据库资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#执行被延迟的BGREWRITEAOF"><span class="toc-number">1.3.5.17.</span> <span class="toc-text">执行被延迟的BGREWRITEAOF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检查持久化操作的运行状态"><span class="toc-number">1.3.5.18.</span> <span class="toc-text">检查持久化操作的运行状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#将AOF缓冲区中的内容写入AOF文件"><span class="toc-number">1.3.5.19.</span> <span class="toc-text">将AOF缓冲区中的内容写入AOF文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关闭异步客户端"><span class="toc-number">1.3.5.20.</span> <span class="toc-text">关闭异步客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#增加cronloops计数器的值"><span class="toc-number">1.3.5.21.</span> <span class="toc-text">增加cronloops计数器的值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化服务器"><span class="toc-number">1.3.6.</span> <span class="toc-text">初始化服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始化服务器状态结构"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">初始化服务器状态结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#载入配置选项"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">载入配置选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#初始化服务器数据结构"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">初始化服务器数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原数据库状态"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">原数据库状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#执行事件循环"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">执行事件循环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重点回顾-5"><span class="toc-number">1.3.7.</span> <span class="toc-text">重点回顾</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">59</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">深入理解Redis（二）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-09</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Redis的数据库"><a href="#Redis的数据库" class="headerlink" title="Redis的数据库"></a>Redis的数据库</h2><h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>redis和mysql类似，redis也有自己不同的数据库。但是和mysql不一样的是，redis的数据库是自发产生的，redis会根据服务器状态，自行的确定数据库的数量。默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000421.jpg" alt=""></p>
<h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p>
<p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line">redis&gt; SELECT <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line">(<span class="literal">nil</span>)</span><br><span class="line">redis[<span class="number">2</span>]&gt; SET msg<span class="string">"another world"</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line"><span class="string">"another world"</span></span><br></pre></td></tr></table></figure>

<h4 id="谨慎处理多数据库程序"><a href="#谨慎处理多数据库程序" class="headerlink" title="谨慎处理多数据库程序"></a>谨慎处理多数据库程序</h4><p>如果你在其他语言的客户端中执行Redis命令，并且该客户端没有像redis-cli那样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。</p>
<h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<p>如我们执行一下命令：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; RPUSH alphabet <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line">(integer)<span class="number">3</span></span><br><span class="line">redis&gt; HSET book name <span class="string">"Redis in Action"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book author <span class="string">"Josiah L. Carlson"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book publisher <span class="string">"Manning"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>最后的模型就是这样：</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000028.jpg" alt=""></p>
<h5 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h5><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">date</span> <span class="string">"2013.12.1"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000391.jpg" alt=""></p>
<h5 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h5><p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p>
<h5 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h5><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p>
<h5 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h5><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</p>
<h5 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h5><p>除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。</p>
<p>比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p>
<p>另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。</p>
<h5 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h5><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会行一些额外的维护操作，其中包括：</p>
<ul>
<li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li>
<li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li>
<li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li>
<li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li>
<li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li>
</ul>
<h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之内</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之后</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。</p>
<p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">1000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) <span class="number">997</span></span><br><span class="line">redis&gt; SET another_key another_value</span><br><span class="line">OK</span><br><span class="line">redis&gt; TIME</span><br><span class="line"><span class="number">1</span>)<span class="string">"1377333070"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"761687"</span></span><br><span class="line">redis&gt; EXPIREAT another_key <span class="number">1377333100</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL another_key</span><br><span class="line">(integer) <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>如果是：EXPIREAT another_key 1385877600000，这表示数据库键过期时间为1385877600000（2013年12月1日零时）。</p>
<h5 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h5><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p>
<ul>
<li>EXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl秒。</li>
<li>PEXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl毫秒。</li>
<li>EXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li>
<li>PEXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li>
</ul>
<p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p>
<h5 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h5><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h5 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h5><p>PERSIST命令可以移除一个键的过期时间：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PEXPIREAT message <span class="number">1391234400000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">13893281</span></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>ERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h5 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h5><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT alphabet <span class="number">1385877600000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL alphabet</span><br><span class="line">(integer) <span class="number">8549007</span></span><br><span class="line">redis&gt; PTTL alphabet</span><br><span class="line">(integer) <span class="number">8549001011</span></span><br></pre></td></tr></table></figure>

<h5 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h5><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p>
<p>1）检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</p>
<p>2）检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</p>
<h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><p>我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是：如果一个键过期了，那么它什么时候会被删除呢？</p>
<p>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略：</p>
<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ul>
<h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p>
<p>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p>
<p>例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。</p>
<p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p>
<p>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</p>
<p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p>
<h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p> 从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p>
<ul>
<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存，有内存泄漏的危险。</li>
<li>定期删除策略是前两种策略的一种整合和折中：</li>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li>
<li>定期删除策略的难点是确定删除操作执行的时长和频率：</li>
<li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li>
</ul>
<p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p>
<h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h5 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h5><p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li>
<li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li>
</ul>
<h5 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h5><p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h4 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h4><p>我们将探讨过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p>
<h5 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h5><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p>
<h5 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h5><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>
<ul>
<li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li>
<li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li>
</ul>
<h5 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h5><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p>
<p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p>
<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li>
<li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li>
</ul>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p>
<h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p>
<ul>
<li>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：</li>
<li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。</li>
<li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。</li>
<li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。</li>
<li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。</li>
<li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El。</li>
</ul>
<p>关于数据库通知功能的详细用法，以及notify-keyspace-events选项的更多设置，Redis的官方文档已经做了很详细的介绍，这里不再赘述。</p>
<h5 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h5><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type,<span class="keyword">char</span> *event,robj *key,<span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。</p>
<p>event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。</p>
<p>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递传递该命令所引发的事件的相关信息。</p>
<h5 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h5><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span></span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(server.notify_keyspace_events &amp; type):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment">#内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment">#内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyevent@&#123;dbid&#125;__:&#123;event&#125;"</span>.format(dbid=dbid,event=event)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure>

<p>notifyKeyspaceEvent函数执行以下操作：</p>
<p>1）server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</p>
<p>2）如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</p>
<p>3）最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</p>
<h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</li>
<li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li>
<li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li>
<li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li>
<li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li>
<li>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</li>
<li>Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li>
<li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li>
<li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
</ul>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p>
<p>比如：一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000211.jpg" alt=""></p>
<p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p>
<p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>
<p>因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p>
<h5 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h5><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p>
<p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</p>
<p>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p>
<p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p>
<p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p>
<ul>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000002.jpg" alt=""></p>
<h5 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h5><p>前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。</p>
<p>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p>
<h5 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h5><p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。</p>
<p>首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</p>
<p>其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</p>
<p>最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：</p>
<ul>
<li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li>
<li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li>
</ul>
<p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p>
<h5 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h5><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h5 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h5><p>在上一节，我们介绍了SAVE命令和BGSAVE的实现方法，并且说明了这两个命令在实现方面的主要区别：SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会。</p>
<p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p>
<p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p>
<h5 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h5><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件。</p>
<p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h5><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p>
<ul>
<li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li>
<li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li>
</ul>
<p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p>
<h5 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h5><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p>
<p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p>
<h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>我们将对RDB文件本身进行介绍，并详细说明文件各个部分的结构和意义。</p>
<p>图展示了一个完整RDB文件所包含的各个部分:</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000011.jpg" alt=""></p>
<p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。本章只介绍第六版RDB文件的结构。</p>
<p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p>
<ul>
<li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li>
<li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li>
</ul>
<p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p>
<p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p>
<h5 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h5><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000074.jpg" alt=""></p>
<p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000121.jpg" alt=""></p>
<p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p>
<p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p>
<p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p>
<h5 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h5><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p>
<p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p>
<p>带有过期时间的键值对在RDB文件中的结构：</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000025.jpg" alt=""></p>
<p>带有过期时间的键值对中的TYPE、key、value三个部分的意义，和前面介绍的不带过期时间的键值对的TYPE、key、value三个部分的意义完全相同，至于新增的EXPIRETIME_MS和ms，它们的意义如下：</p>
<ul>
<li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li>
<li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li>
</ul>
<h5 id="Value的编码"><a href="#Value的编码" class="headerlink" title="Value的编码"></a>Value的编码</h5><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p>
<p><strong>1.字符串对象</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p>
<p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。</p>
<p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p>
<ul>
<li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li>
<li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li>
</ul>
<p><strong>2.列表对象</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象<img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000184.jpg" alt=""></p>
<p><strong>3.集合对象</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象.。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000320.jpg" alt=""></p>
<p><strong>4.哈希表对象</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象。</p>
<ul>
<li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li>
<li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li>
</ul>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000410.jpg" alt="img"></p>
<p><strong>5.有序集合对象</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000423.jpg" alt="img"></p>
<p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。</p>
<p>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p>
<p><strong>6.INTSET编码的集合</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p>
<p>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p>
<p><strong>7.ZIPLIST编码的列表、哈希表或者有序集合</strong></p>
<p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p>
<p>1）将压缩列表转换成一个字符串对象。</p>
<p>2）将转换所得的字符串对象保存到RDB文件。</p>
<p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p>
<p>1）读入字符串对象，并将它转换成原来的压缩列表对象。</p>
<p>2）根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</p>
<h4 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h4><h5 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h5><p>根据之前学习的RDB文件结构知识，当一个RDB文件没有包含任何数据库数据时，这个RDB文件将由以下四个部分组成：</p>
<ul>
<li>·五个字节的”REDIS”字符串。</li>
<li>·四个字节的版本号（db_version）。</li>
<li>·一个字节的EOF常量。</li>
<li>·八个字节的校验和（check_sum）。</li>
</ul>
<p>从od命令的输出中可以看到，最开头的是“REDIS”字符串，之后的0006是版本号，再之后的一个字节377代表EOF常量，最后的334 263 C 360 Z 334 362 V八个字节则代表RDB文件的校验和。</p>
<h5 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h5><p>根据之前学习的数据库结构知识，当一个数据库被保存到RDB文件时，这个数据库将由以下三部分组成：</p>
<ul>
<li>·一个一字节长的特殊值SELECTDB。</li>
<li>·一个长度可能为一字节、两字节或者五字节的数据库号码（db_number）。</li>
<li>·一个或以上数量的键值对（key_value_pairs）。</li>
</ul>
<p>观察od命令打印的输出，RDB文件的最开始仍然是REDIS和版本号0006，之后出现的376代表SELECTDB常量，再之后的\0代表整数0，表示被保存的数据库为0号数据库。</p>
<h5 id="包含带有过期时间的字符串键的RDB文件"><a href="#包含带有过期时间的字符串键的RDB文件" class="headerlink" title="包含带有过期时间的字符串键的RDB文件"></a>包含带有过期时间的字符串键的RDB文件</h5><p>根据之前学习的键值对结构知识，一个带有过期时间的键值对将由以下部分组成：</p>
<ul>
<li>·一个一字节长的EXPIRETIME_MS特殊值。</li>
<li>·一个八字节长的过期时间（ms）。</li>
<li>·一个一字节长的类型（TYPE）。</li>
<li>·一个键（key）和一个值（value）。</li>
</ul>
<h5 id="包含一个集合键的RDB文件"><a href="#包含一个集合键的RDB文件" class="headerlink" title="包含一个集合键的RDB文件"></a>包含一个集合键的RDB文件</h5><p>以下是RDB文件各个部分的意义：</p>
<ul>
<li>·REDIS0006：RDB文件标志和版本号。</li>
<li>·376\0：切换到0号数据库。</li>
<li>·002 004 L A N G：002是常量REDIS_RDB_TYPE_SET（这个常量的实际值为整数2），表示这是一个哈希表编码的集合键，004表示键的长度，LANG是键的名字。</li>
<li>·003：集合的大小，说明这个集合包含三个元素。</li>
<li>·004 R U B Y：集合的第一个元素。</li>
<li>·004 J A V A：集合的第二个元素。</li>
<li>·001 C：集合的第三个元素。</li>
<li>·377：代表常量EOF。</li>
<li>·202 312 r 352 346 305*023：代表校验和。</li>
</ul>
<h4 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li>
<li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li>
<li>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</li>
<li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000442.jpg" alt="img"></p>
<p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。</p>
<p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容。</p>
<h5 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h5><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p>
<h5 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h5><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure>

<p><strong>文件的写入和同步</strong></p>
<p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p>
<p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p>
<p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
<p><strong>AOF持久化的效率和安全性</strong></p>
<p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p>
<ul>
<li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li>
<li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li>
<li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li>
</ul>
<h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p>
<p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p>
<p>1）创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</p>
<p>2）从AOF文件中分析并读取出一条写命令。</p>
<p>3）使用伪客户端执行被读出的写命令。</p>
<p>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p>
<p>当完成以上步骤之后，AOF文件所保存的数据库状态就会被完整地还原出来</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000420.jpg" alt=""></p>
<h4 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p>
<h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p>
<h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p>
<p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li>
</ul>
<p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p>
<h4 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li>
<li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li>
<li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li>
<li>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li>
<li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li>
<li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li>
<li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li>
<li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p>
<ul>
<li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
<h5 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h5><p>文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000316.jpg" alt=""></p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p>
<p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p>
<p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p>
<h5 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I/O多路复用程序的实现"></a>I/O多路复用程序的实现</h5><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p>
<h5 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h5><p>I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p>
<ul>
<li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li>
<li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li>
</ul>
<p>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p>
<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p>
<p>ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p>
<p>ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p>
<ul>
<li>·如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li>
<li>·如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li>
<li>·如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li>
<li>·如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li>
</ul>
<p>ae.c/aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p>
<p>ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p>
<p>ae.c/aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p>
<p>ae.c/aeGetApiName函数返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p>
<h5 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h5><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p>
<ul>
<li>·为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li>
<li>·为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li>
<li>·为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li>
<li>·当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p>
<p><strong>1.连接应答处理器</strong></p>
<p>networking.c/acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p>
<p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作，如图。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000266.jpg" alt="img"></p>
<p><strong>2.命令请求处理器</strong></p>
<p>networking.c/readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。</p>
<p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000331.jpg" alt="img"></p>
<p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p>
<p><strong>3.命令回复处理器</strong></p>
<p>networking.c/sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p>
<p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作，如图。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000250.jpg" alt="img"></p>
<p>当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件之间的关联。</p>
<p><strong>4.一次完整的客户端与服务器连接事件示例</strong></p>
<p>让我们来追踪一次Redis客户端与服务器进行连接并发送命令的整个过程，看看在过程中会产生什么事件，而这些事件又是如何被处理的。</p>
<p>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p>
<p>如果这时有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p>
<p>之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p>
<p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000008.jpg" alt="img"></p>
<p>#####　时间事件</p>
<p>Redis的时间事件分为以下两类：</p>
<ul>
<li>·定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li>
<li>·周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li>
</ul>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>·id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li>
<li>·when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li>
<li>·timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li>
</ul>
<p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p>
<ul>
<li>·如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li>
<li>·如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li>
</ul>
<p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p>
<p>#####　实现</p>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p>图展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件：因为新的时间事件总是插入到链表的表头，所以三个时间事件分别按ID逆序排序，表头事件的ID为3，中间事件的ID为2，表尾事件的ID为1。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000382.jpg" alt="img"></p>
<p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p>
<p>无序链表并不影响时间事件处理器的性能</p>
<p>在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p>
<h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p>
<h5 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h5><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p>
<ul>
<li>·更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>·清理数据库中的过期键值对。</li>
<li>·关闭和清理连接失效的客户端。</li>
<li>·尝试进行AOF或RDB持久化操作。</li>
<li>·如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>·如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p>
<p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。</p>
<p>从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。</p>
<h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p>
<p>从事件处理的角度来看，Redis服务器的运行流程可以用流程图：</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000428.jpg" alt=""></p>
<p>以下是事件的调度和执行规则：</p>
<p>1）aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</p>
<p>2）因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</p>
<p>3）对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</p>
<p>4）因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</p>
<h4 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li>
<li>文件事件处理器是基于Reactor模式实现的网络通信程序。</li>
<li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li>
<li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li>
<li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li>
<li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li>
<li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li>
<li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p>
<p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p>
<p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p>
<ol>
<li>客户端的套接字描述符。</li>
<li>客户端的名字。</li>
<li>客户端的标志值（flag）。</li>
<li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li>
<li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li>
<li>客户端的输入缓冲区和输出缓冲区。</li>
<li>客户端的复制状态信息，以及进行复制所需的数据结构。</li>
<li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li>
<li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li>
<li>客户端执行发布与订阅功能时用到的数据结构。</li>
<li>客户端的身份验证标志。</li>
<li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li>
</ol>
<h4 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h4><p>客户端状态包含的属性可以分为两类：</p>
<p>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</p>
<p>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</p>
<h5 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h5><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符。</p>
<p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p>
<ul>
<li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。</li>
<li>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数。</li>
</ul>
<h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p>
<h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态</p>
<p>每个标志使用一个常量表示，一部分标志记录了客户端的角色：</p>
<p>·在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</p>
<p>·REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。</p>
<p>·REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</p>
<p>而另外一部分标志则记录了客户端目前所处的状态：</p>
<p>·REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</p>
<p>·REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</p>
<p>·REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。</p>
<p>·REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来，不再阻塞。REDIS_UNBLOCKED标志只能在REDIS_BLOCKED标志已经打开的情况下使用。</p>
<p>·REDIS_MULTI标志表示客户端正在执行事务。</p>
<p>·REDIS_DIRTY_CAS标志表示事务使用WATCH命令监视的数据库键已经被修改，REDIS_DIRTY_EXEC标志表示事务在命令入队时出现了错误，以上两个标志都表示事务的安全性已经被破坏，只要这两个标记中的任意一个被打开，EXEC命令必然会执行失败。这两个标志只能在客户端打开了REDIS_MULTI标志的情况下使用。</p>
<p>·REDIS_CLOSE_ASAP标志表示客户端的输出缓冲区大小超出了服务器允许的范围，服务器会在下一次执行serverCron函数时关闭这个客户端，以免服务器的稳定性受到这个客户端影响。积存在输出缓冲区中的所有内容会直接被释放，不会返回给客户端。</p>
<p>·REDIS_CLOSE_AFTER_REPLY标志表示有用户对这个客户端执行了CLIENT KILL命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端，然后关闭客户端。</p>
<p>·REDIS_ASKING标志表示客户端向集群节点（运行在集群模式下的服务器）发送了ASKING命令。</p>
<p>·REDIS_FORCE_AOF标志强制服务器将当前执行的命令写入到AOF文件里面，REDIS_FORCE_REPL标志强制主服务器将当前执行的命令复制给所有从服务器。执行PUBSUB命令会使客户端打开REDIS_FORCE_AOF标志，执行SCRIPT LOAD命令会使客户端打开REDIS_FORCE_AOF标志和REDIS_FORCE_REPL标志。</p>
<p>·在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送这个命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY标志，否则发送操作会被拒绝执行。</p>
<p>以上提到的所有标志都定义在redis.h文件里面。</p>
<p><strong>PUBSUB命令和SCRIPT LOAD命令的特殊性</strong></p>
<p>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。<br>以上规则适用于绝大部分Redis命令，但PUBSUB命令和SCRIPT LOAD命令是其中的例外。PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。因此，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。SCRIPT LOAD命令的情况与PUBSUB命令类似：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。</p>
<h5 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求</p>
<h5 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h5><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。</p>
<p>argc属性则负责记录argv数组的长度。</p>
<h5 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h5><p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p>
<h5 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h5><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p>
<p>·固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</p>
<p>·可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</p>
<h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证</p>
<h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>最后，客户端还有几个和时间有关的属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<h4 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h4><p>服务器使用不同的方式来创建和关闭不同类型的客户端，本节将介绍服务器创建和关闭客户端的方法。</p>
<h5 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h5><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器（在第12章有介绍），为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p>
<h5 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h5><p>一个普通客户端可以因为多种原因而被关闭：</p>
<p>·如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</p>
<p>·如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</p>
<p>·如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</p>
<p>·如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS_MASTER标志），从服务器（打开了REDIS_SLAVE标志），正在被BLPOP等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</p>
<p>·如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</p>
<p>·如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</p>
<p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。</p>
<p>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p>
<p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p>
<p>·硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</p>
<p>·软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</p>
<h5 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h5><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisClient *lua_client;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h5><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端.</p>
<h4 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li>
<li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li>
<li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li>
<li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li>
<li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li>
<li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li>
<li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li>
<li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li>
<li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li>
</ul>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p>
<h4 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h4><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。</p>
<h5 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h5><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p>
<h5 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h5><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p>
<p>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</p>
<p>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p>
<p>3）调用命令执行器，执行客户端指定的命令。</p>
<h5 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h5><p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p>
<p>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息，表记录了这个结构的各个主要属性的类型和作用：</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000095.jpg" alt=""></p>
<h5 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h5><p>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：</p>
<p>·检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</p>
<p>·根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</p>
<p>·检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</p>
<p>·如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</p>
<p>·如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</p>
<p>·如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</p>
<p>·如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</p>
<p>·如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</p>
<p>·如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</p>
<p>·如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</p>
<h5 id="命令执行器（3）：调用命令的实现函数"><a href="#命令执行器（3）：调用命令的实现函数" class="headerlink" title="命令执行器（3）：调用命令的实现函数"></a>命令执行器（3）：调用命令的实现函数</h5><p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// client</span><br><span class="line">是指向客户端状态的指针</span><br><span class="line">client-&gt;cmd-&gt;proc(client);</span><br></pre></td></tr></table></figure>

<h5 id="命令执行器（4）：执行后续工作"><a href="#命令执行器（4）：执行后续工作" class="headerlink" title="命令执行器（4）：执行后续工作"></a>命令执行器（4）：执行后续工作</h5><p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p>
<p>·如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</p>
<p>·根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</p>
<p>·如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</p>
<p>·如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</p>
<p>当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了</p>
<h5 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h5><p>前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p>
<p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p>
<h5 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h5><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端）</p>
<h5 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h5><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p>
<h5 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h5><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p>
<p>·服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</p>
<p>·对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</p>
<h5 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h5><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">// 用于计算键的空转（idle）时长。</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h5><p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看</p>
<h5 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h5><p>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h5><p>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGTERM信号的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    redisLogFromHandler(REDIS_WARNING,<span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</span><br><span class="line">    <span class="comment">// 打开关闭标识</span></span><br><span class="line">    server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h5><p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p>
<p>·如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。</p>
<p>·如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</p>
<h5 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h5><p>serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</p>
<h5 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h5><p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p>
<h5 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h5><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGSAVE，</span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;                <span class="comment">/* PID of RDB saving child */</span></span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGREWRITEAOF，    </span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;                <span class="comment">/* PID if rewriting process */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p>
<p>·如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</p>
<p>·如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</p>
<p>另一方面，如果rdb_child_pid和aof_child_pid两个属性的值都为-1，那么表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：</p>
<p>1）查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作（这就是上一个小节我们说到的检查）。</p>
<p>2）检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了）。</p>
<p>3）检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）。</p>
<p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000328.jpg" alt=""></p>
<h5 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h5><p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</p>
<h5 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h5><p>在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端</p>
<h5 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h5><p>服务器状态的cronloops属性记录了serverCron函数执行的次数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// serverCron函数的运行次数计数器</span></span><br><span class="line">    <span class="comment">// serverCron函数每执行一次，这个属性的值就增一。</span></span><br><span class="line">    <span class="keyword">int</span> cronloops;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能。</p>
<h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p>
<h5 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h5><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置服务器的运行id </span></span><br><span class="line">    getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);</span><br><span class="line">    <span class="comment">// 为运行id加上结尾字符</span></span><br><span class="line">    server.runid[REDIS_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 设置默认配置文件路径</span></span><br><span class="line">    server.configfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器频率</span></span><br><span class="line">    server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line">    <span class="comment">// 设置服务器的运行架构</span></span><br><span class="line">    server.arch_bits = (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器端口号</span></span><br><span class="line">    server.port = REDIS_SERVERPORT;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是initServerConfig函数完成的主要工作：</p>
<p>·设置服务器的运行ID。</p>
<p>·设置服务器的默认运行频率。</p>
<p>·设置服务器的默认配置文件路径。</p>
<p>·设置服务器的运行架构。</p>
<p>·设置服务器的默认端口号。</p>
<p>·设置服务器的默认RDB持久化条件和AOF持久化条件。</p>
<p>·初始化服务器的LRU时钟。</p>
<p>·创建命令表。</p>
<p>initServerConfig函数设置的服务器状态属性基本都是一些整数、浮点数、或者字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象这些数据结构在之后的步骤才会被创建出来。</p>
<h5 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h5><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p>
<h5 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h5><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p>
<p>·server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</p>
<p>·server.db数组，数组中包含了服务器的所有数据库。</p>
<p>·用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</p>
<p>·用于执行Lua脚本的Lua环境server.lua。</p>
<p>·用于保存慢查询日志的server.slowlog属性。</p>
<p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p>
<p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p>
<p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p>
<p>·为服务器设置进程信号处理器。</p>
<p>·创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</p>
<p>·打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</p>
<p>·为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</p>
<p>·如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</p>
<p>·初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备。</p>
<h5 id="原数据库状态"><a href="#原数据库状态" class="headerlink" title="原数据库状态"></a>原数据库状态</h5><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p>
<p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p>
<p>·如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</p>
<p>·相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</p>
<h5 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h5><p>在初始化的最后一步，服务器将打印出日志。</p>
<h4 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h4><p>一个命令请求从发送到完成主要包括以下步骤：</p>
<ul>
<li>1）客户端将命令请求发送给服务器；</li>
<li>2）服务器读取命令请求，并分析出命令参数；</li>
<li>3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li>
<li>4）服务器将命令回复返回给客户端。</li>
</ul>
<p>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</p>
<p>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p>
<ul>
<li>1）初始化服务器状态；</li>
<li>2）载入服务器配置；</li>
<li>3）初始化服务器数据结构；</li>
<li>4）还原数据库状态；</li>
<li>5）执行事件循环。</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/"><i class="fa fa-chevron-left">  </i><span>利用Nginx进行前后端分离项目部署-ruoyi</span></a></div><div class="next-post pull-right"><a href="/2020/06/02/redis3/"><span>深入理解Redis（一）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>