<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="B+树索引和算法"><meta name="keywords" content="MySQL"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>B+树索引和算法 | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-树索引和算法"><span class="toc-number">1.</span> <span class="toc-text">B+树索引和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉查找法"><span class="toc-number">1.1.1.</span> <span class="toc-text">二叉查找法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉查找树与平衡二叉树"><span class="toc-number">1.1.2.</span> <span class="toc-text">二叉查找树与平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树"><span class="toc-number">1.1.3.</span> <span class="toc-text">B+ 树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-树的插入操作"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">B+树的插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-树的删除操作"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">B+树的删除操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB的B-树索引"><span class="toc-number">1.2.</span> <span class="toc-text">InnoDB的B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#聚集索引"><span class="toc-number">1.2.1.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助索引"><span class="toc-number">1.2.2.</span> <span class="toc-text">辅助索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树索引的管理"><span class="toc-number">1.2.3.</span> <span class="toc-text">B+树索引的管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cardinality值"><span class="toc-number">1.3.</span> <span class="toc-text">Cardinality值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Cardinality值"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是Cardinality值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB存储引擎的Cardinality统计"><span class="toc-number">1.3.2.</span> <span class="toc-text">InnoDB存储引擎的Cardinality统计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树索引的使用"><span class="toc-number">1.4.</span> <span class="toc-text">B+树索引的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合索引"><span class="toc-number">1.5.</span> <span class="toc-text">联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-number">1.5.1.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化器选择不使用索引的情况"><span class="toc-number">1.5.2.</span> <span class="toc-text">优化器选择不使用索引的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-Range-Read-优化"><span class="toc-number">1.5.3.</span> <span class="toc-text">Multi-Range Read 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Index-Condition-Pushdown-ICP-优化"><span class="toc-number">1.5.4.</span> <span class="toc-text">Index Condition Pushdown( ICP )优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希算法"><span class="toc-number">1.6.</span> <span class="toc-text">哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表"><span class="toc-number">1.6.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希索引"><span class="toc-number">1.6.2.</span> <span class="toc-text">哈希索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全文检索"><span class="toc-number">1.7.</span> <span class="toc-text">全文检索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#倒排索引"><span class="toc-number">1.7.1.</span> <span class="toc-text">倒排索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB全文检索"><span class="toc-number">1.7.2.</span> <span class="toc-text">InnoDB全文检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全文检索-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">全文检索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Natural-Language"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">Natural Language</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boolean"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#query-Expansion"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">query Expansion</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">95</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">66</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">B+树索引和算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-01</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="B-树索引和算法"><a href="#B-树索引和算法" class="headerlink" title="B+树索引和算法"></a>B+树索引和算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是在学习编程的过程中，必须越过的坎。很多数据结构理解起来并不会太难，但是要说到会灵活运用，那就有很长一段路需要走。</p>
<p>而现在要学习的，就是运用在MySQL数据库里面的数据结构——B+树。</p>
<p>但是在了解B+树之前，先说说它的来源。</p>
<h4 id="二叉查找法"><a href="#二叉查找法" class="headerlink" title="二叉查找法"></a>二叉查找法</h4><p>我们需要查询这个值的时，最基本的算法就是使用二叉查找法，它能在一个已排序好的数组中，极大的提高查找的效率，这种算法思想被广泛地运用到了生活的各个领域。但是值得注意的是，二叉查找法也仅仅是给众多人提供一个足够好的思路而已，它所衍生出来的各种算法，才是真正被运用的算法。</p>
<p>二叉查找法非常的简单，这里懒得讲了:sleeping:</p>
<h4 id="二叉查找树与平衡二叉树"><a href="#二叉查找树与平衡二叉树" class="headerlink" title="二叉查找树与平衡二叉树"></a>二叉查找树与平衡二叉树</h4><p>B+树，就是先通过二叉查找树，再通过平衡二叉树，所衍生出来的。</p>
<p>二叉搜索树也是一种树，适用与一般二叉树的全部操作，但二叉搜索树能够实现数据的快速查找。</p>
<p>性质：</p>
<ul>
<li>非空左子树的所有键值小于其根节点的键值</li>
<li>非空右子树的所有键值大于其根节点的键值</li>
<li>左右子树都是二叉查找树</li>
</ul>
<p>可以浅显的理解为，将一个排序好的数组，转为二叉树的形式，去查找。</p>
<p>但是，你也要想，如果这个树被广泛的使用后，添加了非常多，非常大的数字，那么这个二叉树的中心节点不变的话，岂不是形成了“右重左轻”的二叉树呢？</p>
<p>于是，便由这个思想，改进成了一个，平衡二叉树。</p>
<p>平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：</p>
<ul>
<li>平衡二叉树要么是一棵空树</li>
<li>要么保证左右子树的高度之差不大于 1</li>
<li>子树也必须是一颗平衡二叉树</li>
</ul>
<p>也就是说，树的两个左子树的高度差别不会太大，一旦有了新的节点加入，则会通过左旋或者是右旋的方式，去稳定的保持根节点必须为中心节点。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡二叉树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。</p>
<p><img src="https://box.kancloud.cn/eccb1d67a2b49c28bfdb9eee8e93c685_897x237.png" alt=""></p>
<p>可以看出，所有记录都在叶节点中，并且是顺序存放的，如果我们从最左边的叶节点开始顺序遍历，可以得到所有键值的顺序排序：5、10、15、20、25、30、50、55、60、65、75、80、85、90。</p>
<p>一个最形象的比喻是：把它看作为一个刻度尺，我们总是先看到厘米，再由厘米，找到毫米。</p>
<h5 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h5><p>B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法：</p>
<p><img src="https://box.kancloud.cn/2122478de5826e7d6581f0a441598087_903x400.png" alt=""></p>
<p>我们用实例来分析B+树的插入，我们插入28这个键值，发现当前Leaf Page和Index Page都没有满，我们直接插入就可以了。</p>
<p><img src="https://box.kancloud.cn/03518dfdb10771c4bda7bb4e472ea021_898x220.png" alt=""></p>
<p>这次我们再插入一条70这个键值，这时原先的Leaf Page已经满了，但是Index Page还没有满，符合表的第二种情况，这时插入Leaf Page后的情况为50、55、60、65、70。我们根据中间的值60拆分叶节点。</p>
<p><img src="https://box.kancloud.cn/1808b3e428e0aa74fd7e6cd2c976f6e1_836x294.png" alt=""></p>
<p>因为图片显示的关系，这次我没有能在各叶节点加上双向链表指针。最后我们来插入记录95，这时符合表5-1讨论的第三种情况，即Leaf Page和Index Page都满了，这时需要做两次拆分。</p>
<p><img src="https://box.kancloud.cn/938eab2179096474f075120bdb81663e_869x393.png" alt=""></p>
<p>可以看到，不管怎么变化，B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。</p>
<p>旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上。通常情况下，左兄弟被首先检查用来做旋转操作，这时我们插入键值70，其实B+树并不会急于去拆分叶节点，而是做旋转，50，55，55旋转。</p>
<p><img src="https://box.kancloud.cn/b193456c7db65d4257612f48a8064e17_901x225.png" alt=""></p>
<p>可以看到，采用旋转操作使B+树减少了一次页的拆分操作，而这时B+树的高度依然还是2。</p>
<h5 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h5><p>B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶节点中的记录依然排序，同插入一样，B+树的删除操作同样需要考虑如表5-2所示的三种情况，与插入不同的是，删除根据填充因子的变化来衡量。</p>
<p><img src="https://box.kancloud.cn/ba29654ad6ef9445a0fc01251198e620_903x246.png" alt=""></p>
<p>首先，删除键值为70的这条记录，该记录符合表5-2讨论的第一种情况，删除后。</p>
<p><img src="https://box.kancloud.cn/92e83659ef72c970cb6aed620dc33e56_905x393.png" alt=""></p>
<p>接着我们删除键值为25的记录，这也是表5-2讨论的第一种情况，但是该值还是Index Page中的值，因此在删除Leaf Page中25的值后，还应将25的右兄弟节点的28更新到Page Index中，最后可得到图。</p>
<p><img src="https://box.kancloud.cn/aa292aa7671d2859709bc1cae0e6b28f_897x401.png" alt=""></p>
<p>最后我们来看删除键值为60的情况，删除Leaf Page中键值为60的记录后，填充因子小于50%，这时需要做合并操作，同样，在删除Index Page中相关记录后需要做Index Page的合并操作，最后得到图。</p>
<p><img src="https://box.kancloud.cn/e65eff5a8a50f72ce99baf4a7b633c2f_795x289.png" alt=""></p>
<h3 id="InnoDB的B-树索引"><a href="#InnoDB的B-树索引" class="headerlink" title="InnoDB的B+树索引"></a>InnoDB的B+树索引</h3><p>B+树索引其本质就是B+树在数据库中的实现，但是B+索引在数据库中有一个特点就是其高扇出性，因此在数据库中，B+树的高度一般都在2～3层，也就是对于查找某一键值的行记录，最多只需要2到3次IO，这倒不错。因为我们知道现在一般的磁盘每秒至少可以做100次IO，2～3次的IO意味着查询时间只需0.02～0.03秒。</p>
<p>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助聚集索引（secondary index）辅助聚集索引有时也称非聚集索引（non-clustered index）。</p>
<p>但是不管是聚集还是非聚集的索引，其内部都是B+树的，即高度平衡的，叶节点存放着所有的数据。聚集索引与非聚集索引不同的是，叶节点存放的是否是一整行的信息。</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的叶节点成为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p>
<p>由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在许多情况下，查询优化器非常倾向于采用聚集索引，因为聚集索引能够让我们在索引的叶节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。</p>
<p>现在我们来看一张表，我们以人为的方式让其每个页只能存放两个行记录，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL [qiushibaike]&gt; create table t(</span><br><span class="line">    -&gt; a int not null, </span><br><span class="line">    -&gt; b varchar(8000),</span><br><span class="line">    -&gt; c int not null,</span><br><span class="line">    -&gt; primary key (a),</span><br><span class="line">    -&gt; key idx_c(c)</span><br><span class="line">    -&gt; )engine&#x3D;INNODB;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t select 1,repeat(&#39;a&#39;,7000),-1;</span><br><span class="line"></span><br><span class="line">insert into t select 2,repeat(&#39;a&#39;,7000),-2;</span><br><span class="line"></span><br><span class="line">insert into t select 3,repeat(&#39;a&#39;,7000),-3;</span><br><span class="line"></span><br><span class="line">insert into t select 4,repeat(&#39;a&#39;,7000),-4;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们表的定义和插入方式使得目前每个页只能存放两个行记录，我们用py_innodb_page_info工具来分析表空间，可得：py_innodb_page_info.py-v mytest/t.ibd</p>
<p>page level为0000的即是数据页。我们要分析的是page level为0001的页，该页是B+树的根，我们来看看索引的根页中存放的数据。</p>
<p>我们直接通过页尾的Page Directory来分析，从00 63可以知道该页中行开始的位置。接着通过Recorder Header来分析，0xc063开始的值为69 6e 66 69 6d 75 6d 00，就代表infimum伪行记录。之前的5个字节01 00 02 00 1b就是Recorder Header，分析第4位到第8位的值1代表该行记录中只有一个记录（需要记住的是，InnoDB的Page Directory是稀疏的），即infimum记录本身。我们通过Recorder Header中最后的两个字节00 1b来判断下一条记录的位置，即c063+1b=c073，读取键值可得80 01，就是主键为1的键值（我们制定的INT是无符号的，因此二进制是0x8001，而不是0x0001），80 01后值00 00 00 04代表指向数据页的页号。以同样的方式，可以找到80 02和80 04这两个键值以及它们指向的数据页。</p>
<p>通过以上对于非数据页节点的分析，我们发现数据页上存放的是完整的行记录，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，而不是一个完整的行记录。因此我们构造的这颗二叉树大致如图所示。</p>
<p><img src="https://box.kancloud.cn/052bf51b4267db01fcee3330315327a4_717x367.png" alt=""></p>
<p>许多数据库的文档会这样告诉读者：聚集索引按照顺序物理地存储数据。但是试想，如果聚集索引必须按照特定顺序存放物理记录的话，则维护成本即显得非常之高了。所以，聚集索引的存储并不是物理上的连续，相反是逻辑上连续的。这其中有两点：一是我们前面说过的页通过双向链表链接，页按照主键的顺序排列。另一点是每个页中的记录也是通过双向链表进行维护，物理存储上可以同样不按照主键存储。</p>
<p>聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。叶节点的数据就是我们要查询的数据，如我们要查询一张注册用户的表，查询最后注册的10位用户，由于B+树索引是双向链表的，我们可以快速找到最后一个数据页，并取出10条记录，我们用Explain进行分析，可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from Profile order by id limit 10;</span><br></pre></td></tr></table></figure>

<p>另一个是范围查询（range query），如果要查找主键某一范围内的数据，通过叶节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可，又如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from Profile where id＞10 and id＜10000;</span><br></pre></td></tr></table></figure>

<p>Explain得到了MySQL的执行计划（execute plan），并且rows列给出了一个查询结果的预估返回行数。要注意的是，rows代表的是一个预估值，不是确切的值，如果我们实际进行这句SQL的查询，可以看到实际上只有9 946行记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from Profile where id＞10 and id＜10000;</span><br></pre></td></tr></table></figure>

<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>对于辅助索引（也称非聚集索引），叶级别不包含行的全部数据。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签（bookmark），该书签用来告诉InnoDB存储引擎，哪里可以找到与索引相对应的行数据。因为InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。显示了InnoDB存储引擎中辅助索引与聚集索引的关系。</p>
<p><img src="https://box.kancloud.cn/df601c6a557b2ed7a53ad0b5936493df_553x578.png" alt=""></p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。举例来说，如果在一颗高度为3的辅助索引树中查找数据，那么需要对这颗辅助索引遍历3次找到指定主键；如果聚集索引树的高度同样为3，那么还需要对聚集索引进行3次查找，才能最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO来访问最终的一个数据页。</p>
<p>对于其他的一些数据库，如Microsoft SQL Server数据库，其表类型有一种不是索引组织表，称为堆表。在数据的存放按插入顺序方面，与MySQL的MyISAM存储引擎有些类似。堆表的特性决定了堆表上的索引都是非聚集的，但是堆表没有主键。因此这时书签是一个行标识符（row identifier，RID），可以用如“文件号：页号：槽号”的格式来定位实际的行。</p>
<p>堆表的非聚集索引既然不需要再通过主键对聚集索引进行查找，那不是速度会更快吗？答案是也许，在某些只读的情况下，书签为行标识符方式的非聚集索引可能会比书签为主键方式的非聚集索引快。但是考虑在OLTP（OnLine Transaction Processing，在线事务处理）应用的情况下，表可能还需要发生插入、更新、删除等DML操作。当进行这类操作时，书签为行标识符方式的非聚集索引可能需要不断更新行标识符所指向数据页的位置，这时的开销可能就会大于书签为主键方式的非聚集索引了。</p>
<p>Microsoft SQL Server数据库DBA问过这样的问题，为什么在SQL Server上还要使用索引组织表？堆表的书签性使得非聚集查找可以比主键书签方式更快，并且非聚集可能在一张表中存在多个，我们需要对多个非聚集索引的查找。而且对于非聚集索引的离散读取，索引组织表上的非聚集索引会比堆表上的聚集索引慢一些。当然，在一些情况下，使用堆表的确会比索引组织表更快，但是我觉得大部分是由于存在于OLAP（On-Line Analytical Processing，在线分析处理）的应用。其次就是前面提到的，表中数据是否需要更新，并且更新会否影响到物理地址的变更。此外另一个不能忽视的是对于排序和范围查找，索引组织表可以通过B+树的中间节点就找到要查找的所有页，然后进行读取，而堆表的特性决定了这对其是不能实现的。最后，非聚集索引的离散读，的确是存在上述情况，但是一般的数据库都通过实现预读（read ahead）技术来避免多次的离散读操作。因此，具体是建堆表还是索引组织表，这取决于你的应用，不存在哪个更优的情况。这和InnoDB存储引擎好还是MyISAM存储引擎好的问题是一样的，具体情况具体分析。</p>
<p>接下来，我们通过阅读表空间文件来分析InnoDB存储引擎的非聚集索引，我们还是分析上一小节所用的表t。</p>
<p>不同的是，在表t上再建立一个列c，并对列c创建非聚集索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alter table t add c int not null;</span><br><span class="line"></span><br><span class="line">update t set c&#x3D;0-a;</span><br><span class="line"></span><br><span class="line">alter table t add key idx_c(c); </span><br><span class="line"></span><br><span class="line">show index from t;</span><br><span class="line"></span><br><span class="line">select a,c from t;</span><br></pre></td></tr></table></figure>

<p>然后用py_innodb_page_info工具来分析表空间，可得：py_innodb_page_info.py-v t.ibd</p>
<p>对比前一次我们的分析，可以看到这次多了一个页。分析page offset为4的页，该页为非聚集索引所在页，通过工具hexdump分析可得：</p>
<p>因为只有4行数据，并且列c只有4个字节，因此在一个非聚集索引页中即可完成，整理分析可得下图所示的关系：</p>
<p><img src="https://box.kancloud.cn/f8cf1eed60ff8ed1c451aa70cef3da1b_692x529.png" alt=""></p>
<p>显示了表t中辅助索引idx_c和聚集索引的关系。可以看到辅助索引的叶节点中包含了列c的值和主键的值。这里键值因为我特意设为负值，你会发现-1以7f ff ff ff的方式进行内部存储。7（0111）最高位为0，代表负值，实际的值应该取反后，加1，即得-1。</p>
<h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><p>索引的创建和删除可以通过两种方法，一种是ALTER TABLE，另一种是CREATE/DROP INDEX。ALTER TABLE创建索引的语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line"></span><br><span class="line">|ADD&#123;INDEX|KEY&#125;[index_name]</span><br><span class="line"></span><br><span class="line">[index_type] (index_col_name，……) [index_option]……</span><br><span class="line"></span><br><span class="line">ALTER TABLE tbl_name</span><br><span class="line"></span><br><span class="line">DROP PRIMARY KEY</span><br><span class="line"></span><br><span class="line">|DROP &#123;INDEX|KEY&#125; index_name</span><br><span class="line"></span><br><span class="line">CREATE&#x2F;DROP INDEX的语法同样很简单：</span><br><span class="line"></span><br><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line"></span><br><span class="line">[index_type]</span><br><span class="line"></span><br><span class="line">ON tbl_name（index_col_name，……）</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON tbl_name</span><br></pre></td></tr></table></figure>

<p>索引可以索引整个列的数据，也可以只索引一个列的开头部分数据，如前面我们创建的表t，b列为varchar(8000)，但是我们可以只索引前100个字段，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add key idx_b (b(100));</span><br></pre></td></tr></table></figure>

<p>目前MySQL数据库存在的一个普遍问题是，所有对于索引的添加或者删除操作，MySQL数据库是先创建一张新的临时表，然后把数据导入临时表，删除原表，再把临时表重名为原来的表名。因此对于一张大表，添加和删除索引需要很长的时间。对于从Microsoft SQL Server或Oracle数据库的DBA来说，MySQL数据库的索引维护始终让他们非常苦恼。</p>
<p>InnoDB存储引擎从版本InnoDB Plugin开始，支持一种称为快速索引创建方法。当然这种方法只限定于辅助索引，对于主键的创建和删除还是需要重建一张表。对于辅助索引的创建，InnoDB存储引擎会对表加上一个S锁。在创建的过程中，不需要重建表，因此速度极快。但是在创建的过程中，由于上了S锁，因此创建的过程中该表只能进行读操作。删除辅助索引操作就更简单了，只需在InnoDB存储引擎的内部视图更新下，将辅助索引的空间标记为可用，并删除MySQL内部视图上对于该表的索引定义即可。</p>
<p>查看表中索引的信息可以使用SHOW INDEX语句。如我们来分析表t，之前先加一个联合索引，可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t add key idx_a_b(a,c);</span><br><span class="line">show index from t;</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/22711aeae934f7f594f2ba9c5b8a8c1a_668x214.png" alt=""></p>
<p>因为在表t上有3个索引：一个主键索引，c列上的索引，和b列前100个字节构成的索引。</p>
<p>接着我们来具体讲解每个列的含义：</p>
<p><strong>Table</strong>：索引所在的表名。<br><strong>Non_unique</strong>：非唯一的索引，可以看到primary key是0，因为必须是唯一的。<br><strong>Key_name</strong>：索引的名称，我们可以通过这个名称来DROP INDEX。<br><strong>Seq_in_index</strong>：索引中该列的位置，如果看联合索引idx_a_b就比较直观了。<br><strong>Column_name</strong>：索引的列<br><strong>Collation</strong>：列以什么方式存储在索引中。可以是’A’或者NULL。B+树索引总是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶来存放索引数据，而不是对数据进行排序。<br><strong>Cardinality</strong>：非常关键的值，表示索引中唯一值的数目的估计值。Cardinality/表的行数应尽可能接近1，如果非常小，那么需要考虑是否还需要建这个索引。<br><strong>Sub_part</strong>：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示我们只索引b列的前100个字符。如果索引整个列，则该字段为NULL。<br><strong>Packed</strong>：关键字如何被压缩。如果没有被压缩，则为NULL。<br><strong>Null</strong>：是否索引的列含有NULL值。可以看到idx_b这里为Yes。因为我们定义的b列允许NULL值。<br><strong>Index_type</strong>：索引的类型。InnoDB存储引擎只支持B+树索引，所以这里显示的都是BTREE。<br><strong>Comment</strong>：注释。<br><strong>Cardinality</strong>值非常关键，优化器会根据这个值来判断是否使用这个索引。但是这个值并不是实时更新的，并非每次索引的更新都会更新该值，因为这样代价太大了。因此这个值是不太准确的，只是一个大概的值。上面显示的结果主键的Cardinality为2，但是很显然我们表中有4条记录，这个值应该是4。如果需要更新索引Cardinality的信息，可以使用ANALYZE TABLE命令。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br><span class="line"></span><br><span class="line">show index from t;</span><br></pre></td></tr></table></figure>

<p>这时的Cardinality的值就对了。不过，在每个系统上可能得到的结果不一样，因为ANALYZE TABLE现在还存在一些问题，可能会影响得到最后的结果。</p>
<p>另一个问题是MySQL数据库对于Cardinality计数的问题，在运行一段时间后，可能会看到下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from Profile;</span><br></pre></td></tr></table></figure>

<p>Cardinality为NULL，在某些情况下可能会发生索引建立了、但是没有用到，或者explain两条基本一样的语句，但是最终出来的结果不一样。一个使用索引，另外一个使用全表扫描，这时最好的解决办法就是做一次ANALYZE TABLE的操作。因此我建议在一个非高峰时间，对应用程序下的几张核心表做ANALYZE TABLE操作，这能使优化器和索引更好地为你工作。</p>
<h3 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h3><h4 id="什么是Cardinality值"><a href="#什么是Cardinality值" class="headerlink" title="什么是Cardinality值"></a>什么是Cardinality值</h4><p>不是所有的查询条件出现的列都需要添加索引。对于什么时候添加B+树索引。一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，他们可取值范围很小，称为低选择性。如</p>
<p>SELECT * FROM student WHERE sex=’M’</p>
<p>按性别进行查询时，可取值一般只有M、F。因此SQL语句得到的结果可能是该表50%的数据(加入男女比例1:1)这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，属于高选择性。则此时使用B+树的索引是最合适的。例如对于姓名字段，基本上在一个应用中不允许重名的出现</p>
<p>怎样查看索引是否有高选择性？通过SHOW INDEX结果中的列Cardinality来观察。非常关键，表示所以中不重复记录的预估值，需要注意的是Cardinality是一个预估值，而不是一个准确值基本上用户也不可能得到一个准确的值，在实际应用中，Cardinality/n_row_in_table应尽可能的接近1，如果非常小,那用户需要考虑是否还有必要创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对于字段添加B+树索引是非常有必要的。如</p>
<p>SELECT * FROM member WHERE usernick=’David’;</p>
<p>表member大约有500W行数据,usernick字段上有一个唯一索引。这是如果查找用户名为David的用户，将得到如下执行计划:</p>
<p><img src="https://box.kancloud.cn/9f039a02e8b70586f3ea8e6fee66efc1_783x337.png" alt=""></p>
<p>可以看到使用了usernick这个索引。这也符合之前提到的高可选择性，即SQL语句取表中较少行的原则。</p>
<h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>建立索引的前提是高选择性。这对数据库来说才具有实际意义，那么数据库是怎样统计Cardinality的信息呢?因为MySQL数据库中有各种不同的存储引擎，而每种存储引擎对于B+树索引的实现又各不相同。所以对Cardinality统计时放在存储引擎层进行的</p>
<p>在生成环境中，索引的更新操作可能非常频繁。如果每次索引在发生操作时就对其进行Cardinality统计，那么将会对数据库带来很大的负担。另外需要考虑的是，如果一张表的数据非常大，如一张表有50G的数据，那么统计一次Cardinality信息所需要的时间可能非常长。这样的环境下，是不能接受的。因此，数据库对于Cardinality信息的统计都是通过采样的方法完成</p>
<p>在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：insert和update。InnoDB存储引擎内部对更新Cardinality信息的策略为:</p>
<p><strong><em>表中1/16的数据已发生了改变</em></strong></p>
<p>stat_modified_counter&gt;2000 000 000</p>
<p>第一种策略为自从上次统计Cardinality信息后，表中的1/16的数据已经发生过变化，这是需要更新Cardinality信息</p>
<p>第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，这时表中的数据实际并没有增加，实际发生变化的还是这一行数据，则第一种更新策略就无法适用这种情况，故在InnoDB存储引擎内部有一个计数器start_modified_counter,用来表示发生变化的次数,当start_modified_counter&gt;2 000 000 000 时，则同样更新Cardinality信息</p>
<p>接着考虑InnoDB存储引擎内部是怎样进行Cardinality信息统计和更新操作呢？同样是通过采样的方法。默认的InnoDB存储引擎对8个叶子节点Leaf Page进行采用。采用过程如下</p>
<p>取得B+树索引中叶子节点的数量，记为A</p>
<p>随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，即为P1，P2….P8</p>
<p>通过采样信息给出Cardinality的预估值: Cardinality=(P1+P2+…+P8)*A/8</p>
<p>根据上述的说明可以发现，在InnoDB存储引擎中，Cardinality值通过对8个叶子节点预估而得的。而不是一个实际精确的值。再者，每次对Cardinality值的统计，都是通过随机取8个叶子节点得到的，这同时有暗示了另外一个Cardinality现象，即每次得到的Cardinality值可能不同的，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM OrderDetails</span><br></pre></td></tr></table></figure>

<p>上述SQL语句会触发MySQL数据库对于Cardinality值的统计，第一次运行得到的结果如图:</p>
<p><img src="https://box.kancloud.cn/02290ed6797f9b0bb0cf39ec178f690e_836x121.png" alt=""></p>
<p>在上述测试过程中，并没有通过INSERT、UPDATE这类的操作来改变OrderDetails中的内容，但是当第二次运行SHOW INDEX FROM OrderDetails语句是，发生了变化，如图:</p>
<p><img src="https://box.kancloud.cn/3f3035101c02738ac7297c81edf8f474_830x134.png" alt=""></p>
<p>可以看到，当第二次运行SHOW INDEX FROM OrderDetails语句时，表OrderDetails索引中的Cardinality值发生了变化，虽然表OrderDetails本身并没有发生任何变化，但是由于Cardinality是随机取8个叶子节点进行分析，所以即使表没有发生变化，用户观察到索引Cardinality值还是会发生变化，这本身不是Bug,而是随机采样而导致的结果</p>
<p>当然，有一种情况可以使得用户每次观察到的索引Cardinality值是一样的。那就是表足够小，表的叶子节点树小于或者等于8个。这时即使随机采样，也总是会采取倒这些页，因此每次得到的Cardinality值是相同的</p>
<p>在InnoDB1.2版本之前，可以通过innodb_stats_sample_pages用来设置统计Cardinality时每次采样页的数量，默认为8.同时，参数innodb_stats_method用来判断如何对待索引中出现NULL值记录。该参数默认值为nulls_equal,表示将NULL值记录为相等的记录。其有效值还nulls_unequal,nulls_ignored,分别表示将NULL值记录视为不同的记录和忽略NULL值记录。例如某夜中索引记录为NULL、NULL、1、2、2、3、3、3,在参数innodb_stats_method默认设置下，该页的Cardinality为4；若参数innodb_stats_method为nulls_unequal,则该页的Cardinality为5，若参数innodb_stats_method为nulls_ignored，则Cardinality值为3</p>
<p>当执行ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX 以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎会重新计算索引Cardinality值，若表中的数据量非常大，并且表中存在多个辅助索引时，执行上述操作可能会非常慢，虽然用户可能并不希望去更新Cardinality值</p>
<p>InnoDB1.2版本提供了更多参数对Cardinality进行设置。如表:</p>
<p><img src="https://box.kancloud.cn/2911102ff7b234496670844748bd3919_846x451.png" alt=""></p>
<h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3><p>并不是在所有的查询条件下出现的列都需要添加索引。对于什么时候添加B+树索引，我的经验是访问表中很少一部分行时，使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，即低选择性。<br>对于性别，可取值的范围只有’M’、’F’。对上述SQL语句得到的结果可能是该表50%的数据（我们假设男女比例1：1），这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，即高选择性，则此时使用B+树索引是最适合的，例如姓名字段，基本上在一个应用中都不允许重名的出现。</p>
<p>因此，当访问高选择性字段并从表中取出很少一部分行时，对这个字段添加B+树索引是非常有必要的。但是如果出现了访问字段是高选择性的，但是取出的行数据占表中大部分的数据时，这时MySQL数据库就不会使用B+树索引了。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引 运用的是多个索引列。 创建方法跟单个索引一样。<br>这么做的好处就是</p>
<ul>
<li>第一：是使用了B+树索引</li>
<li>第二：已经对第二个键值进行排序了</li>
</ul>
<p>注意：但是对于单个列查询是不引起联合索引。<br>关联查询的查询语句: select * from 表名 where id = * * * and user=  * * *</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create table buy_log(</span><br><span class="line">	userid int unsigned not null,</span><br><span class="line">    buy_date date</span><br><span class="line">)engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into buy_log values(1,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(2,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(3,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-02-01&#39;);</span><br><span class="line">insert into buy_log values(3,&#39;2009-02-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-03-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-04-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-05-01&#39;);</span><br><span class="line"></span><br><span class="line">alter table buy_log add key (userid);</span><br><span class="line">alter table buy_log add key (userid,buy_date);</span><br></pre></td></tr></table></figure>

<p>只对userid查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from buy_log where userid&#x3D;2</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/d97d0dfb5412d5c8e2087d611cc41812_942x76.png" alt=""></p>
<p>possible_keys 说明有两个索引可以用 userid,userid_2 但是优化器选择了userid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from buy_log where userid&#x3D;1 order by buy_date limit 3</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/155f7a727cc4a8d887744b92807bd11e_1141x90.png" alt=""></p>
<p>这里运用到了两个字段 所以优化器会选择userid_2 因为联合索引userid_2 已经排序好 buy_date</p>
<p>也可以 (a,b,c)当做联合索引但是如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from buy_log where a&#x3D;*** order by c</span><br></pre></td></tr></table></figure>

<p>这个情况就运行不了联合索引 因为c并不需要排序</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>InnoDB在1.0之后 或者 MySQL 在5.0或者以下的不支持覆盖索引。 就是从辅助索引中查询的记录，而不需要查询聚集索引中的记录。 好处就是辅助索引不包含整个行记录的所有信息，骨气大小远小于聚集索引。因此可以减少大量的IO操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select count(*) from buy_log;</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/b238db7600c4433df4cead41a06b9b03_981x89.png" alt=""></p>
<p>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。</p>
<p>如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。</p>
<h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>当执行 explain命令进行sql语句分析时,就会发现优化器并没有选择索引去查找数据,而是通过扫描聚集索引,也就是直接进行全表的扫描来得到的数据。 这种情况多发生与范围查找、JOIN链接操作等情况下。<br>可以通过show index from 表名查询索引:</p>
<p><img src="https://box.kancloud.cn/8442efc72a4a11803041d60214dab52a_1421x266.png" alt=""></p>
<p>可以看出该表是有使用(OrderID,ProductID)的联合主键,此外还有OrderID的单个索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where orderid &gt; 10000 and orderid&lt;10200;s</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/52e0c6962730c212f6a3b362514791c4_1377x130.png" alt=""></p>
<p>选择的是聚集索引而非辅助索引,原因是:OrderID索引不能覆盖到我们要查询的信息。虽然OrderID索引数据是顺序存放，但是再次进行书签查找数据是无序的，因此变为磁盘上离散读操作。如果要求访问的数据量小，则优化器还是会选择辅助索引，但是数据大的时候（一般20%左右），优化器会选择通过聚集索引来查找数据。因为顺序读比离散读快，但是如果是固态硬盘，随机读猜中非常快，同时自信确定使用辅助索引可以带来更好的性能 可以使用关键词 FORCE INDEX 来强制使用摸个索引,如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 force index(OrderID) where orderid &gt; 10000 and orderid&lt;10200;</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/54698ca8ce531cecebb14dc70e8f2a7e_860x143.png" alt=""></p>
<h4 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h4><p>MySQL5.6版本开始 支持 Multi-Range Read (MRR)优化。其目的是为了减少磁盘的随机访问，并且将随机访问转化为顺序的数据访问 这对 IO-bound类型的SQL查询语句可带来性能极大的提升。MRR适用于range，ref，eq_ref类型的查询。</p>
<p>MRR优化有以下几个好处：<br>（1）MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。<br>（2）减少缓冲池中页被替换的次数。<br>（3）批量处理对键值的查询操作。</p>
<p>对InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作MRR工作方式如下：<br>（1）讲查询得到的辅助索引键值存放在一个缓存中，这时缓存重点数据是根据辅助索引键值排序的。<br>（2）将缓存中的键值根据RowID进行排序。<br>（3）根据RowID的排序顺序来访问实际的数据文件。<br>此外 混吃次不是足够大，不能放下一张表中的所有数据，此时离散读操作会导致缓存中的页被替换出缓冲池，然后又不断读入换冲池。若是安装主键访问，则可以将此重复行为降为最低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where key_part1 &gt;&#x3D;1000 and key_part1 &lt;2000 and key_part2 &#x3D;10000</span><br></pre></td></tr></table></figure>

<p>表中 ( key_part1,key_part2)的联合索引,因此索引根据key_part1,key_part2的位置关系排序 没有 MRR查询类型为Range,sql优化器会先将key_part1大于1000 且小于2000的数据都取出,即使key_part2不等于10000。取出后进行过滤。这导致无用数据被取出。 如果启用MRR 会使其性能大大的提升。<br>优化器会将查询条件拆分为（1000,10000）（1001,10000），….，（1999,10000），最后进行数据的查询。<br>速度也是相差很大的。<br>启动方法:optimizer_switch 中的标记(flag)来控制。 总是开启MRR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@optimizer_switch &#x3D; &#39;mrr&#x3D;on,mrr_cost_based&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>

<p>read_rnd_buffer_size 用来控制键值的缓冲区大小,默认为256k;</p>
<p>查看命令: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@read_rnd_buffer_size\G;</span><br></pre></td></tr></table></figure>

<h4 id="Index-Condition-Pushdown-ICP-优化"><a href="#Index-Condition-Pushdown-ICP-优化" class="headerlink" title="Index Condition Pushdown( ICP )优化"></a>Index Condition Pushdown( ICP )优化</h4><p>需要在MySQL5.6版本支持这种根据索引进行查询的优化方式.之前的MySQL版本不支持Index Condition Pushdown, 首先是根据索引来查找记录,然后在根据where条件来过滤记录。 在支持Index Condition Pushdown后，MySQL数据库会取出索引的同时，判断是否进行where条件的过滤，也就是将where的部分过滤操作放在存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能。</p>
<p>Index Condition Pushdown( ICP )优化支持range，ref，eq_ref，ref_or_null类型的查询。当前支持MyISAM和InnoDB存储引擎。</p>
<p><img src="https://box.kancloud.cn/095a7816002971c6e7bbfb68910c5e4a_889x694.png" alt=""></p>
<p>Extra表示附加信息，常见的有如下几种（也按查询效率从高到低排列）：<br>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。<br>Using where：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where。如果type列是ALL或index，而没有出现该信息，则你有可能在执行错误的查询：返回所有数据。<br>Using filesort：不是“使用文件索引”的含义！filesort是MySQL所实现的一种排序策略，通常在使用到排序语句ORDER BY的时候，会出现该信息。<br>Using temporary：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</p>
<p>如果EXPLAIN出现后面两个信息（Using filesort，Using temporary），而rows又比较大，通常意味着你需要调整查询语句，或者需要添加索引，总之需要尽量消除这两个信息。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表 也称为散列表,用一个数组(即直接寻址表)T[0..m-1]表示动态集合,其中每个位置(或称槽或者桶)对应全域U中的一个关键字。图说明了这个方法k指向集合中的一个关键字为K的元素。如果集合中没有关键词k的元素 则T[k]=NULL;</p>
<p>元素h（k）利用哈希函数h，根据关键字k计算出槽位置。函数h将关键词域U映射到哈希T[0..m-1]的槽位上。但是两个关键词可能映射到同一个槽上。这种情况称为碰撞。链接法解决碰撞问题。</p>
<p><img src="https://box.kancloud.cn/eb96e30db568d22a2c90d0901e063380_602x339.png" alt=""></p>
<p>一般使用除法散列法：哈希函数：h（k）=k mod m；</p>
<p><img src="https://box.kancloud.cn/ca1c30861432f42005053893dd7aabd6_847x230.png" alt=""></p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引只能通过 等值条件查找如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where id_x&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/c4c3b890efa62b43f167dd97e40c9520_696x380.png" alt=""></p>
<p>通过参数 innodb_adaptive_hash_index来禁用和启动特性,默认为开启。</p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>全文检索(full_test search)是将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。它可以根据需要获取全文中有关的章、节、段、句等信息，也可以进行各种统计和分析。<br>InnoDB在1.2.X开始之前支持全文检索，其支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。<br>如：select * from 表名 where title like ‘中午%’; 这个语句是可以通过 B+树索引进行查询<br>如：select * from 表名 where title like ‘%中午%’; 这个就不能用B+树能够更好的工作了</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文检索通常使用倒排索引（inverted index）来实现。倒排索引在辅助表（auxiliary table） 中存储了单词与单词自身在一个或者多个文档中所在位置之间的映射。利用相关数组实现，其拥有两种表现形式：<br>（1） inverted file index，其表现形式为{ 单词,单词所在的文档的ID}<br>（2）full inverted index,其表现形式为{ 单词,( 单词,单词所在的文档的位置)}</p>
<p><img src="https://box.kancloud.cn/dfcafde3dcbe4af20aed33c451d7a3a5_834x576.png" alt=""></p>
<p>对 inverted file index 其仅存文档id,而full inverted index存储的是对(pair),即(DocumentId,Position),因此存储的倒排索引如下图：</p>
<p><img src="https://box.kancloud.cn/d5d661bbb6a71ae614d259a2b7bbac7a_828x257.png" alt=""></p>
<p>full inverted index存储了单词所在的位置信息,但是同时也暂用了更多的空间,但是能更好的的定位数据。</p>
<h4 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h4><p>将(DocumentId,Position)视为一个“ilist”。因此全文检索的表中，有一个是word 字，另一个是ilist字段，并且word字段上设有索引。<br>由于Innodb 存储引擎在ilist 字段中存放了Position信息，故可以进行Proximity Search（邻近搜索），而MyISAM存储不支持改特性。</p>
<p>在InnoDB存储引擎中，为了提高全文检索的并行性能，共有6张Auxiliary Table（辅助表），目前每张表根据word的Latin编码进行分区<br>Auxiliary Table（辅助表）是持久表，存放磁盘上。在全文索引中，还有另一个重要的概念FTS Index Cache（全文索引索引缓存）来听全文检索的性能。<br>FTS Index Cache是一个红黑树结构，其中根据（word，ilist）进行排序。意味着插入的数据已经更新到对应的表，但是全文索引更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table 可能没有更新。 InnoDB存储索引会批量对Auxiliary Table 进行更新，而不是每次插入就更新一次Auxiliary Table。当对全文检索进行查询时，Auxiliary Table首先会对FTS Index Cache 中对应的word 字段合并到Auxiliary Table中在查询. 这种合并提高了InnoDB存储引擎的性能,并且由于红黑树排序后进行批量插入,其产生Auxiliary Table相对较小。</p>
<p>Innodb运行用户查看置顶倒排索引的Auxiliary Table种的分词信息，可以通过参数设置innodb_ft_aux_table 来观察倒排索引的Auxiliary Table。<br>test 架构下表fts_a的Auxiliary Table;<br>set global innodb_ft_aux_table = ‘test/fts_a’;</p>
<p>查询test架构下的表fts_a的分词信息select * from information_schema.INNODB_FT_INDEX_TABLE;</p>
<p>参数innodb_ft_cache_size 控制FTS Index Cache的大小,默认值为32M。当该缓存满时，会将掐中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大参该参数可以提高全文检索的性能，但是在宕机时，未同步到磁盘重点索引信息可能需要更长的时间恢复。</p>
<p>FTS Document ID 是另一种概念。Innodb存储引擎中，为了支持全文检索，必须有一个列与word进行映射，这个列为FTS_DOS_ID，类型必须是 BIGINT UNSIGNED NOT NULL,并且Innodb引擎会加入名为FTS_DOC_ID_INDEX 的Unique Index. 上述操作是有Innodb引擎自己完成的。 用户也可以自己在建表时自动添加FTS_DOC_ID，已经对应的Unique Index。但是类型必须是 BIGINT UNSIGNED NOT NULL</p>
<p>文档分词的插入是事务提交时完成的，而对于删除操作，其在事务提交时，不删除磁盘Auxiliary Table重点记录,而只是删除FTS Cache index中的记录,对于Auxiliary Table中被删除的记录,FTS Document ID,并将其保存在DELETED auxiliary table中.在 innodb_ft_aux_table设置之后,可以访问information_schema价格下的表innodb_ft_deleted 中观察删除的FTS Document ID。文档的DML操作并不能删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，用户可以手工将已经删除的记录从索引中彻底删除，改命令是OPTIMIZE TABLE。该命令可以做其他的操作 所以可以通过参数innodb_optimize_</p>
<p>_onle进行设置。如:<br>set global innodb_optimize_fulltext_onlt=1;<br>optimize tablefts_a;<br>可以通过innodb_ft_num_wird_optimize 进行限制分词数量。默认为2000。</p>
<p>当InnoDB存储引擎的全文检索还存在以下的限制：</p>
<ul>
<li><p>（1）一个表只能有一个全文检索的索引。</p>
</li>
<li><p>（2）有多列组成的全文检索的索引列必须使用相同的字符集与排序规则。</p>
</li>
<li><p>（3）不支持没有单词界定符（delimiter） 的语言。如中文、日语、韩语等。</p>
</li>
</ul>
<h4 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h4><p>MySQL 5.6.4里才添加了InnoDB引擎的Full-Text索引支持。</p>
<p>设置全文搜索:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE  &#96;表名&#96; ADD FULLTEXT (</span><br><span class="line">&#96;字段名&#96;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>MySQL数据库之前全文检索(Full-Text Search)的查询，其语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,....) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line"> IN NATURAL LANGUAGE MODE </span><br><span class="line"> | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line"> | IN BOOLEAN MODE</span><br><span class="line"> |WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MySQL 数据库通过MATCH()…AGAINST()语法支持全文检索的查询,MATCH指定了需要被查询的列,AGAINST指定了使用何种方法去进行查询。下面将对各种查询模式进行详细的介绍。</p>
<h5 id="Natural-Language"><a href="#Natural-Language" class="headerlink" title="Natural Language"></a>Natural Language</h5><p>全文检索沟通过MATCH函数进行查询，默认采用Natural Language模式，其表示查询带有指定word的文档。对于创建的表fts_a，查询body 字段中带有pease的文档，若不使用全文索引技术，则允许使用下述sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fts_a where body like &#39;%Pease%’;</span><br></pre></td></tr></table></figure>

<p>显然上述sql语句不能使用B+树索引.若采用全文检索技术,可以用下面的sql语句进行查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from fts_a </span><br><span class="line">where match(body)</span><br><span class="line">against (&#39;Pottidge&#39; in natural language mode);</span><br></pre></td></tr></table></figure>

<p>默认是in natural languagemode 所以可以省略:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cco_images where match(label) against (&#39;Romanesco&#39;);</span><br></pre></td></tr></table></figure>

<p>查询计划:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from cco_images where match(label) against (&#39;Romanesco&#39;);</span><br></pre></td></tr></table></figure>

<p>可以看到 type这列显示的是fulltext,即表示使用全文检索技术。同时，若表没有创建倒排索引，则只需match 函数会抛出类错误：Can’t find FULLTEXT index matching the column list 意思是:”找不到与列列表匹配的FULLTEXT索引”。<br>如果使用innodb搜索引擎里的mysql版本低于3.6.4时回报：the used table type doesn’t support fulltest indexes<br>翻译是：“使用的表类型不支持完整索引”</p>
<p>查询的范围结果是根据相关性（relevance）进行降序排序的，即相关性最高的结果放在第一位。相关性的值是一个非负的浮点数字，0表示没有任何的相关性。根据mysql官方文档可知，相关性计算根据以下四个条件：</p>
<ul>
<li>（1）word是否在文档中出现。</li>
<li>（2）word在文档中出现的次数。</li>
<li>（3）word在索引列中的数量。</li>
<li>（4）多少个文档包含该word。</li>
</ul>
<p><img src="https://box.kancloud.cn/d7a3190a95553023abeb14fe42e20335_826x267.png" alt=""></p>
<p>该查询没有经过相关性的排序 所以该查询的速度比常规的 match查询速度要快。</p>
<p>对于InnoDB存储引擎的全文检索，还需要考虑以下的因素：</p>
<ul>
<li>（1）查询的word在stopword列中。忽略该字符串的查询。</li>
<li>（2）查询的word的字符串长度是否在区间【innodb_ft_min_token_size,innodb_ft_max_token_size】内 InnoDB存储引擎中，参数innodb_ft_min_token_size默认是3，innodb_ft_max_token_size默认是84 如果不在范围内 这会忽略</li>
</ul>
<h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>MySQL数据库允许使用IN BOOLEAN MODE修饰符来进行全文检索。当使用该修饰符时，查询字符串的前后字符会有特殊的含义，例如下面的语句要求查询有字符串Vitaminhaltig但没有Romanesco的文档，其中+和-分别表示这个单词必须出现，或者一定不存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * fromselect * from cco_images where match(label) against (&#39;-Romanesco +Vitaminhaltig &#39; in boolean mode);</span><br></pre></td></tr></table></figure>

<p>Boolean 全文检索支持一下几种操作符:</p>
<p>（1）+表示该word必须存在。<br>（2）-表示该word必须被排除<br>（3）（no operator）表示该word是可选的，但是如果出现，其相关性会更高<br>（4）@distance 表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。这种全文检索的查询也称为Proximity Search。 如MATCH(label) AGAINST (‘“Pease pot”@30’ IN BOOLEAN MODE) 表示字符串Peace和pot之间的距离需在30字节以内。<br>（5）&gt;表示出现该单词时增加相关性。<br>（6）&lt;表示出现该单词时降低相关性。<br>（7）~表示允许出现该单词，但是出现是相关性为负（全文检索查询运行负相关性）。<br>（8）* 表示以该单词开头的单词，如lik*，表示可以是lik、like，又或者likes。<br>（9） “ 表示短语。</p>
<p>如果在against（里面添加上“”这表示该两个单词是一个短语） 如下：</p>
<p><img src="https://box.kancloud.cn/7987472fb2b45b36230ce3478a5050a1_689x75.png" alt=""></p>
<h5 id="query-Expansion"><a href="#query-Expansion" class="headerlink" title="query Expansion"></a>query Expansion</h5><p>mysql数据库支持扩展查询。 这种查询在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。<br>通过查询短句中添加with query expansion 或 in natural languange mode with query expansion 可以开启blind query expamsoin（又称 automaticrelevance feedback）。该查询分为两个阶段。</p>
<ul>
<li>（1）第一阶段 根据单词进行全文索引查询。</li>
<li>（2）第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/09/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C1/"><i class="fa fa-chevron-left">  </i><span>项目设计：一个服装定制商城</span></a></div><div class="next-post pull-right"><a href="/2020/02/26/%E7%AE%97%E6%B3%951/"><span>SnowFlake算法生成全局唯一ID</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2024 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>