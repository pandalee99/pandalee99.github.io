<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="使用Netty+Nacos+Protobuf制作RPC框架"><meta name="keywords" content="RPC,Java"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>使用Netty+Nacos+Protobuf制作RPC框架 | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#使用Netty-Nacos-Protobuf制作RPC框架"><span class="toc-number">1.</span> <span class="toc-text">使用Netty+Nacos+Protobuf制作RPC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#显现的功能"><span class="toc-number">1.1.1.</span> <span class="toc-text">显现的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试"><span class="toc-number">1.1.2.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端分析"><span class="toc-number">1.2.</span> <span class="toc-text">服务端分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractRpcServer"><span class="toc-number">1.2.1.</span> <span class="toc-text">AbstractRpcServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServer"><span class="toc-number">1.2.2.</span> <span class="toc-text">NettyServer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NacosUtil"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">NacosUtil</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServiceProviderImpl"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">ServiceProviderImpl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShutdownHook"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">ShutdownHook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#心跳检测"><span class="toc-number">1.2.3.</span> <span class="toc-text">心跳检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServerHandler"><span class="toc-number">1.2.4.</span> <span class="toc-text">NettyServerHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestHandler"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">RequestHandler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编解码器"><span class="toc-number">1.2.5.</span> <span class="toc-text">编解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码器"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">编码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解码器"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">解码器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protobuf"><span class="toc-number">1.2.6.</span> <span class="toc-text">Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBuffer"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">LinkedBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Schema"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">Schema</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProtostuffIOUtil"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">ProtostuffIOUtil</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RuntimeSchema"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">RuntimeSchema</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端分析"><span class="toc-number">1.3.</span> <span class="toc-text">客户端分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RpcClientProxy"><span class="toc-number">1.3.1.</span> <span class="toc-text">RpcClientProxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClient"><span class="toc-number">1.3.2.</span> <span class="toc-text">NettyClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负载均衡"><span class="toc-number">1.3.3.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NacosServiceDiscovery"><span class="toc-number">1.3.4.</span> <span class="toc-text">NacosServiceDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnprocessedRequests"><span class="toc-number">1.3.5.</span> <span class="toc-text">UnprocessedRequests</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelProvider"><span class="toc-number">1.3.6.</span> <span class="toc-text">ChannelProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyClientHandler"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">NettyClientHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完结"><span class="toc-number">1.4.</span> <span class="toc-text">完结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">87</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">61</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">使用Netty+Nacos+Protobuf制作RPC框架</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-02</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a name="ly3F9"></a></p>
<h1 id="使用Netty-Nacos-Protobuf制作RPC框架"><a href="#使用Netty-Nacos-Protobuf制作RPC框架" class="headerlink" title="使用Netty+Nacos+Protobuf制作RPC框架"></a>使用Netty+Nacos+Protobuf制作RPC框架</h1><p><a name="KeQ2k"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a name="FQTT2"></a></p>
<h3 id="显现的功能"><a href="#显现的功能" class="headerlink" title="显现的功能"></a>显现的功能</h3><p>这个RPC实现了一些基本的功能：</p>
<ul>
<li>使用Netty来进行网络传输，效率比起传统的NIO要高很多。</li>
<li>使用单例模式，在Netty获取Channel的过程中，会有一个ChannelProvider去提供Channel单例。</li>
<li>使用Nacos作为服务的注册中心，用于管理注册的服务，当客户端请求发过来时，Nacos会寻找合适的服务返回给客户端消费。</li>
<li>实现了负载均衡的功能，，客户端对于Nacos返回的服务列表，会使用负载均衡算法，选择一个自己需要的服务加入，目前实现了轮询算法和随机选取算法。</li>
<li>加入了心跳检测机制，并不会发送完消息立即结束，而是保持的长连接，提高效率。</li>
<li>使用Potobuf作为对象的的序列化工具，实现Netty中的编/解码的功能，提高了效率。</li>
<li>实现了钩子函数，当服务端下线的时候会自动去Nacos注销服务。</li>
<li>使用CompletableFuture来接受客户端返回的结果。</li>
</ul>
<p><a name="UlREa"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>由于使用Nacos，调试比较简单：<br />下载好Nacos，无论是win版还是linux版，在官网都有，比较方便；<br />但是由于Nacos一般都要配置数据库，为了方便测试，可以使用命令先进行单机运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">114514</span>, <span class="string">"Client send a Message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> NettyServer(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后会有一个测试结果：<br />客户端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513541152-f58818bf-b30d-438c-bebd-3374cb6f6b3f.png#averageHue=%23f5ecea&clientId=ucfcf756b-0ecd-4&from=paste&height=400&id=uc9973f1d&name=image.png&originHeight=600&originWidth=2205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111506&status=done&style=none&taskId=ubbd01eee-67bf-4697-b872-6eef4c3b304&title=&width=1470" alt="image.png"><br />服务端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513584290-393ae7f9-f650-4a6d-b6a2-ad58cd7c2360.png#averageHue=%23f5ebe9&clientId=ucfcf756b-0ecd-4&from=paste&height=301&id=u72da898a&name=image.png&originHeight=452&originWidth=2307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88585&status=done&style=none&taskId=u57f54541-d548-4720-aca7-051e4b65050&title=&width=1538" alt="image.png"></p>
<p><a name="VFwOu"></a></p>
<h2 id="服务端分析"><a href="#服务端分析" class="headerlink" title="服务端分析"></a>服务端分析</h2><p>首先服务端都会实现一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.PROTOBUF_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口通常定义了默认的序列化方法，开始方法，和发布服务的方法。<br />接着会有一个抽象类去实现这个接口：<br><a name="DbRAB"></a></p>
<h3 id="AbstractRpcServer"><a href="#AbstractRpcServer" class="headerlink" title="AbstractRpcServer"></a>AbstractRpcServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"启动类缺少 @ServiceScan 注解"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"出现未知错误"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service<span class="class">.<span class="keyword">class</span>).<span class="title">name</span>()</span>;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"创建 "</span> + clazz + <span class="string">" 时有错误发生"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">""</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    这段代码是在判断 Service 注解中的 name 属性是否为空，如果为空，</span></span><br><span class="line"><span class="comment">                    则说明该服务实现类实现了多个接口，并且需要将每个接口都发布成一个独立的服务。</span></span><br><span class="line"><span class="comment">                    所以，代码通过获取该服务实现类的所有接口，然后将每个接口都作为一个独立的服务进行发布。</span></span><br><span class="line"><span class="comment">                    如果 name 属性不为空，则说明只需要将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                    此时，代码直接将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanServices 的作用：这段代码是服务扫描的核心实现，它通过获取启动类的信息，获取服务扫描的基础包路径，然后扫描该路径下的所有类，判断是否有@Service注解，如果有，就将该服务发布到注册中心。<br />具体的实现流程如下：</p>
<ol>
<li>调用ReflectUtil.getStackTrace()方法获取当前方法调用的栈信息，得到启动类的全限定名。</li>
<li>使用Class.forName()方法加载启动类，判断启动类是否被@ServiceScan注解所标注，如果没有则抛出异常。</li>
<li>获取@ServiceScan注解的参数值，即基础包路径。</li>
<li>调用ReflectUtil.getClasses()方法获取指定包下的所有类，遍历这些类，判断是否被@Service注解所标注。</li>
<li>如果被@Service注解所标注，则获取@Service注解的参数值，即服务名称，如果未指定服务名称，则获取该服务实现类实现的所有接口，并将该服务发布到注册中心。</li>
<li>如果指定了服务名称，则直接将该服务发布到注册中心。</li>
</ol>
<p>该方法主要的功能就是扫描服务，将服务发布到注册中心，为后续的服务调用提供依据<br />接着我们来看看这个所需要的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务扫描的基包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而上述提到的ReflectUtil这个类是一个比较常见的类，这个类是一个工具类，提供了两个静态方法：getStackTrace(): 返回当前调用栈顶部的类名。利用Java的反射机制，调用 new Throwable().getStackTrace() 方法获取当前调用栈信息，返回调用栈顶部的类名。<br />getClasses(String packageName): 获取指定包名下所有的类。该方法通过输入一个包名，然后通过反射机制查找该包下的所有类，返回一个 Set&lt;Class&lt;?&gt;&gt; 对象。该方法实现的过程比较复杂，具体过程为：</p>
<ol>
<li>通过 Thread.currentThread().getContextClassLoader().getResources(packageDirName) 获取指定包名下的所有资源。</li>
<li>遍历所有资源，如果是文件，则通过递归方式查找该文件夹下所有的类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li>
<li>如果是 Jar 包，则通过 JarFile 对象查找该 Jar 包中的所有类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li>
</ol>
<p>该工具类可以用于类加载器等需要动态加载类的场景，例如 Spring 框架中的 Bean 加载、RPC 框架中的服务注册等</p>
<p><a name="azGEB"></a></p>
<h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><p>接着便是这个RPC服务端的逻辑实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同时也继承了serviceRegistry和serviceProvider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 256)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"启动服务器时有错误发生: "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类实现了一个基于Netty框架的RPC服务器，它继承了抽象类AbstractRpcServer，并且拥有服务注册表（serviceRegistry）和服务提供者（serviceProvider）的实例。<br />在构造函数中，传入了服务器的主机名和端口号，以及序列化器（serializer）。在构造函数中还调用了扫描服务的方法scanServices()。<br />在start()方法中，创建了两个EventLoopGroup，用于处理连接和IO的事件。然后使用ServerBootstrap创建了一个服务端的引导类，通过设置一系列的选项和处理器来配置Netty服务器。其中，ChannelInitializer是一个特殊的处理器，用于在Channel被创建时执行一些初始化操作。在这个ChannelInitializer中，注册了一个IdleStateHandler用于处理空闲连接，以及自定义的编解码器和处理器。<br />最后，通过调用bind()方法绑定主机名和端口号，并且调用sync()方法等待服务器启动完成。当关闭服务器时，调用shutdownGracefully()方法优雅地关闭EventLoopGroup。<br />这就是这个类的大体流程，接下来，可以一个个分开来看<br />其中，NacosServiceRegistry会返回一个服务注册器实例，但是这个实例实际上会调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"注册服务时有错误发生:"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是NacosUtil去实现服务注册：<br><a name="Q2Adh"></a></p>
<h4 id="NacosUtil"><a href="#NacosUtil" class="headerlink" title="NacosUtil"></a>NacosUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">"127.0.0.1:8848"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接到Nacos时有错误发生: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"注销服务 &#123;&#125; 失败"</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个Nacos工具类，用于连接到Nacos服务注册中心并与之进行交互。主要包含以下几个方法：</p>
<ol>
<li>getNacosNamingService()方法用于获取NacosNamingService实例。</li>
<li>registerService(String serviceName, InetSocketAddress address)方法用于向Nacos注册服务实例，即将提供服务的服务地址和端口注册到Nacos中，以便客户端可以通过服务名称查找到该服务。</li>
<li>getAllInstance(String serviceName)方法用于获取指定服务名称下的所有服务实例，返回一个Instance列表。</li>
<li>clearRegistry()方法用于清空注册中心中注册的服务实例，即将服务注销。</li>
</ol>
<p>通过这个工具类，我们可以将服务注册到Nacos服务注册中心，并通过Nacos中心来查找并获取服务实例，以便客户端可以通过服务名称调用相应的服务。<br><a name="wIRIl"></a></p>
<h4 id="ServiceProviderImpl"><a href="#ServiceProviderImpl" class="headerlink" title="ServiceProviderImpl"></a>ServiceProviderImpl</h4><p>而ServiceProviderImpl默认的服务注册表，保存服务端本地服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">"向接口: &#123;&#125; 注册服务: &#123;&#125;"</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个服务提供者的默认实现类，它实现了 ServiceProvider 接口中的方法，可以将提供者实例添加到服务注册表中，提供了一种方便地访问服务的方式。在服务注册表中，服务名与服务实例之间的映射关系是使用 ConcurrentHashMap 实现的。它有两个主要方法：</p>
<ol>
<li>addServiceProvider(T service, String serviceName)：将服务提供者添加到服务注册表中，当服务名已经存在于注册表中时，则不进行任何操作。</li>
<li>getServiceProvider(String serviceName)：根据服务名从服务注册表中获取相应的服务实例。如果服务不存在，则抛出 RpcException 异常，表示未找到服务。</li>
</ol>
<p><a name="RA6ZR"></a></p>
<h4 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h4><p>当一个服务开启之后，也会开始一个钩子函数，它的Runtime类会使用getRuntime().addShutdownHook()方法，在服务结束前，注销掉所有的在Nacos的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"关闭后将自动注销所有服务"</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类是一个单例，它提供了一个静态方法getShutdownHook()来获取一个实例。它注册了一个JVM shutdown hook，该hook会在JVM关闭前被执行，清除所有注册到Nacos服务注册中心上的服务和所有线程池。这个类的作用是确保在JVM关闭前执行清除操作，避免可能的资源泄漏和数据一致性问题。</p>
<p><a name="klHf5"></a></p>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>这里在SocketChannel中加入了一个IdleStateHandler，使其具有心跳检测功能<br />在 Netty 中，IdleStateHandler 是一个用于处理空闲状态的处理器。它可以在 Channel 上检测特定类型的空闲时间，并在这些时间段内未发生读取、写入或读写事件时触发相应的事件。常用的空闲状态类型有三种：READER_IDLE，WRITER_IDLE 和 ALL_IDLE。<br />IdleStateHandler 可以用于实现心跳机制，可以通过配置空闲时间间隔和触发事件来判断是否需要发送心跳包。它可以被添加到 Netty 的 ChannelPipeline 中，以监视 Channel 上的空闲事件，以便可以采取适当的措施，例如关闭连接或发送心跳消息。</p>
<p><a name="fWDhA"></a></p>
<h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><p>这里也同时添加了一个NettyServerHandler去处理在Channel中发生的时间。<br />先拿上面的心跳检测为例子，如果收到了一个心跳包，便会打印一条日志，告诉服务端收到了。而在长时间没有收到心跳包后，则会关闭上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">"接收到客户端心跳包..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"服务器接收到请求: &#123;&#125;"</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"通道不可写"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"处理过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"长时间未收到心跳包，断开连接..."</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleChannelInboundHandler 是 Netty 中的一个基础类，实现了 ChannelInboundHandler 接口。它主要用于处理入站事件，即从对等端接收到的数据或状态更改事件，例如对等端连接或断开连接。与 ChannelInboundHandlerAdapter 不同的是，SimpleChannelInboundHandler 可以自动释放资源，因此不需要显示地调用 ReferenceCountUtil.release() 释放资源。<br />当数据从远程节点传入时，SimpleChannelInboundHandler 将自动将其转换为指定类型的对象，并在调用 channelRead0() 方法时向你提供该对象，你只需要处理传入的数据。可以使用这个类来构建各种应用程序，例如聊天应用程序、游戏服务器、文件传输应用程序等。<br />而这里的requestHandler是一个单例，表示全程都使用这个单例去处理请求，这样就不会浪费大量的资源去重复创建实例。<br><a name="MTSdN"></a></p>
<h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">"服务:&#123;&#125; 成功调用方法:&#123;&#125;"</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个RequestHandler使用的方法不多，最为主要的方法还是：<br>:::info<br>result = method.invoke(service, rpcRequest.getParameters());<br>:::<br>这个方法会调用Method实例的invoke方法，去执行相应的请求。<br />在Java中，Method类是反射机制的一部分，它代表一个类中的一个方法。可以使用Method类来获取关于方法的信息，如方法名、参数列表、返回类型、修饰符等，并且可以使用Method类来调用该方法。Method类提供了许多用于获取和调用方法的方法，如invoke()、getName()、getParameterTypes()、getReturnType()等。反射机制中的Method类可以使得在运行时动态地获取和调用类中的方法。</p>
<p><a name="Le2TA"></a></p>
<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器可以说是整个RPC框架中最为重要的一部分，那么RPC为什么需要编解码器呢？<br />因为在RPC通信过程中，数据需要在网络中传输。在不同的计算机之间通信需要将对象序列化为字节流，传输完成后再反序列化为对象。编解码器的作用就是将对象序列化和反序列化的过程封装起来，让开发者可以更方便地进行通信。在Netty中，SimpleChannelInboundHandler类可以自动完成消息的解码和编码，大大简化了编解码器的编写过程。<br />那为什么不用直接用序列化？<br />虽然序列化可以将对象转换成字节流进行网络传输，但是它并不能满足RPC的需求。<br />RPC需要一个通用的方式来序列化和反序列化各种类型的消息，包括基本数据类型、复合数据类型和自定义类型等。而不同的序列化实现可能只支持特定的类型或数据格式，因此无法满足这个需求。<br />此外，RPC需要支持不同的编解码器，以便兼容不同的协议和框架。使用编解码器可以使得不同的实现之间相互兼容，也方便进行协议升级和兼容性处理。<br />因此，编解码器是RPC中必不可少的组件，它能够实现通用的序列化和反序列化，同时兼容不同的协议和框架，满足RPC的需求。</p>
<p><a name="BVL84"></a></p>
<h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>MessageToByteEncoder 是 Netty 提供的编码器抽象类，用于将消息转换为字节流进行网络传输。在 Netty 应用中，可以使用它将自定义的消息对象编码为二进制数据，以便通过网络进行传输。<br />实现 MessageToByteEncoder 需要重写 encode() 方法，该方法会在消息被写入通道前被自动调用。在 encode() 方法中，我们需要将消息对象转换为字节流，并将字节流写入到 ByteBuf 中。写入到 ByteBuf 中的字节流会在后续的 ChannelHandler 中被传递，最终通过网络传输到远程节点。<br />MessageToByteEncoder 中还提供了一些辅助方法，如 writeXXX() 系列方法可以将不同类型的数据写入到 ByteBuf 中，以及提供了一些钩子方法，可以在编码过程中对消息进行处理，比如对消息进行压缩、加密等操作。<br />总之，MessageToByteEncoder 是 Netty 提供的编码器抽象类，通过继承它可以实现自定义的消息编码器。<br />CommonEncoder继承了MessageToByteEncoder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个 Netty 中的编码器类，用于将消息对象转换为二进制字节流，以便在网络上进行传输。在 RPC 中，消息通常是由客户端和服务端之间相互传递的。因为在不同的机器之间传递数据时，需要将数据序列化为二进制流，才能在网络中传输。但是，不同的序列化方式可能具有不同的数据格式和协议，所以需要使用编解码器来统一数据格式和协议。这个类实现了 Netty 中的 MessageToByteEncoder 类，并将消息对象编码为二进制流，遵循了一个特定的协议，包括一个魔数、消息类型、序列化方式、消息长度和消息内容。其中，魔数用于识别协议版本，消息类型用于标识消息是请求还是响应，序列化方式用于指定消息内容的序列化方式，消息长度用于指定消息内容的长度，消息内容就是序列化后的消息体。这个类是 RPC 通信中必不可少的一部分。</p>
<p><a name="Mudkb"></a></p>
<h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>ReplayingDecoder是Netty提供的一种特殊类型的解码器。与普通解码器不同，ReplayingDecoder可以在缓冲区数据不足时进行暂停，并在数据可用时恢复处理，而不是等待缓冲区填满。<br />具体来说，ReplayingDecoder类通过继承ByteToMessageDecoder类并使用状态机模式实现。状态机模式通过在每个状态中重写decode()方法来定义不同的处理行为。当状态更改时，它将转移到下一个状态，直到解码完成为止。<br />ReplayingDecoder的主要作用是简化解码器的实现，尤其是对于一些不确定数据长度的解码器。通过使用ReplayingDecoder，可以避免手动跟踪缓冲区中的字节数，从而减少出错的可能性。同时，ReplayingDecoder还可以提供更好的性能，因为它只需要处理缓冲区中实际可用的数据，而不是缓冲区中的所有数据<br />CommonDecoder继承了ReplayingDecoder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的协议包: &#123;&#125;"</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的数据包: &#123;&#125;"</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的反序列化器: &#123;&#125;"</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类是一个Netty解码器，用于将字节流转换为对象。具体来说，它的作用是将从网络中接收到的字节流解码为指定的Java对象，以供后续处理。<br />在方法decode()中，它首先读取一个整数值，如果它不等于预定义的一个常量值，就会抛出一个RpcException异常，这表示该字节流不是正确的RPC协议包。接下来，它读取协议包类型和序列化器类型，并检查它们是否为预期值，否则将抛出异常。然后，它读取字节流的长度，并将剩余的字节读入到字节数组中。最后，它使用指定的序列化器将字节流反序列化为预期的Java对象，并将其添加到输出列表中</p>
<p><a name="y5CbI"></a></p>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protocol Buffers（简称protobuf）是一种轻便高效的数据序列化格式，由Google开发。它与XML和JSON等格式相比，具有更小的数据体积和更快的解析速度，同时也可以生成各种编程语言的代码，从而方便了跨语言的数据交换和通信。在Java中，我们可以通过使用Protobuf库来实现Protobuf的序列化和反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; schemaCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        Class clazz = obj.getClass();</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        Object obj = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">"PROTOBUF"</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Schema <span class="title">getSchema</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = schemaCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(schema)) &#123;</span><br><span class="line">            <span class="comment">// 这个schema通过RuntimeSchema进行懒创建并缓存</span></span><br><span class="line">            <span class="comment">// 所以可以一直调用RuntimeSchema.getSchema(),这个方法是线程安全的</span></span><br><span class="line">            schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(schema)) &#123;</span><br><span class="line">                schemaCache.put(clazz, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个实现了CommonSerializer接口的类，用于将Java对象序列化为Protobuf格式的字节数组，或者将字节数组反序列化为Java对象。<br />具体来说，该类中的serialize方法将一个Java对象序列化为Protobuf格式的字节数组，实现过程如下：</p>
<ol>
<li>获取对象的类类型Class clazz。</li>
<li>通过getSchema方法获取该类对应的Schema对象。</li>
<li>使用该Schema对象和LinkedBuffer对象调用ProtostuffIOUtil.toByteArray方法将Java对象序列化为字节数组。</li>
<li>最后清空LinkedBuffer对象并返回序列化后的字节数组。</li>
</ol>
<p>而deserialize方法则是将字节数组反序列化为Java对象：</p>
<ol>
<li>获取对象的类类型Class clazz。</li>
<li>通过getSchema方法获取该类对应的Schema对象。</li>
<li>调用schema.newMessage()创建一个该类的空对象。</li>
<li>使用字节数组和Schema对象调用ProtostuffIOUtil.mergeFrom方法将字节数组反序列化为Java对象并返回。</li>
</ol>
<p>同时，为了提高性能，该类中使用了缓存机制，通过ConcurrentHashMap缓存Schema对象，以便在下次序列化或反序列化时能够更快地获取Schema对象，避免了重复创建的开销。</p>
<p>在具体的分析下面类的作用：<br><a name="RoCQJ"></a></p>
<h4 id="LinkedBuffer"><a href="#LinkedBuffer" class="headerlink" title="LinkedBuffer"></a>LinkedBuffer</h4><p>LinkedBuffer是Protostuff序列化库中的一个类，用于在序列化过程中存储数据。它是一个基于链表的动态缓存区，它会自动根据当前写入数据的大小来调整缓存区的大小。<br />具体来说，LinkedBuffer维护了一个字节数组（即缓存区），一个指向缓存区首部的指针和一个指向缓存区尾部的指针。当我们往缓存区写入数据时，LinkedBuffer会先检查当前剩余的空间是否足够，如果不够则会自动扩展缓存区。扩展时会新建一个更大的缓存区，并将当前缓存区中的数据复制到新缓存区中，然后将新缓存区设置为当前缓存区。<br />LinkedBuffer使用链表来管理多个缓存区，每次扩展时都会新建一个缓存区并添加到链表尾部。这样做的好处是可以避免频繁的内存分配和拷贝，从而提高序列化性能。<br />在上面的代码中，LinkedBuffer被用于在ProtobufSerializer类中序列化对象时存储数据。当我们调用ProtostuffIOUtil.toByteArray()方法将一个对象序列化为字节数组时，需要传入一个LinkedBuffer对象作为参数，这个对象会在序列化过程中被自动扩展。当序列化完成后，我们需要手动调用LinkedBuffer.clear()方法清空缓存区，以便下次使用。<br><a name="I3nN9"></a></p>
<h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>在 Protobuf 序列化中，Schema 是一个用于描述消息结构的类，类似于 Java 对象中的 Class。Schema 类的实例提供了一些方法来获取消息的字段和类型信息，从而可以将消息序列化和反序列化为二进制数据。<br />在使用 Protobuf 进行序列化时，我们需要为每个消息类创建一个 Schema 对象，并将其缓存起来以供重复使用。这样可以提高序列化和反序列化的效率，避免重复创建和解析 Schema 对象。<br />在上面提供的 ProtobufSerializer 类中，getSchema 方法用于获取指定类型的 Schema 对象。如果缓存中已经存在该类型的 Schema 对象，则直接返回；否则，使用 RuntimeSchema.getSchema 方法创建一个新的 Schema 对象，并将其存入缓存中。这样，在序列化和反序列化时，就可以直接使用缓存中的 Schema 对象，提高了性能。<br><a name="FAUkt"></a></p>
<h4 id="ProtostuffIOUtil"><a href="#ProtostuffIOUtil" class="headerlink" title="ProtostuffIOUtil"></a>ProtostuffIOUtil</h4><p>ProtostuffIOUtil是Protostuff序列化框架中的一个工具类，主要提供了将Java对象序列化成byte数组和将byte数组反序列化成Java对象的功能。<br />它提供了以下主要的静态方法：</p>
<ul>
<li>toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)：将一个Java对象序列化成byte数组。</li>
<li>fromByteArray(byte[] data, T message, Schema<T> schema)：将一个byte数组反序列化成Java对象。</li>
<li>mergeFrom(byte[] data, T message, Schema<T> schema)：将一个byte数组中的数据合并到一个Java对象中。</li>
</ul>
<p>其中，Schema是Protostuff序列化框架中的一个关键接口，用于描述Java对象的序列化格式。而LinkedBuffer则是一个可扩容的缓冲区，用于存储序列化后的数据。在使用Protostuff进行序列化时，可以通过LinkedBuffer.allocate()方法创建一个缓冲区，用于存储序列化后的数据。<br><a name="S4KTX"></a></p>
<h4 id="RuntimeSchema"><a href="#RuntimeSchema" class="headerlink" title="RuntimeSchema"></a>RuntimeSchema</h4><p>RuntimeSchema是Protostuff库的一个类，它提供了将Java类转换为Protobuf格式的Schema的功能。在使用Protobuf进行序列化和反序列化时，需要提供一个Schema来指定序列化的字段、类型等信息。RuntimeSchema的作用就是根据Java类的结构生成一个对应的Schema。<br />通常情况下，使用Protobuf进行序列化和反序列化时，需要手动定义一个Proto文件来描述消息的结构。而使用RuntimeSchema，可以将Java类当作Proto文件来使用，它会自动生成一个对应的Schema。<br />需要注意的是，由于RuntimeSchema是在运行时生成的，因此会对性能产生一定影响。在高性能场景中，建议使用预编译的Proto文件来进行序列化和反序列化。</p>
<p><a name="njTxV"></a></p>
<h2 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a>客户端分析</h2><p>要实现客户端的逻辑，最基本的就是要实现动态代理：<br />InvocationHandler 是 Java 标准库中的一个接口，它用于实现动态代理。<br />动态代理是一种运行时生成代理对象的技术。使用动态代理可以在运行时动态地创建一个实现特定接口的代理类，这个代理类可以将所有方法调用委托给指定的对象或方法。在委托调用前或调用后，代理类可以执行额外的逻辑，例如统计方法调用次数、记录方法调用日志等。<br />InvocationHandler 接口定义了一个方法 invoke，该方法会在代理类每次调用方法时被调用。该方法有三个参数：</p>
<ol>
<li>proxy：代理对象</li>
<li>method：被调用的方法</li>
<li>args：被调用方法的参数列表</li>
</ol>
<p>invoke 方法的返回值是 Object 类型，它表示被调用方法的返回值。因此，当我们想要使用动态代理技术时，需要实现 InvocationHandler 接口并重写 invoke 方法，来控制代理类如何处理方法调用<br><a name="mEV6K"></a></p>
<h3 id="RpcClientProxy"><a href="#RpcClientProxy" class="headerlink" title="RpcClientProxy"></a>RpcClientProxy</h3><p>RpcClientProxy 将实现 InvocationHandler 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用方法: &#123;&#125;#&#123;&#125;"</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"方法调用请求发送失败"</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个远程调用的客户端代理类RpcClientProxy，实现了InvocationHandler接口，用于生成一个远程服务接口的代理对象。其中，RpcClient是一个抽象类，NettyClient和SocketClient分别是其子类，用于不同的网络传输方式进行远程调用。<br />该类中的getProxy方法，使用了Java动态代理技术，生成了一个实现了远程服务接口的代理对象，该代理对象的所有方法调用都会被拦截并转化为远程调用，从而实现了RPC远程调用的透明化。<br />在invoke方法中，通过封装一个RpcRequest对象来表示对远程服务的调用，并通过客户端发送请求获取到返回结果RpcResponse，最后将返回结果中的数据返回给调用方。在发送远程调用请求之前，还进行了一些简单的参数检查，确保请求的正确性和完整性。<br><a name="Jo1Tm"></a></p>
<h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机轮询策略来进行负载均衡</span></span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//另一个构造方法，表示自定义负载均衡策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注入服务发现</span></span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="comment">//序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="comment">//保留意见</span></span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"未设置序列化器"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"客户端发送消息: %s"</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">"发送消息时有错误发生: "</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个基于Netty的RPC客户端，实现了RpcClient接口，并且封装了发送请求的具体细节。<br />在类的静态代码块中，创建了一个EventLoopGroup和一个Bootstrap对象，用于配置Netty客户端。EventLoopGroup是处理事件循环的抽象类，Bootstrap则是用于客户端引导的类。在其中使用了NioEventLoopGroup和NioSocketChannel类来实现NIO客户端，这里用到了Netty的API。<br />接着在类的构造方法中，初始化了一个服务发现对象和一个序列化器对象。服务发现对象是用于从服务注册中心获取服务地址的。序列化器对象是用于将请求和响应对象序列化和反序列化的，该类的序列化器可以通过传入参数来选择使用哪种类型的序列化器。<br />在sendRequest方法中，首先判断序列化器是否为空，如果为空则抛出异常。然后通过服务发现对象获取到远程服务的地址，根据地址获取一个Channel对象，ChannelProvider.get方法会返回一个新的Channel或者已有的Channel，如果没有就会创建一个新的Channel。在获取到Channel对象后，使用Netty的writeAndFlush方法将请求对象发送到服务端，使用addListener添加一个ChannelFutureListener监听器，可以在发送成功或失败时执行相应的操作，如打印日志或者回调。发送请求时还将该请求的请求ID和响应结果对应的CompletableFuture对象存储到一个全局的UnprocessedRequests对象中。<br />最后，sendRequest方法返回一个CompletableFuture对象，用于异步等待响应结果。在响应结果到达时，UnprocessedRequests对象会将响应结果的CompletableFuture对象取出并使用complete方法设置结果。而调用sendRequest方法的线程会在CompletableFuture对象的get方法上阻塞，直到CompletableFuture对象的complete方法被调用为止，然后会返回响应结果。<br />接着我们一步步看这个客户端有哪些用到的类：</p>
<p><a name="Fzlss"></a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡会共用一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后有着其对应的实现。<br />随机策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>轮询策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以看到，无论是哪一种策略，都是要先获取到Instance实例，然后使用相应的负载均衡策略，那么这个实例，则是Nacos包提供的一个类，那么我们也自然需要一个Nacos方法来提供。</p>
<p><a name="fLeqg"></a></p>
<h3 id="NacosServiceDiscovery"><a href="#NacosServiceDiscovery" class="headerlink" title="NacosServiceDiscovery"></a>NacosServiceDiscovery</h3><p>服务发现类，同时也对上述的负载均衡做出了解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"找不到对应的服务: "</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"获取服务时有错误发生:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个 NacosServiceDiscovery 类，实现了 ServiceDiscovery 接口，主要用于在基于 Nacos 注册中心的服务发现中获取服务地址。具体作用如下：</p>
<ol>
<li>NacosServiceDiscovery 类有一个构造方法，用于初始化负载均衡策略，如果未指定，则默认使用随机负载均衡策略。</li>
<li>lookupService 方法用于获取指定服务名对应的 InetSocketAddress，通过调用 NacosUtil 工具类获取所有的服务实例，然后使用负载均衡策略选择一个实例，最终返回该实例的地址信息。</li>
<li>如果找不到对应的服务，则会抛出 RpcException 异常，并记录错误日志。</li>
</ol>
<p>总之，该类用于实现基于 Nacos 注册中心的服务发现功能，可以根据服务名从注册中心获取服务实例并进行负载均衡选择，返回可用的服务地址。</p>
<p><a name="XrnMt"></a></p>
<h3 id="UnprocessedRequests"><a href="#UnprocessedRequests" class="headerlink" title="UnprocessedRequests"></a>UnprocessedRequests</h3><p>这个类名为 UnprocessedRequests，用于处理未处理的RPC请求。同时也是更好的控制数据的获取，因为如果使用Netty自带的阻塞获取方法，太过于复杂了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，使用了一个静态的 ConcurrentHashMap 对象，用于存储未处理的RPC请求。<br />其中，Key 值为请求的ID，Value 值为一个 CompletableFuture<RpcResponse> 对象，用于异步获取 RPC 响应结果。<br />这可以用来记录客户端发送的请求并等待响应。主要包含以下方法：</p>
<ol>
<li>put(String requestId, CompletableFuture<RpcResponse> future)：将请求 ID 和对应的 CompletableFuture 存储到 ConcurrentHashMap 中。</li>
<li>remove(String requestId)：从 ConcurrentHashMap 中删除指定的请求 ID。</li>
<li>complete(RpcResponse rpcResponse)：根据响应中的请求 ID 找到对应的 CompletableFuture 并将响应数据传递给它。如果没有找到对应的 CompletableFuture，则抛出 IllegalStateException 异常。</li>
</ol>
<p>这个类的作用是确保客户端发送的每个请求都有一个对应的 CompletableFuture 实例，用来等待服务器响应。在客户端收到服务器响应后，可以使用 UnprocessedRequests.complete() 方法将响应数据传递给对应的 CompletableFuture。这种机制使得客户端可以异步发送请求并等待响应，而不需要阻塞线程。<br><a name="rkJoD"></a></p>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture类是Java8引入的一个异步编程工具，用于处理异步操作的结果。它提供了一些方法来处理异步任务的结果，例如将结果传递给下一个任务，等待任务完成，组合多个任务等。<br />在异步编程中，通常会使用回调函数来处理异步任务的结果，但这种方式会使代码变得冗长且难以维护。CompletableFuture类的出现，使得异步编程变得更加简单和可读。<br />CompletableFuture类有以下几个主要特点：</p>
<ol>
<li>可以将一个异步操作的结果传递给下一个操作，这种操作被称为”组合”。</li>
<li>可以等待一个异步操作的结果，并在操作完成后执行一些操作，例如打印日志、释放资源等。</li>
<li>可以在多个异步操作完成后执行一些操作，例如将它们的结果组合起来，计算它们的平均值等。</li>
<li>可以通过异常处理机制来处理异步操作中的异常。</li>
</ol>
<p>使用CompletableFuture类，可以更加方便地处理异步任务，提高代码的可读性和可维护性。同时，它也是Java并发编程中非常有用的工具之一。<br><a name="PP3yo"></a></p>
<h3 id="ChannelProvider"><a href="#ChannelProvider" class="headerlink" title="ChannelProvider"></a>ChannelProvider</h3><p>这段代码实现了一个用于获取客户端 Channel 的工具类 ChannelProvider。它维护了一个 Map 类型的 channels 成员变量，用于缓存已经连接的 Channel 对象，通过 get 方法获取指定地址的 Channel 对象。</p>
<ol>
<li>在 get 方法中，首先根据地址和序列化器生成 key，从 channels 缓存中查找是否已有对应的 Channel 对象。如果有，就返回已有的 Channel 对象；如果没有，就通过 bootstrap 进行连接。在连接成功后，将新建的 Channel 对象存入 channels 缓存，并返回该对象。如果连接失败，返回 null。</li>
<li>在 connect 方法中，通过 CompletableFuture 异步获取连接结果。在连接成功后，将 Channel 对象作为 CompletableFuture 的返回值。</li>
<li>initializeBootstrap 方法则初始化 Bootstrap 对象，并设置一些常用的参数，如连接超时时间、是否启用 TCP 底层心跳机制等。</li>
</ol>
<p>ChannelProvider 为客户端连接提供了一个通用的方法，简化了客户端连接的过程，提高了代码的复用性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接客户端时有错误发生"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"客户端连接成功!"</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, 5000)</span></span><br><span class="line"><span class="class">                //是否开启 <span class="title">TCP</span> 底层心跳机制</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                //<span class="title">TCP</span>默认开启了 <span class="title">Nagle</span> 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。<span class="title">TCP_NODELAY</span> 参数的作用就是控制是否启用 <span class="title">Nagle</span> 算法。</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更详细一点的说：<br />这段代码实现了一个用于获取Netty客户端Channel的工具类ChannelProvider。它提供了一个get方法，该方法接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取与指定服务提供者（IP地址和端口号）之间的连接。该方法首先将InetSocketAddress和序列化器的编码方式作为key，从Map中查找已有的Channel。如果找到的Channel是可用的，那么直接返回这个Channel。如果找到的Channel不可用，那么将它从Map中删除。接下来创建一个新的Channel，该Channel使用了上述编码方式进行了初始化，并且连接到了指定的服务提供者，最后将新创建的Channel保存到Map中。<br />在ChannelProvider类中，包含了一个静态的EventLoopGroup类型的变量eventLoopGroup和一个静态的Bootstrap类型的变量bootstrap。在类初始化时，这些变量被初始化为一个NioEventLoopGroup和一个Bootstrap实例。Bootstrap实例会初始化连接到远程服务提供者的客户端的参数，包括TCP连接、超时时间、TCP底层心跳机制等。这就是Channel的模板，创建一次就好了，不用每次都创建一次，这样可以很好的减少代码冗余和提高复用性。</p>
<ul>
<li>get()方法是ChannelProvider的主要方法。它接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取连接到指定服务提供者的Channel。首先，根据传入的参数，生成一个唯一的key，用于从Map中查找是否已经存在一个可用的Channel。如果找到的Channel是可用的，直接返回这个Channel对象。否则，创建一个新的Channel，并且将它保存到Map中。最后，返回新创建的Channel对象。</li>
<li>initChannel()方法用于初始化客户端Channel的pipeline。在这里，我们首先添加了一个自定义的序列化编解码器，然后添加了一个心跳检测处理器IdleStateHandler、一个通用解码器CommonDecoder和一个客户端处理器NettyClientHandler。这些处理器将按照顺序添加到客户端Channel的pipeline中。</li>
<li>connect()方法用于创建连接到指定服务提供者的Channel，并返回连接成功后的Channel对象。为了处理异步连接的结果，它使用了一个CompletableFuture对象completableFuture，该对象用于接收连接结果。当连接成功时，completableFuture将被设置为连接成功的Channel对象；当连接失败时，completableFuture将抛出异常。</li>
</ul>
<p>这个Channel包含的一个NettyClientHandler，有相应对收到请求的处理：<br><a name="ie8Yn"></a></p>
<h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">"客户端接收到消息: %s"</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"发送心跳包 [&#123;&#125;]"</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个 Netty 客户端处理器，用于处理服务器发送的响应消息。它继承了 Netty 的 SimpleChannelInboundHandler 类，实现了其中的 channelRead0() 方法和 exceptionCaught() 方法。<br />在channelRead0()方法中，通过UnprocessedRequests对象的complete()方法处理返回的RpcResponse对象。在此方法中，使用logger打印接收到的消息，然后调用UnprocessedRequests.complete()方法，将对应的CompletableFuture对象标记为完成，并将RpcResponse对象作为结果<br />在 exceptionCaught() 方法中，发生异常时，会先记录日志，然后关闭客户端通道。<br />另外，该类还重写了 userEventTriggered() 方法，用于发送心跳包。如果客户端在一段时间内没有发送数据，则会自动触发该方法，并向服务器发送一个心跳包。当客户端发送心跳包时，会调用 ChannelProvider 类的 get() 方法获取一个 Channel 对象，并向该 Channel 对象写入一个标记了心跳标志的 RpcRequest 对象，最后调用 close() 方法关闭该 Channel。</p>
<p><a name="RGhhY"></a></p>
<h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RPC/">RPC</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/"><i class="fa fa-chevron-left">  </i><span>实现Spring框架中的IOC和AOP</span></a></div><div class="next-post pull-right"><a href="/2022/11/27/rpc01/"><span>RPC框架的学习与基本实现</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2023 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>