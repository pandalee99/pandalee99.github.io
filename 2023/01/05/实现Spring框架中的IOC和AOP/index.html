<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="实现Spring框架中的IOC和AOP"><meta name="keywords" content="Java,Spring"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>实现Spring框架中的IOC和AOP | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">1.</span> <span class="toc-text">
</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实现IOC"><span class="toc-number">2.</span> <span class="toc-text">实现IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用IOC"><span class="toc-number">2.1.</span> <span class="toc-text">为什么要用IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC的实现步骤"><span class="toc-number">2.2.</span> <span class="toc-text">IOC的实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bean-定义了框架的数据结构"><span class="toc-number">2.3.</span> <span class="toc-text">bean 定义了框架的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Utils工具包"><span class="toc-number">2.4.</span> <span class="toc-text">Utils工具包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassUtils"><span class="toc-number">2.4.1.</span> <span class="toc-text">ClassUtils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanUtils"><span class="toc-number">2.4.2.</span> <span class="toc-text">BeanUtils</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法举例：AOP"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">用法举例：AOP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReflectionUtils"><span class="toc-number">2.4.3.</span> <span class="toc-text">ReflectionUtils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JsonUtils"><span class="toc-number">2.4.4.</span> <span class="toc-text">JsonUtils</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory"><span class="toc-number">2.5.</span> <span class="toc-text">BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getBean"><span class="toc-number">2.5.1.</span> <span class="toc-text">getBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createBean"><span class="toc-number">2.5.2.</span> <span class="toc-text">createBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#populateBean"><span class="toc-number">2.5.3.</span> <span class="toc-text">populateBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getPropertySetter"><span class="toc-number">2.5.4.</span> <span class="toc-text">getPropertySetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他属性"><span class="toc-number">2.5.5.</span> <span class="toc-text">其他属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">2.6.</span> <span class="toc-text">ApplicationContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试结果"><span class="toc-number">2.7.</span> <span class="toc-text">测试结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">2.8.</span> <span class="toc-text">
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-2"><span class="toc-number">3.</span> <span class="toc-text">
</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实现AOP"><span class="toc-number">4.</span> <span class="toc-text">实现AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Aop-是什么"><span class="toc-number">4.1.</span> <span class="toc-text">Aop 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要使用Aop"><span class="toc-number">4.2.</span> <span class="toc-text">为什么需要使用Aop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Invocation"><span class="toc-number">4.3.</span> <span class="toc-text">Invocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CglibMethodInvocation"><span class="toc-number">4.3.1.</span> <span class="toc-text">CglibMethodInvocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReflectioveMethodeInvocation"><span class="toc-number">4.3.2.</span> <span class="toc-text">ReflectioveMethodeInvocation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interceptor"><span class="toc-number">4.4.</span> <span class="toc-text">Interceptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Advisor"><span class="toc-number">4.5.</span> <span class="toc-text">Advisor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Core"><span class="toc-number">4.6.</span> <span class="toc-text">Core</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CglibAopProxy"><span class="toc-number">4.6.1.</span> <span class="toc-text">CglibAopProxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DynamicAdvisedInterceptor"><span class="toc-number">4.6.2.</span> <span class="toc-text">DynamicAdvisedInterceptor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AopBeanFactoryImpl"><span class="toc-number">4.7.</span> <span class="toc-text">AopBeanFactoryImpl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-number">4.8.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TestClass"><span class="toc-number">4.8.1.</span> <span class="toc-text">TestClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Json"><span class="toc-number">4.8.2.</span> <span class="toc-text">Json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MainTest"><span class="toc-number">4.8.3.</span> <span class="toc-text">MainTest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#截图："><span class="toc-number">4.8.4.</span> <span class="toc-text">截图：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#补充："><span class="toc-number">5.</span> <span class="toc-text">补充：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jdk动态代理和Cglib动态代理什么关系"><span class="toc-number">5.1.</span> <span class="toc-text">Jdk动态代理和Cglib动态代理什么关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#那是不是Cglib效率更高？为什么还需要JDK动态代理-？"><span class="toc-number">5.1.1.</span> <span class="toc-text">那是不是Cglib效率更高？为什么还需要JDK动态代理 ？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别"><span class="toc-number">5.2.</span> <span class="toc-text">(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用JDK动态代理实现AOP功能："><span class="toc-number">5.2.1.</span> <span class="toc-text">使用JDK动态代理实现AOP功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Cglib动态代理实现AOP功能："><span class="toc-number">5.2.2.</span> <span class="toc-text">使用Cglib动态代理实现AOP功能：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC-使用反射、JDK、Cglib去实现依赖注入的区别"><span class="toc-number">5.3.</span> <span class="toc-text">(IOC)使用反射、JDK、Cglib去实现依赖注入的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"><span class="toc-number">5.3.1.</span> <span class="toc-text">只使用反射与使用Cglib和反射来完成依赖注入有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"><span class="toc-number">5.3.2.</span> <span class="toc-text">只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对比"><span class="toc-number">5.4.</span> <span class="toc-text">对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cglib"><span class="toc-number">5.4.1.</span> <span class="toc-text">Cglib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK动态代理"><span class="toc-number">5.4.2.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cglib相对于JDK动态代理"><span class="toc-number">5.4.3.</span> <span class="toc-text">Cglib相对于JDK动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行过程"><span class="toc-number">5.5.</span> <span class="toc-text">运行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cglib代理"><span class="toc-number">5.5.1.</span> <span class="toc-text">Cglib代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK动态代理-1"><span class="toc-number">5.5.2.</span> <span class="toc-text">JDK动态代理</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">89</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">64</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">实现Spring框架中的IOC和AOP</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a name="Bk5lF"></a></p>
<h1 id=""><a href="#" class="headerlink" title=""></a><br /></h1><p><a name="vHThd"></a></p>
<h1 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h1><p><a name="GCsad"></a></p>
<h2 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h2><p>我们知道Java 是一门面向对象的语言，在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586204787-8e47e2aa-7ad0-4df8-8c02-ab5b48ccf51b.png#averageHue=%23fcfcfc&clientId=u426a4097-24c8-4&from=paste&height=271&id=u2625783a&name=image.png&originHeight=406&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62561&status=done&style=none&taskId=u59dd5fa3-6a83-4d1d-a27d-f26295c1a96&title=&width=388" alt="image.png"></p>
<p>这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586265815-d527e12e-f00d-495f-ae51-7e3e8d3cdf8e.png#averageHue=%23fdfdfd&clientId=u426a4097-24c8-4&from=paste&height=265&id=ud4222345&name=image.png&originHeight=398&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48632&status=done&style=none&taskId=u1d036425-b7d4-4fd4-94b3-985ef332386&title=&width=400.6666666666667" alt="image.png"></p>
<p>这个时候我们发现，我们类之间的关系都由 IoC 框架负责维护类，同时将类注入到需要的类中。也就是类的使用者只负责使用，而不负责维护。把专业的事情交给专业的框架来完成。大大的减少开发的复杂度。<br><a name="KMNbL"></a></p>
<h2 id="IOC的实现步骤"><a href="#IOC的实现步骤" class="headerlink" title="IOC的实现步骤"></a>IOC的实现步骤</h2><ol>
<li>初始化 IoC 容器。</li>
<li>读取配置文件。</li>
<li>将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition</li>
<li>利用数据结构依次实例化相应的对象</li>
<li>注入对象之间的依赖关系</li>
</ol>
<p><a name="iZZUZ"></a></p>
<h2 id="bean-定义了框架的数据结构"><a href="#bean-定义了框架的数据结构" class="headerlink" title="bean 定义了框架的数据结构"></a>bean 定义了框架的数据结构</h2><p>定义了bean的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] interfaceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;PropertyArg&gt; propertyArgs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含了对象的 name，class的名称。如果是接口的实现，还有该对象实现的接口。以及构造函数的传参的列表 constructorArgs 和需要注入的参数列表 propertyArgs</p>
<p><a name="rgpUm"></a></p>
<h2 id="Utils工具包"><a href="#Utils工具包" class="headerlink" title="Utils工具包"></a>Utils工具包</h2><p><a name="pETF3"></a></p>
<h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefultClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefultClassLoader().loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个工具类 ClassUtils，提供了两个静态方法：</p>
<ol>
<li>getDefultClassLoader() 方法返回当前线程的上下文类加载器（Context Class Loader）；</li>
<li>loadClass(String className) 方法用于根据类名加载对应的 Class 对象，首先调用 getDefultClassLoader() 方法获取默认的类加载器，然后使用该类加载器加载指定的类。如果指定的类名不存在，该方法将会打印异常栈信息，并返回 null。</li>
</ol>
<p>这个工具类可以方便地加载任何类，尤其在使用反射技术时非常有用，因为你可以通过类名动态地获取 Class 对象。同时，由于使用了线程的上下文类加载器，也可以避免一些类加载器隔离的问题。<br><a name="Hd0uf"></a></p>
<h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instanceByCglib</span><span class="params">(Class&lt;T&gt; clz,Constructor ctr,Object[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clz);</span><br><span class="line">        enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ctr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create(ctr.getParameterTypes(),args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个工具类 BeanUtils，提供了一个静态方法 instanceByCglib，用于创建对象。具体而言：</p>
<ol>
<li>Class<T> 参数表示要创建的对象的类；</li>
<li>Constructor 参数表示要使用的构造方法，可以为 null；</li>
<li>Object[] 参数表示构造方法的参数数组，如果 Constructor 参数为 null，则此参数也应为 null。</li>
</ol>
<p>该方法使用 CGLIB 库创建对象。首先创建一个 Enhancer 对象，并设置其父类为 clz，然后设置回调为 NoOp.INSTANCE，这意味着创建的对象不会被代理。如果 ctr 为 null，则直接通过 enhancer.create() 创建对象，否则通过 enhancer.create(ctr.getParameterTypes(), args) 使用指定的构造方法创建对象。</p>
<p>CGLIB 是一个基于 ASM 库的代码生成库，可以用于创建动态代理、增强类等。在本代码中，CGLIB 用于创建对象并调用构造方法。这种方式相对于使用 new 运算符创建对象，具有更高的灵活性和动态性。</p>
<p><a name="Ts732"></a></p>
<h4 id="用法举例：AOP"><a href="#用法举例：AOP" class="headerlink" title="用法举例：AOP"></a>用法举例：AOP</h4><p>这个也是aop的用法<br />在cglib包下，Enhancer这个类的作用是为指定的类创建代理类。具体来说，Enhancer类可以动态地生成一个指定类的子类，该子类可以用来拦截指定类中的方法调用，从而实现代理模式。<br />Enhancer类的使用方法类似于Java动态代理中的Proxy类。首先，需要创建一个Enhancer对象，并设置要代理的目标类和回调方法。然后，通过调用Enhancer对象的create方法，生成代理类的实例。这个代理类会继承目标类，同时实现回调方法，从而实现对目标类方法的拦截和处理。<br />Enhancer类的使用比较灵活，可以代理任意的类，包括没有实现任何接口的类。但是，由于Enhancer是通过生成目标类的子类来实现代理的，所以目标类必须有默认的构造函数，并且不能是final类。<br />假设我们有一个简单的UserService接口，其中定义了一个getUser方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们想为该接口创建一个代理类，记录getUser方法的调用次数。我们可以使用cglib的Enhancer类来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceProxy(target));</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getUser"</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个UserServiceProxy类，它实现了MethodInterceptor接口，用于拦截目标对象的方法调用。在构造方法中，我们传入了目标对象target，并使用Enhancer类生成一个UserService的代理对象。在intercept方法中，我们记录了getUser方法的调用次数，并使用MethodProxy类来调用目标对象的对应方法。<br />接下来，我们可以使用该代理类来调用getUser方法，并检查调用次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = UserServiceProxy.createProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">userService.getUser(<span class="number">1</span>);</span><br><span class="line">userService.getUser(<span class="number">2</span>);</span><br><span class="line">System.out.println(userService.getCount()); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们首先使用createProxy方法创建了UserService的代理对象，并调用了getUser方法两次。最后，我们打印了代理对象的调用次数，发现它的确记录了两次getUser方法的调用。<br /><strong>它为什么要这么做呢，直接new难道不行吗？</strong><br />使用代理模式的一个主要目的是在不改变原有代码的情况下，为现有对象添加额外的行为或功能。在上面的例子中，我们通过使用cglib的Enhancer类创建了一个代理对象，使得我们可以在不修改原有UserServiceImpl类的情况下，为getUser方法添加了记录调用次数的功能。<br />如果直接new一个新的对象，虽然可以实现类似的功能，但是需要对原有代码进行修改，将原有的对象替换成新的对象，这样就不太符合“开闭原则”，即对扩展开放，对修改关闭的设计原则。同时，在某些情况下，我们可能无法直接访问到原有对象的构造函数，这就导致了不能直接创建新对象的限制。<br />使用代理模式，可以通过创建代理对象来扩展原有对象的行为，而不需要修改原有对象的代码。同时，代理对象还可以在原有对象的基础上增加额外的行为，提高代码的可扩展性和可维护性。</p>
<p><a name="uyyXf"></a></p>
<h3 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectField</span><span class="params">(Field field,Object obj,Object value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个工具类 ReflectionUtils，提供了一个静态方法 injectField，用于设置某个对象的属性值。具体而言：</p>
<ol>
<li>Field 参数表示要设置的属性的字段；</li>
<li>Object 参数表示要设置属性值的对象；</li>
<li>Object 参数表示要设置的属性值。</li>
</ol>
<p>该方法首先判断 field 是否为空，如果不为空则将其设置为可访问，然后使用 field.set(obj, value) 方法设置对象的属性值。如果属性为 final 修饰的静态变量，则此方法将无法修改其值。</p>
<p>这个工具类可以方便地在代码中设置对象的属性值，尤其在使用反射技术时非常有用，因为你可以通过反射动态修改对象的属性。但是，使用反射技术也有一些缺点，例如性能较低、容易引起安全问题等，需要谨慎使用。<br><a name="UZCBE"></a></p>
<h3 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a>JsonUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*JsonUtils 的作用就是为了解析我们的json配置文件。代码比较长，与我们的 IoC 原理关系不大*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is,Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is,cls);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">writeValue</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] writeByteValue(Object entity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsBytes(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line">        mapper.getDeserializationConfig().withoutFeatures(<span class="keyword">new</span> DeserializationFeature[]&#123;DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES&#125;);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_YAML_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个工具类，封装了基于Jackson库的Json序列化和反序列化功能。具体作用如下：</p>
<ul>
<li>定义了一个ObjectMapper对象，用于将Java对象转化为JSON格式，或将JSON格式转化为Java对象。</li>
<li>提供了多个readValue()和writeValue()方法，用于不同类型之间的转化。其中，readValue()方法支持将JSON格式的字符串、输入流或字节数组反序列化成Java对象，而writeValue()方法则将Java对象序列化成JSON格式的字符串或字节数组。</li>
<li>设置了一些序列化和反序列化的配置，如格式化输出、忽略空值、支持单引号、允许注释等。</li>
<li>如果反序列化失败，则返回null</li>
</ul>
<p><a name="fz6Ke"></a></p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>先定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有对应的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryImpl</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefineMap= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//查找对象是否已经实例化过</span></span><br><span class="line">        Object bean = beanMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环依赖问题</span></span><br><span class="line">        Object earlyBean = earlySingletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span> (earlyBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生了循环依赖，提前返回尚未加载完成的bean:"</span> + name);</span><br><span class="line">            <span class="keyword">return</span> earlyBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有实例化，那就需要调用createBean来创建对象</span></span><br><span class="line">        BeanDefinition beanDefinition = beanDefineMap.get(name);</span><br><span class="line">        bean = createBean(beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为了解决循环依赖，先添加到早期单例中</span></span><br><span class="line">            earlySingletonObjects.put(name, bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对象创建成功以后，注入对象需要的参数</span></span><br><span class="line">            populateBean(bean,beanDefinition);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再吧对象存入Map中方便下次使用。</span></span><br><span class="line">            beanMap.put(name,bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从早期单例Map中移除</span></span><br><span class="line">            earlySingletonObjects.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束返回</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, BeanDefinition bd)</span></span>&#123;</span><br><span class="line">        beanDefineMap.put(name,bd);</span><br><span class="line">        beanNameSet.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String beanName = beanDefinition.getClassName();</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        Class&lt;?&gt; clz = ClassUtils.loadClass(beanName);</span><br><span class="line">        <span class="keyword">if</span>(clz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"can not find bean by beanName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取构造器参数</span></span><br><span class="line">        List&lt;ConstructorArg&gt; constructorArgs = beanDefinition.getConstructorArgs();</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty())&#123;</span><br><span class="line">            List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConstructorArg constructorArg : constructorArgs) &#123;</span><br><span class="line">                <span class="comment">//放入Map</span></span><br><span class="line">                objects.add(getBean(constructorArg.getRef()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,clz.getConstructor(),objects.toArray());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(Object bean, BeanDefinition bd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;PropertyArg&gt; propertyArgs = bd.getPropertyArgs();</span><br><span class="line">        <span class="keyword">if</span> (propertyArgs != <span class="keyword">null</span> &amp;&amp; !propertyArgs.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历在json中配置的属性</span></span><br><span class="line">            <span class="keyword">for</span> (PropertyArg arg : propertyArgs) &#123;</span><br><span class="line">                String propertyName = arg.getName();</span><br><span class="line">                String value = arg.getValue();</span><br><span class="line">                String ref = arg.getRef();</span><br><span class="line">                Object injectValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接赋值</span></span><br><span class="line">                    injectValue = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(ref)) &#123;</span><br><span class="line">                    <span class="comment">//获取bean</span></span><br><span class="line">                    injectValue = getBean(ref);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">                method.invoke(bean, injectValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取具体某个属性的setter方法</span></span><br><span class="line"><span class="comment">     * 此处做法比较简单粗暴</span></span><br><span class="line"><span class="comment">     * 实际上Spring在读取配置文件时就已经将各属性，方法，getter/setter都读取好了。</span></span><br><span class="line"><span class="comment">     * 在这就只需要调用BeanWrapper的方法来为属性赋值就可以了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getPropertySetter</span><span class="params">(BeanDefinition bd, String propertyName, Object injectValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = Class.forName(bd.getClassName());</span><br><span class="line">        Class&lt;?&gt; injectClazz = injectValue.getClass();</span><br><span class="line">        Class&lt;?&gt; supClass = injectValue.getClass().getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (supClass != <span class="keyword">null</span> &amp;&amp; supClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            injectClazz = supClass;</span><br><span class="line">        &#125;</span><br><span class="line">        propertyName = propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">        Method setter = beanClass.getMethod(<span class="string">"set"</span> + propertyName, injectClazz);</span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现了一个简单的Bean工厂，主要功能是通过Bean的名字获取Bean的实例，实现了Bean的创建、注入属性和循环依赖的处理。</p>
<p>其中，BeanFactoryImpl类实现了BeanFactory接口，定义了三个ConcurrentHashMap类型的变量，分别用来存储Bean实例、Bean定义和Bean名称集合。它还包含了一个earlySingletonObjects成员变量，用来处理循环依赖的问题。</p>
<p><a name="TT8Dj"></a></p>
<h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><p>getBean 方法是 Spring 框架中的一个核心方法，用于从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例。该方法接收一个参数 name，表示需要获取的 Bean 的名称。该方法会根据给定的名称先在 BeanFactory 中查找是否已经有该名称对应的 Bean 实例，如果没有找到，则尝试创建一个新的实例并将其注册到 BeanFactory 中。<br />在实现类 BeanFactoryImpl 中，该方法会先从 beanMap 中查找是否已经有该名称对应的 Bean 实例，如果找到了则直接返回该实例。如果没有找到，则需要通过 createBean 方法创建一个新的实例。在创建实例之前，该方法会检查 earlySingletonObjects 中是否已经有该名称对应的早期单例对象，如果有则说明存在循环依赖的问题，此时会返回早期单例对象，避免出现死锁的情况。<br />getBean 方法会调用 createBean 方法创建 Bean 实例，然后调用 populateBean 方法为实例注入需要的属性。在注入属性之后，该方法会将创建好的 Bean 实例注册到 beanMap 中，以备下次获取时直接返回。<br />总之，getBean 方法的作用是从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例，如果找不到则创建一个新的实例，并且可以解决循环依赖的问题。<br><a name="qkBoo"></a></p>
<h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>createBean 方法的作用是通过传入的 BeanDefinition 对象，使用反射来实例化一个 Java 对象，并返回该对象的实例。该方法首先通过 BeanDefinition 对象中的类名获取该类的 Class 对象，然后根据该对象获取相应的构造函数，如果有构造函数的参数，则递归调用 getBean 方法获取构造函数的参数，最后使用 CGLIB 库的 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果构造函数没有参数，则直接使用 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果获取 Class 对象失败，会抛出异常。<br><a name="kaiGR"></a></p>
<h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>populateBean方法的作用是为一个JavaBean对象注入它所依赖的其他对象或属性，这些对象或属性在BeanDefinition中被定义，并且在配置文件中被配置好。populateBean方法会根据BeanDefinition中的属性列表，将对应的属性值设置到JavaBean对象中。属性的值可能是简单类型的值，也可能是其他JavaBean对象的引用。<br />具体而言，populateBean方法会遍历BeanDefinition中的属性列表，对于每一个属性，它会根据属性的名称、值或引用，找到JavaBean对象中对应的setter方法，然后调用该方法将属性值设置到JavaBean对象中。需要注意的是，setter方法的名称是根据属性名生成的，例如，如果属性名是foo，那么setter方法的名称就是setFoo。<br />populateBean方法的实现比较简单粗暴，实际上，Spring框架在读取配置文件时已经将各属性、方法、getter/setter都读取好了，并且使用了更加高效和灵活的方式来为JavaBean对象注入属性值。</p>
<p>这两行代码的作用是为一个Java Bean对象的属性赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">method.invoke(bean, injectValue);</span><br></pre></td></tr></table></figure>

<p>第一行代码使用getPropertySetter方法获取一个指定属性的Setter方法。getPropertySetter方法根据属性名称、注入值类型和Bean定义，动态地获取该属性的Setter方法。这里使用反射机制，构造出要调用的方法，以便在第二行代码中使用。<br />第二行代码使用反射机制调用Java Bean对象的Setter方法，并把该属性的值作为参数传入。这里的bean是要赋值的Java Bean对象，injectValue是要注入的值。<br><a name="E6WQy"></a></p>
<h3 id="getPropertySetter"><a href="#getPropertySetter" class="headerlink" title="getPropertySetter"></a>getPropertySetter</h3><p>getPropertySetter方法的作用是根据传入的BeanDefinition、属性名和属性值，获取对应的setter方法，并返回该方法。在populateBean方法中，会根据BeanDefinition中配置的属性名、属性值以及对应的setter方法，将属性值设置到对象中，实现对对象属性的注入。getPropertySetter方法通过反射获取类的setter方法，并根据属性值的类型确定setter方法的参数类型，最终返回setter方法，供populateBean方法调用。<br><a name="ptLbT"></a></p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>这段代码实现了一个简单的 Bean 工厂。主要功能包括：</p>
<ol>
<li>实现了 BeanFactory 接口，提供了 getBean() 方法来获取指定名称的 Bean 实例。</li>
<li>实现了注册 BeanDefinition 的方法 registerBean()，用来将 BeanDefinition 存储到 Map 中。</li>
<li>使用 ConcurrentHashMap 来存储 Bean 实例对象和 BeanDefinition 对象。</li>
<li>支持循环依赖。通过使用 ConcurrentHashMap 存储早期的 Bean 实例对象，解决了循环依赖问题。</li>
<li>支持注入属性。通过在 BeanDefinition 中配置 PropertyArg 属性参数列表，来对 Bean 实例对象进行属性注入。</li>
<li>支持构造器注入。通过在 BeanDefinition 中配置 ConstructorArg 构造器参数列表，来对 Bean 实例对象进行构造器注入。</li>
<li>支持通过反射创建 Bean 实例对象，使用 CGLib 动态代理技术生成代理对象。</li>
</ol>
<p>总体来说，这段代码实现了一个简单的 IoC 容器，能够解决基本的 Bean 创建、管理和依赖注入的问题。但是这个容器还有一些限制，例如只支持单例模式、只支持 setter 注入、只能通过 BeanDefinition 来配置 Bean 等等。真正的 IoC 容器，例如 Spring，还有更多更复杂的功能和特性。</p>
<p><a name="zPI4R"></a></p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        loadFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = JsonUtils.readValue(is,<span class="keyword">new</span> TypeReference&lt;List&lt;BeanDefinition&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(beanDefinitions != <span class="keyword">null</span> &amp;&amp; !beanDefinitions.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">                registerBean(beanDefinition.getName(), beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为JsonApplicationContext的类，继承了BeanFactoryImpl类。JsonApplicationContext类的作用是通过从Json文件中读取bean定义来初始化IoC容器。它包含了一个构造方法和两个私有方法：init()和loadFile()。<br />构造方法JsonApplicationContext(String fileName)接收Json文件的名称，并将其存储在fileName变量中。<br />方法init()用于初始化IoC容器，它调用了loadFile()方法从Json文件中加载bean定义。<br />方法loadFile()用于加载Json文件并注册bean定义到IoC容器中。它首先通过当前线程的类加载器获取Json文件的输入流，然后通过JsonUtils.readValue()方法将输入流转换成BeanDefinition对象列表。最后，它遍历BeanDefinition列表，并调用registerBean()方法注册bean定义到IoC容器中。<br />总之，这段代码是一个简单的IoC容器实现，它可以从Json文件中读取bean定义，并将其注册到容器中，以供应用程序使用。<br><a name="ADAO4"></a></p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679590784248-a8543b7e-dd3d-46b8-abdd-300c77964292.png#averageHue=%23f5f3f2&clientId=u426a4097-24c8-4&from=paste&height=209&id=u14ed6355&name=image.png&originHeight=313&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27393&status=done&style=none&taskId=u042025fc-fe77-4110-8479-550549e9f78&title=&width=651.3333333333334" alt="image.png"></p>
<p><a name="P6I4h"></a></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br /></h2><p><a name="fFT0I"></a></p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a><br /></h1><p><a name="xvv2L"></a></p>
<h1 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h1><p><a name="lvOkY"></a></p>
<h2 id="Aop-是什么"><a href="#Aop-是什么" class="headerlink" title="Aop 是什么"></a>Aop 是什么</h2><p>面向切面的程序设计（aspect-oriented programming，AOP）。通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。</p>
<p><a name="rbIL5"></a></p>
<h2 id="为什么需要使用Aop"><a href="#为什么需要使用Aop" class="headerlink" title="为什么需要使用Aop"></a>为什么需要使用Aop</h2><p>面向切面编程，实际上就是通过预编译或者动态代理技术在不修改源代码的情况下给原来的程序统一添加功能的一种技术。我们看几个关键词，第一个是“动态代理技术”，这个就是Spring Aop实现底层技术。第二个“不修改源代码”，这个就是Aop最关键的地方，也就是我们平时所说的非入侵性。。第三个“添加功能”，不改变原有的源代码，为程序添加功能。</p>
<p>举个例子：如果某天你需要统计若干方法的执行时间，如果不是用Aop技术，你要做的就是为每一个方法开始的时候获取一个开始时间，在方法结束的时候获取结束时间。二者之差就是方法的执行时间。如果对每一个需要统计的方法都做如上的操作，那代码简直就是灾难。如果我们使用Aop技术，在不修改代码的情况下，添加一个统计方法执行时间的切面。代码就变得十分优雅。具体这个切面怎么实现？<br />Spring Aop实现的代码非常非常的绕。也就是说 Spring 为了灵活做了非常深层次的抽象。同时 Spring为了兼容 @AspectJ 的Aop协议，使用了很多 Adapter （适配器）模式又进一步的增加了代码的复杂程度。<br />Spring 的 Aop 实现主要以下几个步骤：</p>
<ol>
<li>初始化 Aop 容器。</li>
<li>读取配置文件。</li>
<li>将配置文件装换为 Aop 能够识别的数据结构 – Advisor。这里展开讲一讲这个advisor。Advisor对象中包又含了两个重要的数据结构，一个是 Advice，一个是 Pointcut。Advice的作用就是描述一个切面的行为，pointcut描述的是切面的位置。两个数据结的组合就是”在哪里，干什么“。这样 Advisor 就包含了”在哪里干什么“的信息，就能够全面的描述切面了。</li>
<li>Spring 将这个 Advisor 转换成自己能够识别的数据结构 – AdvicedSupport。Spirng 动态的将这些方法拦截器织入到对应的方法。</li>
<li>生成动态代理代理。</li>
<li>提供调用，在使用的时候，调用方调用的就是代理方法。也就是已经织入了增强方法的方法</li>
</ol>
<p><a name="acqJR"></a></p>
<h2 id="Invocation"><a href="#Invocation" class="headerlink" title="Invocation"></a>Invocation</h2><p>先定义好方法调用接口和代理方法调用接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] getArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理方法的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyMethodInvocation</span> <span class="keyword">extends</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="AkGkM"></a></p>
<h3 id="CglibMethodInvocation"><a href="#CglibMethodInvocation" class="headerlink" title="CglibMethodInvocation"></a>CglibMethodInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title">ReflectioveMethodeInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibMethodInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(proxy, target, method, arguments, interceptorList);</span><br><span class="line">        <span class="keyword">this</span>.methodProxy = methodProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是定义了一个基于CGLIB动态代理的方法调用类CglibMethodInvocation，它继承了ReflectiveMethodeInvocation类，其中包含了目标对象、目标方法、方法参数以及一组方法拦截器，它们一起构成了一个完整的方法调用链。CglibMethodInvocation在父类的基础上增加了一个MethodProxy类型的属性methodProxy，并重写了invokeOriginal()方法，该方法使用methodProxy对象调用目标方法，实现了方法的调用。该类主要在AOP中使用，用于执行目标方法，并将方法拦截器应用于目标方法之前或之后的操作。</p>
<p><a name="G0Nbp"></a></p>
<h3 id="ReflectioveMethodeInvocation"><a href="#ReflectioveMethodeInvocation" class="headerlink" title="ReflectioveMethodeInvocation"></a>ReflectioveMethodeInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectioveMethodeInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectioveMethodeInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] arguments = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行完所有的拦截器后，执行目标方法</span></span><br><span class="line">        <span class="keyword">if</span>(currentInterceptorIndex == <span class="keyword">this</span>.interceptorList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeOriginal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代的执行拦截器。回顾上面的讲解，我们实现的拦击都会执行 im.proceed() 实际上就在调用这个方法。</span></span><br><span class="line">        AopMethodInterceptor interceptor = interceptorList.get(++currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invokeMethodUseReflection(target,method,arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个基础的反射方法调用的实现类 ReflectiveMethodInvocation，实现了 ProxyMethodInvocation 接口。在 Spring 的 AOP 中，每个被拦截的方法都会被包装成一个 MethodInvocation，这个包装类里包含了目标对象、方法、参数等信息，并提供了一个 proceed 方法用来执行下一个拦截器或目标方法。</p>
<p>ReflectiveMethodInvocation 中的 proceed 方法主要用于按照拦截器链依次执行 AopMethodInterceptor 的拦截逻辑。如果拦截器都执行完成，最后就会调用 invokeOriginal 方法来执行目标方法。另外，这个类也提供了获取代理对象、获取方法、获取参数等方法。</p>
<p><a name="osu7V"></a></p>
<h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeMethodAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeforeMethodAdvice advice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeforeMethodAdviceInterceptor</span><span class="params">(BeforeMethodAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        advice.before(mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterRunningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AfterRunningAdvice advice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterRunningAdviceInterceptor</span><span class="params">(AfterRunningAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnVal = mi.proceed();</span><br><span class="line">        advice.after(returnVal,mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 <strong>mi.proceed()</strong>才是执行原有的方法。而advice我们上文就说过，是描述增强的方法”干什么“的数据结构，所以对于这个before拦截器，我们就把advice对应的增强方法放在了真正执行的方法前面。而对于after拦截器而言，就放在了真正执行的方法后面。<br />这里主要是定义拦截器，一个before，一个after。<br><a name="Kqika"></a></p>
<h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//干什么</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line">    <span class="comment">//在哪里</span></span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AopMethodInterceptor&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptor</span><span class="params">(AopMethodInterceptor interceptor)</span></span>&#123;</span><br><span class="line">        list.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptors</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptors)</span></span>&#123;</span><br><span class="line">        list.addAll(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个AdvisedSupport就是我们Aop框架能够理解的数据结构，这个时候问题就变成了<strong>对于哪个目标，增加哪些拦截器</strong>。这里的AopMethodInterceptor 是一个接口，before拦截器和after拦截器都实现了这个接口。都能够使用这个功能。<br><a name="a0X2d"></a></p>
<h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p><a name="yJ9IG"></a></p>
<h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] constructorArgTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; rootClass = advised.getTargetSource().getTagetClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)&#123;</span><br><span class="line">            classLoader = ClassUtils.getDefultClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(rootClass.getSuperclass());</span><br><span class="line">        <span class="comment">//增加拦截器的核心方法</span></span><br><span class="line">        Callback callbacks = getCallBack(advised);</span><br><span class="line">        enhancer.setCallback(callbacks);</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; constructorArgs.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> enhancer.create(constructorArgTypes,constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Callback <span class="title">getCallBack</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是实现 Cglib AOP 代理的核心逻辑。其中 CglibAopProxy 类实现了 AopProxy 接口，用于创建代理对象，而 AdvisedSupport 是 AOP 配置信息的载体。<br />具体来说，getProxy() 方法返回代理对象，getProxy(ClassLoader classLoader) 方法返回通过指定类加载器加载的代理对象。在这两个方法中，通过使用 CGLIB 提供的 Enhancer 类，实现代理对象的创建和设置拦截器。<br />在 getCallBack(AdvisedSupport advised) 方法中，通过将 AdvisedSupport 中的拦截器链和目标对象传递给 DynamicAdvisedInterceptor，最终得到一个 Callback 对象，它是 Enhancer 的回调函数。<br />回到 getProxy() 和 getProxy(ClassLoader classLoader) 方法，它们的核心是通过 Enhancer 的 setSuperclass 方法，设置代理对象的父类，然后通过 setCallback 方法，将 Callback 对象设置为拦截器。<br />在这个过程中，如果 constructorArgs 不为空，则使用带参数的 enhancer.create 方法创建代理对象。否则，使用不带参数的 enhancer.create 方法创建代理对象。<br />最后，通过调用 enhancer.create 方法返回代理对象。<br />看看核心方法：<br>:::info<br>//增加拦截器的核心方法<br />Callback callbacks = getCallBack(advised);<br>:::</p>
<blockquote>
<p>private Callback getCallBack(AdvisedSupport advised) {<br />    return new DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());<br />}</p>
</blockquote>
<p><a name="xdGBY"></a></p>
<h3 id="DynamicAdvisedInterceptor"><a href="#DynamicAdvisedInterceptor" class="headerlink" title="DynamicAdvisedInterceptor"></a>DynamicAdvisedInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptorList, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">        <span class="keyword">this</span>.targetSource = targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现了CGLib动态代理中的拦截器，它实现了MethodInterceptor接口。在intercept方法中，它接收了被代理的对象(obj)、目标方法(method)、方法参数(args)以及方法代理(proxy)，然后使用这些参数创建一个CglibMethodInvocation对象，然后调用该对象的proceed()方法，实现拦截器的链式执行。这个拦截器类将所有的AOP拦截器封装成了一个拦截器链，同时传入了目标对象的引用(TargetSource)，以便执行目标方法。在实际调用的时候，这个拦截器会按照拦截器列表依次调用所有的拦截器，并在最后调用目标方法，实现了AOP拦截器的动态织入。</p>
<p>而其方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的方法正是：<strong>CglibMethodInvocation</strong></p>
<p><a name="IBgca"></a></p>
<h2 id="AopBeanFactoryImpl"><a href="#AopBeanFactoryImpl" class="headerlink" title="AopBeanFactoryImpl"></a>AopBeanFactoryImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopBeanFactoryImpl</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AopBeanDefinition&gt; aopBeanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; aopBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object aopBean = aopBeanMap.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBeanDefinitionMap.containsKey(name))&#123;</span><br><span class="line">            AopBeanDefinition aopBeanDefinition = aopBeanDefinitionMap.get(name);</span><br><span class="line">            AdvisedSupport advisedSupport = getAdvisedSupport(aopBeanDefinition);</span><br><span class="line">            aopBean = <span class="keyword">new</span> CglibAopProxy(advisedSupport).getProxy();</span><br><span class="line">            aopBeanMap.put(name,aopBean);</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, AopBeanDefinition aopBeanDefinition)</span></span>&#123;</span><br><span class="line">        aopBeanDefinitionMap.put(name,aopBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AdvisedSupport <span class="title">getAdvisedSupport</span><span class="params">(AopBeanDefinition aopBeanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        List&lt;String&gt; interceptorNames = aopBeanDefinition.getInterceptorNames();</span><br><span class="line">        <span class="keyword">if</span>(interceptorNames != <span class="keyword">null</span> &amp;&amp; !interceptorNames.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (String interceptorName : interceptorNames) &#123;</span><br><span class="line"></span><br><span class="line">                Advice advice = (Advice) getBean(interceptorName);</span><br><span class="line"></span><br><span class="line">                Advisor advisor = <span class="keyword">new</span> Advisor();</span><br><span class="line">                advisor.setAdvice(advice);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> BeforeMethodAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = BeforeMethodAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> AfterRunningAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = AfterRunningAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">new</span> TargetSource();</span><br><span class="line"></span><br><span class="line">        Object object = getBean(aopBeanDefinition.getTarget());</span><br><span class="line"></span><br><span class="line">        targetSource.setTagetClass(object.getClass());</span><br><span class="line">        targetSource.setTagetObject(object);</span><br><span class="line"></span><br><span class="line">        advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisedSupport;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个AOP Bean Factory，它是一个扩展了普通Bean Factory的类，用于创建和管理AOP bean。该类继承了BeanFactoryImpl，并重写了getBean方法，用于检查所请求的Bean是否已经是AOP bean，如果是则返回AOP bean。如果不是AOP bean，则继续通过调用父类的getBean方法获取普通bean。AopBeanFactoryImpl还有registerBean方法，用于将定义的AOP bean注册到AOP Bean Factory的aopBeanDefinitionMap中。</p>
<p>在getAdvisedSupport方法中，它会创建一个AdvisedSupport对象，将目标对象和增强器（Advice）封装到Advisor对象中，并根据Advice类型将它们转化为对应的AopMethodInterceptor对象，然后将所有的AopMethodInterceptor对象添加到AdvisedSupport对象中。最后将目标对象封装到TargetSource对象中，并设置到AdvisedSupport对象中。然后返回AdvisedSupport对象。</p>
<p>当getBean方法检测到所请求的Bean是AOP bean时，它会从aopBeanDefinitionMap中获取Bean的定义，并创建相应的AdvisedSupport对象。然后创建一个CglibAopProxy对象，并使用该对象创建代理对象，最后将代理对象添加到aopBeanMap中。最终返回代理对象。</p>
<p><a name="BIrI3"></a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a name="mlhhh"></a></p>
<h3 id="TestClass"><a href="#TestClass" class="headerlink" title="TestClass"></a>TestClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"开始计时"</span>);</span><br><span class="line">        ThreadLocalUtils.set(startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印随机数值: "</span>+ UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndTimeAfterMethod</span> <span class="keyword">implements</span> <span class="title">AfterRunningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">after</span><span class="params">(Object returnVal, Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> startTime = ThreadLocalUtils.get();</span><br><span class="line">        ThreadLocalUtils.remove();</span><br><span class="line">        System.out.println(<span class="string">"方法耗时："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a test method"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="JGPr2"></a></p>
<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"beforeMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"StartTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"processMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"ProcessTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"afterMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"EndTimeAfterMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"TestService"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testServiceProxy"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"core.ProxyFactoryBean"</span>,</span><br><span class="line">    <span class="attr">"target"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"interceptorNames"</span>:[</span><br><span class="line">      <span class="string">"beforeMethod"</span>,</span><br><span class="line">      <span class="string">"processMethod"</span>,</span><br><span class="line">      <span class="string">"afterMethod"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a name="Z3M5m"></a></p>
<h3 id="MainTest"><a href="#MainTest" class="headerlink" title="MainTest"></a>MainTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AopApplictionContext aopApplictionContext = <span class="keyword">new</span> AopApplictionContext(<span class="string">"application.json"</span>);</span><br><span class="line">        aopApplictionContext.init();</span><br><span class="line">        TestService testService = (TestService) aopApplictionContext.getBean(<span class="string">"testServiceProxy"</span>);</span><br><span class="line">        testService.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="hemjx"></a></p>
<h3 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679659265097-017a1abd-1cbb-4840-9849-5c67b070dbed.png#averageHue=%23f7f6f5&clientId=u4abc7da4-0982-4&from=paste&height=171&id=u5b9f1a31&name=image.png&originHeight=256&originWidth=1143&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18875&status=done&style=none&taskId=ue6550e3c-a161-4300-b134-338c0010524&title=&width=762" alt="image.png"></p>
<p><a name="FXW4m"></a></p>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><a name="SO1vU"></a></p>
<h2 id="Jdk动态代理和Cglib动态代理什么关系"><a href="#Jdk动态代理和Cglib动态代理什么关系" class="headerlink" title="Jdk动态代理和Cglib动态代理什么关系"></a>Jdk动态代理和Cglib动态代理什么关系</h2><p>JDK动态代理和Cglib动态代理是两种常用的Java动态代理方式，它们都是用于在运行时动态地创建代理对象，实现对目标对象的增强功能。<br />JDK动态代理是通过Java反射机制来实现的，它只能为接口创建代理对象，而无法为类创建代理对象。JDK动态代理通过实现目标对象所实现的接口，在运行时生成一个代理类，代理类中包含了目标对象的引用以及拦截器对象的引用，从而可以在调用代理对象的方法时，将方法调用转发给拦截器对象进行处理。<br />Cglib动态代理则是通过生成目标对象的子类来实现的，它可以为类创建代理对象。Cglib动态代理在运行时通过生成目标对象的子类，重写目标对象的方法，并将目标对象的引用注入到代理对象中。当调用代理对象的方法时，代理对象会先调用目标对象的方法，然后再调用拦截器对象的方法进行增强处理。<br />虽然JDK动态代理和Cglib动态代理实现方式不同，但它们都可以实现对目标对象的增强功能，常用于实现AOP（面向切面编程）功能。在实际开发中，根据需要选择不同的动态代理方式，如果目标对象实现了接口，则可以使用JDK动态代理；如果目标对象没有实现接口，则可以使用Cglib动态代理。</p>
<p><a name="qRBPD"></a></p>
<h3 id="那是不是Cglib效率更高？为什么还需要JDK动态代理-？"><a href="#那是不是Cglib效率更高？为什么还需要JDK动态代理-？" class="headerlink" title="那是不是Cglib效率更高？为什么还需要JDK动态代理 ？"></a>那是不是Cglib效率更高？为什么还需要JDK动态代理 ？</h3><p>一般情况下，使用CGLIB生成代理类的效率确实比使用JDK动态代理更高，因为CGLIB是通过在编译时生成字节码来实现代理的，相对于JDK动态代理而言，不需要在运行时动态生成代理类。因此，在需要频繁生成代理类的场景下，使用CGLIB可能更适合。</p>
<p>然而，需要注意的是，CGLIB生成的代理类通常比原始类的大小要大，且CGLIB代理使用了更多的内存，这在创建大量代理对象的场景下可能会成为性能瓶颈。此外，由于CGLIB使用了底层字节码操作库，因此在某些环境下可能存在兼容性问题，需要额外考虑。</p>
<p>因此，在选择代理方式时，需要考虑实际场景和需求，并根据具体情况选择合适的代理方式。如果需要生成大量代理对象，并且不考虑内存占用问题，CGLIB可能更适合；如果需要更轻量级的代理方式，或者需要支持多态性、继承等特性，则JDK动态代理可能更合适。</p>
<p><a name="iHnyN"></a></p>
<h2 id="AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别"><a href="#AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别" class="headerlink" title="(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别"></a>(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别</h2><p>假设我们有一个接口UserService和一个实现类UserServiceImpl，其中UserService提供了一个getUserById()方法用于获取用户信息。我们需要对getUserById()方法进行日志记录，以便监控用户信息查询情况。<br><a name="VA788"></a></p>
<h3 id="使用JDK动态代理实现AOP功能："><a href="#使用JDK动态代理实现AOP功能：" class="headerlink" title="使用JDK动态代理实现AOP功能："></a>使用JDK动态代理实现AOP功能：</h3><p>我们可以使用JDK动态代理来创建UserService接口的代理对象，并将一个实现了InvocationHandler接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的invoke()方法，在该方法中实现日志记录功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class[]&#123;UserService.class&#125;, proxy);</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="uzJJw"></a></p>
<h3 id="使用Cglib动态代理实现AOP功能："><a href="#使用Cglib动态代理实现AOP功能：" class="headerlink" title="使用Cglib动态代理实现AOP功能："></a>使用Cglib动态代理实现AOP功能：</h3><p>我们可以使用Cglib动态代理来创建UserServiceImpl类的代理对象，并将一个实现了MethodInterceptor接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的intercept()方法，在该方法中实现日志记录功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceInterceptor());</span><br><span class="line"></span><br><span class="line">        UserServiceImpl userServiceProxy = (UserServiceImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述示例代码可以看出，使用JDK动态代理时，需要创建一个实现了InvocationHandler接口的拦截器对象，并将其注入到代理对象中；而使用Cglib动态代理时，需要创建一个实现了MethodInterceptor接口的拦截器对象，并将其注入到代理对象中。在JDK动态代理中，代理对象必须实现目标对象所实现的接口；而在Cglib动态代理中，代理对象</p>
<p><a name="lHuvV"></a></p>
<h2 id="IOC-使用反射、JDK、Cglib去实现依赖注入的区别"><a href="#IOC-使用反射、JDK、Cglib去实现依赖注入的区别" class="headerlink" title="(IOC)使用反射、JDK、Cglib去实现依赖注入的区别"></a>(IOC)使用反射、JDK、Cglib去实现依赖注入的区别</h2><p><a name="MOXbp"></a></p>
<h3 id="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用Cglib和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"></a>只使用反射与使用Cglib和反射来完成依赖注入有什么区别？</h3><p>在Spring中，依赖注入可以通过只使用反射或使用Cglib和反射来完成。下面是它们之间的一些区别：</p>
<ol>
<li>实现方式：只使用反射时，Spring通过反射机制来动态创建对象并设置属性值。而使用Cglib和反射时，Spring通过Cglib在运行时动态创建代理类，并在代理类中使用反射来设置属性值。</li>
<li>性能：只使用反射时，每次获取Bean时都需要通过反射机制来动态创建对象和设置属性值，因此在性能上可能存在一定的开销。而使用Cglib和反射时，Spring可以在第一次获取Bean时创建代理类，并缓存代理类实例，之后每次获取Bean时都可以直接使用代理类，从而提高了性能。</li>
<li>功能扩展：只使用反射时，Spring的功能扩展比较有限，因为只能使用Java反射机制来动态创建对象和设置属性值。而使用Cglib和反射时，Spring可以通过Cglib来实现更多的功能扩展，比如实现AOP切面等。</li>
</ol>
<p>总的来说，只使用反射相对于使用Cglib和反射来完成依赖注入，性能可能会稍差一些，但是在一些场景下可能会更加灵活，因为不需要引入Cglib这样的第三方库。而使用Cglib和反射来完成依赖注入则能够更好地支持一些功能扩展，比如实现AOP切面等。</p>
<p>举一个简单的例子，假设有一个名为UserService的服务类，它依赖于名为UserDao的DAO类。下面是使用只使用反射和使用Cglib和反射来实现依赖注入的代码示例：：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，Spring会通过反射来动态创建UserService和UserDao对象，并在运行时调用setUserDao方法来设置依赖关系。</p>
<p>使用Cglib和反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDaoInterceptor拦截器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法执行前做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"Before method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="comment">// 在方法执行后做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"After method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDaoProxy"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoProxy"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cglib.proxy.Enhancer"</span></span><br><span class="line">        factory-method=<span class="string">"create"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"interceptor"</span></span><br><span class="line">        ref=<span class="string">"userDaoInterceptor"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoInterceptor"</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDaoInterceptor"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，Spring使用Cglib创建一个名为userDaoProxy的代理类，这个代理类继承自UserDao类，并在运行时动态生成。代理类中有一个拦截器UserDaoInterceptor，它会在UserDao类的方法执行前后做一些额外的处理，比如日志记录等。当Spring需要注入UserDao依赖时，会注入userDaoProxy代理类，代理类会使用反射来设置依赖关系。此外，当调用UserService的saveUser方法时，userDaoProxy代理类会通过反射调用UserDao的save方法，并在方法执行前后调用UserDaoInterceptor的相关方法。</p>
<p><a name="jlq4z"></a></p>
<h3 id="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"></a>只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？</h3><p>使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象。<br />举个例子，假设有一个UserService接口和UserService实现类，实现类需要注入一个UserDao对象。下面分别使用反射和JDK动态代理来完成依赖注入：<br />使用反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            userDao = (UserDao) constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们使用Class.forName方法获取UserDaoImpl类的Class对象，然后使用反射获取构造函数，并创建UserDaoImpl对象。</p>
<p>使用JDK动态代理和反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            Object dao = constructor.newInstance();</span><br><span class="line">            method.invoke(target, dao);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">this</span>);</span><br><span class="line">        ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">        userDao = (UserDao) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; UserDao<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">proxy</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们创建了一个UserServiceProxy代理类，实现了InvocationHandler接口，并重写了invoke方法。在invoke方法中，如果是set方法，我们使用反射获取UserDaoImpl类的Class对象和构造函数，创建UserDaoImpl对象，并通过反射调用set方法来完成依赖注入。否则，我们通过反射调用目标对象的方法。</p>
<p>然后，在UserServiceImpl构造方法中，我们创建了UserServiceProxy代理对象，并使用Proxy.newProxyInstance方法创建了一个UserDao的代理对象。这个代理对象会拦截所有UserDao的方法调用，并通过InvocationHandler的invoke方法进行处理。</p>
<p>需要注意的是，由于代理对象实现了UserDao接口，因此在使用代理对象时，需要将其转换为UserDao类型。</p>
<p>总的来说，使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象，可以对其方法进行拦截和处理。</p>
<p><a name="j91gI"></a></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><a name="AQ3Uy"></a></p>
<h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3><p>Cglib是通过字节码生成技术来实现动态代理的，它会在运行时动态生成被代理类的子类，并在子类中覆盖被代理类的方法，从而实现方法拦截和增强。</p>
<p>在Spring中，当使用Cglib代理时，Spring会在运行时动态生成被代理类的子类，并在子类中实现依赖注入。Cglib会通过反射机制获取被代理类的构造函数和参数，然后通过Constructor.newInstance方法创建被代理类的实例。</p>
<p>具体来说，Spring会在运行时动态生成一个类，继承被代理类，并重写其中需要拦截和增强的方法。同时，它还会在生成的类中添加一个无参构造函数，并在其中通过反射机制实例化被代理类，并完成依赖注入。在这个过程中，Cglib会使用asm字节码操作库来生成字节码，完成类的定义和加载。</p>
<p>因此，使用Cglib代理时，它会通过字节码生成技术来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用JDK动态代理，不需要被代理类实现接口，可以拦截和增强非public方法，但是会比JDK动态代理更消耗内存和CPU资源。<br><a name="Mu6c3"></a></p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过反射机制来实现动态代理的，它会在运行时动态生成一个实现了被代理接口的代理类，并在代理类中实现方法拦截和增强。</p>
<p>在Spring中，当使用JDK动态代理时，Spring会使用Java提供的Proxy类来生成代理类，并在代理类中实现依赖注入。具体来说，Spring会使用Proxy类的newProxyInstance方法来生成代理类，该方法需要传入一个ClassLoader对象、一组被代理的接口、和一个InvocationHandler对象。在生成代理类的过程中，JDK动态代理会通过反射机制获取被代理接口的方法，然后通过InvocationHandler对象的invoke方法来进行方法的拦截和增强。</p>
<p>因此，使用JDK动态代理时，它会通过反射机制来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用Cglib代理，需要被代理类实现接口，不能拦截和增强非public方法，但是会比Cglib代理更节省内存和CPU资源。<br><a name="UrKkw"></a></p>
<h3 id="Cglib相对于JDK动态代理"><a href="#Cglib相对于JDK动态代理" class="headerlink" title="Cglib相对于JDK动态代理"></a>Cglib相对于JDK动态代理</h3><p>Cglib相对于JDK动态代理来说，有以下两个方面的优势，导致它在一些情况下可能比JDK动态代理更快：</p>
<ol>
<li><p>Cglib代理不需要被代理类实现接口，可以拦截和增强非public方法，而JDK动态代理只能代理实现了接口的类。因此，在需要拦截非public方法的情况下，Cglib代理可能比JDK动态代理更适合。</p>
</li>
<li><p>在拦截方法调用的时候，Cglib代理不需要调用被代理类的方法，而JDK动态代理需要通过反射调用被代理类的方法。因此，在需要进行大量方法调用的情况下，Cglib代理可能比JDK动态代理更快。</p>
</li>
</ol>
<p>总的来说，Cglib代理和JDK动态代理各有优缺点，在具体的应用场景中需要根据实际情况选择合适的代理方式。</p>
<p><a name="aSPZk"></a></p>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><a name="eXFA4"></a></p>
<h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理是基于继承来实现代理，它会在运行时动态生成目标对象的子类，并在子类中重写目标对象的非final方法，从而实现对目标对象的代理。这个子类会被当作代理类，被加载到JVM中，并用来完成方法调用。</p>
<p>具体来说，Cglib会使用ASM等字节码操作库生成代理类的字节码，然后通过ClassLoader将其加载到JVM中。生成的代理类会继承目标对象的类，并重写目标对象的非final方法。在生成代理类后，Cglib会创建代理对象，这个代理对象实际上就是生成的代理类的实例。当代理对象调用目标对象的方法时，实际上是调用了生成的代理类中重写的方法，从而实现了代理的功能。</p>
<p>因此，Cglib生成的子类会替代原始的目标对象，成为代理对象的实现。这个子类重写了目标对象的方法，从而实现了对目标对象方法的增强和拦截。<br><a name="r0cru"></a></p>
<h3 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是基于接口来实现代理的，它会在运行时动态生成一个代理接口的代理类，并将这个代理类实例化成代理对象。这个代理类会实现目标对象实现的接口，并且会拦截所有接口中定义的方法调用。</p>
<p>具体来说，JDK动态代理会在运行时使用Java反射机制动态生成代理类的字节码，并将其加载到JVM中。生成的代理类会实现目标对象实现的接口，并在代理类中实现对目标对象方法的拦截和增强。当代理对象调用目标对象的方法时，实际上是通过反射机制调用了代理类中的方法，从而实现了代理的功能。</p>
<p>因此，JDK动态代理实现了对接口的代理，可以通过实现一个代理接口来实现代理功能，而且可以在运行时动态生成代理类，并将其加载到JVM中，实现了对目标对象的动态代理。同时，由于是基于接口来实现代理的，所以在类型上更加灵活，但也因为这个原因，只能代理实现了接口的类。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/04/14/Disruptor-1/"><i class="fa fa-chevron-left">  </i><span>高性能队列：Disruptor</span></a></div><div class="next-post pull-right"><a href="/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"><span>关于循环依赖的见解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2023 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>