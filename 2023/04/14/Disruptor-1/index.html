<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="高性能队列：Disruptor"><meta name="keywords" content="队列,Disruptor"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>高性能队列：Disruptor | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的内置队列"><span class="toc-number">2.</span> <span class="toc-text">Java的内置队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁导致的效率问题"><span class="toc-number">2.1.</span> <span class="toc-text">加锁导致的效率问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#被破坏的共享"><span class="toc-number">2.2.</span> <span class="toc-text">被破坏的共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#共享缓存带来的影响"><span class="toc-number">2.2.1.</span> <span class="toc-text">共享缓存带来的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#那么缓存与ArrayBlockingQueue有什么关系呢？"><span class="toc-number">2.2.2.</span> <span class="toc-text">那么缓存与ArrayBlockingQueue有什么关系呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Disruptor的设计"><span class="toc-number">3.</span> <span class="toc-text">Disruptor的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#核心设计"><span class="toc-number">3.1.</span> <span class="toc-text">核心设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用无锁的设计"><span class="toc-number">3.3.</span> <span class="toc-text">使用无锁的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环形队列"><span class="toc-number">3.4.</span> <span class="toc-text">环形队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一个生产者"><span class="toc-number">3.4.1.</span> <span class="toc-text">一个生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多个生产者"><span class="toc-number">3.4.2.</span> <span class="toc-text">多个生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#读数据流程"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">读数据流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#写数据流程"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">写数据流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决伪共享的问题"><span class="toc-number">3.5.</span> <span class="toc-text">解决伪共享的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-number">4.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟性能测试"><span class="toc-number">5.</span> <span class="toc-text">延迟性能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo"><span class="toc-number">7.</span> <span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">93</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">66</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">高性能队列：Disruptor</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-14</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a name="oYoyt"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易所中的低延迟和高吞吐量需求而设计的。它主要用来解决在多线程环境中生产者和消费者之间的数据传递问题。Disruptor 由 LMAX 的 Martin Thompson 和 Dave Farley 于 2011 年发明，现在是一个开源项目。</p>
<blockquote>
<p>The Disruptor is the result of our efforts to build the world’s highest performance financial exchange at LMAX. Early designs focused on architectures derived from SEDA [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_1" target="_blank" rel="noopener">1</a>] and Actors [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_2" target="_blank" rel="noopener">2</a>] using pipelines for throughput. After profiling various implementations it became evident that the queuing of events between stages in the pipeline was dominating the costs. We found that queues also introduced latency and high levels of jitter. We expended significant effort on developing new queue implementations with better performance. However it became evident that queues as a fundamental data structure are limited due to the conflation of design concerns for the producers, consumers, and their data storage. The Disruptor is the result of our work to build a concurrent structure that cleanly separates these concerns.</p>
</blockquote>
<p>Disruptor 的核心思想是，通过使用环形的数据结构（RingBuffer）和避免锁来实现数据的高速传递。RingBuffer 类似于一个循环队列，内部包含一个预先分配好的对象数组，该数组的大小为 2 的幂次方。这样设计的一个原因是可以通过位运算快速计算数组中的索引，提升性能。创建此环形数据结构后，生产者可以将事件（通常是某个类的实例）发布到 RingBuffer 的下一个可用位置，同时消费者可以从 RingBuffer 中读取和处理事件。通过使用序号（Sequence）来表示 RingBuffer 中各个条目的位置，生产者和消费者之间可以实现非阻塞的协同工作模式，从而达到最大的性能优势。<br />Disruptor 还支持多个生产者和多个消费者的场景，消费者可以独立处理事件，也可以按照依赖关系顺序进行处理。这使得Disruptor 可以在保持低延迟的同时，实现并行处理并提高整体系统吞吐量。</p>
<p>那Disruptor相比于Java内置的队列而言，有什么优势呢，这里需要进一步的分析<br><a name="CVc3m"></a></p>
<h2 id="Java的内置队列"><a href="#Java的内置队列" class="headerlink" title="Java的内置队列"></a>Java的内置队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232326187-0473b7b4-ba77-4943-a805-2a343871d150.png#averageHue=%23e1e1e1&clientId=u294810c7-fb47-4&from=paste&height=186&id=ud6f9c576&originHeight=372&originWidth=1212&originalType=binary&ratio=2&rotation=0&showTitle=false&size=68156&status=done&style=none&taskId=ub09db3d5-5196-46d9-acc2-89707ac10fe&title=&width=606" alt="image.png"><br />在Java中ArrayBlockingQueue是靠锁去控制它的并发安全的，而且是有界的队列。</p>
<p>ArrayBlockingQueue（数组阻塞队列）通过内部的锁（ReentrantLock）和两个条件变量（Condition）notEmpty和notFull来保证线程安全。</p>
<ol>
<li>ReentrantLock（可重入锁）：ArrayBlockingQueue使用ReentrantLock作为内部的锁来控制对队列的访问。在读取、写入、删除等操作时，需要先获取锁，完成操作后再释放锁。使用lock及unlock方法对数据进行保护，确保同一时刻只有一个线程能执行特定的操作。 </li>
<li>条件变量（Condition）：ArrayBlockingQueue有两个Condition，分别是notEmpty和notFull。当队列为空时，使用notEmpty.await()方法阻塞读线程；当队列满时，使用notFull.await()方法阻塞写线程。当数据被删除后，notEmpty.signal()唤醒读线程继续读取；当数据被添加后，notFull.signal()唤醒写线程继续写入。 </li>
</ol>
<p>通过这些同步措施，ArrayBlockingQueue确保了在多线程环境下的线程安全性<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232394025-16fa469d-9921-4e33-acb5-4c8d725374d4.png#averageHue=%232d2d2d&clientId=u294810c7-fb47-4&from=paste&height=236&id=u00680c6f&originHeight=472&originWidth=1282&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44409&status=done&style=none&taskId=u06f63704-23cf-4250-8d9c-269cc5fecf6&title=&width=641" alt="image.png"><br />而LinkedTransferQueue都是通过原子变量CAS这种不加锁的方式来实现的，但是它们都是使用链表的方式去实现的，这种方式的会出现两个问题，一个是由于无界导致的OOM，一个是这种数据结构也会影响到JVM的GC效率，所以，在大多数时候，还是使用ArrayBlockingQueue比较的常见，那么，ArrayBlockingQueue 有什么问题呢。</p>
<p><a name="oLbbN"></a></p>
<h3 id="加锁导致的效率问题"><a href="#加锁导致的效率问题" class="headerlink" title="加锁导致的效率问题"></a>加锁导致的效率问题</h3><p>这里引用LMAX交易所的数据：</p>
<blockquote>
<p>We will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which increments a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel Westmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar across all languages with the same basic primitives.<br>Once a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up significantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results of this simple experiment are shown in the table below:</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233609316-d2ddb2d5-2975-480c-a740-3463916fb39e.png#averageHue=%23fbfafa&clientId=u294810c7-fb47-4&from=paste&height=367&id=ua84c85bb&originHeight=734&originWidth=2064&originalType=binary&ratio=2&rotation=0&showTitle=false&size=113743&status=done&style=none&taskId=u86ed9446-fa4e-421c-9e57-fa897f4eea4&title=&width=1032" alt="image.png"><br />这里LMAX使用一个程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。测试结果显然，加锁与CAS的差别还是比较大的。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233889498-6c9beec5-949e-4088-b74e-00bdb38af9a0.png#averageHue=%232b2b2b&clientId=u294810c7-fb47-4&from=paste&height=492&id=ub7be082a&originHeight=984&originWidth=1434&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126074&status=done&style=none&taskId=uced54ebb-973c-4a4b-a939-456ce64a777&title=&width=717" alt="image.png"><br />这个加锁加在了offer，以此来保证线程的安全性，但是这样的方式显然会损失不少性能。<br />而CAS的呢，这里则使用了unsafe去使用魔法，使其不加锁的情况下，仍然可以保证线程安全：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234138046-0d2ed826-05bc-459f-87de-af5aa633a9e4.png#averageHue=%232d2c2b&clientId=u294810c7-fb47-4&from=paste&height=189&id=u78cb1884&originHeight=378&originWidth=1370&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79015&status=done&style=none&taskId=uad351660-7a33-427d-a31f-ae88e1069cb&title=&width=685" alt="image.png"></p>
<p>那为什么ArrayBlockingQueue非要加锁<br />看到这里大家可能会有一个疑惑，那为什么ArrayBlockingQueue不用cas而选择加锁呢？<br />使用ArrayBlockingQueue而非CAS的原因主要包括以下几点：</p>
<ol>
<li>锁的简化。ArrayBlockingQueue适用于生产者和消费者的场景。当队列为空时，消费者线程需要等待；当队列已满时，生产者线程需要等待。这种有固定边界的队列在这种场景下可以简化设计。通过使用锁，可以简化这种等待-通知的逻辑。锁本身支持等待-通知机制，使用条件变量Condition实现。 </li>
<li>性能。考虑到在有边界的队列情况下，竞争可能会比较激烈。当队列为空或已满时，CAS操作可能会导致大量的失败尝试和自旋。这会影响性能，并消耗更多的CPU资源。而在这些竞争激烈的情况下，锁的性能往往优于CAS操作。 </li>
<li>简单性。相比于使用CAS操作实现的非阻塞数据结构，使用锁实现的数据结构通常更容易理解和实现。这意味着更少的错误和更容易维护的代码。 </li>
</ol>
<p>而Disruptor是一个高性能队列库，它的设计初衷是为了解决高并发、低延迟的场景。Disruptor之所以能够使用CAS（Compare And Swap）操作，主要是基于以下几个原因：</p>
<ol>
<li>缓存行填充。Disruptor利用缓存行填充（Cache Line Padding）来减少伪共享（False Sharing）的问题。伪共享会导致缓存行失效，从而影响性能。通过将生产者和消费者的指针放置在不同的缓存行上，避免了伪共享问题，从而提高了使用CAS操作的性能。 </li>
<li>锁消除。Disruptor消除了锁的使用，通过使用原子操作（如CAS）进行并发控制。这减少了锁带来的开销，提高了性能。在高并发场景下，锁的竞争可能会导致严重的性能问题，而CAS操作可以更好地支持这些场景。 </li>
<li>数据结构设计。Disruptor的数据结构设计是基于环形缓冲区（Ring Buffer）的，这使得它在内存分配和管理上更加高效。通常情况下，无锁队列的设计和实现相对复杂，但Disruptor通过使用环形缓冲区，将其复杂程度降低，使得CAS操作的实现变得可行。 </li>
<li>无阻塞。Disruptor采用无阻塞算法，避免了死锁、阻塞等问题。在高并发场景下，无阻塞算法通常具有更好的伸缩性。当线程之间存在很多竞争时，锁定资源可能会导致性能瓶颈。而CAS操作提供了一种无锁的方式来解决资源竞争问题。 </li>
<li>批处理。Disruptor支持批处理，它可以将多个操作组合在一起执行。这样可以充分利用CPU缓存、减少上下文切换，从而提高CAS操作的性能。 </li>
</ol>
<p>Disruptor之所以能够使用CAS操作，主要是因为其数据结构设计、缓存行填充、无锁算法和批处理等技术的应用。这些技术使得Disruptor在高并发和低延迟场景下具有优秀的性能，满足了高性能队列的需求。<br><a name="XJbbR"></a></p>
<h3 id="被破坏的共享"><a href="#被破坏的共享" class="headerlink" title="被破坏的共享"></a>被破坏的共享</h3><p>这里需要提一提一个比较底层的知识，那就是CPU的三级cache：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238904423-7c2ab82a-340e-4193-933d-f40108692896.png#averageHue=%23f4f4f4&clientId=u294810c7-fb47-4&from=paste&height=703&id=u96748072&originHeight=1406&originWidth=1502&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275200&status=done&style=none&taskId=u7bb6a08a-075c-48ad-ade2-9790ddae633&title=&width=751" alt="4-modified.png"><br />CPU的三级缓存，即L1、L2和L3缓存，是一种位于CPU内部的高速存储器。它们主要用于存储那些频繁使用的数据和指令，从而提高CPU处理速度。<br />L1缓存（一级缓存）：它是CPU内部最接近执行单元的缓存，速度非常快，但存储容量相对较小，通常在32KB-64KB之间。L1缓存通常分为数据缓存（用于存储操作数）和指令缓存（用于存储已经预取的指令）。<br />L2缓存（二级缓存）：它位于L1缓存之后，速度略低于L1缓存，但具有较大的存储容量，通常在256KB到8MB之间。L2缓存通常用于存储那些不太频繁使用的数据和指令。在某些CPU设计中，L2缓存可能是共享的，这意味着它可以存储来自不同执行单元的数据和指令。<br />L3缓存（三级缓存）：它位于L2缓存之后，速度低于L2缓存，但在容量和访问速度方面，它将较之主存储器（例如DDR RAM）有很大优势。L3缓存容量范围通常在8MB至32MB之间，但在某些高端处理器中可能更大。L3缓存主要用于在L2缓存中未命中的数据和指令的存储，它可以在多个核之间共享。<br />这种分级存储的方式有效地将处理器的计算能力靠近主存储器的速度。当CPU需要访问数据或指令时，它首先检查L1缓存，然后是L2缓存，最后是L3缓存。如果三级缓存都未命中，CPU将从主存储器中获取数据。由于L1、L2和L3缓存的访问速度逐级降低，但存储容量逐级增加，因此它们一起建立了一个高效的层次结构，将最频繁使用的内容存储在越来越快的缓存中，从而提高处理速度。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234350571-75b183be-3153-4664-aaa3-c841032acea7.png#averageHue=%23e5e5e5&clientId=u294810c7-fb47-4&from=paste&height=135&id=u26a1a90a&originHeight=226&originWidth=1246&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35435&status=done&style=none&taskId=u35f7847f-ab8f-4446-9329-30b47597cde&title=&width=742" alt="image.png"><br><a name="zGraA"></a></p>
<h4 id="共享缓存带来的影响"><a href="#共享缓存带来的影响" class="headerlink" title="共享缓存带来的影响"></a>共享缓存带来的影响</h4><p>缓存由许多缓存行组成。通常情况下，每个缓存行包含64字节，它们有效地引用了主内存中的一系列地址。在这种情况下，一个Java的long类型变量占用8字节，所以一个缓存行可以容纳8个long类型的变量。<br />当CPU从主存中获取数据时，相邻的数据也会被存储到相同的缓存行中。<br />在访问一个long类型的数组时，如果数组中的一个值被加载到缓存中，相邻的7个值也会自动被加载。这使得你可以快速地遍历该数组。实际上，在连续的内存块中分配的任何数据结构都可以被快速遍历。<br />以下示例展示了利用缓存行特性与不利用缓存行特性之间效果的对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineEffect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//考虑一般缓存行大小是64字节，一个 long 类型占8字节</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">long</span>[][] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">                sum = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">1024</span> * <span class="number">1024</span>;j++)&#123;</span><br><span class="line">                sum = arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234667637-b701dcd8-2230-437d-8483-dd0adece47f8.png#averageHue=%23303030&clientId=u294810c7-fb47-4&from=paste&height=62&id=uc4c05076&originHeight=124&originWidth=622&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10940&status=done&style=none&taskId=u021fd135-9ce1-4a0c-a783-98314c511c7&title=&width=311" alt="image.png"><br><a name="NRlFb"></a></p>
<h4 id="那么缓存与ArrayBlockingQueue有什么关系呢？"><a href="#那么缓存与ArrayBlockingQueue有什么关系呢？" class="headerlink" title="那么缓存与ArrayBlockingQueue有什么关系呢？"></a><strong>那么缓存与ArrayBlockingQueue有什么关系呢？</strong></h4><p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量<br />这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234428482-ef2034bb-27f7-41f5-a649-5ecfd622a3b3.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=327&id=u0f02d98d&originHeight=654&originWidth=1966&originalType=binary&ratio=2&rotation=0&showTitle=false&size=131679&status=done&style=none&taskId=u1010804e-920f-4f30-9e79-f63781197f8&title=&width=983" alt="3-modified.png"><br />如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。<br />这种无法充分使用缓存行特性的现象，称为伪共享。<br />对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。<br /><strong>不知道大家有没有看过《Java并发编程艺术》，那本书也写了有无共享缓存导致的区别</strong><br /><strong>而解决伪共享的最好方法，就是填充</strong><br />下面是一个验证程序，去表达有填充和无填充导致的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValueNoPadding[] longs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            runTest(i);</span><br><span class="line">            System.out.println(<span class="string">"Thread num "</span> + i + <span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        longs = <span class="keyword">new</span> ValueNoPadding[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> ValueNoPadding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235086298-b4fd3d05-611f-47b2-a3cf-ee5403674406.png#averageHue=%23383838&clientId=u294810c7-fb47-4&from=paste&height=236&id=uebb152fa&originHeight=472&originWidth=550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=51500&status=done&style=none&taskId=uafd42923-c20d-4e89-9d3a-492afc10140&title=&width=275" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235220121-d84e6b19-a9b3-426c-a382-4eca89265e03.png#averageHue=%23393939&clientId=u294810c7-fb47-4&from=paste&height=227&id=ua3371d3a&originHeight=454&originWidth=484&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46562&status=done&style=none&taskId=ud852761a-cefd-4547-9b5d-2fe30fbd767&title=&width=242" alt="image.png"><br />左边是ValueNoPadding，右边是ValuePadding。</p>
<p>由此可见，有无共享导致的区别还是挺大的。<br />那么这么明显的问题，他们都没有注意到吗？那当然不是，事实上，已经有一个注解@Contended去解决了这个问题：<br /><code>@Contended</code> 注解用于在Java类及其字段上提高内存访问性能。它可以显式地向JVM表示，被修饰的元素（通常是字段）可能会产生伪共享（false sharing）问题。<br />伪共享是指多个线程频繁访问不同变量，但这些变量位于同一个缓存行上。这会导致缓存行频繁失效和重载，从而降低多线程程序的性能。<br /><code>@Contended</code> 注解提示JVM在分配内存时为标注元素添加额外的内存填充，以确保它们分布在不同的缓存行上。这有助于消除伪共享，从而提高线程间的并发性能。<br />要注意的是，<code>@Contended</code> 支持并不是所有JVM版本都有。在Oracle的Hotspot JVM上，默认情况下仅在Java 9及以上版本可用。 若要在低于Java 9的JVM版本上使用<code>@Contended</code>, 需要启动JVM时添加 <code>-XX:-RestrictContended</code> 参数。<br />示例使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.vm.annotation.Contended;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value1 &amp; Value2 with padding to avoid False Sharing</span></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中，<code>Foo</code> 类及其字段 <code>value1</code> 和 <code>value2</code> 使用了 <code>@Contended</code> 注解，以避免伪共享问题。</p>
<p><a name="e83UL"></a></p>
<h2 id="Disruptor的设计"><a href="#Disruptor的设计" class="headerlink" title="Disruptor的设计"></a>Disruptor的设计</h2><p><a name="aaV5Q"></a></p>
<h3 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h3><p>Disruptor是一个高性能、低延迟的并发框架，最初由LMAX公司开发。它用于解决在复杂多线程环境下数据共享和并发访问的问题。Disruptor的设计目标是使开发人员能够在高负载场景下编写出较低延迟和高吞吐量的应用程序。其的核心设计模式主要包括以下几个方面：</p>
<ol>
<li>Ring Buffer（环形缓冲区）：Disruptor框架的核心数据结构。Ring Buffer用于存储和共享数据。它是一个环形的数组，长度固定且是2的整数次幂。由于是环形，当写入到达计数器尾部时，将回到数组的开头覆盖旧数据。Ring Buffer提高了数据存储和访问效率，同时降低了并发冲突的可能性。并且，由于数组的特性对处理器的缓存机制更加友好。</li>
<li>Producer（生产者）：生产者将事件数据添加到Ring Buffer中。在Disruptor框架中，可以有多个生产者同时添加事件。</li>
<li>Sequence Barrier（序列屏障）：提供了一种协调机制，以确保生产者和消费者在并行执行时可以正确访问Ring Buffer。</li>
<li>Consumer（消费者）：消费者是处理Ring Buffer中事件的实际执行者。Disruptor支持多个消费者同时处理事件，可以为消费者定义依赖关系。当多个消费者同时访问Ring Buffer时，事件将根据消费者依赖关系顺序处理。</li>
<li>WaitStrategy（等待策略）：Disruptor提供了一组内置的等待策略，用于控制生产者和消费者在等待事件处理时的行为。例如，线程执行、空轮询、阻塞等待等。</li>
</ol>
<p>使用Disruptor可以高效地处理多线程的并发问题。相比传统的阻塞队列和锁，Disruptor通过这些设计模式实现了更低的延迟和更高的吞吐量，适用于高性能需求的场景。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235832610-789e1be7-524d-4d8f-80c8-e187a86cd8ba.png#averageHue=%23f5f5f5&clientId=u294810c7-fb47-4&from=paste&height=719&id=ud1e82361&originHeight=1438&originWidth=1964&originalType=binary&ratio=2&rotation=0&showTitle=false&size=267070&status=done&style=none&taskId=u81cba5c1-7ebd-4d0e-9fa9-ce68b93ba42&title=&width=982" alt="image.png"><br><a name="yFUmD"></a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Disruptor还具有元素位置定位和无锁这两个优势特点，它们可以进一步提高Disruptor的性能。接下来详细介绍这三个特点：</p>
<ol>
<li>元素位置定位：<br />在Disruptor的Ring Buffer中，每个元素（事件）的位置都是通过一个序列号（Sequence）来表示的。这个序列号对应于Ring Buffer数组的一个索引位置。根据序列号计算索引位置的公式如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; sequence % bufferSize</span><br></pre></td></tr></table></figure>

<p>其中<code>sequence</code>表示元素的序列号（从0开始递增），<code>bufferSize</code>表示Ring Buffer的大小（长度）。<br />由于Ring Buffer的长度是2的整数次幂，这样的设计使得计算索引位置非常高效。只需要进行按位与（<code>sequence &amp; (bufferSize - 1)</code>）操作即可完成计算，避免了除法和取余运算，从而提高了性能。</p>
<ol start="2">
<li>无锁：<br />Disruptor在设计时确保了多个生产者和消费者在操作Ring Buffer时都无需使用锁。利用了无锁数据结构的原子操作，例如CAS（Compare And Swap）等，确保了在高并发环境下正确、高效地访问共享数据。无锁设计相对于基于锁的同步方式减少了线程上下文切换的开销，降低了竞争冲突，从而大幅提高了应用程序的性能。</li>
<li>环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好（CPU加载空间局部性原则）。</li>
</ol>
<p>在Disruptor框架中，生产者和消费者都使用单调递增的序列号（Sequence）来表示所操作的元素。当生产者或消费者需要添加或处理事件时，它们会使用CAS操作更新相应的Sequence。因此，消费者之间即使在并行执行时，也能够正确地知道对方的处理进度，这样消费者之间可以互不干扰地处理事件。</p>
<p><a name="KDa9A"></a></p>
<h3 id="使用无锁的设计"><a href="#使用无锁的设计" class="headerlink" title="使用无锁的设计"></a>使用无锁的设计</h3><p>Disruptor中的主要无锁设计是通过RingBuffer来实现的。RingBuffer是Disruptor中一个循环的缓冲区，使用无锁技术实现高性能的并发访问。<br />在Disruptor中，生产者和消费者共同操作RingBuffer。生产者发布事件时(下面的demo有示例)，会通过<strong>next()</strong>方法申请序号，并一次性地预分配多个序列号。消费者根据序列号处理相应的事件，确保消费者事件间无锁、无阻塞地运行。<br />Disruptor通过使用设计如<strong>Sequence</strong>、<strong>Sequencer</strong>和<strong>Cursor</strong>等类和遵循一定的规则，在高并发环境下保证了生产者和消费者间的正确交互，实现了高性能的无锁设计。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239186747-7e49977c-3b81-43e7-bd05-adc3aa5de15f.png#averageHue=%233a3734&clientId=u294810c7-fb47-4&from=paste&height=331&id=udce0dff4&originHeight=662&originWidth=2358&originalType=binary&ratio=2&rotation=0&showTitle=false&size=223750&status=done&style=none&taskId=u1b7af166-361f-4a85-b8d1-4f7f7f12eb0&title=&width=1179" alt="image.png"></p>
<p><a name="xlu1z"></a></p>
<h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>Disruptor的RingBuffer是一个环形缓冲区，它是Disruptor框架的核心组件。它采用环形数据结构使得生产者和消费者能够高效地在无锁的情况下共享数据。下面详细讲解RingBuffer的原理：</p>
<ol>
<li>数据结构：RingBuffer实际上是一个包含预定义大小的对象数组，这个数组的大小必须为2的幂。之所以使用2的幂，是因为这样可以优化某些计算，例如通过位运算取模运算，提高性能。数组中的每个元素对应一个事件（Event），生产者负责产生事件，消费者负责处理事件。 </li>
<li>序列号（Sequence）：在Disruptor中，生产者和消费者通过序列号（Sequence）来定位RingBuffer中的位置。序列号是一个单调递增的long值，用于表示事件的位置。生产者申请序列号时，序列号递增。消费者处理事件时，根据序列号在RingBuffer中找到相应的事件。 </li>
<li>环形缓冲区：由于RingBuffer是环形的，当数组的末尾已经用完时，生产者可以从数组的开头开始重用位置。这样，在RingBuffer不满的情况下，生产者总是可以写入事件而不会遇到阻塞。当然，在RingBuffer满的情况下，生产者可能需要等待消费者消费事件来释放空间。 </li>
<li>索引计算：由于RingBuffer的长度是2的幂，例如长度为8的RingBuffer，可以通过位运算得到索引：<code>index = sequence &amp; (bufferSize - 1)</code>。这比取模运算效率更高。 </li>
<li>生产者-消费者交互：在Disruptor中，生产者和消费者通过遵循一定的规则实现环形缓冲区的无锁访问，提高并发性能。主要有以下规则：a) 生产者只需要关心最慢的消费者，因为只有当所有消费者完成对当前事件的处理，才能确保生产者可以安全地覆盖之前的事件；b) 消费者之间可能存在依赖关系，可以通过屏障（Barrier）等方法确保消费者按照顺序处理事件。 </li>
</ol>
<p>下面通过一个过程示例，来表达Disruptor的解决思路：<br />启动时，将预先分配环形缓冲区的所有内存。环形缓冲区可以存储指向 entry 的指针数组，也可以存储表示 entry 的结构数组。这些 entry 中的每一个通常不是传递的数据本身，类似对象池机制，而是它的容器。这种 entry 的预分配消除了支持垃圾回收的语言中的问题，因为 entry 将被重用，并在整个 Disruptor 实例存活期间都有效。这些 entry 的内存是同时分配的。<br />一般的数据结构是像下面这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239747113-fa180ee3-e71d-44be-9b6c-ba59c58dff57.png#averageHue=%23f6f6f6&clientId=u294810c7-fb47-4&from=paste&height=518&id=u09798d04&originHeight=1426&originWidth=1536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=214415&status=done&style=none&taskId=u0a61dd2e-e675-4e3e-b624-e76156bbf00&title=&width=558" alt="5-modified.png"><br />我们可以使用一个环状的数组结构改进成下面这样：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239757886-48ce5b14-d7fa-4a54-a762-b2f41cff6647.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=623&id=u749158d5&originHeight=1658&originWidth=958&originalType=binary&ratio=2&rotation=0&showTitle=false&size=203627&status=done&style=none&taskId=uaf451706-9b1e-4450-8a06-017678ed102&title=&width=360" alt="6-modified.png"><br />数组的连续多个元素会一并加载到 CPU Cache 里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。遍历访问时 CPU 层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。</p>
<p>在像 Java 这样的托管运行时环境中开发低延迟系统时，垃圾收集机制可能会带来问题。分配的内存越多，给垃圾收集器带来的负担就越大。当对象的寿命很短或实际上是常驻的时候，垃圾收集器工作得最好。在环形缓冲区中预先分配 entry 意味着它对于垃圾收集器来说是常驻内存的，垃圾回收的负担就很轻。同时，数组结构对处理器的缓存机制更加友好。数组长度 2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心 index 溢出的问题。index 是 long 类型，即使 100 万 QPS 的处理速度，也需要 30 万年才能用完。</p>
<p>一般的 Cache Line 大小在 64 字节左右，然后 Disruptor 在非常重要的字段前后加了很多额外的无用字段。可以让这一个字段占满一整个缓存行，这样就可以避免未共享导致的误杀。</p>
<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。<br><a name="hIbfE"></a></p>
<h4 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h4><p>下面用非环形的结构模拟无锁读写：</p>
<ol>
<li>申请写入m个元素</li>
<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素</li>
<li>若是返回的正确，则生产者开始写入元素</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239966093-8f5b4adc-c6a0-43b7-8194-be501aa8c466.png#averageHue=%23f7f7f7&clientId=u294810c7-fb47-4&from=paste&height=555&id=ub77b53b5&originHeight=1550&originWidth=1108&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146321&status=done&style=none&taskId=u0824520d-67aa-42c3-897e-9eec115f60d&title=&width=397" alt="7-modified.png"><br><a name="CqVJN"></a></p>
<h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor 的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过 CAS 很容易达到。只需要在分配元素的时候，通过 CAS 判断一下这段空间是否已经分配出去即可。</p>
<p>但如何防止读取的时候，读到还未写的元素。Disruptor 在多个生产者的情况下，引入了一个与 Ring Buffer 大小相同的 buffer，Available Buffer。当某个位置写入成功的时候，便把 Availble Buffer 相应的位置置位，标记为写入成功。读取的时候，会遍历 Available Buffer，来判断元素是否已经就绪。<br><a name="XHwEt"></a></p>
<h5 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h5><p>生产者多线程写入的情况会复杂很多：</p>
<p>申请读取到序号n；<br />若 writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从 reader cursor 开始读取 available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；<br />消费者读取元素。<br />如下图所示，读线程读到下标为 2 的元素，三个线程 Writer1/Writer2/Writer3 正在向 RingBuffer 相应位置写数据，写线程被分配到的最大元素下标是 11。</p>
<p>读线程申请读取到下标从3到11的元素，判断 writer cursor&gt;=11。然后开始读取 availableBuffer，从 3 开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p>
<p>然后，消费者读取下标从 3 到 6 共计 4 个元素（多个生产者情况下，消费者消费过程示意图）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240468257-7e87656e-2609-4e11-892c-80c9499fcbfb.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=439&id=u20b89bf1&originHeight=1278&originWidth=1538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=186527&status=done&style=none&taskId=u6c6dc0d3-e25c-4be8-b703-9df811896ab&title=&width=528" alt="8-modified.png"></p>
<p><a name="H7wxf"></a></p>
<h5 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h5><p>多个生产者写入的时候：</p>
<ol>
<li>申请写入 m 个元素；</li>
<li>若是有 m 个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li>
<li>生产者写入元素，写入元素的同时设置 available Buffer 里面相应的位置，以标记自己哪些位置是已经写入成功的。</li>
</ol>
<p>如下图所示，Writer1 和 Writer2 两个线程写入数组，都申请可写的数组空间。Writer1 被分配了下标 3 到下表 5 的空间，Writer2 被分配了下标 6 到下标 9 的空间。<br />Writer1 写入下标 3 位置的元素，同时把 available Buffer 相应位置置位，标记已经写入成功，往后移一位，开始写下标 4 位置的元素。Writer2 同样的方式。最终都写入完成。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240479384-12ad2519-4832-4a2f-b322-be738d75bd89.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=454&id=ue940e65d&originHeight=1216&originWidth=1544&originalType=binary&ratio=2&rotation=0&showTitle=false&size=170725&status=done&style=none&taskId=uf080f650-c299-46f0-ab23-8b0a327bde7&title=&width=576" alt="9-modified.png"></p>
<p><a name="zLdit"></a></p>
<h3 id="解决伪共享的问题"><a href="#解决伪共享的问题" class="headerlink" title="解决伪共享的问题"></a>解决伪共享的问题</h3><p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可即缓存行填充（Padding），使一个对象占用的内存大小刚好为64bytes或它的整数倍，这样就保证了一个缓存行里不会有多个对象，这其实是一种以空间换时间的方案。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689237986676-153e1cdb-479e-47d0-9dba-e8146605e61a.png#averageHue=%232c2c2b&clientId=u294810c7-fb47-4&from=paste&height=433&id=ud05fae06&originHeight=866&originWidth=1384&originalType=binary&ratio=2&rotation=0&showTitle=false&size=90326&status=done&style=none&taskId=u010ab547-b40b-4b4e-a891-4c20e58822c&title=&width=692" alt="image.png"></p>
<p>而Sequence选择继承PhsPadding：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238216429-1e66812a-2ce7-40f6-9ff1-9c858e9cec60.png#averageHue=%232c2b2b&clientId=u294810c7-fb47-4&from=paste&height=639&id=u129d6da7&originHeight=1278&originWidth=1688&originalType=binary&ratio=2&rotation=0&showTitle=false&size=180493&status=done&style=none&taskId=uc4925b8e-d6e1-4cf4-9dc3-ebbf22379c1&title=&width=844" alt="image.png"></p>
<p>Sequence实际value变量的左右均被填充了7个long型变量，其自身也是long型变量，一个long型变量占据8个字节，所以序号与他上一个/下一个序号之间的最小内存距离为：158=120byte，加上对象头的8个字节，可以确保sequence大小128byte=264byte（有的CPU缓存行是128byte）<br />这样直接的代价就是增大的15倍的内存消耗空间，这样的设计导致不可能有两个cursor出现在同一个cpu cache line中, 就解决了”伪共享”问题。</p>
<p><a name="b5l5B"></a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后，官网也提供了很多测试用例：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241111749-4f61900f-733d-42ca-9517-7d8816ab5e9b.png#averageHue=%23745e3e&clientId=u294810c7-fb47-4&from=paste&height=631&id=u2b078ad4&originHeight=1262&originWidth=2372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=354512&status=done&style=none&taskId=uc7f47b10-d568-47a6-a524-bfaaf2ab59b&title=&width=1186" alt="image.png"><br><a name="h9Ao1"></a></p>
<h2 id="延迟性能测试"><a href="#延迟性能测试" class="headerlink" title="延迟性能测试"></a>延迟性能测试</h2><blockquote>
<p>To measure latency we take the three stage pipeline and generate events at less than saturation. This is achieved by waiting 1 microsecond after injecting an event before injecting the next and repeating 50 million times. To time at this level of precision it is necessary to use time stamp counters from the CPU. We chose CPUs with an invariant TSC because older processors suffer from changing frequency due to power saving and sleep states. Intel Nehalem and later processors use an invariant TSC which can be accessed by the latest Oracle JVMs running on Ubuntu 11.04. No CPU binding has been employed for this test. For comparison we use the ArrayBlockingQueue once again. We could have used ConcurrentLinkedQueueviii which is likely to give better results but we want to use a bounded queue implementation to ensure producers do not outpace consumers by creating back pressure. The results below are for 2.2Ghz Core i7-2720QM running Java 1.6.0_25 64-bit on Ubuntu 11.04. Mean latency per hop for the Disruptor comes out at 52 nanoseconds compared to 32,757 nanoseconds for ArrayBlockingQueue. Profiling shows the use of locks and signalling via a condition variable are the main cause of latency for the ArrayBlockingQueue.</p>
</blockquote>
<p>为了测量延迟，我们采用三级管道并在低于饱和度的情况下生成事件。这是通过在注入一个事件之后等待 1 微秒，然后再注入下一个事件并重复 5000 万次来实现的。为了达到这种精度水平，必须使用 CPU 的时间戳计数器。我们选择具有不变 TSC 的 CPU，因为较旧的处理器会因省电和睡眠状态而发生频率变化。Intel Nehalem 及更高版本的处理器使用不变的 TSC，可由 Ubuntu 11.04 上运行的最新 Oracle JVM 访问。此测试未使用 CPU 绑定。为了进行比较，我们再次使用 ArrayBlockingQueue。我们本可以使用 ConcurrentLinkedQueueviii，它可能会提供更好的结果，但我们希望使用有界队列实现来确保生产者不会因产生背压而超过消费者。以下结果适用于在 Ubuntu 11.04 上运行 Java 1.6.0_25 64 位的 2.2Ghz Core i7-2720QM。Disruptor 的每跳平均延迟为 52 纳秒，而 ArrayBlockingQueue 的平均每跳延迟为 32,757 纳秒。分析显示，使用锁和通过条件变量发送信号是 ArrayBlockingQueue 延迟的主要原因。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241005080-b62ef96a-8687-4c10-95b5-5cd418cf4500.png#averageHue=%23fafaf9&clientId=u294810c7-fb47-4&from=paste&height=315&id=ub74af72d&originHeight=630&originWidth=2000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=112876&status=done&style=none&taskId=u6f04c628-8884-4568-b617-d8c2d0d0ecc&title=&width=1000" alt="image.png"><br><a name="oXwBS"></a></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Disruptor是一个高性能、低延迟的并发框架，源自LMAX公司，主要用于实现开发者在多线程程序中无锁队列的操作。ArrayBlockingQueue则是一个基于数组实现的有界阻塞队列，是Java标准库中的一个组件。两者各有优点和局限性，具体如下：</p>
<p>根据上面的分析，可以得出一个结论，Disruptor的性能远高于ArrayBlockingQueue。Disruptor采用一种基于环形数组的数据结构（RingBuffer），通过适当的同步策略和无锁优化技术，实现了非常高的并发性能。因此，在高并发、低延迟场景下，Disruptor的吞吐量和延迟表现显著优于ArrayBlockingQueue。相比之下，ArrayBlockingQueue基于传统的锁和条件变量机制，性能较低、延迟能力有限。<br />但是，相对而言，想要更高的性能吗，就不得不放弃易用。，Disruptor编写相对复杂，可读性较差。由于Disruptor采用了更为底层的原理并使用了许多高级优化技术，例如缓存行填充，预分配对象，内存屏障等，使得其代码实现较为复杂，不易上手。而ArrayBlockingQueue实现相对简单，开发者能更容易理解和使用其原理。<br />最后，Disruptor对依赖环境要求较高。Disruptor的优化策略需要在特定的运行环境下生效，例如，其环形数组的大小需要设置为2的次幂，以充分利用硬件缓存。此外，Disruptor优化适用于JAVA SE环境，在ANDROID等其他环境尚未被广泛验证。而ArrayBlockingQueue作为JDK内置组件，在不同平台环境下的兼容性和稳定性更优。<br />所以，可以得出一个结论，Disruptor与ArrayBlockingQueue在性能、易用性和兼容性方面存在差异。若应用场景追求极致的并发性能、低延迟并能承担较高的开发成本，应选择Disruptor。但若应用场景对性能要求较低，需要简单、易用且兼容性强的阻塞队列，ArrayBlockingQueue则是更好的选择。总之，开发者需要根据实际需求权衡两者的优势和劣势。<br />写到这里，我想起了计算机界的经典名言：*<em>没有银弹  *</em>。意思是没有什么东西是最好最有效而又没有任何缺点的。<br />在软件工程中也是一样，没有最好的技术，只有最合适的技术。面对不同的场景，应该使用更加适合这个场景的技术，这样才能使得效率提高。我想，如何将手中的知识掌握好，然后在合适的环境中发挥它的效果，不仅仅是技术中的艺术，也是软件的工程。</p>
<p><a name="p6ZMt"></a></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><blockquote>
<p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started</a></p>
</blockquote>
<p>结合用例写一个demo<br />事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"LongEvent&#123;"</span> + <span class="string">"value="</span> + value + <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.ringBuffer 事件队列 下一个槽</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        Long data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.取出空的事件队列</span></span><br><span class="line">            LongEvent longEvent = ringBuffer.get(sequence);</span><br><span class="line">            data = byteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//3.获取事件队列传递的数据</span></span><br><span class="line">            longEvent.setValue(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者准备发送数据："</span>);</span><br><span class="line">            <span class="comment">//4.发布事件</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LongEventMain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F; 2.创建工厂</span><br><span class="line">        EventFactory&lt;LongEvent&gt; eventFactory &#x3D; new LongEventFactory();</span><br><span class="line">        &#x2F;&#x2F; 3.创建ringBuffer 大小</span><br><span class="line">        int ringBufferSize &#x3D; 1024 * 1024; &#x2F;&#x2F; ringBufferSize大小一定要是2的N次方</span><br><span class="line">        &#x2F;&#x2F; 4.创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,</span><br><span class="line">                ProducerType.SINGLE, new YieldingWaitStrategy());</span><br><span class="line">        &#x2F;&#x2F; 5.连接消费端方法</span><br><span class="line">        disruptor.handleEventsWith(new LongEventHandler());</span><br><span class="line">        &#x2F;&#x2F; 6.启动</span><br><span class="line">        disruptor.start();</span><br><span class="line">        &#x2F;&#x2F; 7.创建RingBuffer容器</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line">        &#x2F;&#x2F; 8.创建生产者</span><br><span class="line">        LongEventProducer producer &#x3D; new LongEventProducer(ringBuffer);</span><br><span class="line">        &#x2F;&#x2F; 9.指定缓冲区大小</span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;</span><br><span class="line">            byteBuffer.putLong(0, i);</span><br><span class="line">            producer.onData(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;10.关闭disruptor和executor</span><br><span class="line">        disruptor.shutdown();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689236784814-f6573ce5-7ae5-4dbb-8ab5-23494429c7db.png#averageHue=%23313131&clientId=u294810c7-fb47-4&from=paste&height=219&id=uc5f85ba0&originHeight=438&originWidth=1228&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67544&status=done&style=none&taskId=u9e26cf5a-6617-4ad3-ac64-93a6fc72847&title=&width=614" alt="image.png"><br /></p>
<p><a name="Ohdad"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_memory_barriers" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/disruptor.html</a><br><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a><br><a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/</a><br><a href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/18/disruptor.html</a><br><a href="https://zhuanlan.zhihu.com/p/229338771" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/229338771</a><br><a href="https://zhuanlan.zhihu.com/p/513468454" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/513468454</a><br><a href="https://qin.news/disruptor/" target="_blank" rel="noopener">https://qin.news/disruptor/</a></p>
</blockquote>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%98%9F%E5%88%97/">队列</a><a class="post-meta__tags" href="/tags/Disruptor/">Disruptor</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/12/20/Python-1/"><i class="fa fa-chevron-left">  </i><span>实践经验-Py架构</span></a></div><div class="next-post pull-right"><a href="/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/"><span>实现Spring框架中的IOC和AOP</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2024 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>