<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring高级注解与接口"><meta name="keywords" content="Spring"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>Spring高级注解与接口 | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CommandLineRunner"><span class="toc-number">1.</span> <span class="toc-text">CommandLineRunner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostConstruct"><span class="toc-number">2.</span> <span class="toc-text">@PostConstruct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConditionalOnProperty"><span class="toc-number">3.</span> <span class="toc-text">@ConditionalOnProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NestedConfigurationProperty"><span class="toc-number">4.</span> <span class="toc-text">@NestedConfigurationProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InstantiationAwareBeanPostProcessorAdapter"><span class="toc-number">5.</span> <span class="toc-text">InstantiationAwareBeanPostProcessorAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContextAware"><span class="toc-number">6.</span> <span class="toc-text">ApplicationContextAware</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aspect"><span class="toc-number">7.</span> <span class="toc-text">@Aspect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Around"><span class="toc-number">8.</span> <span class="toc-text">@Around</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Aspect和-Around"><span class="toc-number">8.1.</span> <span class="toc-text">@Aspect和@Around</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">100</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">69</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Spring高级注解与接口</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-28</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>这里开始记录一些学到的强力的注解和接口</p>
<h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>CommandLineRunner是Spring Boot框架中的一个接口，用于定义在应用程序启动后执行的任务。它包含一个run方法，该方法在应用程序启动后被调用，并接收命令行参数作为参数。<br>具体来说，CommandLineRunner接口的作用是允许开发人员在应用程序启动后执行一些初始化或后续操作的逻辑。通过实现CommandLineRunner接口并重写run方法，你可以在应用程序启动后执行自定义的逻辑代码。<br>当应用程序启动时，Spring Boot会自动扫描并检测实现了CommandLineRunner接口的Bean，并在启动后调用它们的run方法。这样，你可以在应用程序启动后执行一些必要的初始化任务，例如加载数据、启动定时任务、建立连接等。<br>在CommandLineRunner接口的run方法中，你可以编写任何你希望在应用程序启动后执行的代码。该方法可以抛出Exception异常，因此你可以在其中处理任何可能发生的异常情况。<br>总结起来，CommandLineRunner接口允许你在应用程序启动后执行自定义的逻辑代码。通过实现该接口并重写run方法，你可以在应用程序启动后执行一些初始化或后续操作的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"ConfigProperties properties:&#123;&#125;"</span>, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>@PostConstruct是Java标准库中的一个注解，它用于标记一个方法，在对象创建后立即执行。在Spring框架中，@PostConstruct注解被用于定义在Bean初始化之后执行的方法。</p>
<p>具体来说，当一个Bean被实例化并完成依赖注入后，Spring容器会检测该Bean中是否存在被@PostConstruct注解标记的方法。如果存在，Spring容器会在Bean初始化完成后立即调用该方法。</p>
<p>@PostConstruct注解的作用是允许开发人员在Bean初始化之后执行一些自定义的初始化逻辑。这些逻辑可以包括数据加载、资源初始化、建立连接等操作。通过在方法上添加@PostConstruct注解，你可以确保在Bean完全初始化之后执行这些操作。</p>
<p>需要注意的是，@PostConstruct注解只能用于非静态方法，并且只能标记一个方法。如果在一个类中存在多个被@PostConstruct注解标记的方法，它们的执行顺序是不确定的。</p>
<p>总结起来，@PostConstruct注解用于标记一个方法，在Bean初始化之后立即执行。它允许开发人员在Bean初始化完成后执行一些自定义的初始化逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String targetService = properties.getTargetService();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(targetService))&#123;</span><br><span class="line">        targetService = System.getenv(<span class="string">"TService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CompensateContextHolder.setTargetService(targetService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p>@ConditionalOnProperty是Spring Boot框架中的一个条件注解，用于根据配置属性的值来决定是否启用或禁用特定的组件或配置。<br>具体来说，@ConditionalOnProperty注解用于在特定的配置属性满足条件时才加载或启用某个组件。它接收一个或多个属性参数，用于指定要检查的配置属性的名称和期望的值。<br>比如：@ConditionalOnProperty注解的value参数设置为”compensate.enabled”，表示要检查名为”compensate.enabled”的配置属性。而havingValue参数设置为”true”，表示期望该配置属性的值为”true”。<br>因此，当配置属性”compensate.enabled”的值为”true”时，被注解的组件或配置将被加载或启用。如果配置属性的值不是”true”，则被注解的组件或配置将被禁用或忽略。<br>这个注解通常用于根据配置属性的值来决定是否启用某些特定的功能或组件。通过使用@ConditionalOnProperty注解，你可以根据配置属性的值来动态地控制应用程序的行为，使其更加灵活和可配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"compensate.enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompensateManager <span class="title">compensateManager</span><span class="params">(DataSource dataSource, CompensateExecutionChain chain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompensateManager(properties, dataSource, chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NestedConfigurationProperty"><a href="#NestedConfigurationProperty" class="headerlink" title="@NestedConfigurationProperty"></a>@NestedConfigurationProperty</h2><p>@NestedConfigurationProperty是Spring框架中的一个注解，用于指示一个属性应该被视为嵌套的配置属性。它通常用于嵌套类中的属性，以便在配置文件中以嵌套的方式组织属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="keyword">private</span> String country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，Employee类包含一个嵌套类Address，它表示员工的地址信息。Address类具有三个属性：street、city和country。<br>通过这种方式，可以在Employee类中组织员工的信息，并将地址信息作为嵌套类的属性。这样，可以更清晰地表示员工对象的结构，并在配置文件中以嵌套的方式配置地址信息。<br>在配置文件中，可以使用以下方式配置Employee对象的属性和Address对象的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">employee.name=John Doe</span><br><span class="line">employee.age=<span class="number">30</span></span><br><span class="line">employee.address.street=<span class="number">123</span> Main St</span><br><span class="line">employee.address.city=New York</span><br><span class="line">employee.address.country=USA</span><br></pre></td></tr></table></figure>

<p>这样，就可以通过嵌套类的方式组织和配置复杂的对象结构。</p>
<h2 id="InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessorAdapter</h2><p>InstantiationAwareBeanPostProcessorAdapter是Spring框架中的一个接口，它是InstantiationAwareBeanPostProcessor接口的适配器类。这个接口在Spring的Bean生命周期中扮演着重要的角色。<br>InstantiationAwareBeanPostProcessor接口定义了一组回调方法，用于在Spring容器实例化Bean之前和之后进行自定义处理。而InstantiationAwareBeanPostProcessorAdapter是一个适配器类，它提供了默认的空实现，使得我们可以只关注我们感兴趣的回调方法，而不需要实现接口中的所有方法。<br>这个接口的作用是允许开发者在Bean实例化的不同阶段进行自定义的处理。它提供了以下几个重要的回调方法：<br>postProcessBeforeInstantiation(): 在实例化Bean之前调用，允许开发者返回一个自定义的Bean实例，或者返回null来使用默认的实例化机制。<br>postProcessAfterInstantiation(): 在实例化Bean之后调用，允许开发者对实例进行自定义的处理，例如修改属性值或执行其他初始化操作。<br>postProcessPropertyValues(): 在Bean的属性注入之前调用，允许开发者对属性值进行自定义的处理，例如修改属性值或验证属性的合法性。<br>通过实现InstantiationAwareBeanPostProcessor接口或使用InstantiationAwareBeanPostProcessorAdapter适配器类，开发者可以在Bean实例化的不同阶段进行自定义的处理。这样，我们可以在Spring容器实例化Bean时，对Bean进行额外的操作或修改，以满足特定的需求。<br>以下是一个简单的示例，展示了如何使用InstantiationAwareBeanPostProcessorAdapter接口来自定义处理Bean实例化的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == MyBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之前，返回一个自定义的Bean实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">"Custom Instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null，使用默认的实例化机制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyBean) &#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之后，对其进行自定义的处理</span></span><br><span class="line">            MyBean myBean = (MyBean) bean;</span><br><span class="line">            myBean.setSomeProperty(<span class="string">"Custom Property Value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个名为CustomBeanPostProcessor的类，它继承自InstantiationAwareBeanPostProcessorAdapter适配器类。我们重写了postProcessBeforeInstantiation()和postProcessAfterInstantiation()方法来实现自定义的处理逻辑。<br>在postProcessBeforeInstantiation()方法中，我们检查要实例化的Bean是否是MyBean类。如果是，我们返回一个自定义的MyBean实例，否则返回null，使用默认的实例化机制。<br>在postProcessAfterInstantiation()方法中，我们检查实例化后的Bean是否是MyBean类的实例。如果是，我们对其进行自定义的处理，例如设置属性值。<br>通过使用CustomBeanPostProcessor类，我们可以在Bean实例化的过程中对特定的Bean进行自定义处理。这样，我们可以根据需要修改Bean的实例或属性，以满足特定的业务逻辑或需求。</p>
<h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><p>ApplicationContextAware接口是Spring框架中的一个接口，用于实现对应用程序上下文（ApplicationContext）的感知。<br>该接口继承自Aware接口，通过实现ApplicationContextAware接口，可以让Bean获取对应用程序上下文的引用，并在需要时进行操作。<br>具体来说，ApplicationContextAware接口定义了一个方法setApplicationContext(ApplicationContext var1)，当Bean被实例化并注入到Spring容器中时，Spring容器会自动调用该方法，并将当前的应用程序上下文作为参数传递进来。<br>通过实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文的引用，并利用它来进行一些操作，例如获取其他Bean、发布事件、访问资源等。<br>一般来说，这么整就行了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来，ApplicationContextAware接口的作用是让Bean获取对应用程序上下文的引用，以便在需要时进行操作。通过实现该接口并实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文，并利用它进行各种操作。</p>
<h2 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h2><p>@Aspect注解是Spring框架中的一个注解，用于声明一个切面（Aspect）。切面是一种用于横切关注点（Cross-cutting Concerns）的模块化方式，它可以定义一组通用的横切逻辑，并将其应用到多个目标对象中。<br>具体来说，@Aspect注解用于标记一个类为切面类，该类中定义了一些通用的横切逻辑，例如日志记录、性能监控、事务管理等。切面类通常包含一些切点（Pointcut）和通知（Advice）的定义。</p>
<ul>
<li>切点（Pointcut）：切点定义了在哪些连接点（Join Point）上应用通知。连接点是程序执行过程中可以插入切面逻辑的点，例如方法调用、方法执行、异常抛出等。切点通过表达式或注解来定义，用于匹配符合条件的连接点。</li>
<li>通知（Advice）：通知定义了在切点上执行的具体逻辑。通知可以在切点之前、之后、抛出异常时等不同的时机执行。常见的通知类型包括前置通知（Before）、后置通知（After）、返回通知（AfterReturning）和异常通知（AfterThrowing）等。</li>
</ul>
<p>通过使用@Aspect注解，Spring框架可以识别并将切面类纳入到AOP（面向切面编程）的管理中。在运行时，Spring会根据切点和通知的定义，将切面逻辑织入到目标对象的相应连接点上，从而实现横切关注点的功能。<br>要使用切面，需要完成以下步骤：</p>
<ol>
<li>在Spring配置文件中启用AOP的自动代理功能。可以使用<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a>标签或@EnableAspectJAutoProxy注解来实现。这将告诉Spring框架在运行时自动创建代理对象，并将切面逻辑织入到目标对象的连接点上。</li>
<li>创建目标对象。目标对象是需要应用切面逻辑的对象。可以是任何Spring管理的Bean，例如服务类、控制器等。</li>
<li>创建切面类。切面类是包含切点和通知的类。使用@Aspect注解标记切面类，并在其中定义切点和通知的方法。</li>
<li>在切面类中定义切点。切点定义了在哪些连接点上应用通知。可以使用表达式或注解来定义切点，以匹配符合条件的连接点。</li>
<li>在切面类中定义通知。通知定义了在切点上执行的具体逻辑。可以使用@Before、@After、@AfterReturning、@AfterThrowing等注解来定义不同类型的通知。</li>
<li>运行应用程序。当目标对象的方法被调用时，切面逻辑会自动织入到连接点上，根据切点和通知的定义执行相应的逻辑。</li>
</ol>
<p>以下是一个简单的示例，演示如何使用切面类来实现日志记录的横切逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        MyService myService = context.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        myService.doSomething();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Doing something..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.example.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethodExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个MyService类作为目标对象，其中包含一个doSomething()方法。我们还创建了一个LoggingAspect类作为切面类，其中定义了一个前置通知，用于在目标对象的方法执行之前记录日志。<br>在MainApp类中，我们使用AnnotationConfigApplicationContext来加载Spring配置，并获取MyService的实例。当调用myService.doSomething()方法时，切面类中的前置通知会被触发，输出日志信息：”Before method execution: Logging…”。<br>通过以上步骤，我们成功地将切面逻辑应用到目标对象的连接点上，实现了日志记录的横切逻辑<br>总结起来，@Aspect注解用于声明一个切面类，该类中定义了切点和通知，用于实现横切关注点的功能。通过使用@Aspect注解，Spring框架可以识别并管理切面类，将切面逻辑织入到目标对象的连接点上。</p>
<h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>@Around是一个用于定义环绕通知的注解。在Spring AOP中，环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。<br>使用@Around注解可以将一个方法标记为环绕通知方法。这个方法会在目标方法执行之前和之后执行，可以在这个方法中编写自定义的逻辑来控制目标方法的执行。<br>环绕通知方法需要满足一些要求：</p>
<ul>
<li>方法的返回类型可以是任意类型，通常是Object。</li>
<li>方法的参数可以是ProceedingJoinPoint类型，用于执行目标方法，也可以是其他参数，根据需要进行定义。</li>
</ul>
<p>在环绕通知方法中，可以通过调用ProceedingJoinPoint对象的proceed()方法来执行目标方法。在调用proceed()方法之前，可以在目标方法执行前进行一些前置操作，而在调用proceed()方法之后，可以在目标方法执行后进行一些后置操作。通过使用@Around注解，我们可以更灵活地控制目标方法的执行过程，例如在执行前后进行日志记录、性能监控、事务管理等操作。<br>比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.example.service.MyService.doSomething(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"After method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个LoggingAspect切面类，并在其中使用@Around注解标记了一个环绕通知方法aroundAdvice()。该方法接受一个ProceedingJoinPoint参数，用于执行目标方法。<br>在aroundAdvice()方法中，我们首先输出了一条日志信息，表示在目标方法执行之前的前置操作。然后，通过调用joinPoint.proceed()方法，执行了目标方法。最后，我们又输出了一条日志信息，表示在目标方法执行之后的后置操作。<br>通过这个示例，我们可以在目标方法执行前后添加自定义的逻辑，例如记录日志、计算方法执行时间等。这样，每次调用MyService的doSomething()方法时，都会触发切面的环绕通知方法。</p>
<h3 id="Aspect和-Around"><a href="#Aspect和-Around" class="headerlink" title="@Aspect和@Around"></a>@Aspect和@Around</h3><p>@Aspect和@Around是Spring AOP框架中的两个不同的注解，它们在AOP的实现中扮演不同的角色。</p>
<ul>
<li>@Aspect注解用于标记一个类为切面类。切面类是包含切面逻辑的类，它定义了在哪些连接点上应用切面逻辑，并且可以包含多个通知类型（如前置通知、后置通知、环绕通知等）。通过使用@Aspect注解，我们可以将一个普通的类声明为切面类，以便在Spring AOP中使用。</li>
<li>@Around注解是一个通知类型的注解，用于定义环绕通知。环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。通过使用@Around注解，我们可以将一个方法标记为环绕通知方法，以便在切面中定义自定义的逻辑。</li>
</ul>
<p>因此，@Aspect注解用于标记切面类，而@Around注解用于标记环绕通知方法。切面类可以包含多个通知类型的方法，而环绕通知方法是其中的一种。切面类通过@Aspect注解告诉Spring AOP框架它是一个切面类，而环绕通知方法通过@Around注解告诉框架它是一个环绕通知方法。</p>
<p>综上所述，@Aspect和@Around是Spring AOP框架中的两个不同的注解，用于不同的目的。@Aspect用于标记切面类，而@Around用于标记环绕通知方法。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/11/02/compensate/"><i class="fa fa-chevron-left">  </i><span>补偿框架</span></a></div><div class="next-post pull-right"><a href="/2023/04/14/Disruptor-1/"><span>高性能队列：Disruptor</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2024 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>