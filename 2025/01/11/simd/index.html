<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="利用SIMD优化UTF-16到UTF-8的转换"><meta name="keywords" content="C++"><meta name="author" content="攀"><meta name="copyright" content="攀"><title>利用SIMD优化UTF-16到UTF-8的转换 | 小世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小世界" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#巧用-SIMD-加速-UTF-16-到-UTF-8-的转换"><span class="toc-number">1.</span> <span class="toc-text">巧用 SIMD 加速 UTF-16 到 UTF-8 的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、背景引入"><span class="toc-number">1.1.</span> <span class="toc-text">一、背景引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、SIMD-技术简介"><span class="toc-number">1.2.</span> <span class="toc-text">二、SIMD 技术简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、代码实现与详细分析"><span class="toc-number">1.3.</span> <span class="toc-text">三、代码实现与详细分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（一）代码整体功能概述"><span class="toc-number">1.3.1.</span> <span class="toc-text">（一）代码整体功能概述</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/pandalee99/image_store/master/hexo/c17f0489-42cd-439a-94bd-0612598b142f.jpg"></div><div class="author-info__name text-center">攀</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Pandalee99">GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">107</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">71</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">链接</div><a class="author-info-links__name text-center" href="https://github.com/Pandalee99/Concurrent-programming">GItHub配套资源</a><a class="author-info-links__name text-center" href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a><a class="author-info-links__name text-center" href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">利用SIMD优化UTF-16到UTF-8的转换</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-01-11</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="巧用-SIMD-加速-UTF-16-到-UTF-8-的转换"><a href="#巧用-SIMD-加速-UTF-16-到-UTF-8-的转换" class="headerlink" title="巧用 SIMD 加速 UTF-16 到 UTF-8 的转换"></a>巧用 SIMD 加速 UTF-16 到 UTF-8 的转换</h1><h2 id="一、背景引入"><a href="#一、背景引入" class="headerlink" title="一、背景引入"></a>一、背景引入</h2><p>在当今数字化信息爆炸的时代，软件应用需要处理来自全球各地的多语言文本。不同的字符编码标准应运而生，其中 UTF - 16 和 UTF - 8 是 Unicode 编码体系下非常重要的两种编码方式。UTF - 16 以其简单直接的方式对大部分常用的 Unicode 字符进行编码，在一些操作系统和编程语言内部使用较为广泛；而 UTF - 8 由于其对 ASCII 字符的兼容性以及可变长度编码节省存储空间的特性，成为了网络传输和文件存储的首选编码。</p>
<p>然而，在实际的应用场景中，经常需要在这两种编码之间进行转换。传统的逐字符转换方法虽然逻辑简单，但在处理大规模文本时效率低下，会成为系统性能的瓶颈。为了提高转换效率，我们可以借助现代处理器提供的单指令多数据（SIMD，Single Instruction Multiple Data）技术。</p>
<h2 id="二、SIMD-技术简介"><a href="#二、SIMD-技术简介" class="headerlink" title="二、SIMD 技术简介"></a>二、SIMD 技术简介</h2><p>SIMD 技术是现代处理器中一项强大的并行计算特性。它允许处理器在单个指令周期内同时对多个数据元素执行相同的操作，就像一个高效的流水线工人，能够同时处理多个任务。例如，我们常见的 SSE（Streaming SIMD Extensions）、AVX（Advanced Vector Extensions）等指令集都是 SIMD 技术的具体实现。</p>
<p>在本文中，我们将使用 AVX2 指令集。AVX2 指令集支持 256 位寄存器，这意味着我们可以在一个寄存器中同时存储 16 个 16 位的数据元素。通过使用 AVX2 指令，我们可以一次性对这 16 个元素进行比较、运算等操作，大大减少了指令执行的次数，从而提高了程序的运行效率。</p>
<h2 id="三、代码实现与详细分析"><a href="#三、代码实现与详细分析" class="headerlink" title="三、代码实现与详细分析"></a>三、代码实现与详细分析</h2><h3 id="（一）代码整体功能概述"><a href="#（一）代码整体功能概述" class="headerlink" title="（一）代码整体功能概述"></a>（一）代码整体功能概述</h3><p>下面是一个使用 SIMD 优化的 UTF - 16 到 UTF - 8 转换的函数代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这两个辅助函数已经实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">utf16ToUtf8</span><span class="params">(<span class="keyword">char16_t</span> utf16Char, <span class="keyword">char</span>*&amp; output)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">utf16SurrogatePairToUtf8</span><span class="params">(<span class="keyword">char16_t</span> highSurrogate, <span class="keyword">char16_t</span> lowSurrogate, <span class="keyword">char</span>*&amp; output)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">utf16ToUtf8</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::u16string &amp;utf16, <span class="keyword">bool</span> is_little_endian)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> utf8;</span><br><span class="line">    <span class="comment">// 预先分配足够的空间，避免在转换过程中频繁进行内存重新分配，提高效率</span></span><br><span class="line">    utf8.reserve(utf16.size() * <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一些常量，用于后续的比较操作</span></span><br><span class="line">    <span class="keyword">const</span> __m256i limit1 = _mm256_set1_epi16(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">const</span> __m256i limit2 = _mm256_set1_epi16(<span class="number">0x800</span>);</span><br><span class="line">    <span class="keyword">const</span> __m256i surrogate_high_start = _mm256_set1_epi16(<span class="number">0xD800</span>);</span><br><span class="line">    <span class="keyword">const</span> __m256i surrogate_high_end = _mm256_set1_epi16(<span class="number">0xDBFF</span>);</span><br><span class="line">    <span class="keyword">const</span> __m256i surrogate_low_start = _mm256_set1_epi16(<span class="number">0xDC00</span>);</span><br><span class="line">    <span class="keyword">const</span> __m256i surrogate_low_end = _mm256_set1_epi16(<span class="number">0xDFFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时缓冲区，用于存储转换后的 UTF - 8 字节</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>]; </span><br><span class="line">    <span class="keyword">char</span> *output = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> n = utf16.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环，每次处理 16 个 UTF - 16 字符</span></span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">16</span> &lt;= n) &#123;</span><br><span class="line">        <span class="comment">// 从 UTF - 16 字符串中加载 16 个字符到 256 位寄存器中</span></span><br><span class="line">        __m256i in = _mm256_loadu_si256(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> __m256i *&gt;(utf16.data() + i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输入是大端字节序，需要进行字节交换</span></span><br><span class="line">        <span class="keyword">if</span> (!is_little_endian) &#123;</span><br><span class="line">            in = _mm256_or_si256(</span><br><span class="line">                _mm256_slli_epi16(in, <span class="number">8</span>),</span><br><span class="line">                _mm256_srli_epi16(in, <span class="number">8</span>)); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成掩码，用于判断每个字符需要多少字节来表示</span></span><br><span class="line">        __m256i mask1 = _mm256_cmpgt_epi16(in, limit1);</span><br><span class="line">        __m256i mask2 = _mm256_cmpgt_epi16(in, limit2);</span><br><span class="line">        __m256i high_surrogate_mask =</span><br><span class="line">            _mm256_and_si256(_mm256_cmpgt_epi16(in, surrogate_high_start),</span><br><span class="line">                             _mm256_cmpgt_epi16(in, surrogate_high_end));</span><br><span class="line">        __m256i low_surrogate_mask =</span><br><span class="line">            _mm256_and_si256(_mm256_cmpgt_epi16(in, surrogate_low_start),</span><br><span class="line">                             _mm256_cmpgt_epi16(in, surrogate_low_end));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据掩码判断情况进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (_mm256_testz_si256(mask1, mask1)) &#123;</span><br><span class="line">            <span class="comment">// 所有字符值都小于 0x80，每个字符用 1 字节表示</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">                *output++ = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(utf16[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_mm256_testz_si256(mask2, mask2)) &#123;</span><br><span class="line">            <span class="comment">// 所有字符值都小于 0x800，每个字符用 2 字节表示</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">                utf16ToUtf8(utf16[i + j], output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在 1、2 和 3 字节表示的字符混合情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_mm256_testz_si256(high_surrogate_mask, high_surrogate_mask) &amp;&amp;</span><br><span class="line">                    j + <span class="number">1</span> &lt; <span class="number">16</span> &amp;&amp;</span><br><span class="line">                    !_mm256_testz_si256(low_surrogate_mask, low_surrogate_mask)) &#123;</span><br><span class="line">                    <span class="comment">// 处理代理对</span></span><br><span class="line">                    utf16SurrogatePairToUtf8(utf16[i + j], utf16[i + j + <span class="number">1</span>], output);</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    utf16ToUtf8(utf16[i + j], output);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将临时缓冲区中的转换结果追加到 UTF - 8 字符串中</span></span><br><span class="line">        utf8.append(buffer, output - buffer);</span><br><span class="line">        <span class="comment">// 重置缓冲区指针</span></span><br><span class="line">        output = buffer; </span><br><span class="line">        <span class="comment">// 移动到下一组 16 个字符</span></span><br><span class="line">        i += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余的字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; utf16[i] &gt;= <span class="number">0xD800</span> &amp;&amp; utf16[i] &lt;= <span class="number">0xDBFF</span> &amp;&amp;</span><br><span class="line">            utf16[i + <span class="number">1</span>] &gt;= <span class="number">0xDC00</span> &amp;&amp; utf16[i + <span class="number">1</span>] &lt;= <span class="number">0xDFFF</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理代理对</span></span><br><span class="line">            utf16SurrogatePairToUtf8(utf16[i], utf16[i + <span class="number">1</span>], output);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            utf16ToUtf8(utf16[i], output);</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一次转换结果追加到 UTF - 8 字符串中</span></span><br><span class="line">    utf8.append(buffer, output - buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> utf8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>（二）代码详细分析</p>
<p>初始化部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> utf8;</span><br><span class="line">utf8.reserve(utf16.size() * <span class="number">3</span>);</span><br></pre></td></tr></table></figure>


<p>这里我们创建了一个 std::string 类型的 utf8 字符串，用于存储最终转换后的 UTF - 8 编码文本。通过调用 reserve 函数，我们预先为 utf8 分配了足够的空间。因为 UTF - 16 字符转换为 UTF - 8 后，每个字符最多可能需要 3 个字节来表示，所以我们根据输入的 UTF - 16 字符串长度乘以 3 来预留空间，这样可以避免在转换过程中频繁进行内存重新分配，从而提高程序的运行效率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppconst __m256i limit1 = _mm256_set1_epi16(<span class="number">0x80</span>);</span><br><span class="line"><span class="keyword">const</span> __m256i limit2 = _mm256_set1_epi16(<span class="number">0x800</span>);</span><br></pre></td></tr></table></figure>



<p>这些代码使用 _mm256_set1_epi16 函数将常量值广播到 256 位寄存器的每个 16 位元素中。这些常量在后续的比较操作中非常重要，用于判断每个 UTF - 16 字符转换为 UTF - 8 时需要多少个字节来表示。例如，limit1 用于判断字符是否可以用 1 个字节表示（小于 0x80），limit2 用于判断字符是否可以用 2 个字节表示（小于 0x800）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i + <span class="number">16</span> &lt;= n) &#123;</span><br><span class="line"> __m256i in = _mm256_loadu_si256(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> __m256i *&gt;(utf16.data() + i));</span><br><span class="line"> <span class="comment">// 字节序处理</span></span><br><span class="line"> <span class="keyword">if</span> (!is_little_endian) &#123;</span><br><span class="line">     in = _mm256_or_si256(</span><br><span class="line">         _mm256_slli_epi16(in, <span class="number">8</span>),</span><br><span class="line">         _mm256_srli_epi16(in, <span class="number">8</span>));</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在主循环中，我们每次从输入的 UTF - 16 字符串中加载 16 个 16 位的字符到 256 位寄存器 __m256i 中。使用 _mm256_loadu_si256 函数进行非对齐加载，因为输入的字符串不一定是按 256 位对齐的。如果输入的 UTF - 16 字符串是大端字节序（is_little_endian 为 false），我们需要进行字节交换操作，通过 _mm256_slli_epi16 和 _mm256_srli_epi16 函数分别进行左移和右移 8 位，然后使用 _mm256_or_si256 函数将结果合并，从而实现字节序的转换。</span></span><br><span class="line">cpp__m256i mask1 = _mm256_cmpgt_epi16(in, limit1);</span><br><span class="line">__m256i mask2 = _mm256_cmpgt_epi16(in, limit2);</span><br><span class="line"><span class="comment">// 其他掩码计算...</span></span><br><span class="line"><span class="comment">//这部分代码使用 _mm256_cmpgt_epi16 函数对寄存器中的每个 16 位元素与常量进行比较。比较结果会生成一个掩码，掩码中的每个位对应寄存器中的一个元素，如果元素大于比较值，则对应位为 1，否则为 0。这些掩码用于后续判断每个字符需要多少字节来表示，以及是否为代理对的一部分。</span></span><br><span class="line">cpp</span><br></pre></td></tr></table></figure>

<p>主循环部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_mm256_testz_si256(mask1, mask1)) &#123;</span><br><span class="line"> <span class="comment">// All values &lt; 0x80, 1 byte per character</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">     *output++ = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(utf16[i + j]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_mm256_testz_si256(mask2, mask2)) &#123;</span><br><span class="line"> <span class="comment">// All values &lt; 0x800, 2 bytes per character</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">     utf16ToUtf8(utf16[i + j], output);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// Mix of 1, 2, and 3 byte characters</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">     <span class="keyword">if</span> (_mm256_testz_si256(high_surrogate_mask, high_surrogate_mask) &amp;&amp;</span><br><span class="line">         j + <span class="number">1</span> &lt; <span class="number">16</span> &amp;&amp;</span><br><span class="line">         !_mm256_testz_si256(low_surrogate_mask, low_surrogate_mask)) &#123;</span><br><span class="line">         <span class="comment">// Surrogate pair</span></span><br><span class="line">         utf16SurrogatePairToUtf8(utf16[i + j], utf16[i + j + <span class="number">1</span>], output);</span><br><span class="line">         ++j;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         utf16ToUtf8(utf16[i + j], output);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>根据生成的掩码，我们进行不同的处理。如果 mask1 全为 0，说明这 16 个字符的值都小于 0x80，每个字符可以直接用 1 个字节表示，我们将其直接转换为 char 类型并存储到临时缓冲区中。如果 mask1 不全为 0，但 mask2 全为 0，说明这些字符的值都小于 0x800，每个字符需要用 2 个字节表示，我们调用 utf16ToUtf8 函数进行转换。如果 mask2 也不全为 0，说明存在 1、2 和 3 字节表示的字符混合情况，并且可能存在代理对。对于代理对，我们调用 utf16SurrogatePairToUtf8 函数进行处理，同时跳过下一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">utf8.append(buffer, output - buffer);</span><br><span class="line">output &#x3D; buffer; &#x2F;&#x2F; Reset output buffer pointer</span><br><span class="line">i +&#x3D; 16;</span><br></pre></td></tr></table></figure>



<p>每次处理完 16 个字符后，我们将临时缓冲区中的转换结果追加到 utf8 字符串中。然后重置临时缓冲区的指针，以便下一次存储新的转换结果。最后，将索引 i 增加 16，移动到下一组 16 个字符进行处理。</p>
<p>处理剩余字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; utf16[i] &gt;= <span class="number">0xD800</span> &amp;&amp; utf16[i] &lt;= <span class="number">0xDBFF</span> &amp;&amp;</span><br><span class="line">     utf16[i + <span class="number">1</span>] &gt;= <span class="number">0xDC00</span> &amp;&amp; utf16[i + <span class="number">1</span>] &lt;= <span class="number">0xDFFF</span>) &#123;</span><br><span class="line">     <span class="comment">// Surrogate pair</span></span><br><span class="line">     utf16SurrogatePairToUtf8(utf16[i], utf16[i + <span class="number">1</span>], output);</span><br><span class="line">     ++i;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     utf16ToUtf8(utf16[i], output);</span><br><span class="line"> &#125;</span><br><span class="line"> ++i;</span><br><span class="line">&#125;</span><br><span class="line">utf8.append(buffer, output - buffer);</span><br></pre></td></tr></table></figure>



<p>当主循环处理完能被 16 整除的部分后，可能还会有剩余的字符。这部分代码会逐个处理这些剩余字符。如果遇到代理对，调用 utf16SurrogatePairToUtf8 函数进行处理；否则，调用 utf16ToUtf8 函数进行转换。最后，将临时缓冲区中最后一次转换的结果追加到 utf8 字符串中。</p>
<p>通过使用 SIMD 技术，我们成功地对 UTF - 16 到 UTF - 8 的转换过程进行了优化。利用 AVX2 指令集的并行计算能力，一次性处理 16 个字符，减少了指令执行次数，提高了程序的运行效率。特别是在处理大规模文本时，这种优化效果会更加明显。<br>然而，需要注意的是，SIMD 编程需要对处理器指令集有一定的了解，并且代码的可移植性可能会受到一定影响。在不同的处理器架构上，可能需要调整指令集的使用。因此，在实际应用中，我们需要根据具体的平台和需求进行权衡和优化，以达到最佳的性能和兼容性。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2024/12/29/bazel/"><span>Bazel工程化集成google/benchmark</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://bbsfiles.vivo.com.cn/vivobbs/attachment/forum/201706/23/120105q39c9ql9syl7b4ye.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2025 By 攀</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>