<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实现Spring框架中的IOC和AOP</title>
      <link href="/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/"/>
      <url>/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/</url>
      
        <content type="html"><![CDATA[<p><a name="Bk5lF"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a><br /></h1><p><a name="vHThd"></a></p><h1 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h1><p><a name="GCsad"></a></p><h2 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h2><p>我们知道Java 是一门面向对象的语言，在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586204787-8e47e2aa-7ad0-4df8-8c02-ab5b48ccf51b.png#averageHue=%23fcfcfc&clientId=u426a4097-24c8-4&from=paste&height=271&id=u2625783a&name=image.png&originHeight=406&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62561&status=done&style=none&taskId=u59dd5fa3-6a83-4d1d-a27d-f26295c1a96&title=&width=388" alt="image.png"></p><p>这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586265815-d527e12e-f00d-495f-ae51-7e3e8d3cdf8e.png#averageHue=%23fdfdfd&clientId=u426a4097-24c8-4&from=paste&height=265&id=ud4222345&name=image.png&originHeight=398&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48632&status=done&style=none&taskId=u1d036425-b7d4-4fd4-94b3-985ef332386&title=&width=400.6666666666667" alt="image.png"></p><p>这个时候我们发现，我们类之间的关系都由 IoC 框架负责维护类，同时将类注入到需要的类中。也就是类的使用者只负责使用，而不负责维护。把专业的事情交给专业的框架来完成。大大的减少开发的复杂度。<br><a name="KMNbL"></a></p><h2 id="IOC的实现步骤"><a href="#IOC的实现步骤" class="headerlink" title="IOC的实现步骤"></a>IOC的实现步骤</h2><ol><li>初始化 IoC 容器。</li><li>读取配置文件。</li><li>将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition</li><li>利用数据结构依次实例化相应的对象</li><li>注入对象之间的依赖关系</li></ol><p><a name="iZZUZ"></a></p><h2 id="bean-定义了框架的数据结构"><a href="#bean-定义了框架的数据结构" class="headerlink" title="bean 定义了框架的数据结构"></a>bean 定义了框架的数据结构</h2><p>定义了bean的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] interfaceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;PropertyArg&gt; propertyArgs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了对象的 name，class的名称。如果是接口的实现，还有该对象实现的接口。以及构造函数的传参的列表 constructorArgs 和需要注入的参数列表 propertyArgs</p><p><a name="rgpUm"></a></p><h2 id="Utils工具包"><a href="#Utils工具包" class="headerlink" title="Utils工具包"></a>Utils工具包</h2><p><a name="pETF3"></a></p><h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefultClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefultClassLoader().loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ClassUtils，提供了两个静态方法：</p><ol><li>getDefultClassLoader() 方法返回当前线程的上下文类加载器（Context Class Loader）；</li><li>loadClass(String className) 方法用于根据类名加载对应的 Class 对象，首先调用 getDefultClassLoader() 方法获取默认的类加载器，然后使用该类加载器加载指定的类。如果指定的类名不存在，该方法将会打印异常栈信息，并返回 null。</li></ol><p>这个工具类可以方便地加载任何类，尤其在使用反射技术时非常有用，因为你可以通过类名动态地获取 Class 对象。同时，由于使用了线程的上下文类加载器，也可以避免一些类加载器隔离的问题。<br><a name="Hd0uf"></a></p><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instanceByCglib</span><span class="params">(Class&lt;T&gt; clz,Constructor ctr,Object[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clz);</span><br><span class="line">        enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ctr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create(ctr.getParameterTypes(),args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 BeanUtils，提供了一个静态方法 instanceByCglib，用于创建对象。具体而言：</p><ol><li>Class<T> 参数表示要创建的对象的类；</li><li>Constructor 参数表示要使用的构造方法，可以为 null；</li><li>Object[] 参数表示构造方法的参数数组，如果 Constructor 参数为 null，则此参数也应为 null。</li></ol><p>该方法使用 CGLIB 库创建对象。首先创建一个 Enhancer 对象，并设置其父类为 clz，然后设置回调为 NoOp.INSTANCE，这意味着创建的对象不会被代理。如果 ctr 为 null，则直接通过 enhancer.create() 创建对象，否则通过 enhancer.create(ctr.getParameterTypes(), args) 使用指定的构造方法创建对象。</p><p>CGLIB 是一个基于 ASM 库的代码生成库，可以用于创建动态代理、增强类等。在本代码中，CGLIB 用于创建对象并调用构造方法。这种方式相对于使用 new 运算符创建对象，具有更高的灵活性和动态性。</p><p><a name="Ts732"></a></p><h4 id="用法举例：AOP"><a href="#用法举例：AOP" class="headerlink" title="用法举例：AOP"></a>用法举例：AOP</h4><p>这个也是aop的用法<br />在cglib包下，Enhancer这个类的作用是为指定的类创建代理类。具体来说，Enhancer类可以动态地生成一个指定类的子类，该子类可以用来拦截指定类中的方法调用，从而实现代理模式。<br />Enhancer类的使用方法类似于Java动态代理中的Proxy类。首先，需要创建一个Enhancer对象，并设置要代理的目标类和回调方法。然后，通过调用Enhancer对象的create方法，生成代理类的实例。这个代理类会继承目标类，同时实现回调方法，从而实现对目标类方法的拦截和处理。<br />Enhancer类的使用比较灵活，可以代理任意的类，包括没有实现任何接口的类。但是，由于Enhancer是通过生成目标类的子类来实现代理的，所以目标类必须有默认的构造函数，并且不能是final类。<br />假设我们有一个简单的UserService接口，其中定义了一个getUser方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想为该接口创建一个代理类，记录getUser方法的调用次数。我们可以使用cglib的Enhancer类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceProxy(target));</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getUser"</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个UserServiceProxy类，它实现了MethodInterceptor接口，用于拦截目标对象的方法调用。在构造方法中，我们传入了目标对象target，并使用Enhancer类生成一个UserService的代理对象。在intercept方法中，我们记录了getUser方法的调用次数，并使用MethodProxy类来调用目标对象的对应方法。<br />接下来，我们可以使用该代理类来调用getUser方法，并检查调用次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = UserServiceProxy.createProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">userService.getUser(<span class="number">1</span>);</span><br><span class="line">userService.getUser(<span class="number">2</span>);</span><br><span class="line">System.out.println(userService.getCount()); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们首先使用createProxy方法创建了UserService的代理对象，并调用了getUser方法两次。最后，我们打印了代理对象的调用次数，发现它的确记录了两次getUser方法的调用。<br /><strong>它为什么要这么做呢，直接new难道不行吗？</strong><br />使用代理模式的一个主要目的是在不改变原有代码的情况下，为现有对象添加额外的行为或功能。在上面的例子中，我们通过使用cglib的Enhancer类创建了一个代理对象，使得我们可以在不修改原有UserServiceImpl类的情况下，为getUser方法添加了记录调用次数的功能。<br />如果直接new一个新的对象，虽然可以实现类似的功能，但是需要对原有代码进行修改，将原有的对象替换成新的对象，这样就不太符合“开闭原则”，即对扩展开放，对修改关闭的设计原则。同时，在某些情况下，我们可能无法直接访问到原有对象的构造函数，这就导致了不能直接创建新对象的限制。<br />使用代理模式，可以通过创建代理对象来扩展原有对象的行为，而不需要修改原有对象的代码。同时，代理对象还可以在原有对象的基础上增加额外的行为，提高代码的可扩展性和可维护性。</p><p><a name="uyyXf"></a></p><h3 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectField</span><span class="params">(Field field,Object obj,Object value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ReflectionUtils，提供了一个静态方法 injectField，用于设置某个对象的属性值。具体而言：</p><ol><li>Field 参数表示要设置的属性的字段；</li><li>Object 参数表示要设置属性值的对象；</li><li>Object 参数表示要设置的属性值。</li></ol><p>该方法首先判断 field 是否为空，如果不为空则将其设置为可访问，然后使用 field.set(obj, value) 方法设置对象的属性值。如果属性为 final 修饰的静态变量，则此方法将无法修改其值。</p><p>这个工具类可以方便地在代码中设置对象的属性值，尤其在使用反射技术时非常有用，因为你可以通过反射动态修改对象的属性。但是，使用反射技术也有一些缺点，例如性能较低、容易引起安全问题等，需要谨慎使用。<br><a name="UZCBE"></a></p><h3 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a>JsonUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*JsonUtils 的作用就是为了解析我们的json配置文件。代码比较长，与我们的 IoC 原理关系不大*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is,Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is,cls);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">writeValue</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] writeByteValue(Object entity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsBytes(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line">        mapper.getDeserializationConfig().withoutFeatures(<span class="keyword">new</span> DeserializationFeature[]&#123;DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES&#125;);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_YAML_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类，封装了基于Jackson库的Json序列化和反序列化功能。具体作用如下：</p><ul><li>定义了一个ObjectMapper对象，用于将Java对象转化为JSON格式，或将JSON格式转化为Java对象。</li><li>提供了多个readValue()和writeValue()方法，用于不同类型之间的转化。其中，readValue()方法支持将JSON格式的字符串、输入流或字节数组反序列化成Java对象，而writeValue()方法则将Java对象序列化成JSON格式的字符串或字节数组。</li><li>设置了一些序列化和反序列化的配置，如格式化输出、忽略空值、支持单引号、允许注释等。</li><li>如果反序列化失败，则返回null</li></ul><p><a name="fz6Ke"></a></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>先定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有对应的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryImpl</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefineMap= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//查找对象是否已经实例化过</span></span><br><span class="line">        Object bean = beanMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环依赖问题</span></span><br><span class="line">        Object earlyBean = earlySingletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span> (earlyBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生了循环依赖，提前返回尚未加载完成的bean:"</span> + name);</span><br><span class="line">            <span class="keyword">return</span> earlyBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有实例化，那就需要调用createBean来创建对象</span></span><br><span class="line">        BeanDefinition beanDefinition = beanDefineMap.get(name);</span><br><span class="line">        bean = createBean(beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为了解决循环依赖，先添加到早期单例中</span></span><br><span class="line">            earlySingletonObjects.put(name, bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对象创建成功以后，注入对象需要的参数</span></span><br><span class="line">            populateBean(bean,beanDefinition);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再吧对象存入Map中方便下次使用。</span></span><br><span class="line">            beanMap.put(name,bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从早期单例Map中移除</span></span><br><span class="line">            earlySingletonObjects.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束返回</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, BeanDefinition bd)</span></span>&#123;</span><br><span class="line">        beanDefineMap.put(name,bd);</span><br><span class="line">        beanNameSet.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String beanName = beanDefinition.getClassName();</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        Class&lt;?&gt; clz = ClassUtils.loadClass(beanName);</span><br><span class="line">        <span class="keyword">if</span>(clz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"can not find bean by beanName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取构造器参数</span></span><br><span class="line">        List&lt;ConstructorArg&gt; constructorArgs = beanDefinition.getConstructorArgs();</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty())&#123;</span><br><span class="line">            List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConstructorArg constructorArg : constructorArgs) &#123;</span><br><span class="line">                <span class="comment">//放入Map</span></span><br><span class="line">                objects.add(getBean(constructorArg.getRef()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,clz.getConstructor(),objects.toArray());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(Object bean, BeanDefinition bd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;PropertyArg&gt; propertyArgs = bd.getPropertyArgs();</span><br><span class="line">        <span class="keyword">if</span> (propertyArgs != <span class="keyword">null</span> &amp;&amp; !propertyArgs.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历在json中配置的属性</span></span><br><span class="line">            <span class="keyword">for</span> (PropertyArg arg : propertyArgs) &#123;</span><br><span class="line">                String propertyName = arg.getName();</span><br><span class="line">                String value = arg.getValue();</span><br><span class="line">                String ref = arg.getRef();</span><br><span class="line">                Object injectValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接赋值</span></span><br><span class="line">                    injectValue = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(ref)) &#123;</span><br><span class="line">                    <span class="comment">//获取bean</span></span><br><span class="line">                    injectValue = getBean(ref);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">                method.invoke(bean, injectValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取具体某个属性的setter方法</span></span><br><span class="line"><span class="comment">     * 此处做法比较简单粗暴</span></span><br><span class="line"><span class="comment">     * 实际上Spring在读取配置文件时就已经将各属性，方法，getter/setter都读取好了。</span></span><br><span class="line"><span class="comment">     * 在这就只需要调用BeanWrapper的方法来为属性赋值就可以了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getPropertySetter</span><span class="params">(BeanDefinition bd, String propertyName, Object injectValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = Class.forName(bd.getClassName());</span><br><span class="line">        Class&lt;?&gt; injectClazz = injectValue.getClass();</span><br><span class="line">        Class&lt;?&gt; supClass = injectValue.getClass().getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (supClass != <span class="keyword">null</span> &amp;&amp; supClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            injectClazz = supClass;</span><br><span class="line">        &#125;</span><br><span class="line">        propertyName = propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">        Method setter = beanClass.getMethod(<span class="string">"set"</span> + propertyName, injectClazz);</span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了一个简单的Bean工厂，主要功能是通过Bean的名字获取Bean的实例，实现了Bean的创建、注入属性和循环依赖的处理。</p><p>其中，BeanFactoryImpl类实现了BeanFactory接口，定义了三个ConcurrentHashMap类型的变量，分别用来存储Bean实例、Bean定义和Bean名称集合。它还包含了一个earlySingletonObjects成员变量，用来处理循环依赖的问题。</p><p><a name="TT8Dj"></a></p><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><p>getBean 方法是 Spring 框架中的一个核心方法，用于从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例。该方法接收一个参数 name，表示需要获取的 Bean 的名称。该方法会根据给定的名称先在 BeanFactory 中查找是否已经有该名称对应的 Bean 实例，如果没有找到，则尝试创建一个新的实例并将其注册到 BeanFactory 中。<br />在实现类 BeanFactoryImpl 中，该方法会先从 beanMap 中查找是否已经有该名称对应的 Bean 实例，如果找到了则直接返回该实例。如果没有找到，则需要通过 createBean 方法创建一个新的实例。在创建实例之前，该方法会检查 earlySingletonObjects 中是否已经有该名称对应的早期单例对象，如果有则说明存在循环依赖的问题，此时会返回早期单例对象，避免出现死锁的情况。<br />getBean 方法会调用 createBean 方法创建 Bean 实例，然后调用 populateBean 方法为实例注入需要的属性。在注入属性之后，该方法会将创建好的 Bean 实例注册到 beanMap 中，以备下次获取时直接返回。<br />总之，getBean 方法的作用是从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例，如果找不到则创建一个新的实例，并且可以解决循环依赖的问题。<br><a name="qkBoo"></a></p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>createBean 方法的作用是通过传入的 BeanDefinition 对象，使用反射来实例化一个 Java 对象，并返回该对象的实例。该方法首先通过 BeanDefinition 对象中的类名获取该类的 Class 对象，然后根据该对象获取相应的构造函数，如果有构造函数的参数，则递归调用 getBean 方法获取构造函数的参数，最后使用 CGLIB 库的 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果构造函数没有参数，则直接使用 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果获取 Class 对象失败，会抛出异常。<br><a name="kaiGR"></a></p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>populateBean方法的作用是为一个JavaBean对象注入它所依赖的其他对象或属性，这些对象或属性在BeanDefinition中被定义，并且在配置文件中被配置好。populateBean方法会根据BeanDefinition中的属性列表，将对应的属性值设置到JavaBean对象中。属性的值可能是简单类型的值，也可能是其他JavaBean对象的引用。<br />具体而言，populateBean方法会遍历BeanDefinition中的属性列表，对于每一个属性，它会根据属性的名称、值或引用，找到JavaBean对象中对应的setter方法，然后调用该方法将属性值设置到JavaBean对象中。需要注意的是，setter方法的名称是根据属性名生成的，例如，如果属性名是foo，那么setter方法的名称就是setFoo。<br />populateBean方法的实现比较简单粗暴，实际上，Spring框架在读取配置文件时已经将各属性、方法、getter/setter都读取好了，并且使用了更加高效和灵活的方式来为JavaBean对象注入属性值。</p><p>这两行代码的作用是为一个Java Bean对象的属性赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">method.invoke(bean, injectValue);</span><br></pre></td></tr></table></figure><p>第一行代码使用getPropertySetter方法获取一个指定属性的Setter方法。getPropertySetter方法根据属性名称、注入值类型和Bean定义，动态地获取该属性的Setter方法。这里使用反射机制，构造出要调用的方法，以便在第二行代码中使用。<br />第二行代码使用反射机制调用Java Bean对象的Setter方法，并把该属性的值作为参数传入。这里的bean是要赋值的Java Bean对象，injectValue是要注入的值。<br><a name="E6WQy"></a></p><h3 id="getPropertySetter"><a href="#getPropertySetter" class="headerlink" title="getPropertySetter"></a>getPropertySetter</h3><p>getPropertySetter方法的作用是根据传入的BeanDefinition、属性名和属性值，获取对应的setter方法，并返回该方法。在populateBean方法中，会根据BeanDefinition中配置的属性名、属性值以及对应的setter方法，将属性值设置到对象中，实现对对象属性的注入。getPropertySetter方法通过反射获取类的setter方法，并根据属性值的类型确定setter方法的参数类型，最终返回setter方法，供populateBean方法调用。<br><a name="ptLbT"></a></p><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>这段代码实现了一个简单的 Bean 工厂。主要功能包括：</p><ol><li>实现了 BeanFactory 接口，提供了 getBean() 方法来获取指定名称的 Bean 实例。</li><li>实现了注册 BeanDefinition 的方法 registerBean()，用来将 BeanDefinition 存储到 Map 中。</li><li>使用 ConcurrentHashMap 来存储 Bean 实例对象和 BeanDefinition 对象。</li><li>支持循环依赖。通过使用 ConcurrentHashMap 存储早期的 Bean 实例对象，解决了循环依赖问题。</li><li>支持注入属性。通过在 BeanDefinition 中配置 PropertyArg 属性参数列表，来对 Bean 实例对象进行属性注入。</li><li>支持构造器注入。通过在 BeanDefinition 中配置 ConstructorArg 构造器参数列表，来对 Bean 实例对象进行构造器注入。</li><li>支持通过反射创建 Bean 实例对象，使用 CGLib 动态代理技术生成代理对象。</li></ol><p>总体来说，这段代码实现了一个简单的 IoC 容器，能够解决基本的 Bean 创建、管理和依赖注入的问题。但是这个容器还有一些限制，例如只支持单例模式、只支持 setter 注入、只能通过 BeanDefinition 来配置 Bean 等等。真正的 IoC 容器，例如 Spring，还有更多更复杂的功能和特性。</p><p><a name="zPI4R"></a></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        loadFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = JsonUtils.readValue(is,<span class="keyword">new</span> TypeReference&lt;List&lt;BeanDefinition&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(beanDefinitions != <span class="keyword">null</span> &amp;&amp; !beanDefinitions.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">                registerBean(beanDefinition.getName(), beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为JsonApplicationContext的类，继承了BeanFactoryImpl类。JsonApplicationContext类的作用是通过从Json文件中读取bean定义来初始化IoC容器。它包含了一个构造方法和两个私有方法：init()和loadFile()。<br />构造方法JsonApplicationContext(String fileName)接收Json文件的名称，并将其存储在fileName变量中。<br />方法init()用于初始化IoC容器，它调用了loadFile()方法从Json文件中加载bean定义。<br />方法loadFile()用于加载Json文件并注册bean定义到IoC容器中。它首先通过当前线程的类加载器获取Json文件的输入流，然后通过JsonUtils.readValue()方法将输入流转换成BeanDefinition对象列表。最后，它遍历BeanDefinition列表，并调用registerBean()方法注册bean定义到IoC容器中。<br />总之，这段代码是一个简单的IoC容器实现，它可以从Json文件中读取bean定义，并将其注册到容器中，以供应用程序使用。<br><a name="ADAO4"></a></p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679590784248-a8543b7e-dd3d-46b8-abdd-300c77964292.png#averageHue=%23f5f3f2&clientId=u426a4097-24c8-4&from=paste&height=209&id=u14ed6355&name=image.png&originHeight=313&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27393&status=done&style=none&taskId=u042025fc-fe77-4110-8479-550549e9f78&title=&width=651.3333333333334" alt="image.png"></p><p><a name="P6I4h"></a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br /></h2><p><a name="fFT0I"></a></p><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><br /></h1><p><a name="xvv2L"></a></p><h1 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h1><p><a name="lvOkY"></a></p><h2 id="Aop-是什么"><a href="#Aop-是什么" class="headerlink" title="Aop 是什么"></a>Aop 是什么</h2><p>面向切面的程序设计（aspect-oriented programming，AOP）。通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。</p><p><a name="rbIL5"></a></p><h2 id="为什么需要使用Aop"><a href="#为什么需要使用Aop" class="headerlink" title="为什么需要使用Aop"></a>为什么需要使用Aop</h2><p>面向切面编程，实际上就是通过预编译或者动态代理技术在不修改源代码的情况下给原来的程序统一添加功能的一种技术。我们看几个关键词，第一个是“动态代理技术”，这个就是Spring Aop实现底层技术。第二个“不修改源代码”，这个就是Aop最关键的地方，也就是我们平时所说的非入侵性。。第三个“添加功能”，不改变原有的源代码，为程序添加功能。</p><p>举个例子：如果某天你需要统计若干方法的执行时间，如果不是用Aop技术，你要做的就是为每一个方法开始的时候获取一个开始时间，在方法结束的时候获取结束时间。二者之差就是方法的执行时间。如果对每一个需要统计的方法都做如上的操作，那代码简直就是灾难。如果我们使用Aop技术，在不修改代码的情况下，添加一个统计方法执行时间的切面。代码就变得十分优雅。具体这个切面怎么实现？<br />Spring Aop实现的代码非常非常的绕。也就是说 Spring 为了灵活做了非常深层次的抽象。同时 Spring为了兼容 @AspectJ 的Aop协议，使用了很多 Adapter （适配器）模式又进一步的增加了代码的复杂程度。<br />Spring 的 Aop 实现主要以下几个步骤：</p><ol><li>初始化 Aop 容器。</li><li>读取配置文件。</li><li>将配置文件装换为 Aop 能够识别的数据结构 – Advisor。这里展开讲一讲这个advisor。Advisor对象中包又含了两个重要的数据结构，一个是 Advice，一个是 Pointcut。Advice的作用就是描述一个切面的行为，pointcut描述的是切面的位置。两个数据结的组合就是”在哪里，干什么“。这样 Advisor 就包含了”在哪里干什么“的信息，就能够全面的描述切面了。</li><li>Spring 将这个 Advisor 转换成自己能够识别的数据结构 – AdvicedSupport。Spirng 动态的将这些方法拦截器织入到对应的方法。</li><li>生成动态代理代理。</li><li>提供调用，在使用的时候，调用方调用的就是代理方法。也就是已经织入了增强方法的方法</li></ol><p><a name="acqJR"></a></p><h2 id="Invocation"><a href="#Invocation" class="headerlink" title="Invocation"></a>Invocation</h2><p>先定义好方法调用接口和代理方法调用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] getArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理方法的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyMethodInvocation</span> <span class="keyword">extends</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="AkGkM"></a></p><h3 id="CglibMethodInvocation"><a href="#CglibMethodInvocation" class="headerlink" title="CglibMethodInvocation"></a>CglibMethodInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title">ReflectioveMethodeInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibMethodInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(proxy, target, method, arguments, interceptorList);</span><br><span class="line">        <span class="keyword">this</span>.methodProxy = methodProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是定义了一个基于CGLIB动态代理的方法调用类CglibMethodInvocation，它继承了ReflectiveMethodeInvocation类，其中包含了目标对象、目标方法、方法参数以及一组方法拦截器，它们一起构成了一个完整的方法调用链。CglibMethodInvocation在父类的基础上增加了一个MethodProxy类型的属性methodProxy，并重写了invokeOriginal()方法，该方法使用methodProxy对象调用目标方法，实现了方法的调用。该类主要在AOP中使用，用于执行目标方法，并将方法拦截器应用于目标方法之前或之后的操作。</p><p><a name="G0Nbp"></a></p><h3 id="ReflectioveMethodeInvocation"><a href="#ReflectioveMethodeInvocation" class="headerlink" title="ReflectioveMethodeInvocation"></a>ReflectioveMethodeInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectioveMethodeInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectioveMethodeInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] arguments = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行完所有的拦截器后，执行目标方法</span></span><br><span class="line">        <span class="keyword">if</span>(currentInterceptorIndex == <span class="keyword">this</span>.interceptorList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeOriginal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代的执行拦截器。回顾上面的讲解，我们实现的拦击都会执行 im.proceed() 实际上就在调用这个方法。</span></span><br><span class="line">        AopMethodInterceptor interceptor = interceptorList.get(++currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invokeMethodUseReflection(target,method,arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基础的反射方法调用的实现类 ReflectiveMethodInvocation，实现了 ProxyMethodInvocation 接口。在 Spring 的 AOP 中，每个被拦截的方法都会被包装成一个 MethodInvocation，这个包装类里包含了目标对象、方法、参数等信息，并提供了一个 proceed 方法用来执行下一个拦截器或目标方法。</p><p>ReflectiveMethodInvocation 中的 proceed 方法主要用于按照拦截器链依次执行 AopMethodInterceptor 的拦截逻辑。如果拦截器都执行完成，最后就会调用 invokeOriginal 方法来执行目标方法。另外，这个类也提供了获取代理对象、获取方法、获取参数等方法。</p><p><a name="osu7V"></a></p><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeMethodAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeforeMethodAdvice advice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeforeMethodAdviceInterceptor</span><span class="params">(BeforeMethodAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        advice.before(mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterRunningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AfterRunningAdvice advice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterRunningAdviceInterceptor</span><span class="params">(AfterRunningAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnVal = mi.proceed();</span><br><span class="line">        advice.after(returnVal,mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <strong>mi.proceed()</strong>才是执行原有的方法。而advice我们上文就说过，是描述增强的方法”干什么“的数据结构，所以对于这个before拦截器，我们就把advice对应的增强方法放在了真正执行的方法前面。而对于after拦截器而言，就放在了真正执行的方法后面。<br />这里主要是定义拦截器，一个before，一个after。<br><a name="Kqika"></a></p><h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//干什么</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line">    <span class="comment">//在哪里</span></span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AopMethodInterceptor&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptor</span><span class="params">(AopMethodInterceptor interceptor)</span></span>&#123;</span><br><span class="line">        list.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptors</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptors)</span></span>&#123;</span><br><span class="line">        list.addAll(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个AdvisedSupport就是我们Aop框架能够理解的数据结构，这个时候问题就变成了<strong>对于哪个目标，增加哪些拦截器</strong>。这里的AopMethodInterceptor 是一个接口，before拦截器和after拦截器都实现了这个接口。都能够使用这个功能。<br><a name="a0X2d"></a></p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p><a name="yJ9IG"></a></p><h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] constructorArgTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; rootClass = advised.getTargetSource().getTagetClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)&#123;</span><br><span class="line">            classLoader = ClassUtils.getDefultClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(rootClass.getSuperclass());</span><br><span class="line">        <span class="comment">//增加拦截器的核心方法</span></span><br><span class="line">        Callback callbacks = getCallBack(advised);</span><br><span class="line">        enhancer.setCallback(callbacks);</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; constructorArgs.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> enhancer.create(constructorArgTypes,constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Callback <span class="title">getCallBack</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是实现 Cglib AOP 代理的核心逻辑。其中 CglibAopProxy 类实现了 AopProxy 接口，用于创建代理对象，而 AdvisedSupport 是 AOP 配置信息的载体。<br />具体来说，getProxy() 方法返回代理对象，getProxy(ClassLoader classLoader) 方法返回通过指定类加载器加载的代理对象。在这两个方法中，通过使用 CGLIB 提供的 Enhancer 类，实现代理对象的创建和设置拦截器。<br />在 getCallBack(AdvisedSupport advised) 方法中，通过将 AdvisedSupport 中的拦截器链和目标对象传递给 DynamicAdvisedInterceptor，最终得到一个 Callback 对象，它是 Enhancer 的回调函数。<br />回到 getProxy() 和 getProxy(ClassLoader classLoader) 方法，它们的核心是通过 Enhancer 的 setSuperclass 方法，设置代理对象的父类，然后通过 setCallback 方法，将 Callback 对象设置为拦截器。<br />在这个过程中，如果 constructorArgs 不为空，则使用带参数的 enhancer.create 方法创建代理对象。否则，使用不带参数的 enhancer.create 方法创建代理对象。<br />最后，通过调用 enhancer.create 方法返回代理对象。<br />看看核心方法：<br>:::info<br>//增加拦截器的核心方法<br />Callback callbacks = getCallBack(advised);<br>:::</p><blockquote><p>private Callback getCallBack(AdvisedSupport advised) {<br />    return new DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());<br />}</p></blockquote><p><a name="xdGBY"></a></p><h3 id="DynamicAdvisedInterceptor"><a href="#DynamicAdvisedInterceptor" class="headerlink" title="DynamicAdvisedInterceptor"></a>DynamicAdvisedInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptorList, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">        <span class="keyword">this</span>.targetSource = targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了CGLib动态代理中的拦截器，它实现了MethodInterceptor接口。在intercept方法中，它接收了被代理的对象(obj)、目标方法(method)、方法参数(args)以及方法代理(proxy)，然后使用这些参数创建一个CglibMethodInvocation对象，然后调用该对象的proceed()方法，实现拦截器的链式执行。这个拦截器类将所有的AOP拦截器封装成了一个拦截器链，同时传入了目标对象的引用(TargetSource)，以便执行目标方法。在实际调用的时候，这个拦截器会按照拦截器列表依次调用所有的拦截器，并在最后调用目标方法，实现了AOP拦截器的动态织入。</p><p>而其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法正是：<strong>CglibMethodInvocation</strong></p><p><a name="IBgca"></a></p><h2 id="AopBeanFactoryImpl"><a href="#AopBeanFactoryImpl" class="headerlink" title="AopBeanFactoryImpl"></a>AopBeanFactoryImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopBeanFactoryImpl</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AopBeanDefinition&gt; aopBeanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; aopBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object aopBean = aopBeanMap.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBeanDefinitionMap.containsKey(name))&#123;</span><br><span class="line">            AopBeanDefinition aopBeanDefinition = aopBeanDefinitionMap.get(name);</span><br><span class="line">            AdvisedSupport advisedSupport = getAdvisedSupport(aopBeanDefinition);</span><br><span class="line">            aopBean = <span class="keyword">new</span> CglibAopProxy(advisedSupport).getProxy();</span><br><span class="line">            aopBeanMap.put(name,aopBean);</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, AopBeanDefinition aopBeanDefinition)</span></span>&#123;</span><br><span class="line">        aopBeanDefinitionMap.put(name,aopBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AdvisedSupport <span class="title">getAdvisedSupport</span><span class="params">(AopBeanDefinition aopBeanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        List&lt;String&gt; interceptorNames = aopBeanDefinition.getInterceptorNames();</span><br><span class="line">        <span class="keyword">if</span>(interceptorNames != <span class="keyword">null</span> &amp;&amp; !interceptorNames.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (String interceptorName : interceptorNames) &#123;</span><br><span class="line"></span><br><span class="line">                Advice advice = (Advice) getBean(interceptorName);</span><br><span class="line"></span><br><span class="line">                Advisor advisor = <span class="keyword">new</span> Advisor();</span><br><span class="line">                advisor.setAdvice(advice);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> BeforeMethodAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = BeforeMethodAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> AfterRunningAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = AfterRunningAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">new</span> TargetSource();</span><br><span class="line"></span><br><span class="line">        Object object = getBean(aopBeanDefinition.getTarget());</span><br><span class="line"></span><br><span class="line">        targetSource.setTagetClass(object.getClass());</span><br><span class="line">        targetSource.setTagetObject(object);</span><br><span class="line"></span><br><span class="line">        advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisedSupport;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个AOP Bean Factory，它是一个扩展了普通Bean Factory的类，用于创建和管理AOP bean。该类继承了BeanFactoryImpl，并重写了getBean方法，用于检查所请求的Bean是否已经是AOP bean，如果是则返回AOP bean。如果不是AOP bean，则继续通过调用父类的getBean方法获取普通bean。AopBeanFactoryImpl还有registerBean方法，用于将定义的AOP bean注册到AOP Bean Factory的aopBeanDefinitionMap中。</p><p>在getAdvisedSupport方法中，它会创建一个AdvisedSupport对象，将目标对象和增强器（Advice）封装到Advisor对象中，并根据Advice类型将它们转化为对应的AopMethodInterceptor对象，然后将所有的AopMethodInterceptor对象添加到AdvisedSupport对象中。最后将目标对象封装到TargetSource对象中，并设置到AdvisedSupport对象中。然后返回AdvisedSupport对象。</p><p>当getBean方法检测到所请求的Bean是AOP bean时，它会从aopBeanDefinitionMap中获取Bean的定义，并创建相应的AdvisedSupport对象。然后创建一个CglibAopProxy对象，并使用该对象创建代理对象，最后将代理对象添加到aopBeanMap中。最终返回代理对象。</p><p><a name="BIrI3"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a name="mlhhh"></a></p><h3 id="TestClass"><a href="#TestClass" class="headerlink" title="TestClass"></a>TestClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"开始计时"</span>);</span><br><span class="line">        ThreadLocalUtils.set(startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印随机数值: "</span>+ UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndTimeAfterMethod</span> <span class="keyword">implements</span> <span class="title">AfterRunningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">after</span><span class="params">(Object returnVal, Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> startTime = ThreadLocalUtils.get();</span><br><span class="line">        ThreadLocalUtils.remove();</span><br><span class="line">        System.out.println(<span class="string">"方法耗时："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a test method"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JGPr2"></a></p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"beforeMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"StartTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"processMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"ProcessTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"afterMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"EndTimeAfterMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"TestService"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testServiceProxy"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"core.ProxyFactoryBean"</span>,</span><br><span class="line">    <span class="attr">"target"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"interceptorNames"</span>:[</span><br><span class="line">      <span class="string">"beforeMethod"</span>,</span><br><span class="line">      <span class="string">"processMethod"</span>,</span><br><span class="line">      <span class="string">"afterMethod"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a name="Z3M5m"></a></p><h3 id="MainTest"><a href="#MainTest" class="headerlink" title="MainTest"></a>MainTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AopApplictionContext aopApplictionContext = <span class="keyword">new</span> AopApplictionContext(<span class="string">"application.json"</span>);</span><br><span class="line">        aopApplictionContext.init();</span><br><span class="line">        TestService testService = (TestService) aopApplictionContext.getBean(<span class="string">"testServiceProxy"</span>);</span><br><span class="line">        testService.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="hemjx"></a></p><h3 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679659265097-017a1abd-1cbb-4840-9849-5c67b070dbed.png#averageHue=%23f7f6f5&clientId=u4abc7da4-0982-4&from=paste&height=171&id=u5b9f1a31&name=image.png&originHeight=256&originWidth=1143&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18875&status=done&style=none&taskId=ue6550e3c-a161-4300-b134-338c0010524&title=&width=762" alt="image.png"></p><p><a name="FXW4m"></a></p><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><a name="SO1vU"></a></p><h2 id="Jdk动态代理和Cglib动态代理什么关系"><a href="#Jdk动态代理和Cglib动态代理什么关系" class="headerlink" title="Jdk动态代理和Cglib动态代理什么关系"></a>Jdk动态代理和Cglib动态代理什么关系</h2><p>JDK动态代理和Cglib动态代理是两种常用的Java动态代理方式，它们都是用于在运行时动态地创建代理对象，实现对目标对象的增强功能。<br />JDK动态代理是通过Java反射机制来实现的，它只能为接口创建代理对象，而无法为类创建代理对象。JDK动态代理通过实现目标对象所实现的接口，在运行时生成一个代理类，代理类中包含了目标对象的引用以及拦截器对象的引用，从而可以在调用代理对象的方法时，将方法调用转发给拦截器对象进行处理。<br />Cglib动态代理则是通过生成目标对象的子类来实现的，它可以为类创建代理对象。Cglib动态代理在运行时通过生成目标对象的子类，重写目标对象的方法，并将目标对象的引用注入到代理对象中。当调用代理对象的方法时，代理对象会先调用目标对象的方法，然后再调用拦截器对象的方法进行增强处理。<br />虽然JDK动态代理和Cglib动态代理实现方式不同，但它们都可以实现对目标对象的增强功能，常用于实现AOP（面向切面编程）功能。在实际开发中，根据需要选择不同的动态代理方式，如果目标对象实现了接口，则可以使用JDK动态代理；如果目标对象没有实现接口，则可以使用Cglib动态代理。</p><p><a name="qRBPD"></a></p><h3 id="那是不是Cglib效率更高？为什么还需要JDK动态代理-？"><a href="#那是不是Cglib效率更高？为什么还需要JDK动态代理-？" class="headerlink" title="那是不是Cglib效率更高？为什么还需要JDK动态代理 ？"></a>那是不是Cglib效率更高？为什么还需要JDK动态代理 ？</h3><p>一般情况下，使用CGLIB生成代理类的效率确实比使用JDK动态代理更高，因为CGLIB是通过在编译时生成字节码来实现代理的，相对于JDK动态代理而言，不需要在运行时动态生成代理类。因此，在需要频繁生成代理类的场景下，使用CGLIB可能更适合。</p><p>然而，需要注意的是，CGLIB生成的代理类通常比原始类的大小要大，且CGLIB代理使用了更多的内存，这在创建大量代理对象的场景下可能会成为性能瓶颈。此外，由于CGLIB使用了底层字节码操作库，因此在某些环境下可能存在兼容性问题，需要额外考虑。</p><p>因此，在选择代理方式时，需要考虑实际场景和需求，并根据具体情况选择合适的代理方式。如果需要生成大量代理对象，并且不考虑内存占用问题，CGLIB可能更适合；如果需要更轻量级的代理方式，或者需要支持多态性、继承等特性，则JDK动态代理可能更合适。</p><p><a name="iHnyN"></a></p><h2 id="AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别"><a href="#AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别" class="headerlink" title="(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别"></a>(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别</h2><p>假设我们有一个接口UserService和一个实现类UserServiceImpl，其中UserService提供了一个getUserById()方法用于获取用户信息。我们需要对getUserById()方法进行日志记录，以便监控用户信息查询情况。<br><a name="VA788"></a></p><h3 id="使用JDK动态代理实现AOP功能："><a href="#使用JDK动态代理实现AOP功能：" class="headerlink" title="使用JDK动态代理实现AOP功能："></a>使用JDK动态代理实现AOP功能：</h3><p>我们可以使用JDK动态代理来创建UserService接口的代理对象，并将一个实现了InvocationHandler接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的invoke()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class[]&#123;UserService.class&#125;, proxy);</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="uzJJw"></a></p><h3 id="使用Cglib动态代理实现AOP功能："><a href="#使用Cglib动态代理实现AOP功能：" class="headerlink" title="使用Cglib动态代理实现AOP功能："></a>使用Cglib动态代理实现AOP功能：</h3><p>我们可以使用Cglib动态代理来创建UserServiceImpl类的代理对象，并将一个实现了MethodInterceptor接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的intercept()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceInterceptor());</span><br><span class="line"></span><br><span class="line">        UserServiceImpl userServiceProxy = (UserServiceImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述示例代码可以看出，使用JDK动态代理时，需要创建一个实现了InvocationHandler接口的拦截器对象，并将其注入到代理对象中；而使用Cglib动态代理时，需要创建一个实现了MethodInterceptor接口的拦截器对象，并将其注入到代理对象中。在JDK动态代理中，代理对象必须实现目标对象所实现的接口；而在Cglib动态代理中，代理对象</p><p><a name="lHuvV"></a></p><h2 id="IOC-使用反射、JDK、Cglib去实现依赖注入的区别"><a href="#IOC-使用反射、JDK、Cglib去实现依赖注入的区别" class="headerlink" title="(IOC)使用反射、JDK、Cglib去实现依赖注入的区别"></a>(IOC)使用反射、JDK、Cglib去实现依赖注入的区别</h2><p><a name="MOXbp"></a></p><h3 id="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用Cglib和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"></a>只使用反射与使用Cglib和反射来完成依赖注入有什么区别？</h3><p>在Spring中，依赖注入可以通过只使用反射或使用Cglib和反射来完成。下面是它们之间的一些区别：</p><ol><li>实现方式：只使用反射时，Spring通过反射机制来动态创建对象并设置属性值。而使用Cglib和反射时，Spring通过Cglib在运行时动态创建代理类，并在代理类中使用反射来设置属性值。</li><li>性能：只使用反射时，每次获取Bean时都需要通过反射机制来动态创建对象和设置属性值，因此在性能上可能存在一定的开销。而使用Cglib和反射时，Spring可以在第一次获取Bean时创建代理类，并缓存代理类实例，之后每次获取Bean时都可以直接使用代理类，从而提高了性能。</li><li>功能扩展：只使用反射时，Spring的功能扩展比较有限，因为只能使用Java反射机制来动态创建对象和设置属性值。而使用Cglib和反射时，Spring可以通过Cglib来实现更多的功能扩展，比如实现AOP切面等。</li></ol><p>总的来说，只使用反射相对于使用Cglib和反射来完成依赖注入，性能可能会稍差一些，但是在一些场景下可能会更加灵活，因为不需要引入Cglib这样的第三方库。而使用Cglib和反射来完成依赖注入则能够更好地支持一些功能扩展，比如实现AOP切面等。</p><p>举一个简单的例子，假设有一个名为UserService的服务类，它依赖于名为UserDao的DAO类。下面是使用只使用反射和使用Cglib和反射来实现依赖注入的代码示例：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring会通过反射来动态创建UserService和UserDao对象，并在运行时调用setUserDao方法来设置依赖关系。</p><p>使用Cglib和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDaoInterceptor拦截器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法执行前做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"Before method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="comment">// 在方法执行后做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"After method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDaoProxy"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoProxy"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cglib.proxy.Enhancer"</span></span><br><span class="line">        factory-method=<span class="string">"create"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"interceptor"</span></span><br><span class="line">        ref=<span class="string">"userDaoInterceptor"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoInterceptor"</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDaoInterceptor"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring使用Cglib创建一个名为userDaoProxy的代理类，这个代理类继承自UserDao类，并在运行时动态生成。代理类中有一个拦截器UserDaoInterceptor，它会在UserDao类的方法执行前后做一些额外的处理，比如日志记录等。当Spring需要注入UserDao依赖时，会注入userDaoProxy代理类，代理类会使用反射来设置依赖关系。此外，当调用UserService的saveUser方法时，userDaoProxy代理类会通过反射调用UserDao的save方法，并在方法执行前后调用UserDaoInterceptor的相关方法。</p><p><a name="jlq4z"></a></p><h3 id="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"></a>只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？</h3><p>使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象。<br />举个例子，假设有一个UserService接口和UserService实现类，实现类需要注入一个UserDao对象。下面分别使用反射和JDK动态代理来完成依赖注入：<br />使用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            userDao = (UserDao) constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用Class.forName方法获取UserDaoImpl类的Class对象，然后使用反射获取构造函数，并创建UserDaoImpl对象。</p><p>使用JDK动态代理和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            Object dao = constructor.newInstance();</span><br><span class="line">            method.invoke(target, dao);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">this</span>);</span><br><span class="line">        ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">        userDao = (UserDao) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; UserDao<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">proxy</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个UserServiceProxy代理类，实现了InvocationHandler接口，并重写了invoke方法。在invoke方法中，如果是set方法，我们使用反射获取UserDaoImpl类的Class对象和构造函数，创建UserDaoImpl对象，并通过反射调用set方法来完成依赖注入。否则，我们通过反射调用目标对象的方法。</p><p>然后，在UserServiceImpl构造方法中，我们创建了UserServiceProxy代理对象，并使用Proxy.newProxyInstance方法创建了一个UserDao的代理对象。这个代理对象会拦截所有UserDao的方法调用，并通过InvocationHandler的invoke方法进行处理。</p><p>需要注意的是，由于代理对象实现了UserDao接口，因此在使用代理对象时，需要将其转换为UserDao类型。</p><p>总的来说，使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象，可以对其方法进行拦截和处理。</p><p><a name="j91gI"></a></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><a name="AQ3Uy"></a></p><h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3><p>Cglib是通过字节码生成技术来实现动态代理的，它会在运行时动态生成被代理类的子类，并在子类中覆盖被代理类的方法，从而实现方法拦截和增强。</p><p>在Spring中，当使用Cglib代理时，Spring会在运行时动态生成被代理类的子类，并在子类中实现依赖注入。Cglib会通过反射机制获取被代理类的构造函数和参数，然后通过Constructor.newInstance方法创建被代理类的实例。</p><p>具体来说，Spring会在运行时动态生成一个类，继承被代理类，并重写其中需要拦截和增强的方法。同时，它还会在生成的类中添加一个无参构造函数，并在其中通过反射机制实例化被代理类，并完成依赖注入。在这个过程中，Cglib会使用asm字节码操作库来生成字节码，完成类的定义和加载。</p><p>因此，使用Cglib代理时，它会通过字节码生成技术来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用JDK动态代理，不需要被代理类实现接口，可以拦截和增强非public方法，但是会比JDK动态代理更消耗内存和CPU资源。<br><a name="Mu6c3"></a></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过反射机制来实现动态代理的，它会在运行时动态生成一个实现了被代理接口的代理类，并在代理类中实现方法拦截和增强。</p><p>在Spring中，当使用JDK动态代理时，Spring会使用Java提供的Proxy类来生成代理类，并在代理类中实现依赖注入。具体来说，Spring会使用Proxy类的newProxyInstance方法来生成代理类，该方法需要传入一个ClassLoader对象、一组被代理的接口、和一个InvocationHandler对象。在生成代理类的过程中，JDK动态代理会通过反射机制获取被代理接口的方法，然后通过InvocationHandler对象的invoke方法来进行方法的拦截和增强。</p><p>因此，使用JDK动态代理时，它会通过反射机制来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用Cglib代理，需要被代理类实现接口，不能拦截和增强非public方法，但是会比Cglib代理更节省内存和CPU资源。<br><a name="UrKkw"></a></p><h3 id="Cglib相对于JDK动态代理"><a href="#Cglib相对于JDK动态代理" class="headerlink" title="Cglib相对于JDK动态代理"></a>Cglib相对于JDK动态代理</h3><p>Cglib相对于JDK动态代理来说，有以下两个方面的优势，导致它在一些情况下可能比JDK动态代理更快：</p><ol><li><p>Cglib代理不需要被代理类实现接口，可以拦截和增强非public方法，而JDK动态代理只能代理实现了接口的类。因此，在需要拦截非public方法的情况下，Cglib代理可能比JDK动态代理更适合。</p></li><li><p>在拦截方法调用的时候，Cglib代理不需要调用被代理类的方法，而JDK动态代理需要通过反射调用被代理类的方法。因此，在需要进行大量方法调用的情况下，Cglib代理可能比JDK动态代理更快。</p></li></ol><p>总的来说，Cglib代理和JDK动态代理各有优缺点，在具体的应用场景中需要根据实际情况选择合适的代理方式。</p><p><a name="aSPZk"></a></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><a name="eXFA4"></a></p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理是基于继承来实现代理，它会在运行时动态生成目标对象的子类，并在子类中重写目标对象的非final方法，从而实现对目标对象的代理。这个子类会被当作代理类，被加载到JVM中，并用来完成方法调用。</p><p>具体来说，Cglib会使用ASM等字节码操作库生成代理类的字节码，然后通过ClassLoader将其加载到JVM中。生成的代理类会继承目标对象的类，并重写目标对象的非final方法。在生成代理类后，Cglib会创建代理对象，这个代理对象实际上就是生成的代理类的实例。当代理对象调用目标对象的方法时，实际上是调用了生成的代理类中重写的方法，从而实现了代理的功能。</p><p>因此，Cglib生成的子类会替代原始的目标对象，成为代理对象的实现。这个子类重写了目标对象的方法，从而实现了对目标对象方法的增强和拦截。<br><a name="r0cru"></a></p><h3 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是基于接口来实现代理的，它会在运行时动态生成一个代理接口的代理类，并将这个代理类实例化成代理对象。这个代理类会实现目标对象实现的接口，并且会拦截所有接口中定义的方法调用。</p><p>具体来说，JDK动态代理会在运行时使用Java反射机制动态生成代理类的字节码，并将其加载到JVM中。生成的代理类会实现目标对象实现的接口，并在代理类中实现对目标对象方法的拦截和增强。当代理对象调用目标对象的方法时，实际上是通过反射机制调用了代理类中的方法，从而实现了代理的功能。</p><p>因此，JDK动态代理实现了对接口的代理，可以通过实现一个代理接口来实现代理功能，而且可以在运行时动态生成代理类，并将其加载到JVM中，实现了对目标对象的动态代理。同时，由于是基于接口来实现代理的，所以在类型上更加灵活，但也因为这个原因，只能代理实现了接口的类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于循环依赖的见解</title>
      <link href="/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h1 id="关于循环依赖的见解"><a href="#关于循环依赖的见解" class="headerlink" title="关于循环依赖的见解"></a>关于循环依赖的见解</h1><p>关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章（虽然很多是错误的）。</p><p>发现，<strong>其实二级缓存就能够解决循环依赖问题，根本不需要三级缓存</strong>。</p><p>首先，在单纯IOC的状态下，出现了循环依赖问题，在Bean不涉及代理对象的情况下，是只需要二级缓存的，但是很多文章说，因为涉及到AOP产生了代理对象，所以需要三级缓存，因为二级缓存和三级缓存存的对象不一样。但实际上，就算直接使用二级缓存，也是可以解决循环依赖问题，即使他们不一样。</p><p><strong>在任何状态下，二级缓存都能够完全的解决循环依赖问题，不管Bean有没有产生代理</strong>。</p><p>证明：(代补充)</p><p>但是Spring 为什么还是要使用三级缓存呢？因为设计者对于AOP一直都有一个原则：<strong>在对象初始化完毕后，再去创建代理对象</strong> </p><p>所以<strong>设计者一直在试图延迟代理对象的创建</strong>：</p><p>举例：</p><p>只有二级缓存：</p><p>1、发生了循环依赖，自然，在需要的时候就创建出来代理对象，放入缓存</p><p>2、没发生循环依赖，但是还是每一个对象在创建出原始对象后，就都会去创建代理对象</p><p>有三级缓存：</p><p>1、发生了循环依赖，在需要的时候就创建出来代理对象，放入二级缓存。</p><p>2、没发生循环依赖，正常的在初始化的后置处理器中创建。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Netty+Nacos+Protobuf制作RPC框架</title>
      <link href="/2022/11/02/srpc/"/>
      <url>/2022/11/02/srpc/</url>
      
        <content type="html"><![CDATA[<p><a name="ly3F9"></a></p><h1 id="使用Netty-Nacos-Protobuf制作RPC框架"><a href="#使用Netty-Nacos-Protobuf制作RPC框架" class="headerlink" title="使用Netty+Nacos+Protobuf制作RPC框架"></a>使用Netty+Nacos+Protobuf制作RPC框架</h1><p><a name="KeQ2k"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a name="FQTT2"></a></p><h3 id="显现的功能"><a href="#显现的功能" class="headerlink" title="显现的功能"></a>显现的功能</h3><p>这个RPC实现了一些基本的功能：</p><ul><li>使用Netty来进行网络传输，效率比起传统的NIO要高很多。</li><li>使用单例模式，在Netty获取Channel的过程中，会有一个ChannelProvider去提供Channel单例。</li><li>使用Nacos作为服务的注册中心，用于管理注册的服务，当客户端请求发过来时，Nacos会寻找合适的服务返回给客户端消费。</li><li>实现了负载均衡的功能，，客户端对于Nacos返回的服务列表，会使用负载均衡算法，选择一个自己需要的服务加入，目前实现了轮询算法和随机选取算法。</li><li>加入了心跳检测机制，并不会发送完消息立即结束，而是保持的长连接，提高效率。</li><li>使用Potobuf作为对象的的序列化工具，实现Netty中的编/解码的功能，提高了效率。</li><li>实现了钩子函数，当服务端下线的时候会自动去Nacos注销服务。</li><li>使用CompletableFuture来接受客户端返回的结果。</li></ul><p><a name="UlREa"></a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>由于使用Nacos，调试比较简单：<br />下载好Nacos，无论是win版还是linux版，在官网都有，比较方便；<br />但是由于Nacos一般都要配置数据库，为了方便测试，可以使用命令先进行单机运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">114514</span>, <span class="string">"Client send a Message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> NettyServer(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后会有一个测试结果：<br />客户端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513541152-f58818bf-b30d-438c-bebd-3374cb6f6b3f.png#averageHue=%23f5ecea&clientId=ucfcf756b-0ecd-4&from=paste&height=400&id=uc9973f1d&name=image.png&originHeight=600&originWidth=2205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111506&status=done&style=none&taskId=ubbd01eee-67bf-4697-b872-6eef4c3b304&title=&width=1470" alt="image.png"><br />服务端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513584290-393ae7f9-f650-4a6d-b6a2-ad58cd7c2360.png#averageHue=%23f5ebe9&clientId=ucfcf756b-0ecd-4&from=paste&height=301&id=u72da898a&name=image.png&originHeight=452&originWidth=2307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88585&status=done&style=none&taskId=u57f54541-d548-4720-aca7-051e4b65050&title=&width=1538" alt="image.png"></p><p><a name="VFwOu"></a></p><h2 id="服务端分析"><a href="#服务端分析" class="headerlink" title="服务端分析"></a>服务端分析</h2><p>首先服务端都会实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.PROTOBUF_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口通常定义了默认的序列化方法，开始方法，和发布服务的方法。<br />接着会有一个抽象类去实现这个接口：<br><a name="DbRAB"></a></p><h3 id="AbstractRpcServer"><a href="#AbstractRpcServer" class="headerlink" title="AbstractRpcServer"></a>AbstractRpcServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"启动类缺少 @ServiceScan 注解"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"出现未知错误"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service<span class="class">.<span class="keyword">class</span>).<span class="title">name</span>()</span>;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"创建 "</span> + clazz + <span class="string">" 时有错误发生"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">""</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    这段代码是在判断 Service 注解中的 name 属性是否为空，如果为空，</span></span><br><span class="line"><span class="comment">                    则说明该服务实现类实现了多个接口，并且需要将每个接口都发布成一个独立的服务。</span></span><br><span class="line"><span class="comment">                    所以，代码通过获取该服务实现类的所有接口，然后将每个接口都作为一个独立的服务进行发布。</span></span><br><span class="line"><span class="comment">                    如果 name 属性不为空，则说明只需要将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                    此时，代码直接将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanServices 的作用：这段代码是服务扫描的核心实现，它通过获取启动类的信息，获取服务扫描的基础包路径，然后扫描该路径下的所有类，判断是否有@Service注解，如果有，就将该服务发布到注册中心。<br />具体的实现流程如下：</p><ol><li>调用ReflectUtil.getStackTrace()方法获取当前方法调用的栈信息，得到启动类的全限定名。</li><li>使用Class.forName()方法加载启动类，判断启动类是否被@ServiceScan注解所标注，如果没有则抛出异常。</li><li>获取@ServiceScan注解的参数值，即基础包路径。</li><li>调用ReflectUtil.getClasses()方法获取指定包下的所有类，遍历这些类，判断是否被@Service注解所标注。</li><li>如果被@Service注解所标注，则获取@Service注解的参数值，即服务名称，如果未指定服务名称，则获取该服务实现类实现的所有接口，并将该服务发布到注册中心。</li><li>如果指定了服务名称，则直接将该服务发布到注册中心。</li></ol><p>该方法主要的功能就是扫描服务，将服务发布到注册中心，为后续的服务调用提供依据<br />接着我们来看看这个所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务扫描的基包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上述提到的ReflectUtil这个类是一个比较常见的类，这个类是一个工具类，提供了两个静态方法：getStackTrace(): 返回当前调用栈顶部的类名。利用Java的反射机制，调用 new Throwable().getStackTrace() 方法获取当前调用栈信息，返回调用栈顶部的类名。<br />getClasses(String packageName): 获取指定包名下所有的类。该方法通过输入一个包名，然后通过反射机制查找该包下的所有类，返回一个 Set&lt;Class&lt;?&gt;&gt; 对象。该方法实现的过程比较复杂，具体过程为：</p><ol><li>通过 Thread.currentThread().getContextClassLoader().getResources(packageDirName) 获取指定包名下的所有资源。</li><li>遍历所有资源，如果是文件，则通过递归方式查找该文件夹下所有的类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li><li>如果是 Jar 包，则通过 JarFile 对象查找该 Jar 包中的所有类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li></ol><p>该工具类可以用于类加载器等需要动态加载类的场景，例如 Spring 框架中的 Bean 加载、RPC 框架中的服务注册等</p><p><a name="azGEB"></a></p><h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><p>接着便是这个RPC服务端的逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同时也继承了serviceRegistry和serviceProvider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 256)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"启动服务器时有错误发生: "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类实现了一个基于Netty框架的RPC服务器，它继承了抽象类AbstractRpcServer，并且拥有服务注册表（serviceRegistry）和服务提供者（serviceProvider）的实例。<br />在构造函数中，传入了服务器的主机名和端口号，以及序列化器（serializer）。在构造函数中还调用了扫描服务的方法scanServices()。<br />在start()方法中，创建了两个EventLoopGroup，用于处理连接和IO的事件。然后使用ServerBootstrap创建了一个服务端的引导类，通过设置一系列的选项和处理器来配置Netty服务器。其中，ChannelInitializer是一个特殊的处理器，用于在Channel被创建时执行一些初始化操作。在这个ChannelInitializer中，注册了一个IdleStateHandler用于处理空闲连接，以及自定义的编解码器和处理器。<br />最后，通过调用bind()方法绑定主机名和端口号，并且调用sync()方法等待服务器启动完成。当关闭服务器时，调用shutdownGracefully()方法优雅地关闭EventLoopGroup。<br />这就是这个类的大体流程，接下来，可以一个个分开来看<br />其中，NacosServiceRegistry会返回一个服务注册器实例，但是这个实例实际上会调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"注册服务时有错误发生:"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是NacosUtil去实现服务注册：<br><a name="Q2Adh"></a></p><h4 id="NacosUtil"><a href="#NacosUtil" class="headerlink" title="NacosUtil"></a>NacosUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">"127.0.0.1:8848"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接到Nacos时有错误发生: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"注销服务 &#123;&#125; 失败"</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个Nacos工具类，用于连接到Nacos服务注册中心并与之进行交互。主要包含以下几个方法：</p><ol><li>getNacosNamingService()方法用于获取NacosNamingService实例。</li><li>registerService(String serviceName, InetSocketAddress address)方法用于向Nacos注册服务实例，即将提供服务的服务地址和端口注册到Nacos中，以便客户端可以通过服务名称查找到该服务。</li><li>getAllInstance(String serviceName)方法用于获取指定服务名称下的所有服务实例，返回一个Instance列表。</li><li>clearRegistry()方法用于清空注册中心中注册的服务实例，即将服务注销。</li></ol><p>通过这个工具类，我们可以将服务注册到Nacos服务注册中心，并通过Nacos中心来查找并获取服务实例，以便客户端可以通过服务名称调用相应的服务。<br><a name="wIRIl"></a></p><h4 id="ServiceProviderImpl"><a href="#ServiceProviderImpl" class="headerlink" title="ServiceProviderImpl"></a>ServiceProviderImpl</h4><p>而ServiceProviderImpl默认的服务注册表，保存服务端本地服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">"向接口: &#123;&#125; 注册服务: &#123;&#125;"</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个服务提供者的默认实现类，它实现了 ServiceProvider 接口中的方法，可以将提供者实例添加到服务注册表中，提供了一种方便地访问服务的方式。在服务注册表中，服务名与服务实例之间的映射关系是使用 ConcurrentHashMap 实现的。它有两个主要方法：</p><ol><li>addServiceProvider(T service, String serviceName)：将服务提供者添加到服务注册表中，当服务名已经存在于注册表中时，则不进行任何操作。</li><li>getServiceProvider(String serviceName)：根据服务名从服务注册表中获取相应的服务实例。如果服务不存在，则抛出 RpcException 异常，表示未找到服务。</li></ol><p><a name="RA6ZR"></a></p><h4 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h4><p>当一个服务开启之后，也会开始一个钩子函数，它的Runtime类会使用getRuntime().addShutdownHook()方法，在服务结束前，注销掉所有的在Nacos的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"关闭后将自动注销所有服务"</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个单例，它提供了一个静态方法getShutdownHook()来获取一个实例。它注册了一个JVM shutdown hook，该hook会在JVM关闭前被执行，清除所有注册到Nacos服务注册中心上的服务和所有线程池。这个类的作用是确保在JVM关闭前执行清除操作，避免可能的资源泄漏和数据一致性问题。</p><p><a name="klHf5"></a></p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>这里在SocketChannel中加入了一个IdleStateHandler，使其具有心跳检测功能<br />在 Netty 中，IdleStateHandler 是一个用于处理空闲状态的处理器。它可以在 Channel 上检测特定类型的空闲时间，并在这些时间段内未发生读取、写入或读写事件时触发相应的事件。常用的空闲状态类型有三种：READER_IDLE，WRITER_IDLE 和 ALL_IDLE。<br />IdleStateHandler 可以用于实现心跳机制，可以通过配置空闲时间间隔和触发事件来判断是否需要发送心跳包。它可以被添加到 Netty 的 ChannelPipeline 中，以监视 Channel 上的空闲事件，以便可以采取适当的措施，例如关闭连接或发送心跳消息。</p><p><a name="fWDhA"></a></p><h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><p>这里也同时添加了一个NettyServerHandler去处理在Channel中发生的时间。<br />先拿上面的心跳检测为例子，如果收到了一个心跳包，便会打印一条日志，告诉服务端收到了。而在长时间没有收到心跳包后，则会关闭上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">"接收到客户端心跳包..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"服务器接收到请求: &#123;&#125;"</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"通道不可写"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"处理过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"长时间未收到心跳包，断开连接..."</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleChannelInboundHandler 是 Netty 中的一个基础类，实现了 ChannelInboundHandler 接口。它主要用于处理入站事件，即从对等端接收到的数据或状态更改事件，例如对等端连接或断开连接。与 ChannelInboundHandlerAdapter 不同的是，SimpleChannelInboundHandler 可以自动释放资源，因此不需要显示地调用 ReferenceCountUtil.release() 释放资源。<br />当数据从远程节点传入时，SimpleChannelInboundHandler 将自动将其转换为指定类型的对象，并在调用 channelRead0() 方法时向你提供该对象，你只需要处理传入的数据。可以使用这个类来构建各种应用程序，例如聊天应用程序、游戏服务器、文件传输应用程序等。<br />而这里的requestHandler是一个单例，表示全程都使用这个单例去处理请求，这样就不会浪费大量的资源去重复创建实例。<br><a name="MTSdN"></a></p><h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">"服务:&#123;&#125; 成功调用方法:&#123;&#125;"</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个RequestHandler使用的方法不多，最为主要的方法还是：<br>:::info<br>result = method.invoke(service, rpcRequest.getParameters());<br>:::<br>这个方法会调用Method实例的invoke方法，去执行相应的请求。<br />在Java中，Method类是反射机制的一部分，它代表一个类中的一个方法。可以使用Method类来获取关于方法的信息，如方法名、参数列表、返回类型、修饰符等，并且可以使用Method类来调用该方法。Method类提供了许多用于获取和调用方法的方法，如invoke()、getName()、getParameterTypes()、getReturnType()等。反射机制中的Method类可以使得在运行时动态地获取和调用类中的方法。</p><p><a name="Le2TA"></a></p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器可以说是整个RPC框架中最为重要的一部分，那么RPC为什么需要编解码器呢？<br />因为在RPC通信过程中，数据需要在网络中传输。在不同的计算机之间通信需要将对象序列化为字节流，传输完成后再反序列化为对象。编解码器的作用就是将对象序列化和反序列化的过程封装起来，让开发者可以更方便地进行通信。在Netty中，SimpleChannelInboundHandler类可以自动完成消息的解码和编码，大大简化了编解码器的编写过程。<br />那为什么不用直接用序列化？<br />虽然序列化可以将对象转换成字节流进行网络传输，但是它并不能满足RPC的需求。<br />RPC需要一个通用的方式来序列化和反序列化各种类型的消息，包括基本数据类型、复合数据类型和自定义类型等。而不同的序列化实现可能只支持特定的类型或数据格式，因此无法满足这个需求。<br />此外，RPC需要支持不同的编解码器，以便兼容不同的协议和框架。使用编解码器可以使得不同的实现之间相互兼容，也方便进行协议升级和兼容性处理。<br />因此，编解码器是RPC中必不可少的组件，它能够实现通用的序列化和反序列化，同时兼容不同的协议和框架，满足RPC的需求。</p><p><a name="BVL84"></a></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>MessageToByteEncoder 是 Netty 提供的编码器抽象类，用于将消息转换为字节流进行网络传输。在 Netty 应用中，可以使用它将自定义的消息对象编码为二进制数据，以便通过网络进行传输。<br />实现 MessageToByteEncoder 需要重写 encode() 方法，该方法会在消息被写入通道前被自动调用。在 encode() 方法中，我们需要将消息对象转换为字节流，并将字节流写入到 ByteBuf 中。写入到 ByteBuf 中的字节流会在后续的 ChannelHandler 中被传递，最终通过网络传输到远程节点。<br />MessageToByteEncoder 中还提供了一些辅助方法，如 writeXXX() 系列方法可以将不同类型的数据写入到 ByteBuf 中，以及提供了一些钩子方法，可以在编码过程中对消息进行处理，比如对消息进行压缩、加密等操作。<br />总之，MessageToByteEncoder 是 Netty 提供的编码器抽象类，通过继承它可以实现自定义的消息编码器。<br />CommonEncoder继承了MessageToByteEncoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 Netty 中的编码器类，用于将消息对象转换为二进制字节流，以便在网络上进行传输。在 RPC 中，消息通常是由客户端和服务端之间相互传递的。因为在不同的机器之间传递数据时，需要将数据序列化为二进制流，才能在网络中传输。但是，不同的序列化方式可能具有不同的数据格式和协议，所以需要使用编解码器来统一数据格式和协议。这个类实现了 Netty 中的 MessageToByteEncoder 类，并将消息对象编码为二进制流，遵循了一个特定的协议，包括一个魔数、消息类型、序列化方式、消息长度和消息内容。其中，魔数用于识别协议版本，消息类型用于标识消息是请求还是响应，序列化方式用于指定消息内容的序列化方式，消息长度用于指定消息内容的长度，消息内容就是序列化后的消息体。这个类是 RPC 通信中必不可少的一部分。</p><p><a name="Mudkb"></a></p><h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>ReplayingDecoder是Netty提供的一种特殊类型的解码器。与普通解码器不同，ReplayingDecoder可以在缓冲区数据不足时进行暂停，并在数据可用时恢复处理，而不是等待缓冲区填满。<br />具体来说，ReplayingDecoder类通过继承ByteToMessageDecoder类并使用状态机模式实现。状态机模式通过在每个状态中重写decode()方法来定义不同的处理行为。当状态更改时，它将转移到下一个状态，直到解码完成为止。<br />ReplayingDecoder的主要作用是简化解码器的实现，尤其是对于一些不确定数据长度的解码器。通过使用ReplayingDecoder，可以避免手动跟踪缓冲区中的字节数，从而减少出错的可能性。同时，ReplayingDecoder还可以提供更好的性能，因为它只需要处理缓冲区中实际可用的数据，而不是缓冲区中的所有数据<br />CommonDecoder继承了ReplayingDecoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的协议包: &#123;&#125;"</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的数据包: &#123;&#125;"</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的反序列化器: &#123;&#125;"</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个Netty解码器，用于将字节流转换为对象。具体来说，它的作用是将从网络中接收到的字节流解码为指定的Java对象，以供后续处理。<br />在方法decode()中，它首先读取一个整数值，如果它不等于预定义的一个常量值，就会抛出一个RpcException异常，这表示该字节流不是正确的RPC协议包。接下来，它读取协议包类型和序列化器类型，并检查它们是否为预期值，否则将抛出异常。然后，它读取字节流的长度，并将剩余的字节读入到字节数组中。最后，它使用指定的序列化器将字节流反序列化为预期的Java对象，并将其添加到输出列表中</p><p><a name="y5CbI"></a></p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protocol Buffers（简称protobuf）是一种轻便高效的数据序列化格式，由Google开发。它与XML和JSON等格式相比，具有更小的数据体积和更快的解析速度，同时也可以生成各种编程语言的代码，从而方便了跨语言的数据交换和通信。在Java中，我们可以通过使用Protobuf库来实现Protobuf的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; schemaCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        Class clazz = obj.getClass();</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        Object obj = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">"PROTOBUF"</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Schema <span class="title">getSchema</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = schemaCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(schema)) &#123;</span><br><span class="line">            <span class="comment">// 这个schema通过RuntimeSchema进行懒创建并缓存</span></span><br><span class="line">            <span class="comment">// 所以可以一直调用RuntimeSchema.getSchema(),这个方法是线程安全的</span></span><br><span class="line">            schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(schema)) &#123;</span><br><span class="line">                schemaCache.put(clazz, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个实现了CommonSerializer接口的类，用于将Java对象序列化为Protobuf格式的字节数组，或者将字节数组反序列化为Java对象。<br />具体来说，该类中的serialize方法将一个Java对象序列化为Protobuf格式的字节数组，实现过程如下：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>使用该Schema对象和LinkedBuffer对象调用ProtostuffIOUtil.toByteArray方法将Java对象序列化为字节数组。</li><li>最后清空LinkedBuffer对象并返回序列化后的字节数组。</li></ol><p>而deserialize方法则是将字节数组反序列化为Java对象：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>调用schema.newMessage()创建一个该类的空对象。</li><li>使用字节数组和Schema对象调用ProtostuffIOUtil.mergeFrom方法将字节数组反序列化为Java对象并返回。</li></ol><p>同时，为了提高性能，该类中使用了缓存机制，通过ConcurrentHashMap缓存Schema对象，以便在下次序列化或反序列化时能够更快地获取Schema对象，避免了重复创建的开销。</p><p>在具体的分析下面类的作用：<br><a name="RoCQJ"></a></p><h4 id="LinkedBuffer"><a href="#LinkedBuffer" class="headerlink" title="LinkedBuffer"></a>LinkedBuffer</h4><p>LinkedBuffer是Protostuff序列化库中的一个类，用于在序列化过程中存储数据。它是一个基于链表的动态缓存区，它会自动根据当前写入数据的大小来调整缓存区的大小。<br />具体来说，LinkedBuffer维护了一个字节数组（即缓存区），一个指向缓存区首部的指针和一个指向缓存区尾部的指针。当我们往缓存区写入数据时，LinkedBuffer会先检查当前剩余的空间是否足够，如果不够则会自动扩展缓存区。扩展时会新建一个更大的缓存区，并将当前缓存区中的数据复制到新缓存区中，然后将新缓存区设置为当前缓存区。<br />LinkedBuffer使用链表来管理多个缓存区，每次扩展时都会新建一个缓存区并添加到链表尾部。这样做的好处是可以避免频繁的内存分配和拷贝，从而提高序列化性能。<br />在上面的代码中，LinkedBuffer被用于在ProtobufSerializer类中序列化对象时存储数据。当我们调用ProtostuffIOUtil.toByteArray()方法将一个对象序列化为字节数组时，需要传入一个LinkedBuffer对象作为参数，这个对象会在序列化过程中被自动扩展。当序列化完成后，我们需要手动调用LinkedBuffer.clear()方法清空缓存区，以便下次使用。<br><a name="I3nN9"></a></p><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>在 Protobuf 序列化中，Schema 是一个用于描述消息结构的类，类似于 Java 对象中的 Class。Schema 类的实例提供了一些方法来获取消息的字段和类型信息，从而可以将消息序列化和反序列化为二进制数据。<br />在使用 Protobuf 进行序列化时，我们需要为每个消息类创建一个 Schema 对象，并将其缓存起来以供重复使用。这样可以提高序列化和反序列化的效率，避免重复创建和解析 Schema 对象。<br />在上面提供的 ProtobufSerializer 类中，getSchema 方法用于获取指定类型的 Schema 对象。如果缓存中已经存在该类型的 Schema 对象，则直接返回；否则，使用 RuntimeSchema.getSchema 方法创建一个新的 Schema 对象，并将其存入缓存中。这样，在序列化和反序列化时，就可以直接使用缓存中的 Schema 对象，提高了性能。<br><a name="FAUkt"></a></p><h4 id="ProtostuffIOUtil"><a href="#ProtostuffIOUtil" class="headerlink" title="ProtostuffIOUtil"></a>ProtostuffIOUtil</h4><p>ProtostuffIOUtil是Protostuff序列化框架中的一个工具类，主要提供了将Java对象序列化成byte数组和将byte数组反序列化成Java对象的功能。<br />它提供了以下主要的静态方法：</p><ul><li>toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)：将一个Java对象序列化成byte数组。</li><li>fromByteArray(byte[] data, T message, Schema<T> schema)：将一个byte数组反序列化成Java对象。</li><li>mergeFrom(byte[] data, T message, Schema<T> schema)：将一个byte数组中的数据合并到一个Java对象中。</li></ul><p>其中，Schema是Protostuff序列化框架中的一个关键接口，用于描述Java对象的序列化格式。而LinkedBuffer则是一个可扩容的缓冲区，用于存储序列化后的数据。在使用Protostuff进行序列化时，可以通过LinkedBuffer.allocate()方法创建一个缓冲区，用于存储序列化后的数据。<br><a name="S4KTX"></a></p><h4 id="RuntimeSchema"><a href="#RuntimeSchema" class="headerlink" title="RuntimeSchema"></a>RuntimeSchema</h4><p>RuntimeSchema是Protostuff库的一个类，它提供了将Java类转换为Protobuf格式的Schema的功能。在使用Protobuf进行序列化和反序列化时，需要提供一个Schema来指定序列化的字段、类型等信息。RuntimeSchema的作用就是根据Java类的结构生成一个对应的Schema。<br />通常情况下，使用Protobuf进行序列化和反序列化时，需要手动定义一个Proto文件来描述消息的结构。而使用RuntimeSchema，可以将Java类当作Proto文件来使用，它会自动生成一个对应的Schema。<br />需要注意的是，由于RuntimeSchema是在运行时生成的，因此会对性能产生一定影响。在高性能场景中，建议使用预编译的Proto文件来进行序列化和反序列化。</p><p><a name="njTxV"></a></p><h2 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a>客户端分析</h2><p>要实现客户端的逻辑，最基本的就是要实现动态代理：<br />InvocationHandler 是 Java 标准库中的一个接口，它用于实现动态代理。<br />动态代理是一种运行时生成代理对象的技术。使用动态代理可以在运行时动态地创建一个实现特定接口的代理类，这个代理类可以将所有方法调用委托给指定的对象或方法。在委托调用前或调用后，代理类可以执行额外的逻辑，例如统计方法调用次数、记录方法调用日志等。<br />InvocationHandler 接口定义了一个方法 invoke，该方法会在代理类每次调用方法时被调用。该方法有三个参数：</p><ol><li>proxy：代理对象</li><li>method：被调用的方法</li><li>args：被调用方法的参数列表</li></ol><p>invoke 方法的返回值是 Object 类型，它表示被调用方法的返回值。因此，当我们想要使用动态代理技术时，需要实现 InvocationHandler 接口并重写 invoke 方法，来控制代理类如何处理方法调用<br><a name="mEV6K"></a></p><h3 id="RpcClientProxy"><a href="#RpcClientProxy" class="headerlink" title="RpcClientProxy"></a>RpcClientProxy</h3><p>RpcClientProxy 将实现 InvocationHandler 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用方法: &#123;&#125;#&#123;&#125;"</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"方法调用请求发送失败"</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个远程调用的客户端代理类RpcClientProxy，实现了InvocationHandler接口，用于生成一个远程服务接口的代理对象。其中，RpcClient是一个抽象类，NettyClient和SocketClient分别是其子类，用于不同的网络传输方式进行远程调用。<br />该类中的getProxy方法，使用了Java动态代理技术，生成了一个实现了远程服务接口的代理对象，该代理对象的所有方法调用都会被拦截并转化为远程调用，从而实现了RPC远程调用的透明化。<br />在invoke方法中，通过封装一个RpcRequest对象来表示对远程服务的调用，并通过客户端发送请求获取到返回结果RpcResponse，最后将返回结果中的数据返回给调用方。在发送远程调用请求之前，还进行了一些简单的参数检查，确保请求的正确性和完整性。<br><a name="Jo1Tm"></a></p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机轮询策略来进行负载均衡</span></span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//另一个构造方法，表示自定义负载均衡策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注入服务发现</span></span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="comment">//序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="comment">//保留意见</span></span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"未设置序列化器"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"客户端发送消息: %s"</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">"发送消息时有错误发生: "</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基于Netty的RPC客户端，实现了RpcClient接口，并且封装了发送请求的具体细节。<br />在类的静态代码块中，创建了一个EventLoopGroup和一个Bootstrap对象，用于配置Netty客户端。EventLoopGroup是处理事件循环的抽象类，Bootstrap则是用于客户端引导的类。在其中使用了NioEventLoopGroup和NioSocketChannel类来实现NIO客户端，这里用到了Netty的API。<br />接着在类的构造方法中，初始化了一个服务发现对象和一个序列化器对象。服务发现对象是用于从服务注册中心获取服务地址的。序列化器对象是用于将请求和响应对象序列化和反序列化的，该类的序列化器可以通过传入参数来选择使用哪种类型的序列化器。<br />在sendRequest方法中，首先判断序列化器是否为空，如果为空则抛出异常。然后通过服务发现对象获取到远程服务的地址，根据地址获取一个Channel对象，ChannelProvider.get方法会返回一个新的Channel或者已有的Channel，如果没有就会创建一个新的Channel。在获取到Channel对象后，使用Netty的writeAndFlush方法将请求对象发送到服务端，使用addListener添加一个ChannelFutureListener监听器，可以在发送成功或失败时执行相应的操作，如打印日志或者回调。发送请求时还将该请求的请求ID和响应结果对应的CompletableFuture对象存储到一个全局的UnprocessedRequests对象中。<br />最后，sendRequest方法返回一个CompletableFuture对象，用于异步等待响应结果。在响应结果到达时，UnprocessedRequests对象会将响应结果的CompletableFuture对象取出并使用complete方法设置结果。而调用sendRequest方法的线程会在CompletableFuture对象的get方法上阻塞，直到CompletableFuture对象的complete方法被调用为止，然后会返回响应结果。<br />接着我们一步步看这个客户端有哪些用到的类：</p><p><a name="Fzlss"></a></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡会共用一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有着其对应的实现。<br />随机策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮询策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以看到，无论是哪一种策略，都是要先获取到Instance实例，然后使用相应的负载均衡策略，那么这个实例，则是Nacos包提供的一个类，那么我们也自然需要一个Nacos方法来提供。</p><p><a name="fLeqg"></a></p><h3 id="NacosServiceDiscovery"><a href="#NacosServiceDiscovery" class="headerlink" title="NacosServiceDiscovery"></a>NacosServiceDiscovery</h3><p>服务发现类，同时也对上述的负载均衡做出了解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"找不到对应的服务: "</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"获取服务时有错误发生:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个 NacosServiceDiscovery 类，实现了 ServiceDiscovery 接口，主要用于在基于 Nacos 注册中心的服务发现中获取服务地址。具体作用如下：</p><ol><li>NacosServiceDiscovery 类有一个构造方法，用于初始化负载均衡策略，如果未指定，则默认使用随机负载均衡策略。</li><li>lookupService 方法用于获取指定服务名对应的 InetSocketAddress，通过调用 NacosUtil 工具类获取所有的服务实例，然后使用负载均衡策略选择一个实例，最终返回该实例的地址信息。</li><li>如果找不到对应的服务，则会抛出 RpcException 异常，并记录错误日志。</li></ol><p>总之，该类用于实现基于 Nacos 注册中心的服务发现功能，可以根据服务名从注册中心获取服务实例并进行负载均衡选择，返回可用的服务地址。</p><p><a name="XrnMt"></a></p><h3 id="UnprocessedRequests"><a href="#UnprocessedRequests" class="headerlink" title="UnprocessedRequests"></a>UnprocessedRequests</h3><p>这个类名为 UnprocessedRequests，用于处理未处理的RPC请求。同时也是更好的控制数据的获取，因为如果使用Netty自带的阻塞获取方法，太过于复杂了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中，使用了一个静态的 ConcurrentHashMap 对象，用于存储未处理的RPC请求。<br />其中，Key 值为请求的ID，Value 值为一个 CompletableFuture<RpcResponse> 对象，用于异步获取 RPC 响应结果。<br />这可以用来记录客户端发送的请求并等待响应。主要包含以下方法：</p><ol><li>put(String requestId, CompletableFuture<RpcResponse> future)：将请求 ID 和对应的 CompletableFuture 存储到 ConcurrentHashMap 中。</li><li>remove(String requestId)：从 ConcurrentHashMap 中删除指定的请求 ID。</li><li>complete(RpcResponse rpcResponse)：根据响应中的请求 ID 找到对应的 CompletableFuture 并将响应数据传递给它。如果没有找到对应的 CompletableFuture，则抛出 IllegalStateException 异常。</li></ol><p>这个类的作用是确保客户端发送的每个请求都有一个对应的 CompletableFuture 实例，用来等待服务器响应。在客户端收到服务器响应后，可以使用 UnprocessedRequests.complete() 方法将响应数据传递给对应的 CompletableFuture。这种机制使得客户端可以异步发送请求并等待响应，而不需要阻塞线程。<br><a name="rkJoD"></a></p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture类是Java8引入的一个异步编程工具，用于处理异步操作的结果。它提供了一些方法来处理异步任务的结果，例如将结果传递给下一个任务，等待任务完成，组合多个任务等。<br />在异步编程中，通常会使用回调函数来处理异步任务的结果，但这种方式会使代码变得冗长且难以维护。CompletableFuture类的出现，使得异步编程变得更加简单和可读。<br />CompletableFuture类有以下几个主要特点：</p><ol><li>可以将一个异步操作的结果传递给下一个操作，这种操作被称为”组合”。</li><li>可以等待一个异步操作的结果，并在操作完成后执行一些操作，例如打印日志、释放资源等。</li><li>可以在多个异步操作完成后执行一些操作，例如将它们的结果组合起来，计算它们的平均值等。</li><li>可以通过异常处理机制来处理异步操作中的异常。</li></ol><p>使用CompletableFuture类，可以更加方便地处理异步任务，提高代码的可读性和可维护性。同时，它也是Java并发编程中非常有用的工具之一。<br><a name="PP3yo"></a></p><h3 id="ChannelProvider"><a href="#ChannelProvider" class="headerlink" title="ChannelProvider"></a>ChannelProvider</h3><p>这段代码实现了一个用于获取客户端 Channel 的工具类 ChannelProvider。它维护了一个 Map 类型的 channels 成员变量，用于缓存已经连接的 Channel 对象，通过 get 方法获取指定地址的 Channel 对象。</p><ol><li>在 get 方法中，首先根据地址和序列化器生成 key，从 channels 缓存中查找是否已有对应的 Channel 对象。如果有，就返回已有的 Channel 对象；如果没有，就通过 bootstrap 进行连接。在连接成功后，将新建的 Channel 对象存入 channels 缓存，并返回该对象。如果连接失败，返回 null。</li><li>在 connect 方法中，通过 CompletableFuture 异步获取连接结果。在连接成功后，将 Channel 对象作为 CompletableFuture 的返回值。</li><li>initializeBootstrap 方法则初始化 Bootstrap 对象，并设置一些常用的参数，如连接超时时间、是否启用 TCP 底层心跳机制等。</li></ol><p>ChannelProvider 为客户端连接提供了一个通用的方法，简化了客户端连接的过程，提高了代码的复用性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接客户端时有错误发生"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"客户端连接成功!"</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, 5000)</span></span><br><span class="line"><span class="class">                //是否开启 <span class="title">TCP</span> 底层心跳机制</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                //<span class="title">TCP</span>默认开启了 <span class="title">Nagle</span> 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。<span class="title">TCP_NODELAY</span> 参数的作用就是控制是否启用 <span class="title">Nagle</span> 算法。</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细一点的说：<br />这段代码实现了一个用于获取Netty客户端Channel的工具类ChannelProvider。它提供了一个get方法，该方法接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取与指定服务提供者（IP地址和端口号）之间的连接。该方法首先将InetSocketAddress和序列化器的编码方式作为key，从Map中查找已有的Channel。如果找到的Channel是可用的，那么直接返回这个Channel。如果找到的Channel不可用，那么将它从Map中删除。接下来创建一个新的Channel，该Channel使用了上述编码方式进行了初始化，并且连接到了指定的服务提供者，最后将新创建的Channel保存到Map中。<br />在ChannelProvider类中，包含了一个静态的EventLoopGroup类型的变量eventLoopGroup和一个静态的Bootstrap类型的变量bootstrap。在类初始化时，这些变量被初始化为一个NioEventLoopGroup和一个Bootstrap实例。Bootstrap实例会初始化连接到远程服务提供者的客户端的参数，包括TCP连接、超时时间、TCP底层心跳机制等。这就是Channel的模板，创建一次就好了，不用每次都创建一次，这样可以很好的减少代码冗余和提高复用性。</p><ul><li>get()方法是ChannelProvider的主要方法。它接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取连接到指定服务提供者的Channel。首先，根据传入的参数，生成一个唯一的key，用于从Map中查找是否已经存在一个可用的Channel。如果找到的Channel是可用的，直接返回这个Channel对象。否则，创建一个新的Channel，并且将它保存到Map中。最后，返回新创建的Channel对象。</li><li>initChannel()方法用于初始化客户端Channel的pipeline。在这里，我们首先添加了一个自定义的序列化编解码器，然后添加了一个心跳检测处理器IdleStateHandler、一个通用解码器CommonDecoder和一个客户端处理器NettyClientHandler。这些处理器将按照顺序添加到客户端Channel的pipeline中。</li><li>connect()方法用于创建连接到指定服务提供者的Channel，并返回连接成功后的Channel对象。为了处理异步连接的结果，它使用了一个CompletableFuture对象completableFuture，该对象用于接收连接结果。当连接成功时，completableFuture将被设置为连接成功的Channel对象；当连接失败时，completableFuture将抛出异常。</li></ul><p>这个Channel包含的一个NettyClientHandler，有相应对收到请求的处理：<br><a name="ie8Yn"></a></p><h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">"客户端接收到消息: %s"</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"发送心跳包 [&#123;&#125;]"</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Netty 客户端处理器，用于处理服务器发送的响应消息。它继承了 Netty 的 SimpleChannelInboundHandler 类，实现了其中的 channelRead0() 方法和 exceptionCaught() 方法。<br />在channelRead0()方法中，通过UnprocessedRequests对象的complete()方法处理返回的RpcResponse对象。在此方法中，使用logger打印接收到的消息，然后调用UnprocessedRequests.complete()方法，将对应的CompletableFuture对象标记为完成，并将RpcResponse对象作为结果<br />在 exceptionCaught() 方法中，发生异常时，会先记录日志，然后关闭客户端通道。<br />另外，该类还重写了 userEventTriggered() 方法，用于发送心跳包。如果客户端在一段时间内没有发送数据，则会自动触发该方法，并向服务器发送一个心跳包。当客户端发送心跳包时，会调用 ChannelProvider 类的 get() 方法获取一个 Channel 对象，并向该 Channel 对象写入一个标记了心跳标志的 RpcRequest 对象，最后调用 close() 方法关闭该 Channel。</p><p><a name="RGhhY"></a></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Go语言编写一个web与分布式应用</title>
      <link href="/2022/04/27/go-web-study/"/>
      <url>/2022/04/27/go-web-study/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Go语言编写一个web应用"><a href="#使用Go语言编写一个web应用" class="headerlink" title="使用Go语言编写一个web应用"></a>使用Go语言编写一个web应用</h1><h2 id="初始知识"><a href="#初始知识" class="headerlink" title="初始知识"></a>初始知识</h2><h3 id="go语言的学习"><a href="#go语言的学习" class="headerlink" title="go语言的学习"></a>go语言的学习</h3><p>其实很简单，就不详细写了。</p><p>可以去类似于去菜鸟教程这个网站，去初步的了解编程语言的写法。</p><p>或者是类似于哔哔哔哩这样的视频网站，直接照这视频一步一步的去学习它的写法，不过这种方法比较消耗时间。但是我觉得如果你有一定的编程基础，学这个go真的很简单，没有什么复杂地方。你仅需要注意的是，语法有些不同，你可能要花一段时间去适应它的写法。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然网上很多教程都是使用VScode去写的，但是我觉得不是很好，可能自己对于这种轻量级的工具不是很适应。</p><p>我使用的是IntelliJ IDEA ，然后安装了go的插件之后去写的，我觉得这样写起来比较轻松，这个要看个人了。</p><h3 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h3><p>这个编程语言去做一个web服务的话，有点像cpp一样复古的写法，但是相比于cpp这样语言来肯定要简单得多。不过，如果你有一定的基础的话，会比较轻松吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//初始化一个函数，让其能对web应用进行响应</span></span><br><span class="line"><span class="comment">//第一个参数是路由地址，第二个参数是函数主要功能是收到请求并响应</span></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务器，第一个参数是网络地址，第二个参数是处理方式</span></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后就可以看到结果了。</p><h2 id="正式编写"><a href="#正式编写" class="headerlink" title="正式编写"></a>正式编写</h2><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h4><p>首先要编写一个go程序，就如上面的例子一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := myHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: &amp;mh, <span class="comment">//Handler实际上是一个接口</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，所有的网址都会输出同样的信息，因为每个请求都是使用同一个Handler。而我们应该使用：DefaultServeMux 去进行处理不同的Handler，而我们就需要对每个Handler进行注册，这样才能进行出结果。</p><p>所以我们应该这么改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于我们把我们需要自定义的Handler，根据自己的需要去更改，最后注册到DefaultServeMux当中，完成对不同请求产生不同的响应。</p><h4 id="HandleFunc"><a href="#HandleFunc" class="headerlink" title="HandleFunc"></a>HandleFunc</h4><p>但前面的处理完全可以简写为一个方式，增加可读性，于是乎，我们就要用到这个函数HandleFunc：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HandleFunc</span></span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个HandleFunc本质上还是调用Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把上述代码中的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>其结果也是一样的。因为这其实是接口型函数，表示函数的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是go语言精妙的地方了。你可以面对多种不一样的处理方式，但是只用放在同一个接口当中，这就是go语言使用组成而不是继承的原因。</p><p>总结，如何注册DefaultServeHTTP</p><p>方法一、使用http.Handle（第二个参数是Handler）</p><p>方法二、使用http.HandleFunc（第二个参数是Handler函数）</p><p>方法三、http.HandlerFunc可以进行类型转换，将Handler函数转化成Handler（结构体）来使用</p><h3 id="内置Handler"><a href="#内置Handler" class="headerlink" title="内置Handler"></a>内置Handler</h3><ul><li>func NotFoundHandler() Handler<br>返回一个 handler，它给每个请求的响应都是“404 page not found”</li><li>func RedirectHandler(url string, code int) Handler<br>返回一个 handler，它把每个请求使用给定的状态码跳转到指定的 URL。<br>url，要跳转到的 URL<br>code，跳转的状态码（3xx），常见的：StatusMovedPermanently、StatusFound 或 StatusSeeOther 等</li><li>func StripPrefix(prefix string, h handler) Handler<br>返回一个 handler，它从请求 URL 中去掉指定的前缀，然后再调用另一个 handler。<br>如果请求的 URL 与提供的前缀不符，那么 404<br>略像中间件<br>prefix，URL 将要被移除的字符串前缀<br>h，是一个 handler，在移除字符串前缀之后，这个 handler 将会接收到请求<br>修饰了另一个 Handler </li><li>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler<br>返回一个 handler，它用来在指定时间内运行传入的 h。<br>也相当于是一个修饰器<br>h，将要被修饰的 handler<br>dt，第一个 handler 允许的处理时间<br>msg，如果超时，那么就把 msg 返回给请求，表示响应时间过长</li><li>func FileServer(root FileSystem) Handler<br>返回一个 handler，使用基于 root 的文件系统来响应请求<br>type FileSystem interface {<pre><code>Open(name string) (File, error)</code></pre>  }<br>使用时需要用到操作系统的文件系统，所以还需要委托给：<br>type Dir string<br>func (d Dir) Open(name string) (File, error)</li></ul><h4 id="代码演示：FileServer"><a href="#代码演示：FileServer" class="headerlink" title="代码演示：FileServer"></a>代码演示：FileServer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8888"</span>, http.FileServer(http.Dir(<span class="string">"root"</span>)))</span><br></pre></td></tr></table></figure><p>可以通过这个方法指定root这个根路径，这样打开文件的时候直接去root，直接找到需要的url路径，加载文件</p><h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p> 最基本的肯定是：</p><ul><li><p>HTTP Request 和 HTTP Response（请求和响应）</p></li><li><p>它们具有相同的结构：</p><ul><li><p>​    请求（响应）行</p></li><li><p>​    0 个或多个 Header</p></li><li><p>​    空行</p></li><li><p>​    可选的消息体（Body）</p></li></ul></li></ul><p>而 <strong>net/http</strong> 包提供了用于表示 HTTP 消息的结构，其中Reqeust（是个 struct），代表了客户端发送的 HTTP 请求消息</p><h4 id="URL类型"><a href="#URL类型" class="headerlink" title="URL类型"></a>URL类型</h4><h5 id="URL-Query"><a href="#URL-Query" class="headerlink" title="URL Query"></a>URL Query</h5><p>RawQuery 会提供实际查询的字符串。</p><p>例如： <a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>它的 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>还有一个简便方法可以得到 Key-Value 对：通过 Request 的 Form 字段（以后再说）</p><h5 id="URL-Fragment"><a href="#URL-Fragment" class="headerlink" title="URL Fragment"></a>URL Fragment</h5><p>如果从浏览器发出的请求，那么你无法提取出 Fragment 字段的值</p><p>浏览器在发送请求时会把 fragment 部分去掉</p><p>但不是所有的请求都是从浏览器发出的（例如从 HTTP 客户端包）。</p><h5 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h5><p>请求和响应（Request、Response）的 headers 是通过 Header 类型来描述的，它是一个 map，用来表述 HTTP Header 里的 Key-Value 对。</p><p>Header map 的 key 是 string 类型，value 是 []string</p><p>设置 key 的时候会创建一个空的 []string 作为 value，value 里面第一个元素就是新 header 的值；</p><p>为指定的 key 添加一个新的 header 值，执行 append 操作即可</p><h5 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h5><p>请求和响应的 bodies 都是使用 Body 字段来表示的</p><p>Body 是一个 io.ReadCloser 接口</p><p>一个 Reader 接口</p><p>一个 Closer 接口</p><p>Reader 接口定义了一个 Open 方法：</p><p>参数：[]byte</p><p>返回：byte 的数量、可选的错误</p><p>Closer 接口定义了一个 Close 方法：</p><p>没有参数，返回可选的错误</p><h5 id="代码演示-Fragment"><a href="#代码演示-Fragment" class="headerlink" title="代码演示:Fragment"></a>代码演示:Fragment</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/url"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.URL.Fragment)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过这种方式，看看自己请求有没有Fragment</p><h5 id="代码演示-Header"><a href="#代码演示-Header" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/header"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.Header)</span><br><span class="line">fmt.Fprintln(writer, request.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">fmt.Fprintln(writer, request.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman测试：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/header</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[Accept:[*&#x2F;*] Accept-Encoding:[gzip, deflate, br] Connection:[keep-alive] Postman-Token:[9ddda678-d6f8-42d2-aea5-67816a86c3d7] User-Agent:[PostmanRuntime&#x2F;7.28.3]]</span><br><span class="line">[gzip, deflate, br]</span><br><span class="line">gzip, deflate, br</span><br></pre></td></tr></table></figure><h5 id="代码演示-Header-1"><a href="#代码演示-Header-1" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/post"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">length := request.ContentLength</span><br><span class="line">body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">request.Body.Read(body)</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个方式去展现出body的内容</p><h4 id="URL-Query-1"><a href="#URL-Query-1" class="headerlink" title="URL Query"></a>URL Query</h4><p>例如：<a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>r.URL.RawQuery 会提供实际查询的原始字符串，因为 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>r.URL.Query()，会提供查询字符串对应的 map string string</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">url := request.URL</span><br><span class="line">query := url.Query() <span class="comment">//得到一个map</span></span><br><span class="line"></span><br><span class="line">id := query[<span class="string">"id"</span>]</span><br><span class="line">log.Println(id)</span><br><span class="line"></span><br><span class="line">name := query.Get(<span class="string">"name"</span>)</span><br><span class="line">log.Println(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/home?id=123&amp;name=panda&amp;id=456&amp;name=fox</span><br></pre></td></tr></table></figure><p>控制台显示结果为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[123 456]</span><br><span class="line">panda</span><br></pre></td></tr></table></figure><p>这表明 query[“id”] 是获取所有的值，而query.Get(“name”) 只会获取第一个值</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><h4 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a>enctype</h4><p>接下来看看，如何处理表单类的数据。</p><p>HTML 表单里面的数据会以 name-value 对的形式，通过 POST 请求发送出去，它的数据内容会放在 POST 请求的 Body 里面。</p><p>通过 POST 发送的 name-value 数据对的格式可以通过表单的 Content Type 来指定，也就是 enctype 属性。</p><p>默认值是：application/x-www-form-urlencoded<br>浏览器被要求至少要支持： application/x-www-form-urlencoded 、multipart/form-data。HTML 5 的话，还需要支持 text/plain</p><p>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：    first_name=sau%20sheong&amp;last_name=chang</p><p>如果 enctype 是 multipart/form-data，那么：每一个 name-value 对都会被转换为一个MIME消息部分，每一个部分都有自己的 Content Type 和 Content Disposition</p><p>那么，改如何选择enctype呢？</p><ol><li>简单文本：表单 URL 编码</li><li>大量数据，例如上传文件：multipart-MIME，甚至可以把二进制数据通过选择 Base64 编码，来当作文本进行发送</li></ol><h4 id="Form字段"><a href="#Form字段" class="headerlink" title="Form字段"></a>Form字段</h4><p>Request 上的函数允许我们从 URL 或/和 Body 中提取数据，通过这些字段：    </p><ul><li>Form</li><li>PostForm</li><li>MultipartForm</li></ul><p>Form 里面的数据是 key-value 对。通常的做法是：先调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.Form)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会打印出一个map，包含传入的所有的值。包括url的值和表单的值。</p><p>如果只想要表单的 key-value 对，不要 URL 的，可以使用 PostForm 字段。<br>PostForm 只支持 application/x-www-form-urlencoded</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就只有一个字段</p><p>而想要得到 multipart key-value 对，必须使用 MultipartForm 字段。</p><p>想要使用 MultipartForm 这个字段的话，首先需要调用ParseMultipartForm 这个方法，该方法会在必要时调用 ParseForm 方法<br>，参数是需要读取数据的长度<br>MultipartForm 只包含表单的 key-value 对，返回类型是一个 struct 而不是 map。这个 struct 里有两个 map：1、key 是 string，value 是 []string 。2、空的（key 是 string，value 是文件）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="FormValue-和-PostFormValue-方法"><a href="#FormValue-和-PostFormValue-方法" class="headerlink" title="FormValue 和 PostFormValue 方法"></a>FormValue 和 PostFormValue 方法</h5><ul><li>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用 ParseForm 或 ParseMultipartForm</li><li>PostFormValue 方法也一样，但只能读取 PostForm</li><li>FormValue 和 PostFormValue 都会调用 ParseMultipartForm 方法</li><li>但如果表单的 enctype 设为 multipart/form-data，那么即使你调用ParseMultipartForm 方法，也无法通过 FormValue 获得想要的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.FormValue(<span class="string">"name"</span>))</span><br><span class="line">fmt.Fprintln(writer, request.PostFormValue(<span class="string">"name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>multipart/form-data 最常见的应用场景就是上传文件（例子）：</p><ol><li>首先调用 ParseMultipartForm 方法</li><li>从 File 字段获得 FileHeader，调用其 Open 方法来获得文件</li><li>可以使用 ioutil.ReadAll 函数把文件内容读取到 byte 切片里</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)                      <span class="comment">//1024表示一次性加载到内存的最大字节数</span></span><br><span class="line">fileHeader := request.MultipartForm.File[<span class="string">"upload"</span>][<span class="number">0</span>] <span class="comment">//表示从upload字段获取值</span></span><br><span class="line">file, err := fileHeader.Open()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字如其意，非常简单。但是这部分代码仍然有改进的空间，比如使用FormFile</p><h5 id="FormFile"><a href="#FormFile" class="headerlink" title="FormFile()"></a>FormFile()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//request.ParseMultipartForm(1024)                      //1024表示一次性加载到内存的最大字节数</span></span><br><span class="line"><span class="comment">//fileHeader := request.MultipartForm.File["upload"][0] //表示从upload字段获取值</span></span><br><span class="line"><span class="comment">//file, err := fileHeader.Open()</span></span><br><span class="line"></span><br><span class="line">file, _, err := request.FormFile(<span class="string">"uploader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MultipartReader"><a href="#MultipartReader" class="headerlink" title="MultipartReader()"></a>MultipartReader()</h5><p>方法签名：func (r <em>Request) MultipartReader() (</em>multipart.Reader, error)<br>如果是 multipart/form-data 或 multipart 混合的 POST 请求：1、MultipartReader 返回一个 MIME multipart reader 2、否则返回 nil 和一个错误<br>可以使用该函数代替 ParseMultipartForm 来把请求的 body 作为 stream 进行处理。1、不是把表单作为一个对象来处理的，不是一次性获得整个 map。2、逐个检查来自表单的值，然后每次处理一个</p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h4><p>从服务器向客户端返回响应需要使用 ResponseWriter。ResponseWriter 是一个接口，handler 用它来返回响应。而真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response。</p><p>但是，为什么request是指针，而writer不用是呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(writer http.ResponseWriter, request *http.Request)</span><br></pre></td></tr></table></figure><p>其实，这两个都是按引用进行传递的，ResponseWriter是具有Header、Write、WriteHeader三种方法的接口，response指针实现了以上三种方法，故response是一种特殊的ResponseWriter。</p><p>并且，ResponseWriter还能使用writer.Write([]byte(str))方法，把字符串写入到body里面。</p><h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接收一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回<br>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader(http.StatusOK)，所以 WriteHeader 主要用来发送错误类的 HTTP 状态码<br>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p><h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改<br>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p><h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，包装一个 404 状态码和一个额外的信息<br>ServeFile 函数，从文件系统提供文件，返回给请求者<br>ServeContent 函数，它可以把实现了 io.ReadSeeker 接口的任何东西里面的内容返回给请求者，并且，还可以处理 Range 请求（范围请求），如果只请求了资源的一部分内容，那么 ServeContent 就可以如此响应。而 ServeFile 或 io.Copy 则不行。<br>Redirect 函数，告诉客户端重定向到另一个 URL</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>Web 模板就是预先设计好的 HTML 页面，它可以被模板引擎反复的使用，来产生 HTML 页面<br>Go 的标准库提供了 text/template，html/template 两个模板库，大多数 Go 的 Web 框架都使用这些库作为 默认的模板引擎</p><h4 id="Go-的模板和模板引擎"><a href="#Go-的模板和模板引擎" class="headerlink" title="Go 的模板和模板引擎"></a>Go 的模板和模板引擎</h4><p>go主要使用的是 text/template，HTML 相关的部分使用了 html/template，是个混合体。go模板可以完全无逻辑，但又具有足够的嵌入特性。和大多数模板引擎一样，Go Web 的模板位于无逻辑和嵌入逻辑之间的某个地方</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在 Web 应用中，通产是由 handler 来触发模板引擎。handler 调用模板引擎，并将使用的模板传递给引擎，通常是一组模板文件和动态数据。<br>模板引擎生成 HTML，并将其写入到 ResponseWriter，ResponseWriter 再将它加入到 HTTP 响应中，返回给客户端。</p><h5 id="模板的例子"><a href="#模板的例子" class="headerlink" title="模板的例子"></a>模板的例子</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go Web Programming<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模板必须是可读的文本格式，扩展名任意。对于 Web 应用通常就是 HTML，里面会内嵌一些命令（叫做 action）</span><br><span class="line">text/template 是通用模板引擎，html/template 是 HTML 模板引擎</span><br><span class="line">action 位于双层花括号之间：&#123;&#123; . &#125;&#125;。这里的 . 就是一个 action。它可以命令模板引擎将其替换成一个值。</span><br></pre></td></tr></table></figure><p>是不是有点像jsp</p><h5 id="使用模板引擎"><a href="#使用模板引擎" class="headerlink" title="使用模板引擎"></a>使用模板引擎</h5><ol><li>解析模板源（可以是字符串或模板文件），从而创建一个解析好的 模板的 struct</li><li>执行解析好的模板，并传入 ResponseWriter 和 数据。这会触发模板引擎组合解析好的模板和数据，来产生最终的 HTML，并将它传递给 ResponseWriter </li></ol><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">t, _ := template.ParseFiles(<span class="string">"mytest.html"</span>) <span class="comment">//去解析一个模板文件，一个也在这个包下的html文件，</span></span><br><span class="line">t.Execute(writer, <span class="string">"hello,my friends"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是鉴于现今几乎都是前后端分离的项目了，模板引擎已经几乎要绝迹了，随便学学吧。</p><h4 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h4><h5 id="ParseFiles"><a href="#ParseFiles" class="headerlink" title="ParseFiles"></a>ParseFiles</h5><p>解析模板文件，并创建一个解析好的模板 struct，后续可以被执行<br>ParseFiles 函数是 Template struct 上 ParseFiles 方法的简便调用<br>调用 ParseFiles 后，会创建一个新的模板，模板的名字是文件名<br>ParseFiles 的参数数量可变，但只返回一个模板，当解析多个文件时，第一个文件作为返回的模板（名、内容），其余的作为 map，供后续执行使用</p><h5 id="ParseGlob"><a href="#ParseGlob" class="headerlink" title="ParseGlob"></a>ParseGlob</h5><p>使用模式匹配来解析特定的文件</p><h5 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h5><p>可以解析字符串模板，其它方式最终都会调用 Parse</p><h5 id="Lookup-方法"><a href="#Lookup-方法" class="headerlink" title="Lookup 方法"></a>Lookup 方法</h5><p>通过模板名来寻找模板，如果没找到就返回 nil</p><h5 id="Must-函数"><a href="#Must-函数" class="headerlink" title="Must 函数"></a>Must 函数</h5><p>可以包裹一个函数，返回到一个模板的指针 和 一个错误。如果错误不为 nil，那么就 panic</p><h4 id="模板的Action"><a href="#模板的Action" class="headerlink" title="模板的Action"></a>模板的Action</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action 就是 Go 模板中嵌入的命令，位于两组花括号之间 &#123;&#123; xxx &#125;&#125;，就是一个 Action，而且是最重要的一个。它代表了传入模板的数据</span><br></pre></td></tr></table></figure><p>Action 主要可以分为五类：条件类，迭代/遍历类，设置类，包含类，定义类</p><h5 id="条件Action"><a href="#条件Action" class="headerlink" title="条件Action"></a>条件Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">  other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代-遍历-Action"><a href="#迭代-遍历-Action" class="headerlink" title="迭代/遍历 Action"></a>迭代/遍历 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">  Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>这类 Action 用来遍历数组、slice、map 或 channel 等数据结构，“.”用来表示每次迭代循环中的元素</p><h5 id="设置Action"><a href="#设置Action" class="headerlink" title="设置Action"></a>设置Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>它允许在指定范围内，让“.”来表示其它指定的值（arg）</p><h5 id="包含-Action"><a href="#包含-Action" class="headerlink" title="包含 Action"></a>包含 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template "name" &#125;&#125;</span><br><span class="line">它允许你在模板中包含其它的模板</span><br><span class="line">&#123;&#123; template "name" arg &#125;&#125;</span><br><span class="line">给被包含模板传递参数</span><br></pre></td></tr></table></figure><h4 id="函数与管道"><a href="#函数与管道" class="headerlink" title="函数与管道"></a>函数与管道</h4><h5 id="参数（argument）"><a href="#参数（argument）" class="headerlink" title="参数（argument）"></a>参数（argument）</h5><p>参数就是模板里面用到的值。可以是 bool、整数、string … ，也可以是 struct、struct 的字段、数组的 key 等等<br>参数可以是变量、方法（返回单个值或返回一个值和一个错误）或函数<br>参数可以是一个点“.”，也就是传入模板引擎的那个值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">这里的 arg 就是参数</span><br></pre></td></tr></table></figure><h5 id="在-Action-中设置变量"><a href="#在-Action-中设置变量" class="headerlink" title="在 Action 中设置变量"></a>在 Action 中设置变量</h5><p>可以在 action 中设置变量，变量以 $ 开头：$variable := value<br>一个迭代 action 的例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">  The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="管道（pipeline）"><a href="#管道（pipeline）" class="headerlink" title="管道（pipeline）"></a>管道（pipeline）</h5><p>管道是按顺序连接到一起的参数、函数和方法。和 Unix 的管道类似:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：&#123;&#123; p1 | p2 | p3 &#125;&#125;  ，p1、p2、p3 要么是参数，要么是函数</span><br><span class="line">管道允许我们把参数的输出发给下一个参数，下一个参数由管道（|）分隔开。</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>参数可以是一个函数，Go 模板引擎提供了一些基本的内置函数，功能比较有限。例如 fmt.Sprint 的各类变体等<br>开发者可以自定义函数，可以接收任意数量的输入参数<br>返回：一个值     或       一个值+一个错误</p><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define、template、block</span><br><span class="line">html、js、urlquery。对字符串进行转义，防止安全问题</span><br><span class="line">如果是 Web 模板，那么不会需要经常使用这些函数。</span><br><span class="line">index</span><br><span class="line">print/printf/println</span><br><span class="line">len</span><br><span class="line">with</span><br><span class="line">这些都是内置的函数</span><br></pre></td></tr></table></figure><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template.Funcs(funcMap FuncMap) *Template</span><br><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//value 是函数</span></span><br><span class="line"><span class="comment">//可以有任意数量的参数</span></span><br><span class="line"><span class="comment">//返回单个值的函数或返回一个值+一个错误的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个 FuncMap（map 类型）。</span></span><br><span class="line"><span class="comment">key 是函数名</span></span><br><span class="line"><span class="comment">value 就是函数</span></span><br><span class="line"><span class="comment">把 FuncMap 附加到模板</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>常见用法：template.New(“”).Funcs(funcMap).Parse(…)，调用顺序非常重要。可以在管道中使用，也可以作为正常函数使用。</p><h4 id="模板组合"><a href="#模板组合" class="headerlink" title="模板组合"></a>模板组合</h4><h5 id="Layout-模板"><a href="#Layout-模板" class="headerlink" title="Layout 模板"></a>Layout 模板</h5><p>Layout 模板就是网页中固定的部分，它可以被多个网页重复使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Include（包含）action 的形式：&#123;&#123; template "name" . &#125;，</span><br></pre></td></tr></table></figure><p>以这种方式做 layout 模板是不可行的。而正确的做法是在模板文件里面使用 define action 再定义一个模板。这种形式特别像thymeleaf，就是单纯的将HTML页面强行模块化，使其具有公共部分的属性，总体而言还是比较简单的。而也可以在多个模板文件里，定义同名的模板。</p><h5 id="使用-block-action-定义默认模板"><a href="#使用-block-action-定义默认模板" class="headerlink" title="使用 block action 定义默认模板"></a>使用 block action 定义默认模板</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">block action 可以定义模板，并同时就使用它</span><br><span class="line">template：模板必须可用</span><br><span class="line">block：模板可以不存在</span><br></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eq/ne</span><br><span class="line">lt/gt</span><br><span class="line">le/ge</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><p>字如其意。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>接下来看看如何使用golang去连接数据库，并进行基本的CRUD。</p><h4 id="https-www-jianshu-com-p-7e745fefb8af"><a href="#https-www-jianshu-com-p-7e745fefb8af" class="headerlink" title="https://www.jianshu.com/p/7e745fefb8af"></a><strong><a href="https://www.jianshu.com/p/7e745fefb8af" target="_blank" rel="noopener">https://www.jianshu.com/p/7e745fefb8af</a></strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//"用户名:密码@[连接方式](主机名:端口号)/数据库名"</span></span><br><span class="line">    db,_:=sql.Open(<span class="string">"mysql"</span>,<span class="string">"root:root@(127.0.0.1:3306)/testdatabases"</span>) <span class="comment">// 设置连接数据库的参数</span></span><br><span class="line">    <span class="keyword">defer</span> db.Close()    <span class="comment">//关闭数据库</span></span><br><span class="line">    err:=db.Ping()      <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"数据库连接失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作一：执行数据操作语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sql:="insert into stu values (2,'berry')"</span></span><br><span class="line"><span class="comment">    result,_:=db.Exec(sql)      //执行SQL语句</span></span><br><span class="line"><span class="comment">    n,_:=result.RowsAffected(); //获取受影响的记录数</span></span><br><span class="line"><span class="comment">    fmt.Println("受影响的记录数是",n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作二：执行预处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    stu:=[2][2] string&#123;&#123;"3","ketty"&#125;,&#123;"4","rose"&#125;&#125;</span></span><br><span class="line"><span class="comment">    stmt,_:=db.Prepare("insert into stu values (?,?)")      //获取预处理语句对象</span></span><br><span class="line"><span class="comment">    for _,s:=range stu&#123;</span></span><br><span class="line"><span class="comment">        stmt.Exec(s[0],s[1])            //调用预处理语句</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作三：单行查询</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    var id,name string</span></span><br><span class="line"><span class="comment">    rows:=db.QueryRow("select * from stu where id=4")   //获取一行数据</span></span><br><span class="line"><span class="comment">    rows.Scan(&amp;id,&amp;name)        //将rows中的数据存到id,name中</span></span><br><span class="line"><span class="comment">    fmt.Println(id,"--",name)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作四：多行查询</span></span><br><span class="line">    rows,_:=db.Query(<span class="string">"select * from stu"</span>)       <span class="comment">//获取所有数据</span></span><br><span class="line">    <span class="keyword">var</span> id,name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next()&#123;        <span class="comment">//循环显示所有的数据</span></span><br><span class="line">        rows.Scan(&amp;id,&amp;name)</span><br><span class="line">        fmt.Println(id,<span class="string">"--"</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>前面很多时候，都是使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>HandleFunc这种方式去进行路由控制，但是其实还有更为方便的写法。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>main()：设置类工作<br>controller：1、静态资源 。2、把不同的请求送到不同的 controller 进行处理</p><p>我们实际上应该这么设置才是最为正确的写法。</p><p>例子，先制作出两个页面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerWelcomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">_, err := writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将两个函数进行注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="comment">//RegisterRoutes 用于注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//这里还可以使用静态资源</span></span><br><span class="line">registerHomeRoutes()</span><br><span class="line">registerWelcomeRoutes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在主函数中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">server :&#x3D; http.Server&#123;</span><br><span class="line">Addr:    &quot;localhost:8888&quot;,</span><br><span class="line">Handler: nil,</span><br><span class="line">&#125;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">err :&#x3D; server.ListenAndServe()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是一种代码层面的解耦合，将我们的函数进一步模块化。</p><h4 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h4><p>静态路由：一个路径对应一个页面：</p><p>/home           或       /about</p><p>带参数的路由：根据路由参数，创建出一族不同的页面：</p><p>/companies/123               或            /companies/Google</p><p>这里使用HandlerFunc就可以了，将字符串传入URL，效果是相同的，与Spring+thymeleaf可以说是一模一样。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>现在讲究前后端分离，大多数数据都是使用JSON去传递数据，接下来看看如何在go中使用JSON对象。</p><h4 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h4><p>Go bool：JSON boolean<br>Go float64：JSON 数值<br>Go string：JSON strings<br>Go nil：JSON null.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于未知结构的-JSON"><a href="#对于未知结构的-JSON" class="headerlink" title="对于未知结构的 JSON"></a>对于未知结构的 JSON</h4><p>map[string]interface{} 可以存储任意 JSON 对象<br>[]interface{} 可以存储任意的 JSON 数组</p><h4 id="读取-JSON"><a href="#读取-JSON" class="headerlink" title="读取 JSON"></a>读取 JSON</h4><p>需要一个解码器：dec := json.NewDecoder(r.Body) ，参数需实现 Reader 接口<br>解码器上进行解码：dec.Decode(&amp;query)</p><h4 id="写入-JSON"><a href="#写入-JSON" class="headerlink" title="写入 JSON"></a>写入 JSON</h4><p>需要一个编码器：enc := json.NewEncoder(w)，参数需实现 Writer 接口<br>编码是：enc.Encode(results)</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//首先看看请求的类型</span></span><br><span class="line">dec := json.NewDecoder(request.Body) <span class="comment">//现在JSON就在这个body里边了，并且需要进行解码</span></span><br><span class="line">company := Company&#123;&#125;</span><br><span class="line">err := dec.Decode(&amp;company) <span class="comment">//将密码解码到company这个变量里边</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;             <span class="comment">//如果它不为空</span></span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则将客户端传过来的数据转化为json重新返回给客户端</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">err = enc.Encode(company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := server.ListenAndServe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman进行测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/companies</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">&#123;</span></span><br><span class="line">    "id": 123,</span><br><span class="line">    "name": "google",</span><br><span class="line">    "country": "USA"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码的类型：Marshal-和-Unmarshal"><a href="#编码的类型：Marshal-和-Unmarshal" class="headerlink" title="编码的类型：Marshal 和 Unmarshal"></a>编码的类型：Marshal 和 Unmarshal</h4><p>Marshal（编码）: 把 go struct 转化为 json 格式。MarshalIndent，带缩进<br>Unmarshal（解码）: 把 json 转化为 go struct</p><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "id": 123,</span></span><br><span class="line"><span class="string">    "name": "google",</span></span><br><span class="line"><span class="string">    "country": "USA"</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c := Company&#123;&#125;</span><br><span class="line">_ = json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;c)</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line">bytes, _ := json.Marshal(c)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">bytes2, _ := json.MarshalIndent(c, <span class="string">","</span>, <span class="string">"     "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果为：</span></span><br><span class="line">&#123;<span class="number">123</span> google USA&#125;</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">123</span>,<span class="string">"name"</span>:<span class="string">"google"</span>,<span class="string">"country"</span>:<span class="string">"USA"</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">,     <span class="string">"id"</span>: <span class="number">123</span>,</span><br><span class="line">,     <span class="string">"name"</span>: <span class="string">"google"</span>,</span><br><span class="line">,     <span class="string">"country"</span>: <span class="string">"USA"</span></span><br><span class="line">,&#125;</span><br></pre></td></tr></table></figure><p>区别：</p><p>针对 string 或 bytes：</p><ul><li>Marshal =&gt; String</li><li>Unmarshal &lt;= String</li></ul><p>针对 stream:</p><ul><li>Encode =&gt; Stream，把数据写入到 io.Writer</li><li>Decode &lt;= Stream，从 io.Reader 读取数据</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件大家都懂的，像消息队列，缓存，也是中间件。当然也可以自己捏一个中间件的处理逻辑。</p><h4 id="创建中间件"><a href="#创建中间件" class="headerlink" title="创建中间件"></a>创建中间件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//handler 如果是 nil：DefaultServeMux</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>像这个Handler接口，并可以支持中间件的处理。</p><p>首先创建一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m MyMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 在 next handler 之前做一些事情</span></span><br><span class="line">m.Next.ServeHTTP(w, r)</span><br><span class="line"><span class="comment">// 在 next handler 之后做一些事情</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>途中可以定义中间件需要做的事情。</p><h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ol><li>Logging，日志</li><li>安全，身份认证</li><li>请求超时，减少资源消耗</li><li>响应压缩，提升效率 </li></ol><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间件</span></span><br><span class="line"><span class="keyword">type</span> AuthMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *AuthMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> am.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">am.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//如果什么都没有，执行默认页面</span></span><br><span class="line">auth := request.Header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line"><span class="keyword">if</span> auth != <span class="string">""</span> &#123; <span class="comment">//说明存在身份，则执行逻辑</span></span><br><span class="line">am.Next.ServeHTTP(writer, request)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//否则报异常</span></span><br><span class="line">writer.WriteHeader(http.StatusUnauthorized) <span class="comment">//401未授权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是自定义的中间件类型，接着是主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="built_in">new</span>(middleware.AuthMiddleware))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该中间件注册过后，便可以执行逻辑。</p><p>使用Postman进行测试，一个带Authorization，而另一个不带,测试略。</p><h3 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h3><p>从请求的上下文中获取信息，以用于处理</p><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">Context</span><span class="params">()</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//返回当前请求的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//基于 Context 进行“修改”，（实际上）创建一个新的 Context</span></span><br></pre></td></tr></table></figure><p>有这么两种方式去处理上下文</p><p>看看里面实际上是什么：</p><h4 id="context-Context"><a href="#context-Context" class="headerlink" title="context.Context"></a>context.Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这些方法都是用于读取，不能进行设置</span></span><br></pre></td></tr></table></figure><p>这就是上下文接口里面的方法</p><p>context这个包，也有一些方法，可以返回新的context</p><h4 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h4><ul><li>WithCancel()，它有一个 CancelFunc</li><li>WithDeadline()，带有一个时间戳（time.Time）</li><li>WithTimeout()，带有一个具体的时间段（time.Duration）</li><li>WithValue()，在里面可以添加一些值</li></ul><h4 id="一个超时的例子"><a href="#一个超时的例子" class="headerlink" title="一个超时的例子"></a>一个超时的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeoutMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeoutMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tm.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">tm.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//处理和中间件的一般方式一样</span></span><br><span class="line"></span><br><span class="line">ctx := request.Context()                         <span class="comment">//获取上下文</span></span><br><span class="line">ctx, _ = context.WithTimeout(ctx, <span class="number">3</span>*time.Second) <span class="comment">//修改context的超时判断</span></span><br><span class="line">request.WithContext(ctx)                         <span class="comment">//用我们自定义的context去代替</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)                        <span class="comment">//意图在于，如果我们请求能够在3秒内完成的话，这个chan就会收到一个信号</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                                      <span class="comment">//使用goroutine</span></span><br><span class="line">tm.Next.ServeHTTP(writer, request) <span class="comment">//执行完这个方法后，发送一个信号</span></span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;                   <span class="comment">//发送信号</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//一个竞争的状态</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch: <span class="comment">//正常处理完，得到信号，返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//否则返回错误</span></span><br><span class="line">writer.WriteHeader(http.StatusRequestTimeout)</span><br><span class="line">&#125;</span><br><span class="line">ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先新造好这个中间件，然后注册到main函数里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/middleware"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//time.Sleep(4*time.Second)</span></span><br><span class="line"><span class="comment">//测试用</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, &amp;middleware.TimeoutMiddleware&#123;Next: <span class="built_in">new</span>(middleware.AuthMiddleware)&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后像之前一样去测试，即可。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>这是HTTP的流程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> HTTP/1.1</span><br><span class="line">…</span><br><span class="line">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure><p>都是明文传输的，所以我们有时候就需要HTTPS</p><h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><ul><li>http.ListenAndServe 函数</li><li>http.ListenAndServeTLS 函数</li></ul><p>可以使用ListenAndServeTLS去使其页面变为HTTPS类型，看看接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServeTLS(certFile, keyFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现需要安全证书，而我们的go就可以自己生成安全证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -h</span><br><span class="line">//看看帮助</span><br><span class="line"> -ca</span><br><span class="line">        whether this cert should be its own Certificate Authority</span><br><span class="line">  -duration duration</span><br><span class="line">        Duration that certificate is valid <span class="keyword">for</span> (default <span class="number">8760</span>h0m0s)</span><br><span class="line">  -ecdsa-curve string</span><br><span class="line">        ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521</span><br><span class="line">  -ed25519</span><br><span class="line">        Generate an Ed25519 key</span><br><span class="line">  -host string</span><br><span class="line">        Comma-separated hostnames and IPs to generate a certificate <span class="keyword">for</span></span><br><span class="line">  -rsa-bits int</span><br><span class="line">        Size of RSA key to generate. Ignored <span class="keyword">if</span> --ecdsa-curve is <span class="built_in">set</span> (default <span class="number">2048</span>)</span><br><span class="line">  -<span class="built_in">start</span>-<span class="built_in">date</span> string</span><br><span class="line">        Creation <span class="built_in">date</span> formatted as Jan <span class="number">1</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span> <span class="number">2011</span></span><br></pre></td></tr></table></figure><p>于是乎，便生成证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -host localhost</span><br><span class="line"> //wrote cert.pem</span><br><span class="line"> //wrote key.pem</span><br></pre></td></tr></table></figure><p>之后再测试，发现只有使用HTTPS的前缀，才能打开网页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go_web/controller"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">http.ListenAndServeTLS(<span class="string">"localhost:8888"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们使用的HTTP1.1协议就会自动升级到HTTP2.0协议</p><h3 id="HTTP的协议"><a href="#HTTP的协议" class="headerlink" title="HTTP的协议"></a>HTTP的协议</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>在HTTP/1.1的情况下：</p><ol><li>请求 header+body</li><li>响应 header+body</li></ol><p>这样请求和响应，他们的信息都无法被压缩，会导致传输效率低，但是HTTP2.0使得他们能够压缩加密</p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><p>在这个协议下，请求和响应都是使用Stream来进行的，把消息拆成多个Frame进行发送，每个Frame都可以单独的进行优化。</p><p>Frame类型：Headers、Continuation、Data等等，把请求和响应分成多个Frame，每个数据类型都可以单独优化。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><p>请求多路复用</p></li><li><p>Header 压缩</p></li><li><p>默认安全</p><p>​    HTTP ，但很多决定不支持 HTTP</p><p>​    HTTPS</p></li><li><p>Server Push</p></li></ul><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>在没有Server Push的情况下，每个页面的素材例如：css、html等都是必须发送一个单独的请求来进行的。</p><p>在有了Server Push的情况下，但我们的html页面包含css文件的时候，Server Push会自动传输css文件，即使这个html文件还没有进行对css的引用。这样一来，当html文件需要使用的时候，就不用再次发送请求了。节省了一些加载时间。</p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pusher, ok := writer.(http.Pusher); ok &#123; <span class="comment">//先做类型断言，看看存不存在push</span></span><br><span class="line">pusher.Push(<span class="string">"/css/app.css"</span>, &amp;http.PushOptions&#123; <span class="comment">//如果为真，则说明支持server push</span></span><br><span class="line">Header: http.Header&#123;<span class="string">"Content-Type"</span>: []<span class="keyword">string</span>&#123;<span class="string">"text/css"</span>&#125;&#125;, <span class="comment">//使其自加载这个文件</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后启动服务，进入页面，打开F12看看，结果就清晰明了了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来学习，如何对go web应用进行测试：</p><h4 id="测试-Model-层"><a href="#测试-Model-层" class="headerlink" title="测试 Model 层"></a>测试 Model 层</h4><p>可以编写一个单独的go程序进行测试，然后编写测试函数，并且应该注重命名：</p><ul><li><p>user_test.go</p><p>​    测试代码所在文件的名称以 _test 结尾</p><p>​    对于生产编译，不会包含以 _test 结尾的文件</p><p>​    对于测试编译，会包含以 _test 结尾的文件</p></li><li><p>func TestUpdatesModifiedTime(t *testing.T) { … }</p><p>​    测试函数名应以 Test 开头（需要导出）</p><p>​    函数名需要表达出被验证的特性</p><p>​    测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Company)</span> <span class="title">GetCompanyType</span><span class="params">()</span> <span class="params">(result <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(c.Name, <span class="string">".LTD"</span>) &#123;</span><br><span class="line">result = <span class="string">"Limited Liability Company"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = <span class="string">"Others"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用一个极为简易的例子去测试，判断公司的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCompany_GetCompanyType</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google.LTD"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">companyType := c.GetCompanyType() <span class="comment">//获取类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> companyType != <span class="string">"Limited Liability Company"</span> &#123; <span class="comment">//判断</span></span><br><span class="line">t.Error(<span class="string">"this is others!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果测试通过，则会直接显示PASS</span></span><br><span class="line"><span class="comment">//如果测试不通过。结果如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UN   TestCompany_GetCompanyType</span></span><br><span class="line"><span class="comment">    company_test.go:15: this is others!</span></span><br><span class="line"><span class="comment">--- FAIL: TestCompany_GetCompanyType (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这便是测试的结果。</p><h4 id="测试-Controller-层"><a href="#测试-Controller-层" class="headerlink" title="测试 Controller 层"></a>测试 Controller 层</h4><ol><li>为了尽量保证单元测试的隔离性，测试不要使用例如数据库、外部API、文件系统等外部资源。</li><li>模拟请求和响应</li><li>需要使用 net/http/httptest 提供的功能</li></ol><p>这里有几个函数值得关注：</p><h5 id="NewRequest-函数"><a href="#NewRequest-函数" class="headerlink" title="NewRequest 函数"></a>NewRequest 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//method：HTTP Method</span></span><br><span class="line"><span class="comment">//url：请求的 URL</span></span><br><span class="line"><span class="comment">//body：请求的 Body</span></span><br><span class="line"><span class="comment">//返回的 *Request 可以传递给 handler 函数</span></span><br></pre></td></tr></table></figure><h5 id="ResponseRecorder"><a href="#ResponseRecorder" class="headerlink" title="ResponseRecorder"></a>ResponseRecorder</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseRecorder &#123;</span><br><span class="line">  Code <span class="keyword">int</span> <span class="comment">// 状态码  200、500…</span></span><br><span class="line">HeaderMap http.Header <span class="comment">// 响应的 header</span></span><br><span class="line">Body *bytes.Buffer <span class="comment">// 响应的 body</span></span><br><span class="line">Flushed <span class="keyword">bool</span> <span class="comment">// 缓存是否被 flush 了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来捕获从 handler 返回的响应，只是做记录</span></span><br><span class="line"><span class="comment">//可以用于测试断言</span></span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutesController</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, handlerCompany)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerCompany</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := model.Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收到请求后使用JSON编码，并写到响应里面，并返回回去</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着写一个测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httptest"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandleCompanyCorrect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">r := httptest.NewRequest(http.MethodGet, <span class="string">"/companies"</span>, <span class="literal">nil</span>) <span class="comment">//模拟一个请求</span></span><br><span class="line">w := httptest.NewRecorder()                                 <span class="comment">//用于捕获和记录响应</span></span><br><span class="line">handlerCompany(w, r)                                        <span class="comment">//传入Handler</span></span><br><span class="line"></span><br><span class="line">result, _ := ioutil.ReadAll(w.Result().Body) <span class="comment">//获取响应，提取body</span></span><br><span class="line"></span><br><span class="line">c := model.Company&#123;&#125;</span><br><span class="line">json.Unmarshal(result, &amp;c) <span class="comment">//解码并重新放入c这个变量里边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.ID != <span class="number">123</span> &#123; <span class="comment">//然后判断</span></span><br><span class="line">t.Error(<span class="string">"this is a failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过就显示PASS</span></span><br><span class="line"><span class="comment">//否则显示：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">=== RUN   TestHandleCompanyCorrect</span></span><br><span class="line"><span class="comment">    company_test.go:23: this is a failed</span></span><br><span class="line"><span class="comment">--- FAIL: TestHandleCompanyCorrect (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这还是比较方便的</p><h3 id="Profiling-性能分析"><a href="#Profiling-性能分析" class="headerlink" title="Profiling 性能分析"></a>Profiling 性能分析</h3><h4 id="分析的对象"><a href="#分析的对象" class="headerlink" title="分析的对象"></a>分析的对象</h4><ul><li><p>内存消耗</p></li><li><p>CPU 使用</p></li><li><p>阻塞的 goroutine</p></li><li><p>执行追踪</p></li></ul><p>还有一个 Web 界面：应用的实时数据</p><h4 id="如何分析"><a href="#如何分析" class="headerlink" title="如何分析"></a>如何分析</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import _ “<span class="built_in">net</span>/http/pprof”</span><br><span class="line">引入一个包，设置一些监听的 URL，它们会提供各类诊断信息</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/heap   // 内存</span><br><span class="line">从应用获取内存 dump：应用在使用哪些内存，它们会去哪</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/profile    // CPU</span><br><span class="line">CPU 的快照，可以看到谁在用 CPU</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/block // goroutine</span><br><span class="line">看到阻塞的 goroutine</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/trace?seconds=<span class="number">5</span>  // trace</span><br><span class="line">监控这段时间内，什么在执行，什么在调用什么…</span><br><span class="line"></span><br><span class="line"><span class="function">http:// <span class="title">localhost</span>:8000/<span class="title">debug</span>/<span class="title">pprof</span> // 网页</span></span><br></pre></td></tr></table></figure><p>未完待续…….</p><h1 id="使用Go语言编写一个简易的分布式系统"><a href="#使用Go语言编写一个简易的分布式系统" class="headerlink" title="使用Go语言编写一个简易的分布式系统"></a>使用Go语言编写一个简易的分布式系统</h1><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>在一开始我要去学习用go语言编写一个分布式系统的时候。我会在想什么是分布式系统，分布式系统又跟以往的系统有什么很大的差异，或者说区别嘛。带着这个好奇，我去搜索一下什么才是真正的分布式系统，我以为是非常高深，又难以明白的一门学科，但是我仔细了解分布式系统的原理后。我发现我好像学过？！</p><p>以下资料是来源于我在网上搜索得出的信息：</p><blockquote><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h3><p>​            集  群: 同一个业务,部署在多个服务器上</p><p>​            分布式: 同一个业务,拆分成多个子业务,部署在不同的服务器上</p><p>​            微服务: 同一个业务,按照功能模块拆分,每一个服务只对应一个功能模块</p><h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二.区别"></a>二.区别</h3><p>​     <strong>集群</strong>是多台服务器一起处理同一个业务,可以使用负载均衡使得每一个服务器的负载相对平衡,集群中的一台服务器出现问题,该服务器所负责的业务可以由其他的服务器代为处理.集群是一种物理形态.</p><p>​     <strong>分布式</strong>是把一个业务拆分成多个子业务,给不同的服务器去处理,这里的服务器可以是单个的服务器,也可以是多个服务器集群,一旦处理该业务的服务器出现问题,那么该业务就无法实现了.分布式是一种工作方式.</p><p>​     <strong>微服务</strong>是把一个业务中的各种功能模块进行拆分,给不同的服务去处理,每个服务只处理一个功能模块,该服务可以是单个服务器也可以是多个服务器集群,每个服务之间都是低耦合的.微服务是一种架构风格.</p><p>​    <strong>为什么说分布式不一定是微服务:</strong></p><p>​    假设有一个很大应用,拆分成几个小应用,但还是很庞大,即便使用了分布式,但其依旧不算是微服务,因为微服务的核心要素是微小,简单来说就是这个应用还不够小(嗯..没错就是这样!)</p><p>​            所以我们可以理解为:微服务是分布式的一个子集</p><h3 id="三-应用场景"><a href="#三-应用场景" class="headerlink" title="三.应用场景"></a>三.应用场景</h3><p>假设有一个业务,该业务有5个功能,每个功能单独处理需要1个小时.</p><p>此时,如果只部署一台服务器,则需要5个小时才能处理完该业务,若采用集群或者分布式来处理,结果如下:</p><p>​            1.采用集群处理:提供5台服务器一起处理该业务,则处理每个功能只需12分钟,即处理整个业务只需1个小时</p><p>​    2.采用分布式处理:提供5台服务器,每个服务器处理不同的功能,则一共也只需要一个小时.</p><p>​            该情况下,微服务和分布式的工作原理和最终结果是一样的.</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>​            分布式中的每一个节点,都可以做集群.而集群并不一定就是分布式的.</p><p>​            微服务肯定是分布式的,但分布式不一定是微服务的.</p><p>作者：晔歌歌<br>链接：<a href="https://www.jianshu.com/p/5f157ac8efcf" target="_blank" rel="noopener">https://www.jianshu.com/p/5f157ac8efcf</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>所以说分布式系统其实是一个非常广泛的概念，很多的应用都可以是一个分布式系统，所以我想以我曾经学过的知识微服务，这一方面去了解，或者说是使用：<strong>如何用go编写一个微服务</strong>，也就是分布式系统。</p><p>注：我觉得写go还用前后端耦合，并且还用模板，是非常愚蠢的行为。而微服务是天生前后端分离的（战术后仰）。</p><p>总体分为三个部分：服务注册，服务发现，状态监控。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="创建自定义的日志服务"><a href="#创建自定义的日志服务" class="headerlink" title="创建自定义的日志服务"></a>创建自定义的日志服务</h3><h4 id="实现基本逻辑"><a href="#实现基本逻辑" class="headerlink" title="实现基本逻辑"></a>实现基本逻辑</h4><p>目的在于接受请求，并把请求写入到log里面，是很多应用必备的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为标准库也有一个log，所以可以起一个别名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log *stlog.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的在于把日志写入文件系统</span></span><br><span class="line"><span class="keyword">type</span> fileLog <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fl fileLog)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//首先要打开文件，才能写入</span></span><br><span class="line"><span class="comment">//fl文件路径，os...表示没有则创造，只写，只附加，</span></span><br><span class="line">f, err := os.OpenFile(<span class="keyword">string</span>(fl), os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//defer表示程序最后一定会执行的，这句的意思是必须把文件关闭</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">return</span> f.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把log指向某个文件地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(destination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log = stlog.New(fileLog(destination), <span class="string">"go"</span>, stlog.LstdFlags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/log"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//如果请求是post</span></span><br><span class="line">msg, err := ioutil.ReadAll(request.Body) <span class="comment">//先读取内容</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(msg) == <span class="number">0</span> &#123;         <span class="comment">//如果有错误</span></span><br><span class="line">writer.WriteHeader(http.StatusBadRequest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有错误则写入日志</span></span><br><span class="line">write(<span class="keyword">string</span>(msg))</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//对于其他情况，方法就不进行，直接返回</span></span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%v\n"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写好一个基本的日志服务的逻辑，逻辑较为简单。但还需要完善，接下来就要实现能够运行的日志服务。也就是说，还需要把web服务集中化管理，使其能够正常的运行。</p><p>接着创立一个service，去完善服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, serviceName, host, port <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, serviceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完善了服务启动的逻辑，接着还需要去使这个服务能够正常的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line"><span class="string">"Log service"</span>,</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>接着启动服务，并使用postman进行测试:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:4000/log</span></span><br></pre></td></tr></table></figure><p>输入任意文字，就会看到在根目录下，有一个日志文件生成了。</p><h3 id="服务注册的基本逻辑"><a href="#服务注册的基本逻辑" class="headerlink" title="服务注册的基本逻辑"></a>服务注册的基本逻辑</h3><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>首先需要去尝试编写一下，一个可以将服务都注册进去的注册中心。</p><p>先写一个数据结构，注册中心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注册中心包含了各个服务的名字的地址，紧接着，编写服务注册进去之后的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之后，需要让服务独立运行</p><h4 id="独立服务"><a href="#独立服务" class="headerlink" title="独立服务"></a>独立服务</h4><p>接着就需要将之前的服务，注册到服务中心中。</p><p>这就需要创建一个服务中心主要运行逻辑了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将之前的处理逻辑注册进去</span></span><br><span class="line">http.Handle(<span class="string">"/services"</span>, registry.RegistryService&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的逻辑一样，需要有取消功能，当然其实你在ide中能直接打断，但在大型服务中，每秒都要运行。还是需要自定义取消功能的</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">//一样是定义服务的地址</span></span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = registry.ServerPort</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"注册中心 的服务开始。按任意键停止. \n"</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"结束服务注册"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和日志服务的注册类似，没什么特别的,接着测试：</p><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:3000/services</span></span><br></pre></td></tr></table></figure><p>接着输入json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">     <span class="attr">"serviceName"</span>: <span class="string">"study service"</span>,</span><br><span class="line">    <span class="attr">"serviceURL"</span> : <span class="string">" http://localhost/5000/study"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着显示服务注册成功：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">接受请求：</span><br><span class="line">增加服务：study service ，该服务的//localhost/<span class="number">5000</span>/study</span><br></pre></td></tr></table></figure><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><h4 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h4><p>首先微服务的基本含义是：注册中心是一个服务，然后其他的服务注册到注册中心，然后由主要控制台相互控制和调用。</p><p>那么现在会需要一个客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着需要去改一下日志服务的逻辑，使得日志服务会主动去注册自己：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的<strong>registry.RegisterService(reg)</strong>实际上会去调用client的<strong>func RegisterService(r Registration)</strong>，这样会向注册中心发送一个post请求，去注册自己。</p><p>接着，要去改动日志服务的main函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: <span class="string">"log service"</span>,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是增加了<strong>serviceAddress</strong> ，也就是说所有服务都会使用这同一个逻辑。</p><h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>紧接着两个服务连续启动，先启动注册中心，后启动日志逻辑，结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:4000</span><br></pre></td></tr></table></figure><p>很简单对吧，和Spring cloud的微服务简直一模一样。</p><h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h3><p>那么我们把微服务注册进去了，自然能够调用，但是怎么主动去取消微服务呢？它肯定不是说我自己把自己的微服务关了就行了，同时也需要通知注册中心。</p><h4 id="修改注册中心"><a href="#修改注册中心" class="headerlink" title="修改注册中心"></a>修改注册中心</h4><p>直接在注册中心加上一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[i+<span class="number">1</span>:]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后直接在Switch里面增加一个情况Delete：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清晰，就是一模一样的移除服务，总体代码改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心取消服务的方法定义好了，那么也就需要在其他可注册服务的函数体中定义方法。为了进一步的解除耦合度，取消服务的方法和建立服务的方法一样，需要在client里面编写。</p><h4 id="修改客户端"><a href="#修改客户端" class="headerlink" title="修改客户端"></a>修改客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了ShutdownService去结束这个服务。</p><p>紧接着，去开始服务注册的函数里边，进行取消注册的修改：</p><h4 id="修改服务的注册功能"><a href="#修改服务的注册功能" class="headerlink" title="修改服务的注册功能"></a>修改服务的注册功能</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//启动服务，一旦发生可错误，就取消</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是两个goroutine的修改，使其具有取消服务的功能。</p><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>那么注册中心和服务的逻辑都修改好了，然后和上面的步骤一样，先启动注册中心，后启动日志逻辑，结果为:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止.</span><br><span class="line">q</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">移除服务： <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function"><span class="title">http</span>: <span class="title">Server</span> <span class="title">closed</span></span></span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>前面的服务注册都是一对一的，还体现不了分布式的特点。接下来进行多服务注册，使得一个学生成绩的服务既要使用日志服务，也要注册到注册中心</p><h3 id="业务服务"><a href="#业务服务" class="headerlink" title="业务服务"></a>业务服务</h3><h4 id="基本的数据结构与方法"><a href="#基本的数据结构与方法" class="headerlink" title="基本的数据结构与方法"></a>基本的数据结构与方法</h4><p>首先要编写一个学生的基础信息的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生信息</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">int</span></span><br><span class="line">FirstName <span class="keyword">string</span></span><br><span class="line">LastName  <span class="keyword">string</span></span><br><span class="line">Grades    []Grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分数</span></span><br><span class="line"><span class="keyword">type</span> Grade <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Type  GradeType</span><br><span class="line">Score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GradeType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">//考试类型</span></span><br><span class="line">GradeQuiz = GradeType(<span class="string">"Quiz"</span>)</span><br><span class="line">GradeTest = GradeType(<span class="string">"Test"</span>)</span><br><span class="line">GradeExam = GradeType(<span class="string">"Exam"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的平均成绩</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">Average</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">for</span> _, grade := <span class="keyword">range</span> s.Grades &#123;</span><br><span class="line">result += grade.Score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="keyword">float32</span>(<span class="built_in">len</span>(s.Grades))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找学生 by ID</span></span><br><span class="line"><span class="keyword">type</span> Students []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ss Students)</span> <span class="title">GetByID</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*Student, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ss &#123;</span><br><span class="line"><span class="keyword">if</span> ss[i].ID == id &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ss[i], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生的ID：  %d  未找到"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于外部的访问</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">students      Students</span><br><span class="line">studentsMutex sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着肯定得有一些学生的数据，来做测试，这些数据一开始就会被加载进数据结构中，这暂时是用来代替数据库的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">students = []Student&#123;</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">1</span>,</span><br><span class="line">FirstName: <span class="string">"Nick"</span>,</span><br><span class="line">LastName:  <span class="string">"Carter"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">85</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">82</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">2</span>,</span><br><span class="line">FirstName: <span class="string">"Roberto"</span>,</span><br><span class="line">LastName:  <span class="string">"Baggio"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">81</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">3</span>,</span><br><span class="line">FirstName: <span class="string">"Emma"</span>,</span><br><span class="line">LastName:  <span class="string">"Stone"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">67</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">75</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">4</span>,</span><br><span class="line">FirstName: <span class="string">"Rachel"</span>,</span><br><span class="line">LastName:  <span class="string">"McAdams"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">98</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">99</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">5</span>,</span><br><span class="line">FirstName: <span class="string">"Kelly"</span>,</span><br><span class="line">LastName:  <span class="string">"Clarkson"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">95</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">97</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，也肯定要有server，才能正常的启动服务，需要去编写基本的逻辑，比如获取全部学生信息，根据ID进行信息搜索，增加学生信息等功能：</p><h4 id="服务的逻辑"><a href="#服务的逻辑" class="headerlink" title="服务的逻辑"></a>服务的逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="built_in">new</span>(studentsHandler)</span><br><span class="line"><span class="comment">//这个两个地址是不同的，一个是单个页面</span></span><br><span class="line">http.Handle(<span class="string">"/students"</span>, handler)</span><br><span class="line"><span class="comment">//另一个是必须传入参数的页面</span></span><br><span class="line">http.Handle(<span class="string">"/students/"</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以一个链接需要处理很多情况</span></span><br><span class="line"><span class="comment">// /students 分割后长度是2</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125; 分割后长度是3</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125;/grades  分割后长度是4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//简单对字符进行处理：</span></span><br><span class="line">pathSegments := strings.Split(r.URL.Path, <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(pathSegments) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//获取全部信息</span></span><br><span class="line">sh.getAll(w, r)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//查询</span></span><br><span class="line"><span class="comment">//提取id</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.getOne(w, r, id)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//新增</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.addGrade(w, r, id)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取全部学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getAll</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将学生信息全部转为JSON，返回给data，最后写入</span></span><br><span class="line">data, err := sh.toJSON(students)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据ID，搜索学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getOne</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑与获取全部信息几乎一致</span></span><br><span class="line">data, err := sh.toJSON(student)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Printf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加学生成绩信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">addGrade</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的逻辑一样的，没什么好说</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着要从URL中获取到要传达的学生成绩信息</span></span><br><span class="line"><span class="keyword">var</span> g Grade</span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line">err = dec.Decode(&amp;g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这部分逻辑是获取成绩信息</span></span><br><span class="line"><span class="comment">//如果学生成绩获取正确，就附加信息</span></span><br><span class="line">student.Grades = <span class="built_in">append</span>(student.Grades, g)</span><br><span class="line">w.WriteHeader(http.StatusCreated) <span class="comment">//201</span></span><br><span class="line"></span><br><span class="line">data, err := sh.toJSON(g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"applicaiton/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化为JSON</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">toJSON</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">enc := json.NewEncoder(&amp;b)</span><br><span class="line">err := enc.Encode(obj)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，基础逻辑也已经完善了，接着就是在注册中心里增加服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后，得让web服务可以运行，在cmd文件夹下创建一个新的main函数，写入一样的逻辑代码：</p><h4 id="服务启动器"><a href="#服务启动器" class="headerlink" title="服务启动器"></a>服务启动器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么下来，这个业务服务也就完成了，他们可以互相不干扰的进行服务注册，但是现在grade服务还不能去调用日志服务。所以我们还需要服务发现。</p><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现作用能让grade服务可以请求log服务</p><h4 id="去引用日志服务"><a href="#去引用日志服务" class="headerlink" title="去引用日志服务"></a>去引用日志服务</h4><p>首先肯定是要给服务的数据结构增加一些基本信息，这样才能使得服务有这些基本的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该服务所依赖的其他服务。用slice去保存</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line"><span class="comment">//向外暴露的服务端口</span></span><br><span class="line">ServiceUpdateURL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一条目</span></span><br><span class="line"><span class="keyword">type</span> patchEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Name ServiceName</span><br><span class="line">URL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务变化</span></span><br><span class="line"><span class="keyword">type</span> patch <span class="keyword">struct</span> &#123;</span><br><span class="line">Added   []patchEntry</span><br><span class="line">Removed []patchEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以想想，一个服务如果还依赖着其他的服务。那么，当这个服务正要注册的时候，或者说要加入服务群体的时候。就会在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span></span></span><br></pre></td></tr></table></figure><p>进行服务注册，那么这个时候如果服务还依赖其他服务，比如正要注册的grade服务还依赖log服务，这时候就正好可以去获取依赖。</p><p>修改后代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个找到所需要服务并将其注册的过程。</p><p>接着，grade服务会向注册中心请求这些服务，但是注册中心也需要地方去存储这些请求的服务。</p><p>log服务就会向grade服务提供服务，那么会需要一些数据结构去存储：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去实现它的逻辑，总体修改后代码如下：</p><h4 id="服务的提供者"><a href="#服务的提供者" class="headerlink" title="服务的提供者"></a>服务的提供者</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务注册中心要向URL更新一些信息</span></span><br><span class="line">serviceUpdateURL, err := url.Parse(r.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(serviceUpdateURL.Path, &amp;serviceUpdateHandler&#123;&#125;)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err = enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新服务的处理</span></span><br><span class="line"><span class="keyword">type</span> serviceUpdateHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suh serviceUpdateHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先进行解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line">err := dec.Decode(&amp;p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf("收到更新： %v\n", p)</span></span><br><span class="line">prov.Update(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受到patch的时候，需要进行更新，</span></span><br><span class="line"><span class="keyword">var</span> prov = providers&#123;</span><br><span class="line">services: <span class="built_in">make</span>(<span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span>),</span><br><span class="line">mutex:    <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span> <span class="title">Update</span><span class="params">(pat patch)</span></span> &#123;</span><br><span class="line"><span class="comment">//对传进来的patch更新provider</span></span><br><span class="line">p.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增的情况</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Added &#123;</span><br><span class="line"><span class="comment">//如果这个服务名目前还不存在，就创建新的slice</span></span><br><span class="line"><span class="keyword">if</span> _, ok := p.services[patchEntry.Name]; !ok &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在的话，就在值后边附加URL</span></span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(p.services[patchEntry.Name],</span><br><span class="line">patchEntry.URL)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少的情况</span></span><br><span class="line"><span class="comment">//遍历，对比，移除</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Removed &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs, ok := p.services[patchEntry.Name]; ok &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> providerURLs &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs[i] == patchEntry.URL &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(providerURLs[:i],</span><br><span class="line">providerURLs[i+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后还需要，根据服务的名称来找到它所依赖服务的url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span> <span class="title">get</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">providers, ok := p.services[name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"没有可提供服务的提供商： %v"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机数</span></span><br><span class="line">idx := <span class="keyword">int</span>(rand.Float32() * <span class="keyword">float32</span>(<span class="built_in">len</span>(providers)))</span><br><span class="line"><span class="keyword">return</span> providers[idx], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于这个get方法是私有的，对外再套一个函数：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvider</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> prov.get(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端的client"><a href="#客户端的client" class="headerlink" title="客户端的client"></a>客户端的client</h4><p>log服务现在有服务端的逻辑，但是客户端的服务想使用这个client还是比较麻烦的，所以还需要对log服务有一个自己的client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写日志，把日志写到server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetClientLogger</span><span class="params">(serviceURL <span class="keyword">string</span>, clientService registry.ServiceName)</span></span> &#123;</span><br><span class="line">stlog.SetPrefix(fmt.Sprintf(<span class="string">"[%v] - "</span>, clientService))</span><br><span class="line">stlog.SetFlags(<span class="number">0</span>)</span><br><span class="line">stlog.SetOutput(&amp;clientLogger&#123;url: serviceURL&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> clientLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">url <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl clientLogger)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">b := bytes.NewBuffer([]<span class="keyword">byte</span>(data))</span><br><span class="line"><span class="comment">//写到服务端</span></span><br><span class="line">res, err := http.Post(cl.url+<span class="string">"/log"</span>, <span class="string">"text/plain"</span>, b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to send log message. Service responded with %d - %s"</span>, res.StatusCode, res.Status)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果都没有问题，返回数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以让本地的日志服务写好日志后发送到服务器端保存</p><h4 id="使main函数具有服务发现的功能"><a href="#使main函数具有服务发现的功能" class="headerlink" title="使main函数具有服务发现的功能"></a>使main函数具有服务发现的功能</h4><p>主要是使得两个启动器拥有新的功能：</p><h5 id="grading-service"><a href="#grading-service" class="headerlink" title="grading service"></a>grading service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: []registry.ServiceName&#123;registry.LogService&#125;,</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在服务启动之后使用log服务</span></span><br><span class="line"><span class="keyword">if</span> logProvider, err := registry.GetProvider(registry.LogService); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"发现日志服务: %s\n"</span>, logProvider)</span><br><span class="line">log.SetClientLogger(logProvider, r.ServiceName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="log-service"><a href="#log-service" class="headerlink" title="log service"></a>log service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.LogService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: <span class="built_in">make</span>([]registry.ServiceName, <span class="number">0</span>),</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来便可以测试了。</p><h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><p>按照：registryservice，logservice，gradingservice的顺序启动，测试结果如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span> </span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">GradingService 服务开始。按任意键停止.</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br></pre></td></tr></table></figure><p>这么一来就完成了。</p><h3 id="依赖变化"><a href="#依赖变化" class="headerlink" title="依赖变化"></a>依赖变化</h3><h4 id="重新发现服务"><a href="#重新发现服务" class="headerlink" title="重新发现服务"></a>重新发现服务</h4><p>可以从上述的情况下看到一些不那么方便的点，一是：启动必须按照顺序来，不能随意。二是：当log服务下线后，再上线的话不会被再次发现。这都是服务极为脆弱的表现。那么解决这个问题的最好方法是：使服务具有依赖变化时进行通知的功能。</p><p>可以在服务中更改，使其具备通知的功能,主要是有notify函数，总体修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务通知，当服务上线，而这个服务又被依赖时，告知依赖服务自己上线了</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Added: []patchEntry&#123;</span><br><span class="line">patchEntry&#123;</span><br><span class="line">Name: reg.ServiceName,</span><br><span class="line">URL:  reg.ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">notify</span><span class="params">(fullPatch patch)</span></span> &#123;</span><br><span class="line">r.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> r.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//看看服务的依赖在patch里面存不存在</span></span><br><span class="line"><span class="comment">//对已经注册的服务循环遍历</span></span><br><span class="line"><span class="keyword">for</span> _, reg := <span class="keyword">range</span> r.registrations &#123;</span><br><span class="line"><span class="comment">//并发的发出通知</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reg Registration)</span></span> &#123;</span><br><span class="line"><span class="comment">//对服务所需要的服务进行循环</span></span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line">p := patch&#123;Added: []patchEntry&#123;&#125;, Removed: []patchEntry&#123;&#125;&#125;</span><br><span class="line"><span class="comment">//标志位，为TRUE表示有需要更新的地方</span></span><br><span class="line">sendUpdate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, added := <span class="keyword">range</span> fullPatch.Added &#123;</span><br><span class="line"><span class="comment">//如果添加的服务正好是某个服务的依赖项</span></span><br><span class="line"><span class="keyword">if</span> added.Name == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, added)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看有哪些服务停止了</span></span><br><span class="line"><span class="keyword">for</span> _, removed := <span class="keyword">range</span> fullPatch.Removed &#123;</span><br><span class="line"><span class="comment">///如果停掉的服务正好是所被依赖的服务</span></span><br><span class="line"><span class="keyword">if</span> removed.Name == reqService &#123;</span><br><span class="line">p.Removed = <span class="built_in">append</span>(p.Removed, removed)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后判断标志位，把更新发送到对应的服务</span></span><br><span class="line"><span class="keyword">if</span> sendUpdate &#123;</span><br><span class="line">err := r.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(reg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><p>接着再进行测试，可以看到，当log服务下线后，重新上线时，grading 服务就能够发现log服务了。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125; &#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br></pre></td></tr></table></figure><h4 id="服务下线告知"><a href="#服务下线告知" class="headerlink" title="服务下线告知"></a>服务下线告知</h4><p>接着也容易，把remove方法里面添加下线告知的功能就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下线也告知</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Removed: []patchEntry&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: registry.registrations[i].ServiceName,</span><br><span class="line">URL:  registry.registrations[i].ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//下线告知</span></span><br><span class="line"></span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这部分逻辑就完成了。接下来测试代码。</p><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><p>测试的步骤是先开启注册中心，再开启日志服务，后开始grade服务。然后使得日志服务停止，再重启。可以看到一系列的结果。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span></span><br><span class="line">移除服务： http://localhost:<span class="number">4000</span></span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line">收到更新： &#123;[] []&#125;</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"><span class="title">LogService</span> 服务开始。按任意键停止</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">GradingService</span> 服务开始。按任意键停止.</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br><span class="line"><span class="function">发现日志服务: <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function">收到更新： &#123;[] [&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;]&#125;</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br></pre></td></tr></table></figure><p>使用解除了耦合的网络接口，这也是Spring Cloud的微服务思想，同时也是分布式的一种类型。所以说分布式也没什么神奇之处，最核心的一处在于：<strong>把本地接口转化为了网络接口</strong>。能够理解这一过程，也就理解了分布式的思想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习遇到的问题</title>
      <link href="/2022/04/27/go-language-error-problem/"/>
      <url>/2022/04/27/go-language-error-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="go语言学习遇到的问题"><a href="#go语言学习遇到的问题" class="headerlink" title="go语言学习遇到的问题"></a>go语言学习遇到的问题</h1><p>最近在努力学习go，这个编程语言语法和写法的都和其他的编程语言有着比较大的差异。所以特地记录一下学习go遇到的问题。</p><h2 id="GOPATH和go-module"><a href="#GOPATH和go-module" class="headerlink" title="GOPATH和go module"></a>GOPATH和go module</h2><p>这个问题比较神奇，也是我学习这个编程语言中遇到的比较拧巴的问题。网上的绝大多数的教程都会让你配置GOPATH，然后go程序都必须在GOPATH的SRC这个文件下运行，而这个GOPATH是你windows的环境变量。</p><p><strong>在以前GOPATH下会对go程序的编写严格进行，必须在src下，并且在很多包，或者git下其他的程序之后，整个项目就会变得非常混乱</strong>。</p><p>这样听起来很奇怪不是吗？身为一个比较新鲜的编程语言，既然会有这么愚蠢的方法。</p><p>而网上的教程绝大多数度是让你去配置环境，最后用vscode去编写go程序，但是我自己在用IDEA去写的时候却不会遇到要配置GOPATH这个问题，这是为什么呢？然后我去网上进行了一番搜索之后，了解了一个新鲜的事物，叫做go module。</p><p>而go 1.13版本之后就支持了go module，这使得程序的编写不用在指定的文件夹进行，而是用模块化的方式去编写程序。</p><p>而现在，在有了MODULE之后，GOPATH现在常用于存放第三方API，不进行程序编写了。go module允许go在任意地方进行编写，非常人性化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当你在GOPATH下使用go module时</span><br><span class="line">用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</span><br><span class="line"></span><br><span class="line">GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</span><br><span class="line">GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</span><br><span class="line">GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。</span><br><span class="line">但是我建议新开别的文件夹去写go程序，不要在GoPATH下</span><br></pre></td></tr></table></figure><p>所以，我们应该<strong>使用 go mod init your_project_name</strong></p><p>去实现go的模块化编写</p><h2 id="浅拷贝和深拷贝的问题"><a href="#浅拷贝和深拷贝的问题" class="headerlink" title="浅拷贝和深拷贝的问题"></a>浅拷贝和深拷贝的问题</h2><p>在我用go写leetcode39的时候，遇到了一个奇怪的问题，我加入ans的值是【2,2,2,3】，可是运行结果后，值就变为【2,2,2,1】了，真是奇怪。我在func中有且仅有一个对ans的操作，这真的让我思考了很久，然后一个一个的debug。。。。。。。。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">   ans = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">var</span> currentArray []<span class="keyword">int</span></span><br><span class="line">   <span class="comment">//不断递归搜索的问题</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">      currentArray = <span class="literal">nil</span></span><br><span class="line">      currentArray = <span class="built_in">append</span>(currentArray, candidates[i])</span><br><span class="line">      <span class="comment">//如果当前就是，那么久不用继续了</span></span><br><span class="line">      <span class="keyword">if</span> candidates[i] == target &#123;</span><br><span class="line">         singerAns := []<span class="keyword">int</span>&#123;candidates[i]&#125;</span><br><span class="line">         ans = <span class="built_in">append</span>(ans, singerAns)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//否则递归性搜索</span></span><br><span class="line">         combinationSumRecursiveFunction(candidates, currentArray, i, candidates[i], target)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//for i := 0; i &lt; len(ans); i++ &#123;</span></span><br><span class="line">   <span class="comment">// sum := 0</span></span><br><span class="line">   <span class="comment">// for j := 0; j &lt; len(ans[i]); j++ &#123;</span></span><br><span class="line">   <span class="comment">//    sum += ans[i][j]</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="comment">// if sum != target &#123;</span></span><br><span class="line">   <span class="comment">//    fmt.Println(ans[i])</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSumRecursiveFunction</span><span class="params">(candidates, currentArray []<span class="keyword">int</span>, begin, sum, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := begin; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> candidates[i]+sum == target &#123;</span><br><span class="line">         <span class="comment">//不要去改动currentArray</span></span><br><span class="line">         <span class="comment">//等于就加入ans</span></span><br><span class="line">       correctArr := currentArray</span><br><span class="line">         correctArr = <span class="built_in">append</span>(correctArr, candidates[i])</span><br><span class="line">         ans = <span class="built_in">append</span>(ans, correctArr)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> candidates[i]+sum &lt; target &#123;</span><br><span class="line">         <span class="comment">//小于则可以直接递归，再次搜索</span></span><br><span class="line">         smallerArr := currentArray</span><br><span class="line">         smallerArr = <span class="built_in">append</span>(smallerArr, candidates[i])</span><br><span class="line">         combinationSumRecursiveFunction(candidates, smallerArr, i, candidates[i]+sum, target)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//大于则没有继续搜索的必要了，什么都不做就可以了</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans [][]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>最后，我花了一个小时，终于找到了问题所在，问题在于这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">correctArr := currentArray</span><br><span class="line">correctArr = <span class="built_in">append</span>(correctArr, candidates[i])</span><br><span class="line"><span class="comment">//========================================================================================</span></span><br><span class="line">smallerArr := currentArray</span><br><span class="line">smallerArr = <span class="built_in">append</span>(smallerArr, candidates[i])</span><br></pre></td></tr></table></figure><p>它们之间是浅拷贝关系，我对smallerArr 进行append也会影响到已经加入了ans的数组！！！！！</p><ol><li>调用append函数时，当原有长度加上新追加的长度如果超过容量则会新建一个数组，新旧切片会指向不同的数组；</li><li>如果没有超过容量则在原有数组上追加元素，新旧切片会指向相同的数组，这时对其中一个切片的修改会同时影响到另一个切片。</li></ol><p>改动了正确代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">ans = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> currentArray []<span class="keyword">int</span></span><br><span class="line"><span class="comment">//不断递归搜索的问题</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">currentArray = <span class="literal">nil</span></span><br><span class="line">currentArray = <span class="built_in">append</span>(currentArray, candidates[i])</span><br><span class="line"><span class="comment">//如果当前就是，那么久不用继续了</span></span><br><span class="line"><span class="keyword">if</span> candidates[i] == target &#123;</span><br><span class="line">singerAns := []<span class="keyword">int</span>&#123;candidates[i]&#125;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, singerAns)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//否则递归性搜索</span></span><br><span class="line">combinationSumRecursiveFunction(candidates, currentArray, i, candidates[i], target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; len(ans); i++ &#123;</span></span><br><span class="line"><span class="comment">//sum := 0</span></span><br><span class="line"><span class="comment">//for j := 0; j &lt; len(ans[i]); j++ &#123;</span></span><br><span class="line"><span class="comment">//sum += ans[i][j]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//if sum != target &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println(ans[i])</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSumRecursiveFunction</span><span class="params">(candidates, currentArray []<span class="keyword">int</span>, begin, sum, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := begin; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> candidates[i]+sum == target &#123;</span><br><span class="line"><span class="comment">//不要去改动currentArray</span></span><br><span class="line"><span class="comment">//等于就加入ans</span></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line">correctArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(currentArray))</span><br><span class="line"><span class="built_in">copy</span>(correctArr, currentArray)</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="comment">//correctArr := currentArray</span></span><br><span class="line">correctArr = <span class="built_in">append</span>(correctArr, candidates[i])</span><br><span class="line">ans = <span class="built_in">append</span>(ans, correctArr)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> candidates[i]+sum &lt; target &#123;</span><br><span class="line"><span class="comment">//小于则可以直接递归，再次搜索</span></span><br><span class="line">smallerArr := currentArray</span><br><span class="line">smallerArr = <span class="built_in">append</span>(smallerArr, candidates[i])</span><br><span class="line">combinationSumRecursiveFunction(candidates, smallerArr, i, candidates[i]+sum, target)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//大于则没有继续搜索的必要了，什么都不做就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans [][]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>未完待续。。。。。</p><p><strong>1、深拷贝（Deep Copy）：</strong></p><p>拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。</p><p>值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。</p><p><strong>2、浅拷贝（Shallow Copy）：</strong></p><p>拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。</p><p>引用类型的数据，默认全部都是浅复制，Slice，Map。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目--SpringBoot+Vue交易平台</title>
      <link href="/2021/02/06/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C3/"/>
      <url>/2021/02/06/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C3/</url>
      
        <content type="html"><![CDATA[<h1 id="项目–SpringBoot-Vue交易平台"><a href="#项目–SpringBoot-Vue交易平台" class="headerlink" title="项目–SpringBoot+Vue交易平台"></a>项目–SpringBoot+Vue交易平台</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人做了一个交易平台，后端是SpringBoot，前端是Vue。这个电商平台有分<strong>商家页面</strong>和<strong>普通用户页面</strong>，后续还会增加一个独属于<strong>管理员的页面</strong>。这个电商平台通过<strong>QQ登录进行注册</strong>，并且为每一个注册的的用户分配一个默认好友，可以进行聊天，每一个普通的用户都可以通过申请提交成为一名商家，成为商家之后才可以进行增加自家的商品。</p><p>其实本人之前也做过一个前后的耦合的thymeleaf和SpringBoot的商城，后续也曾想过下一个项目是不是该做一个博客，音乐平台，或者是视频网站，最后考虑到，用工具的方法有千千万万，重要的是对工具的了解程度如何，你能不能更加深入的对单个方面有较为深刻的理解，于是这个项目也是一个电商平台，但在实现了前后端分离的同时，还加入了很多新的技术，并且在一些方面有了更为优秀的解决方案。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>看文章有时候就和看别人家的注释一样，不一定能快速分清楚对方的注释是关键语句还是在水代码行数，所以前面先列出本人做的项目的特点，节约一下阅读的时间，后面会有较为详细的描述。</p><p><strong>实现的模板</strong>：基本CRUD和购物车，秒杀商品，搜索，Socket通信，security安全拦截，微服务等。</p><p><strong>一些特点</strong>：</p><ul><li>使用了redis，在用户访问商品时候会把商品放入redis缓存器，减少数据库的频繁访问，并且使用redis集群实现数据的安全</li><li>使用了redis实现了商品的秒杀，对突然间大量的请求会将其放入redis而不放入数据库，等秒杀活动过了一定时间再使用定时任务，慢慢写入数据库，由于redis的单线程保证了秒杀的安全，也减少了数据库的访问压力，后续的云服务还可以通过将商品放入消息队列的方式，进一步提高性能。</li><li>图片的类型是String，而不是流文件，这里结合了七牛云做图床，实现图片数据库和本地数据库的分离</li><li>每一个用户会有一个默认的好友，以用来测试socket模块，socket模块实现了用户的实时在线聊天，并且还会保存用户的聊天信息。</li><li>申请了QQ互联的功能，只需要QQ扫码便可以进行登录，QQ互联是和VUE 进行结合的，会产生一个全局的JWT来保证用户的权限认证，后端的security也是用JWT来和前端进行权限认证</li><li>搜索模块结合了Elasticsearch，以便于用户进行模糊类型的搜索</li><li>商品平台里面的数据是使用Jsoup爬虫从京东爬取而来的，并且使用雪花算法为每一个商品生成了一个全局唯一的UID</li><li>结合eureka和ribbon实现注册中心和负载均衡，降低访问压力</li></ul><h2 id="项目讲述"><a href="#项目讲述" class="headerlink" title="项目讲述"></a>项目讲述</h2><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><ol><li>SpringBoot （后端）</li><li>MySQL （数据库）</li><li>MyBatis （访问数据库）</li><li>swagger （集成文档）</li><li>SpringSecurity （登录与权限控制）</li><li>JWT （单点登录）</li><li>Jsoup （爬虫，用于补充数据库的数据）</li><li>fastjson （转JSON工具，用于前后端数据交互）</li><li>七牛云 （图床）</li><li>netty-socketio （用于用户之间的通信）</li><li>qq互联 （实现QQ登录）</li><li>redis （中间件，用于数据的缓存）</li><li>elasticsearch （搜索引擎）</li><li>spring-boot-admin （管理后台）</li><li>eureka （微服务的注册中心）</li><li>ribbon （负载均衡）</li><li>docker （容器化）</li><li>Nginx （反向代理）</li><li>aliyunEcs （服务器）</li><li>vue （前端）</li><li>axios （前端api） </li><li>Element-ui （前端UI）</li></ol><h3 id="基本CRUD"><a href="#基本CRUD" class="headerlink" title="基本CRUD"></a>基本CRUD</h3><p>无聊的操作总是千篇一律，有意思的源码也可能涉及跨域。</p><p>一个基本的CRUD，是由mybatis来操作mysql数据库来实现的，mybatis其实也很讲究，有一级缓存二级缓存等等很多原理，mysql也有innodb等等知识，然而这东西在讲系统时讲出来比较麻烦，所以在这篇展示项目的文章中，我仅仅根据我的所写的代码去讲述为什么需要这么写，暂时不写这些工具的原理。</p><p>这个是mybatis中mapper的规范，所有的命名都是根据以下来确定的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">countByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * delete by primary key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id primaryKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deleteCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert record to table</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> insert count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrUpdate</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrUpdateSelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert record to table selective</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> insert count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">selectByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * select by primary key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id primary key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object by primary key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Product <span class="title">selectByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleSelective</span><span class="params">(@Param(<span class="string">"record"</span>)</span> Product record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> ProductExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExample</span><span class="params">(@Param(<span class="string">"record"</span>)</span> Product record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> ProductExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update record selective</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the updated record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update record</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the updated record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBatch</span><span class="params">(List&lt;Product&gt; list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">batchInsert</span><span class="params">(@Param(<span class="string">"list"</span>)</span> List&lt;Product&gt; list)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中运用到了插件mybatiscodehelper</p><p>在控制层中有一个 <strong>BaseController</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而全部的控制器都是通过继承来实现依赖注入的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span>  <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样继承省去了很多代码量</p><p>在后端中，购物车模块的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/add_all_cart_order"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">add_all_cart_order</span><span class="params">(@Validated @RequestBody List&lt;OrderSheet&gt; orderSheets , HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    BigDecimal sum=<span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (OrderSheet o:orderSheets) &#123;<span class="comment">//List&lt;OrderSheet&gt; orderSheets</span></span><br><span class="line">        sum.add(o.getSumMoney());</span><br><span class="line">    &#125;</span><br><span class="line">    String state=<span class="string">"余额不足"</span>;</span><br><span class="line">    User user=userService.selectById(orderSheets.get(<span class="number">0</span>).getUserId());</span><br><span class="line">    BigDecimal money=user</span><br><span class="line">            .getMoney()</span><br><span class="line">            .subtract(sum);</span><br><span class="line">    <span class="keyword">if</span> (money.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">0</span>))==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (OrderSheet o:orderSheets) &#123;<span class="comment">//List&lt;OrderSheet&gt; orderSheets</span></span><br><span class="line">        o.setState(<span class="string">"未收货"</span>);</span><br><span class="line">        orderSheetService.insert(o);</span><br><span class="line">        shoppingCartService.deleteByPrimaryKey(o.getId());</span><br><span class="line">        user.setMoney(user.getMoney().subtract(sum));</span><br><span class="line">        userService.updateByPrimaryKey(user);</span><br><span class="line">        state=<span class="string">"支付成功"</span>;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(state);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数支付方面的代码都与其类似。</p><h3 id="秒杀商品"><a href="#秒杀商品" class="headerlink" title="秒杀商品"></a>秒杀商品</h3><p>首先我先举例一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addorder"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">add_order</span><span class="params">(@Validated @RequestBody OrderSheet orderSheet, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        orderSheet.setId(<span class="keyword">new</span> RandomId().nextId());</span><br><span class="line">        orderSheet.setTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        Product product=productService.selectOneById(orderSheet.getProductId());</span><br><span class="line">        orderSheet.setSumMoney(product.getPrice().multiply(<span class="keyword">new</span> BigDecimal(orderSheet.getAmount())));</span><br><span class="line"><span class="comment">//        redis缓存放入</span></span><br><span class="line">        Boolean success=orderRedis.addOrderByRedis(orderSheet);</span><br><span class="line">        String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(message, <span class="string">"抢购失败"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.succ(message);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        redis缓存放入</span></span><br><span class="line">        orderSheetService.insert(orderSheet);</span><br><span class="line">        <span class="keyword">return</span> Result.succ(JSONObject.toJSONString(orderSheet.getId(),<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>orderSheetService</strong>就是可以被替换为秒杀模块，通过<strong>orderRedis.addOrderByRedis</strong>来实现将商品放入redis，而不涉及数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRedisImpl</span> <span class="keyword">implements</span> <span class="title">OrderRedis</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">addOrderByRedis</span><span class="params">(OrderSheet orderSheet)</span> </span>&#123;</span><br><span class="line">        Long productId = orderSheet.getProductId();</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!jedis.exists(<span class="string">"product_stock_"</span>+productId))&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = jedis.get((<span class="string">"get_product_"</span>+productId).getBytes());</span><br><span class="line">                Product p =(Product) SerializeUtil.unserialize(bytes);</span><br><span class="line">                jedis.set(<span class="string">"product_stock_"</span>+productId,p.getStock()+<span class="string">""</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis.get(<span class="string">"product_stock_"</span>+productId).equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                jedis.decrBy(<span class="string">"product_stock_"</span>+productId , <span class="number">1</span>);</span><br><span class="line">                jedis.lpush((<span class="string">"order_product_"</span>+productId).getBytes() ,SerializeUtil.serialize(orderSheet));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.destroy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法比较简易，这里使用的是Jedis，通过从线程池里获取Jedis的方式保证了Jedis的线程安全，然后由于redis是单线程的，所以Jedis的API的所有操作都具有着原子性。以此实现线程安全的同时能够把数据放入redis 当中，然后通过<strong>TaskService</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 每天半夜1点钟开始执行任务</span></span><br><span class="line"><span class="comment">//    @Scheduled(cron = "0 0 1 * * ?")</span></span><br><span class="line">    <span class="comment">// 下面是用于测试的配置，每分钟执行一次任务</span></span><br><span class="line">     <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"定时任务开始......"</span>);</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; bytes=jedis.lrange(<span class="string">"order_product_885036"</span>.getBytes(), <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span>[] b:bytes) &#123;</span><br><span class="line">            OrderSheet orderSheet =(OrderSheet) SerializeUtil.unserialize(b);</span><br><span class="line">            System.out.println(JSON.toJSONString(orderSheet));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"定时任务结束......"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/// ... 当关闭应用程序时:</span></span><br><span class="line">        pool.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后半夜时分，再将任务写入数据库。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索模块用的是Elasticsearch，这里不得不吐槽一下Elasticsearch的Api更新速度飞快，版本更新也很快，动不动就方法废弃，部署起来真的是不容易：</p><p>现在版本，根据官方文档来看，需要配置  <strong>RestHighLevelClient</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientConfiguration configuration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">"192.168.78.128:9200"</span>)</span><br><span class="line"><span class="comment">//                .connectedTo("localhost:9200")</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//.withConnectTimeout(Duration.ofSeconds(5))</span></span><br><span class="line">                <span class="comment">//.withSocketTimeout(Duration.ofSeconds(3))</span></span><br><span class="line">                <span class="comment">//.useSsl()</span></span><br><span class="line">                <span class="comment">//.withDefaultHeaders(defaultHeaders)</span></span><br><span class="line">                <span class="comment">//.withBasicAuth(username, password)</span></span><br><span class="line">                <span class="comment">// ... other options</span></span><br><span class="line">                .build();</span><br><span class="line">        RestHighLevelClient client = RestClients.create(configuration).rest();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过继承<strong>ElasticsearchRepository</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span> ,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findAllByNameLike</span><span class="params">(String  name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/es_search_product_by_name/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">es_search_product_by_name</span><span class="params">(@PathVariable(name = <span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">    List&lt;Product&gt; allByNameLike = productRepository.findAllByNameLike(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(allByNameLike);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聊天模块"><a href="#聊天模块" class="headerlink" title="聊天模块"></a>聊天模块</h3><p>聊天模块需要配置<strong>SocketIoConfig</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.bossCount&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bossCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.workCount&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.allowCustomRequests&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowCustomRequests;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.upgradeTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> upgradeTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.pingTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pingTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.pingInterval&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下配置在上面的application.yml中已经注明</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例化socketIo的服务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SocketConfig socketConfig = <span class="keyword">new</span> SocketConfig();</span><br><span class="line">        socketConfig.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">        socketConfig.setSoLinger(<span class="number">0</span>);</span><br><span class="line">        com.corundumstudio.socketio.Configuration config = <span class="keyword">new</span> com.corundumstudio.socketio.Configuration();</span><br><span class="line">        config.setSocketConfig(socketConfig);</span><br><span class="line">        <span class="comment">//线上不能使用hostname，血坑</span></span><br><span class="line"><span class="comment">//        config.setHostname(host);</span></span><br><span class="line">        config.setPort(port);</span><br><span class="line">        config.setBossThreads(bossCount);</span><br><span class="line">        config.setWorkerThreads(workCount);</span><br><span class="line">        config.setAllowCustomRequests(allowCustomRequests);</span><br><span class="line">        config.setUpgradeTimeout(upgradeTimeout);</span><br><span class="line">        config.setPingTimeout(pingTimeout);</span><br><span class="line">        config.setPingInterval(pingInterval);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不得不再提一下，聊天记录所用的类有哪些属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"com-sodse-trade-domain-ChatRecord"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRecord</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是自己发送为1，不是自己发送为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"是自己发送为1，不是自己发送为0"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer isSend;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 聊天对象id</span></span><br><span class="line"><span class="comment">     * 每当用户发送一条信息，都会写入一次数据库，其中is_send为1表示自己发的，然后同时给被接受者反向写入id但是send值为0，表示被接收。</span></span><br><span class="line"><span class="comment">     * 第二，当用户删除自己的聊天框时，使用delete把该用户id和对象的id全部满足的记录删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"聊天对象id ,每当用户发送一条信息，都会写入一次数据库，其中is_send为1表示自己发的，然后同时给被接受者反向写入id但是send值为0，表示被接收。,第二，当用户删除自己的聊天框时，使用delete把该用户id和对象的id全部满足的记录删除"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long talkerId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最为关键的方法<strong>SocketIoService</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"socketIOService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoServiceImpl</span> <span class="keyword">implements</span> <span class="title">SocketIoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存已连接的客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketIOClient&gt; clientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * socketIo的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SocketIOServer socketIOServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：当前的service被初始化的时候执行以下的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoStartUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：当我们的系统停止的时候关闭我们的socketIo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoStop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听客户端连接</span></span><br><span class="line">        socketIOServer.addConnectListener(client -&gt; &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此处实现我们的socket的连接的用户的逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String loginUser = getParamsByClient(client).get(<span class="string">"loginUser"</span>).get(<span class="number">0</span>);</span><br><span class="line">            clientMap.put(loginUser, client);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听客户端断开连接</span></span><br><span class="line">        socketIOServer.addDisconnectListener(client -&gt; &#123;</span><br><span class="line">            String loginUser = getParamsByClient(client).get(<span class="string">"loginUser"</span>).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (loginUser != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(loginUser)) &#123;</span><br><span class="line">                clientMap.remove(loginUser);</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理自定义的事件，与连接监听类似</span></span><br><span class="line">        socketIOServer.addEventListener(PUSH_EVENT, PushMessage<span class="class">.<span class="keyword">class</span>, (<span class="title">client</span>, <span class="title">data</span>, <span class="title">ackSender</span>) -&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// TODO do something</span></span><br><span class="line">        &#125;);</span><br><span class="line">        socketIOServer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socketIOServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            socketIOServer.stop();</span><br><span class="line">            socketIOServer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：发送消息到前端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushMessage 发送消息的实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMessageToUser</span><span class="params">(PushMessage pushMessage)</span> </span>&#123;</span><br><span class="line">        clientMap.get(pushMessage.getLoginUser()).sendEvent(PUSH_EVENT, pushMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法为获取client连接中的参数，可根据需求更改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; getParamsByClient(SocketIOClient client) &#123;</span><br><span class="line">        <span class="comment">// 从请求的连接中拿出参数</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = client.getHandshakeData().getUrlParams();</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最为关键的语句我认为应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketIOClient&gt; clientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>通过建立一个<strong>ConcurrentHashMap</strong>，socket能够检测用户是否在线，在线就将用户put进ConcurrentHashMap，不在线就将其移除，若被发送消息的用户在线时，socket就会将这个消息通过ConcurrentHashMap中获得的用户信息来发送给相应的用户，这个特点在于这是后端主动发起消息给前端的，也是我在考虑到了聊天消息是怎么产生的时候，所了解的。</p><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>之前实现过一个前后端耦合的商城，那里的Security配置都比较简单，而这里用的是前后端分离的vue和springboot结合，两者甚至都不在同一个端口，所以这里的security配置也有了很大的改观，并且利用了jwt来作为两个端口的认证凭证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( AuthenticationManagerBuilder auth )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService( myUserDetailsService ).passwordEncoder( <span class="keyword">new</span> BCryptPasswordEncoder() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( HttpSecurity httpSecurity )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line"></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line"></span><br><span class="line">                <span class="comment">//关闭防护</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(<span class="string">"/"</span>).permitAll()<span class="comment">//允许/、/login的访问</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(<span class="string">"/user"</span>).hasRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/user下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin"</span>).hasRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/register"</span>).permitAll()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启跨域</span></span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line"><span class="comment">//                .exceptionHandling().accessDeniedPage("/accessDenied")</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用的是：<strong>auth.userDetailsService( myUserDetailsService ).passwordEncoder( new BCryptPasswordEncoder() );</strong>也就是myUserDetailsService所继承的UserDetails通过重写方法来进行的密码认证。</p><p>在登录阶段，使用的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServiceImpl</span> <span class="keyword">implements</span> <span class="title">AuthService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">( String username, String password )</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken upToken = <span class="keyword">new</span> UsernamePasswordAuthenticationToken( username, password );</span><br><span class="line">        <span class="keyword">final</span> Authentication authentication = authenticationManager.authenticate(upToken);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        <span class="keyword">final</span> UserDetails userDetails = userDetailsService.loadUserByUsername( username );</span><br><span class="line">        <span class="keyword">final</span> String token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">register</span><span class="params">( User userToAdd )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String username = userToAdd.getUsername();</span><br><span class="line">        <span class="keyword">if</span>( !userService.findByUsername(username).isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当用户不存在时</span></span><br><span class="line">        userToAdd=qq_register(userToAdd);</span><br><span class="line">        <span class="comment">//qq注册的处理</span></span><br><span class="line">        BCryptPasswordEncoder encoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        <span class="keyword">final</span> String rawPassword = userToAdd.getPassword();</span><br><span class="line">        userToAdd.setPassword( encoder.encode(rawPassword) );</span><br><span class="line">        <span class="keyword">return</span> userService.insert(userToAdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>jwtTokenUtil.generateToken(userDetails)</strong>，来对Security内置的UserDetails生成JWT</p><p>这里还有一个JWT的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span> <span class="params">( HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String authHeader = request.getHeader( Const.HEADER_STRING );</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith( Const.TOKEN_PREFIX )) &#123;</span><br><span class="line">            <span class="keyword">final</span> String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                        UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                                userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                        authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                                request));</span><br><span class="line">                        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这拦截器首先在<strong>WebSecurityConfig</strong>中被定义了，Security就会使用这个拦截器来作为<strong>authenticationTokenFilter</strong>的认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>在这一模块仅仅使用了eureka和ribbon，eureka作为注册中心，而ribbon作为负载均衡，当然，后续可以使用feign来进行负载均衡。并且还可在多模块的时候再继续使用Hystrix来实现服务熔断，以及和zipkin来实现分布式的链路追踪。</p><p>新建一个工程，配置eureka-server,并且在application.yml文件中配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">eureka_server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">      <span class="attr">hostname:</span> <span class="string">eureka_server_8761</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">service-url:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>同样的在原来的主体工程中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#注册服务的时候使用ip</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">service-url:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>就已经实现了注册中心，然后就是负载均衡：</p><p>在主体工程中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启发现服务功能</span></span><br></pre></td></tr></table></figure><p>并且添加RestTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span><span class="comment">//使用负载均衡机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而controller中注入RestTemplate来实现负载均衡。</p><p>后续暂无。。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MyBatis </tag>
            
            <tag> MySQL </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> Redis </tag>
            
            <tag> 七牛云 </tag>
            
            <tag> JWT </tag>
            
            <tag> 项目 </tag>
            
            <tag> Vue </tag>
            
            <tag> Element—ui </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker搭建Redis集群</title>
      <link href="/2021/02/01/redis5/"/>
      <url>/2021/02/01/redis5/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Docker搭建Redis集群"><a href="#使用Docker搭建Redis集群" class="headerlink" title="使用Docker搭建Redis集群"></a>使用Docker搭建Redis集群</h2><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先需要使用docker下载安装好redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5.0.2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span> 到 /root/workspace/</span></span><br><span class="line">mkdir -p  /docker/redis-node01/data</span><br><span class="line">mkdir -p  /docker/redis-node02/data</span><br><span class="line">mkdir -p  /docker/redis-node03/data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署Redis集群，该集群有3个节点 </span></span><br><span class="line">docker create --name redis-node01 --privileged=true -v /root/workspace/docker/redis-node01/data:/data -p 6379:6379 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-01.conf --port 6379</span><br><span class="line"></span><br><span class="line">docker create --name redis-node02 --privileged=true -v /root/workspace/docker/redis-node02/data:/data -p 6380:6380 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-02.conf --port 6380</span><br><span class="line"></span><br><span class="line">docker create --name redis-node03 --privileged=true -v /root/workspace/docker/redis-node03/data:/data -p 6381:6381 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-03.conf --port 6381</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span></span><br><span class="line">docker start redis-node01 redis-node02 redis-node03</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/1.png" alt="图"></p><p>启动完容器后查看容器IP,这一步极为关键</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器ip</span></span><br><span class="line">docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' redis-node01 redis-node02 redis-node03</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/2.png" alt="图"></p><p>接着为第一个节点搭建集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入redis-node01容器进行操作</span></span><br><span class="line">docker exec -it redis-node01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建redis集群</span></span><br><span class="line">redis-cli --cluster create 172.17.0.3:6379 172.17.0.4:6380 172.17.0.5:6381 --cluster-replicas 0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/3.png" alt="图"></p><p><strong>搭建完成，查看集群信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看集群信息</span></span><br><span class="line"> redis-cli</span><br><span class="line"> 127.0.0.1:6379&gt; cluster nodes</span><br><span class="line"> </span><br><span class="line"> 127.0.0.1:6379&gt; cluster info</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/4.png" alt="图"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>然后使用redis可视化工具测试一下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/5.png" alt="图"></p><p>为节点增加值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/6.png" alt="图"></p><p>查看值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/7.png" alt=""></p><p>搭建完成了，非常之简单</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Elasticsearch和spring-es—Data的实战汇总</title>
      <link href="/2021/01/15/es1/"/>
      <url>/2021/01/15/es1/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Elasticsearch和spring-es—Data的实战汇总"><a href="#关于Elasticsearch和spring-es—Data的实战汇总" class="headerlink" title="关于Elasticsearch和spring-es—Data的实战汇总"></a>关于Elasticsearch和spring-es—Data的实战汇总</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Elasticsearch是一个搜索的服务器，可以抽象为类似数据库的一样的东西。但是它本身的作用并不抽象，很大的业务作用都与数据库有着很大的重合。原理是倒排索引，这篇文章就不细说了</p><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>比如说，在我们需要使用数据库进行搜索的时候，直接模糊查询就好了 <strong>select id from item where itemName like %xxx%</strong> 但是这样的查询并不完美，比如我要找电子产品，我输入手机，那么和产品名称为手机的都会<strong>严格</strong>的被查询回来，可是这样就无法找到类似于：智能机，老人机，这样的称呼，这样很明显是不可学的，那我们是将手机再拆分为两个SQL进行查找吗？也许这样可行，但是对于手这个单词的查找可能会找到手套之类的物品，而这样已经违背的我们的初衷，明显，仅仅在数据库使用like是不明智的选择</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p><strong>性能问题</strong>。我们在进行数据库查找的时候，更多的是这样：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/uChmeeX1Fpyfns636FFuBpwcrBDBZFK9jZ5zYIZxgrD9aibzjejjMaRIXzRnnnIO3tk5I7d2UbdjVN0wCPMyZgQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt=""></p><p>这种like或者where的一行一行的查找，在对于海量的数据的时候，性能会变得非常的差劲，以致于能影响我们数据库的正常使用，<strong>使用了Elasticsearch之后，数据会在ES中有备份，而这样的查找就变成了</strong>：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/uChmeeX1Fpyfns636FFuBpwcrBDBZFK9hY8IYo9qrQe7N2hficOxvN8pWON1zeON6V3sH6zib6pm9SdxzFfmg5UA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt=""></p><p>这正是Elasticsearch的特性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。</p><p>对比关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">索引（indices）---------------------------------Databases 数据库</span><br><span class="line"></span><br><span class="line">  类型（type）----------------------------------Table 数据表</span><br><span class="line"></span><br><span class="line">     文档（Document）---------------------------Row 行</span><br><span class="line"></span><br><span class="line">   字段（Field）---------------------------Columns 列</span><br></pre></td></tr></table></figure><p>详细说明：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>索引库（indices)</td><td>indices是index的复数，代表许多的索引，</td></tr><tr><td>类型（type）</td><td>类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念</td></tr><tr><td>文档（document）</td><td>存入索引库原始的数据。比如每一条商品信息，就是一个文档</td></tr><tr><td>字段（field）</td><td>文档中的属性</td></tr><tr><td>映射配置（mappings）</td><td>字段的数据类型、属性、是否索引、是否存储等特性</td></tr></tbody></table><p>另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的：</p><ul><li>索引集（Indices，index的复数）：逻辑上的完整索引 collection1</li><li>分片（shard）：数据拆分后的各个部分</li><li>副本（replica）：每个分片的复制</li></ul><p>要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>安装好了可以直接使用你的localhost地址，加上端口访问，</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/</span></span><br></pre></td></tr></table></figure><p>首页会出现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: "c48f8b6d6494",</span><br><span class="line">    cluster_name: "docker-cluster",</span><br><span class="line">    cluster_uuid: "zJTUdR71Qya-vCLde_kaiQ",</span><br><span class="line">    version: &#123;</span><br><span class="line">    number: "7.6.2",</span><br><span class="line">    build_flavor: "default",</span><br><span class="line">    build_type: "docker",</span><br><span class="line">    build_hash: "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    build_date: "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    build_snapshot: false,</span><br><span class="line">    lucene_version: "8.4.0",</span><br><span class="line">    minimum_wire_compatibility_version: "6.8.0",</span><br><span class="line">    minimum_index_compatibility_version: "6.0.0-beta1"</span><br><span class="line">    &#125;,</span><br><span class="line">    tagline: "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些都是它的基本情况</p><h4 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>Elasticsearch采用Rest风格API，因此其API就是一次http请求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p>这样会展现出我们这个索引库的所有数据</p><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  /索引库名</span><br></pre></td></tr></table></figure><p>删除索引库</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>而当我们需要往Elasticsearch放入数据时，建议使用Elasticsearch—DATA 使用我们的外部API来放入我们的数据。</p><p>当然也有原生的API：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping/类型名称</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"字段名"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"类型"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="literal">true</span>，</span><br><span class="line">      <span class="string">"store"</span>: <span class="literal">true</span>，</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"分词器"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型名称：就是前面将的type的概念，类似于数据库中的不同表<br>字段名：任意填写 ，可以指定许多属性，例如：</li><li>type：类型，可以是text、long、short、date、integer、object等</li><li>index：是否索引，默认为true</li><li>store：是否存储，默认为false</li><li>analyzer：分词器，这里的<code>ik_max_word</code>即使用ik分词器</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_mapping</span><br></pre></td></tr></table></figure><p>而使用这个方法可以查看我们的各个字段的类型</p><p>官方文档中有对类型的具体阐述：</p><ul><li><p>String类型，又分两种：</p><ul><li>text：可分词，不可参与聚合</li><li>keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合</li></ul></li><li><p>Numerical：数值类型，分两类</p><ul><li>基本数据类型：long、interger、short、byte、double、float、half_float</li><li>浮点数的高精度类型：scaled_float<ul><li>需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。</li></ul></li></ul></li><li><p>Date：日期类型</p><p>elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间</p></li></ul><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>index影响字段的索引情况。</p><ul><li>true：字段会被索引，则可以用来进行搜索。默认值就是true</li><li>false：字段不会被索引，不能用来搜索</li></ul><p>index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。</p><p>但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。</p><p>在我们实体对Class进行操作的时候，可以进行手动标注</p><h5 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h5><p>通过POST请求，可以向一个已经存在的索引库中添加数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/类型名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"key"</span>:<span class="string">"value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并可以通过：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /索引库名/_search</span><br></pre></td></tr></table></figure><p>去查看我们的所有数据。</p><p>这些都是原生的操作方法，但是实际操作过程中，并不会使用这种方法去操作，在Spring中也提供了相应的data-es去操作</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"查询类型"</span>:&#123;</span><br><span class="line">            <span class="attr">"查询条件"</span>:<span class="string">"查询条件值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的query代表一个查询对象，里面可以有不同的查询属性</p><ul><li>查询类型：例如：<code>match_all</code>， <code>match</code>，<code>term</code> ， <code>range</code> 等等</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询所有</p><p>则会在返回的JSON头出现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    took: 7,</span><br><span class="line">    timed_out: false,</span><br><span class="line">    _shards: &#123;</span><br><span class="line">    total: 1,</span><br><span class="line">    successful: 1,</span><br><span class="line">    skipped: 0,</span><br><span class="line">    failed: 0</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>took：查询花费时间，单位是毫秒</li><li>time_out：是否超时</li><li>_shards：分片信息</li><li>hits：搜索结果总览对象<ul><li>total：搜索到的总条数</li><li>max_score：所有结果中文档得分的最高分</li><li>hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息<ul><li>_index：索引库</li><li>_type：文档类型</li><li>_id：文档id</li><li>_score：文档得分</li><li>_source：文档的源数据</li></ul></li></ul></li></ul><h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><p>使用：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/2.png" alt=""></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/product/_search</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"手机"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/3.png" alt="图3"></p><p><strong>match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系</strong></p><h5 id="and"><a href="#and" class="headerlink" title="and"></a>and</h5><p>某些情况下，我们需要更精确查找，我们希望这个关系变成<code>and</code>，可以这样做:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"手机"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/4.png" alt=""></p><h5 id="or和and"><a href="#or和and" class="headerlink" title="or和and"></a>or和and</h5><p>在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。</p><p>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。</p><p><code>match</code> 查询支持 <code>minimum_should_match</code> 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"最新小米手机"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。</p><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/5.png" alt="图五"></p><h4 id="多字段查询"><a href="#多字段查询" class="headerlink" title="多字段查询"></a>多字段查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"小米"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:   [ <span class="string">"name"</span>, <span class="string">"content"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="词条匹配"><a href="#词条匹配" class="headerlink" title="词条匹配"></a>词条匹配</h4><p><strong>term</strong> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些<strong>未分词</strong>的字符串</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"term"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:<span class="number">2699.00</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多词条精确匹配"><a href="#多词条精确匹配" class="headerlink" title="多词条精确匹配"></a>多词条精确匹配</h4><p>terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"terms"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:[<span class="number">2699.00</span>,<span class="number">2899.00</span>,<span class="number">3899.00</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">            <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">///////......</span></span><br></pre></td></tr></table></figure><h3 id="结果过滤"><a href="#结果过滤" class="headerlink" title="结果过滤"></a>结果过滤</h3><h4 id="直接指定字段"><a href="#直接指定字段" class="headerlink" title="直接指定字段"></a>直接指定字段</h4><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，我们可以添加_source的过滤:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"price"</span>],</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"_shards"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"hits"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: &#123;</span><br><span class="line"><span class="attr">"value"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"hits"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"price"</span>: <span class="number">5000</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"iPhone11"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定includes和excludes"><a href="#指定includes和excludes" class="headerlink" title="指定includes和excludes"></a>指定includes和excludes</h4><p>我们也可以通过：</p><ul><li>includes：来指定想要显示的字段</li><li>excludes：来指定不想要显示的字段</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"includes"</span>:[<span class="string">"content"</span>,<span class="string">"price"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">2999</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/6.png" alt=""></p><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="布尔组合"><a href="#布尔组合" class="headerlink" title="布尔组合"></a>布尔组合</h4><p><code>bool</code>把各种其它查询通过<code>must</code>（与）、<code>must_not</code>（非）、<code>should</code>（或）的方式进行组合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>:  <span class="string">"电视"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"手机"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/7.png" alt=""></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">                <span class="attr">"gte"</span>:  <span class="number">1000.0</span>,</span><br><span class="line">                <span class="attr">"lt"</span>:   <span class="number">2800.00</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询允许以下字符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">gt</td><td align="center">大于</td></tr><tr><td align="center">gte</td><td align="center">大于等于</td></tr><tr><td align="center">lt</td><td align="center">小于</td></tr><tr><td align="center">lte</td><td align="center">小于等于</td></tr></tbody></table><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>fuzzy查询是 <code>term</code> 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"appla"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>fuzziness</code>来指定允许的编辑距离:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>:<span class="string">"appla"</span>,</span><br><span class="line">            <span class="attr">"fuzziness"</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><h4 id="条件查询中进行过滤"><a href="#条件查询中进行过滤" class="headerlink" title="条件查询中进行过滤"></a><strong>条件查询中进行过滤</strong></h4><p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用<code>filter</code>方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米手机"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">2000.00</span>,<span class="attr">"lt"</span>:<span class="number">3800.00</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无查询条件，直接过滤"><a href="#无查询条件，直接过滤" class="headerlink" title="无查询条件，直接过滤"></a><strong>无查询条件，直接过滤</strong></h4><p>如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用<code>constant_score</code>取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">             <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">2000.00</span>,<span class="attr">"lt"</span>:<span class="number">3000.00</span>&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="单字段排序"><a href="#单字段排序" class="headerlink" title="单字段排序"></a>单字段排序</h4><p><code>sort</code> 可以让我们按照不同的字段进行排序，并且通过<code>order</code>指定排序的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小米手机"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"price"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><p>假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米手机"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">200000</span>,<span class="attr">"lt"</span>:<span class="number">300000</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">      &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"_score"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合aggregations"><a href="#聚合aggregations" class="headerlink" title="聚合aggregations"></a>聚合aggregations</h2><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫<code>桶</code>，一个叫<code>度量</code>：</p><blockquote><p><strong>桶（bucket）</strong></p></blockquote><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个<code>桶</code>，例如我们根据国籍对人划分，可以得到<code>中国桶</code>、<code>英国桶</code>，<code>日本桶</code>……或者我们按照年龄段对人进行划分：010,1020,2030,3040等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li><li>……</li></ul><p>bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><blockquote><p><strong>度量（metrics）</strong></p></blockquote><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为<code>度量</code></p><p>比较常用的一些度量聚合方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li><li>……</li></ul><h3 id="聚合为桶"><a href="#聚合为桶" class="headerlink" title="聚合为桶"></a>聚合为桶</h3><p>这里我使用了产品的category来分类，聚合为不同的桶：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"size"</span>:<span class="number">0</span>,<span class="attr">"aggs"</span>:&#123;<span class="attr">"popular_category"</span>:&#123;<span class="attr">"terms"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"category"</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率</li><li>aggs：声明这是一个聚合查询，是aggregations的缩写<ul><li>popular_category：给这次聚合起一个名字，任意。<ul><li>terms：划分桶的方式，这里是根据词条划分<ul><li>field：划分桶的字段</li></ul></li></ul></li></ul></li></ul><p>但是，这里我出现了一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata&#x3D;true on [interests] in order to load field data by uninverting the inverted index. Note that this can use significant memory.</span><br></pre></td></tr></table></figure><p>大意就是必须把我们的属性设置为：set fielddata=true。</p><p>这里时候我返回idea，使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Field</span>(type = FieldType.Text,fielddata = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>将字段变为fielddata = true，可是这样一样出现这样的错误，这是为什么呢？</p><h5 id="紧急错误"><a href="#紧急错误" class="headerlink" title="紧急错误"></a>紧急错误</h5><p>之后我通过</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/_mapping</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/0.png" alt=""></p><p>发现了这个错误的原因，原来是这个@field注解并没有生效，所以属性也没有生效。</p><p>之后在网上搜索各个文章，发现很多的做法都是使用外置一个json，也有一部分是用createindex+putindex。</p><p>使用json明显不是官方的做法，简直越来越复杂，而createindex和putindex一起使用也不正确，后来看了看官方文档，标注这两个方法都被弃用了，而且createindex其实已经集成到repository里面自动产生了，很迷惑。</p><p>但是在多次调试的情况下，我获得了两种答案：</p><h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>先使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearchRestTemplate.putMapping(Product<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>将mapping配置放入es连接中，再使用saveALL就行了</p><p>二是升级版本，把springboot升级到2.4.0</p><p>之后便是再次尝试：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/8.png" alt="图"></p><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>popular_category：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的category字段值都会形成一个桶<ul><li>key：这个桶对应的category字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul><h3 id="桶内度量"><a href="#桶内度量" class="headerlink" title="桶内度量"></a>桶内度量</h3><p>我们需要告诉Elasticsearch<code>使用哪个字段</code>，<code>使用何种度量方式</code>进行运算，这些信息要嵌套在<code>桶</code>内，<code>度量</code>的运算会基于<code>桶</code>内的文档进行</p><p>现在，我们为刚刚的聚合结果添加 求价格平均值的度量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_category"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"category"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见<code>度量</code>也是一个聚合</li><li>avg_price：聚合的名称</li><li>avg：度量的类型，这里是求平均值</li><li>field：度量运算的字段</li></ul><p>结果如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/9.png" alt=""></p><h3 id="桶内嵌套桶"><a href="#桶内嵌套桶" class="headerlink" title="桶内嵌套桶"></a>桶内嵌套桶</h3><p>刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_category"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"category"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"maker"</span>:&#123;</span><br><span class="line">                    <span class="attr">"terms"</span>:&#123;</span><br><span class="line">                        <span class="attr">"field"</span>:<span class="string">"brand"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原来的color桶和avg计算我们不变</li><li>maker：在嵌套的aggs下新添一个桶，叫做maker</li><li>terms：桶的划分类型依然是词条</li><li>filed：这里根据make字段进行划分</li></ul><h3 id="划分桶的其它方式"><a href="#划分桶的其它方式" class="headerlink" title="划分桶的其它方式"></a>划分桶的其它方式</h3><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li></ul><h4 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h4><p>histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。</p><p>举例：</p><p>比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的：</p><p>0，200，400，600，…</p><p>上面列出的是每个阶梯的key，也是区间的启点。</p><p>如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket_key = Math.floor((value - offset) / interval) * interval + offset</span><br></pre></td></tr></table></figure><p>value：就是当前数据的值，本例中是450</p><p>offset：起始偏移量，默认为0</p><p>interval：阶梯间隔，比如200</p><p>因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"price"</span>:&#123;</span><br><span class="line">      <span class="attr">"histogram"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="number">1000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图所示：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/10.png" alt=""></p><p>同样还可以指定： “min_doc_count”: 1 去表达，只有存在最小区间的才展示。</p><h2 id="spring-boot-starter-data-elasticsearch"><a href="#spring-boot-starter-data-elasticsearch" class="headerlink" title="spring-boot-starter-data-elasticsearch"></a>spring-boot-starter-data-elasticsearch</h2><p>这里使用的SpringBoot版本是2.3.7。spring-boot-starter-data-elasticsearch版本为2.4.2、</p><p>elasticsearch版本为7.6.2</p><p>首先导入pom文件，然后，新版本的elasticsearch建议使用Configuration器配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientConfiguration configuration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">"192.168.78.128:9200"</span>)</span><br><span class="line"><span class="comment">//                .connectedTo("localhost:9200")</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//.withConnectTimeout(Duration.ofSeconds(5))</span></span><br><span class="line">                <span class="comment">//.withSocketTimeout(Duration.ofSeconds(3))</span></span><br><span class="line">                <span class="comment">//.useSsl()</span></span><br><span class="line">                <span class="comment">//.withDefaultHeaders(defaultHeaders)</span></span><br><span class="line">                <span class="comment">//.withBasicAuth(username, password)</span></span><br><span class="line">                <span class="comment">// ... other options</span></span><br><span class="line">                .build();</span><br><span class="line">        RestHighLevelClient client = RestClients.create(configuration).rest();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"product"</span>, shards = <span class="number">1</span>, replicas = <span class="number">0</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"com-sodse-trade-domain-Product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = ToStringSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ApiModelProperty</span>(<span class="title">value</span> </span>= <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword, analyzer = "ik_max_word")</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>,type = FieldType.Text)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String mainImg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会有一个品牌表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"会有一个品牌表"</span>)</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会有一个分类表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text,fielddata = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"会有一个分类表"</span>)</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当库存为0时则无法购买</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"当库存为0时则无法购买"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为真</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"判断是否为真"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳在创建新商品时产生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>,type = FieldType.Long)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"时间戳在创建新商品时产生"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如手机：颜色，衣服：颜色。。。以逗号隔开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"如手机：颜色，衣服：颜色。。。以逗号隔开"</span>)</span><br><span class="line">    <span class="keyword">private</span> String properties1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如手机规格：8+128gb，衣服 S,M,L,XL,XXL 以逗号隔开。若无第二规格，则在第一个开头显示 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"如手机规格：8+128gb，衣服 S,M,L,XL,XXL 以逗号隔开。若无第二规格，则在第一个开头显示 无"</span>)</span><br><span class="line">    <span class="keyword">private</span> String properties2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快递费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"快递费"</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal courierFees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属于哪一个商家</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"属于哪一个商家"</span>)</span><br><span class="line">    <span class="keyword">private</span> String merchant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p> @ApiModelProperty和ApiModel是我自己的swagger依赖，和Elasticsearch无关。</p><p>Spring Data通过注解来声明字段的映射属性，有下面的三个注解：</p><ul><li>@Document作用在类，标记实体类为文档对象，一般有四个属性<ul><li>indexName：对应索引库名称</li><li>type：对应在索引库中的类型</li><li>shards：分片数量，默认5</li><li>replicas：副本数量，默认1</li></ul></li><li>@Id` 作用在成员变量，标记一个字段作为id主键</li><li>@Field作用在成员变量，标记为文档的字段，并指定字段映射属性：<ul><li>type：字段类型，取值是枚举：FieldType</li><li>index：是否索引，布尔类型，默认是true</li><li>store：是否存储，布尔类型，默认是false</li><li>analyzer：分词器名称：ik_max_word</li></ul></li></ul><p>值得注意的是：@Document的type在新版本被弃用了。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>这里通过继承ElasticsearchRepository来像JPA一样使用它的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span> ,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findAllByNameLike</span><span class="params">(String  name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看常规的操作</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">product_es_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product p=<span class="keyword">new</span> Product();</span><br><span class="line">        p.setId(<span class="number">2L</span>);</span><br><span class="line">        p.setName(<span class="string">"手机"</span>);</span><br><span class="line">        p.setPrice(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        p.setContent(<span class="string">"这是一件物品"</span>);</span><br><span class="line"><span class="comment">//        productRepository.index(p);</span></span><br><span class="line">        productRepository.save(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>productRepository.index() 是 过去弃用的方法，现今使用productRepository.save 去保存一个Object。</p><p>更新和保存同样都是使用save，它会根据主键是否相同来判断是更新还是保存新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">product_es_test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    productRepository.saveAll(productService.find());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>productRepository.saveAll 保存一个<strong>List<Object></strong> 数据</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">es_Delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    productRepository.deleteAll();<span class="comment">//或者是deleteById(1L);</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">product_es_test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Product&gt; products = productRepository.findAllByNameLike(<span class="string">"手机"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Product p:products) &#123;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过像JPA一样自定义方法来进行增删改查操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">"price"</span>));</span><br></pre></td></tr></table></figure><p>还可以选择降序排序等等</p><h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>Spring Data 的另一个强大功能，是根据方法名称自动实现功能。<br>比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。<br>当然，方法名称要符合一定的约定：</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>Elasticsearch Query String</th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByNameAndPrice</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Or</code></td><td><code>findByNameOrPrice</code></td><td><code>{&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Is</code></td><td><code>findByName</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Not</code></td><td><code>findByNameNot</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Between</code></td><td><code>findByPriceBetween</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByPriceLessThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByPriceGreaterThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Before</code></td><td><code>findByPriceBefore</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>After</code></td><td><code>findByPriceAfter</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Like</code></td><td><code>findByNameLike</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByNameStartingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>EndingWith</code></td><td><code>findByNameEndingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>Contains/Containing</code></td><td><code>findByNameContaining</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>In</code></td><td><code>findByNameIn(Collectionnames)</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}}</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByNameNotIn(Collectionnames)</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}}</code></td></tr><tr><td><code>Near</code></td><td><code>findByStoreNear</code></td><td><code>Not Supported Yet !</code></td></tr><tr><td><code>True</code></td><td><code>findByAvailableTrue</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr><tr><td><code>False</code></td><td><code>findByAvailableFalse</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}}</code></td></tr><tr><td><code>OrderBy</code></td><td><code>findByAvailableTrueOrderByNameDesc</code></td><td><code>{&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr></tbody></table><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><h4 id="QueryBuilders"><a href="#QueryBuilders" class="headerlink" title="QueryBuilders"></a>QueryBuilders</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBaseQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 词条查询</span></span><br><span class="line">    MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"小米"</span>);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    Iterable&lt;Product&gt; items = productRepository.search(queryBuilder);</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/11.png" alt=""></p><h4 id="NativeSearchQueryBuilder"><a href="#NativeSearchQueryBuilder" class="headerlink" title="NativeSearchQueryBuilder"></a>NativeSearchQueryBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"手机"</span>));</span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体</p><p><code>Page</code>：默认是分页查询，因此返回的是一个分页的结果对象，包含属性：</p><ul><li>totalElements：总条数</li><li>totalPages：总页数</li><li>Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据</li></ul><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/12.png" alt=""></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"手机"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分页参数</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置分页参数</span></span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    <span class="comment">// 每页大小</span></span><br><span class="line">    System.out.println(items.getSize());</span><br><span class="line">    <span class="comment">// 当前页</span></span><br><span class="line">    System.out.println(items.getNumber());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/13.png" alt=""></p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 构建查询条件</span></span><br><span class="line">       NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">       <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">       queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"书籍"</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 排序</span></span><br><span class="line">       queryBuilder.withSort(SortBuilders.fieldSort(<span class="string">"price"</span>).order(SortOrder.DESC));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">       Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">       <span class="comment">// 打印总条数</span></span><br><span class="line">       System.out.println(items.getTotalElements());</span><br><span class="line">       items.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/14.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot多环境适配</title>
      <link href="/2021/01/05/spring18/"/>
      <url>/2021/01/05/spring18/</url>
      
        <content type="html"><![CDATA[<h1 id="Profile功能"><a href="#Profile功能" class="headerlink" title="Profile功能"></a>Profile功能</h1><p>为了方便多环境适配，springboot简化了profile功能。</p><h3 id="1、application-profile功能"><a href="#1、application-profile功能" class="headerlink" title="1、application-profile功能"></a>1、application-profile功能</h3><ul><li><p>默认配置文件  application.yaml；任何时候都会加载</p></li><li><p>指定环境配置文件  application-{env}.yaml</p></li><li><p>激活指定环境</p></li><li><ul><li>配置文件激活</li><li>命令行激活：java -jar xxx.jar –<strong>spring.profiles.active=prod  –person.name=haha</strong></li></ul></li><li><ul><li><ul><li><strong>修改配置文件的任意值，命令行优先</strong></li></ul></li></ul></li><li><p>默认配置与环境配置同时生效</p></li><li><p>同名配置项，profile配置优先</p></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//比如说再有两个的情况下，</span></span><br><span class="line"><span class="string">application-myprod.yml</span></span><br><span class="line"><span class="string">application-mytest.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.profiles.active=myprod</span></span><br></pre></td></tr></table></figure><p>通过这种方式指定一个配置文件。</p><p>在应用程序启动时默认的配置文件先生效，然后再使用指定的配置文件，当两个配置文件有重复的配置的时候，指定的优先生效。</p><h3 id="2、-Profile条件装配功能"><a href="#2、-Profile条件装配功能" class="headerlink" title="2、@Profile条件装配功能"></a>2、@Profile条件装配功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(value = &#123;<span class="string">"prod"</span>,<span class="string">"default"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name:李四&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;MAVEN_HOME&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;os.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/msg"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg+<span class="string">"==&gt;"</span>+osName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的配置可以对类和返回值产生不同的影响，但一般不这么做，因为一般的项目都比较大而复杂。</p><h3 id="3、profile分组"><a href="#3、profile分组" class="headerlink" title="3、profile分组"></a>3、profile分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.group.production[0]&#x3D;proddb</span><br><span class="line">spring.profiles.group.production[1]&#x3D;prodmq</span><br><span class="line"></span><br><span class="line">使用：--spring.profiles.active&#x3D;production  激活</span><br></pre></td></tr></table></figure><p>当我们指定的指定一个的配置文件的时候，属于它的组也会依次生效</p><h3 id="4、外部化配置"><a href="#4、外部化配置" class="headerlink" title="4、外部化配置"></a>4、外部化配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><ol><li>默认属性（通过设置指定<code>SpringApplication.setDefaultProperties</code>）。</li><li><a href="https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code></a><code>@Configuration</code>类上的注释。请注意，<code>Environment</code>在刷新应用程序上下文之前，不会将此类属性源添加到中。现在配置某些属性（如<code>logging.*</code>和<code>spring.main.*</code>在刷新开始之前先读取）为时已晚。</li><li><strong>配置数据（例如**</strong>文件）<strong>**<code>application.properties</code></strong></li><li>一<code>RandomValuePropertySource</code>，只有在拥有性能<code>random.*</code>。</li><li>操作系统环境变量。</li><li>Java系统属性（<code>System.getProperties()</code>）。</li><li>的JNDI属性<code>java:comp/env</code>。</li><li><code>ServletContext</code> 初始化参数。</li><li><code>ServletConfig</code> 初始化参数。</li><li>来自的属性<code>SPRING_APPLICATION_JSON</code>（嵌入在环境变量或系统属性中的嵌入式JSON）。</li><li>命令行参数。</li><li><code>properties</code>测试中的属性。可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">用于测试应用程序的特定部分</a><a href="https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener"><code>@SpringBootTest</code></a>的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试注释</a>和<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">注释</a>。</li><li><a href="https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener"><code>@TestPropertySource</code></a> 测试中的注释。</li><li><code>$HOME/.config/spring-boot</code>当devtools处于活动状态时，目录中的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools-globalsettings" target="_blank" rel="noopener">Devtools全局设置属性</a>。</li></ol><h3 id="5、外部配置源"><a href="#5、外部配置源" class="headerlink" title="5、外部配置源"></a>5、外部配置源</h3><p>常用：<strong>Java属性文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>、<strong>命令行参数</strong>；</p><h3 id="6、配置文件查找位置"><a href="#6、配置文件查找位置" class="headerlink" title="6、配置文件查找位置"></a>6、配置文件查找位置</h3><p>(1) classpath 根路径</p><p>(2) classpath 根路径下config目录</p><p>(3) jar包当前目录</p><p>(4) jar包当前目录的config目录</p><p>(5) /config子目录的直接子目录</p><h3 id="7、配置文件加载顺序："><a href="#7、配置文件加载顺序：" class="headerlink" title="7、配置文件加载顺序："></a>7、配置文件加载顺序：</h3><ol><li>　当前jar包内部的application.properties和application.yml</li><li>　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li><li>　引用的外部jar包的application.properties和application.yml</li><li>　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li></ol><p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Profile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity+JWT结合Vue在前后端分离下的权限控制</title>
      <link href="/2021/01/05/spring17/"/>
      <url>/2021/01/05/spring17/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringSecurity-JWT结合Vue在前后端分离下的权限控制"><a href="#SpringSecurity-JWT结合Vue在前后端分离下的权限控制" class="headerlink" title="SpringSecurity+JWT结合Vue在前后端分离下的权限控制"></a>SpringSecurity+JWT结合Vue在前后端分离下的权限控制</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>再构建一个前后端分离项目的时候。我们之前在前后端耦合情况下使用的Security配置会和前后端分离的情况下有一些较大的区别。</p><p>就比如在前后端耦合的情况下，所有页面。都是由后端来处理，这样的权限控制较为简易。而且不会出现跨域的问题。按目前结合vue进行前后端分离是当前技术的主流。很多公司和业务都是按照着这个的标准进行的，那么以往的权限控制就不能完全适用于现在了。</p><p>这一段设计经过了我的一些思考。当我在初步的使用vue的时候。我还按照原来的配置去配置security。结果发现这样的权限控制并没有任何效果。起初以为是跨域问题，结果在解决了跨域问题之后，才真正明白了，他们启动的并不是同一个端口。那么我在后端配置的权限控制和前端不同端口的情况下怎么会生效呢？</p><p>于是在查阅了网上的各种资料之后，我找到了一种方法，使用jwt配合security权限控制来进行前后端之间的交流，这样即使是在不同端口的情况下也能实现权限的控制。并且可以将jwt所认证的信息存储在当地的cookie当中。即使用户退出的浏览器在打开浏览器时也不用再次进行登录去认证。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先必不可说的肯定是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- jwt --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--   spring security     权限管理依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 因为在进行前后端分离时，需要用到一个自定义的类型去进行交互。当然这是基本常识，在此也不多讲述：</p><p>这是一个用于交互的实体,前后端用这个类来进行交互。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">// 200是正常，非200表示异常</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">succ</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> succ(<span class="number">200</span>, <span class="string">"操作成功"</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">succ</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        Result r = <span class="keyword">new</span> Result();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fail(<span class="number">400</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(String msg, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fail(<span class="number">400</span>, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        Result r = <span class="keyword">new</span> Result();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义一个用户提交登陆信息使用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"昵称不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>后端需要解决一些跨域问题,这是一个跨域解决方案的一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始配置我们的security:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService; <span class="comment">//自行编写的持久层方法，这里我用的是mybatis </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">        <span class="comment">//需要自定义一个JWT拦截器，下面会提及</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( AuthenticationManagerBuilder auth )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService( myUserDetailsService ).passwordEncoder( <span class="keyword">new</span> BCryptPasswordEncoder() );</span><br><span class="line">    &#125;<span class="comment">//将我们的持久层方法注入到这个security里面，之前的文章说过了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( HttpSecurity httpSecurity )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity.csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/register"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.PUT).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.DELETE).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.GET).authenticated()</span><br><span class="line">                .and()<span class="comment">// 开启跨域</span></span><br><span class="line">                .cors()</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置拦截</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//自定义拦截方法</span></span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyUserDetailsService:这个不用说，就是我们自己定义的获取数据库用户信息的方法。接着使用: <strong>auth.userDetailsService( myUserDetailsService ).passwordEncoder( new BCryptPasswordEncoder() );</strong> 将他住到我们的security权限认证当中。</li><li>JwtTokenFilter：这是我们的拦截器。我们需要对验证的每一个Token.进行验证，判断它的过期时间等等。我们需要把这个拦截器一块注入到security当中。源码在下方：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里看起来复杂，实际就是获取从前端返回的信息，比如username，然后进行数据库查找，然后进行将找到的用户进行加密形成一个Token，将一个信息传递回security</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span> <span class="params">( HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String authHeader = request.getHeader( Const.HEADER_STRING );</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith( Const.TOKEN_PREFIX )) &#123;</span><br><span class="line">            <span class="keyword">final</span> String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                        UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                                userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                        authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                                request));</span><br><span class="line">                        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着这一个认证拦截器又用到了JWT的工具类：这一个工具，通常用于生成JWT，和获取各种JWT的信息，其中用到了我们spring中的依赖注的JWT源码，但我们还需要根据他所给的方法和API，进行自己的改写和判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jwt的各种方法，写法比较固定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5625635588908941275L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME = <span class="string">"sub"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED = <span class="string">"created"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreatedDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date created;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            created = <span class="keyword">new</span> Date((Long) claims.get(CLAIM_KEY_CREATED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            created = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpirationDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiration;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            expiration = claims.getExpiration();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            expiration = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey( Const.SECRET )</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            claims = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Date <span class="title">generateExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis() + Const.EXPIRATION_TIME * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date expiration = getExpirationDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isCreatedBeforeLastPasswordReset</span><span class="params">(Date created, Date lastPasswordReset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (lastPasswordReset != <span class="keyword">null</span> &amp;&amp; created.before(lastPasswordReset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, Const.SECRET )</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">canTokenBeRefreshed</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String refreshedToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            refreshedToken = generateToken(claims);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            refreshedToken = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> refreshedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        User user = (User) userDetails;</span><br><span class="line">        <span class="keyword">final</span> String username = getUsernameFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">                username.equals(user.getUsername())</span><br><span class="line">                        &amp;&amp; !isTokenExpired(token)</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，这种工作大致上就完成了，总体而言并不复杂。就是把JWT和security结合在一起。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@Validated @RequestBody LoginDto loginDto, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"登录"</span>);</span><br><span class="line">    String jwt= authService.login( loginDto.getUsername(), loginDto.getPassword() );</span><br><span class="line">    User user= userService.findByUsername(loginDto.getUsername()).get(<span class="number">0</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Authorization"</span>,jwt);<span class="comment">//放置响应头中</span></span><br><span class="line">    response.setHeader(<span class="string">"Access-control-Expose-Headers"</span>,<span class="string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(MapUtil.builder()</span><br><span class="line">            .put(<span class="string">"id"</span>, user.getId())</span><br><span class="line">            .put(<span class="string">"username"</span>, user.getUsername())</span><br><span class="line">            .map());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用postman或者是vue的axios进行测试，图床崩了暂时就不搞图了</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Security </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element-ui组件使用和一键import功能</title>
      <link href="/2020/07/16/vue2/"/>
      <url>/2020/07/16/vue2/</url>
      
        <content type="html"><![CDATA[<h3 id="Element-ui组件使用"><a href="#Element-ui组件使用" class="headerlink" title="Element-ui组件使用"></a>Element-ui组件使用</h3><p>element-ui首先得通过npm 安装下载，</p><p>其次通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"element-ui/lib/theme-chalk/index.css"</span></span><br></pre></td></tr></table></figure><p>导入进去，</p><p>然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Element)</span><br></pre></td></tr></table></figure><p>被Vue所使用即可了。</p><p>并且通过：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/layout</span><br></pre></td></tr></table></figure><p>访问网站，直接复制在我们components文件夹下面新建的一个Vue里面，既可以使用了。</p><h3 id="一键import"><a href="#一键import" class="headerlink" title="一键import"></a>一键import</h3><p>这个在components下面建一个js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="string">'.'</span>, <span class="literal">false</span>, /\.vue$/</span><br><span class="line">   <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentName = capitalizeFirstLetter(</span><br><span class="line">    fileName.replace(<span class="regexp">/^\.\//</span>, <span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="comment">//因为得到的filename格式是: './dataList.vue', 所以这里我们去掉头和尾，只保留真正的文件名</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果组件在components下面的文件夹里面的话。js就改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">    <span class="string">'.'</span>,<span class="literal">true</span>,/\.vue$/</span><br><span class="line">    <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">233</span>,requireComponent.keys());</span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    <span class="keyword">const</span> componetConfig = requireComponent(fileName);</span><br><span class="line">    <span class="built_in">console</span>.log(componetConfig);</span><br><span class="line">    <span class="keyword">let</span> a = fileName.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    fileName = <span class="string">'.'</span> + fileName.slice(a);</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    <span class="keyword">const</span> componetName = capitalizeFirstLetter(</span><br><span class="line">        fileName.replace(<span class="regexp">/^\.\//</span>,<span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>,<span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">    Vue.component(componetName,componetConfig.default || componetConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后在main.js进行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx.js</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Kurento实现一对一通信</title>
      <link href="/2020/06/20/Kurento1/"/>
      <url>/2020/06/20/Kurento1/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Kurento实现一对一通信"><a href="#利用Kurento实现一对一通信" class="headerlink" title="利用Kurento实现一对一通信"></a>利用Kurento实现一对一通信</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自己的计划是，毕业设计做一个类似于腾讯会议的视频流通信服务，发现想要实现起来并不容易，不过自己也还是慢慢的在摸索，最后找到了一个叫做Kurento的视频流服务器，打算使用这个服务器去开发程序。</p><h3 id="配置与实现"><a href="#配置与实现" class="headerlink" title="配置与实现"></a>配置与实现</h3><p>想要配置这个东西可是非常非常的坑啊，本来自己是去官网找到了一些可以直接运行的例子，然后在本地直接start，完全没有问题，然后拿到虚拟机试一试：</p><p>当然，kurento肯定是利用docker安装的，这个dockerhub也有，这里先列出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name kms -p 8888:8888 kurento/kurento-media-server:xenial-latest</span><br></pre></td></tr></table></figure><p>发现仍然可以使用，最后拿去阿里云服务器试了试，结果就……，完全没有作用，安全组什么的都开了，我之后就觉得会不会是公网ip之类的问题，但是不知道怎么下手，之后再Stack Overflow中，看到了创建者的发言，在公网中必须有turn服务器，于是乎，我便开始了配置turn服务器之路。</p><p>由于在dockerhub没有turn服务器的镜像源，turn服务器安装这块坑就大了，网上有很多的教程，非常之乱，又要什么内网ip，什么什么md5验证，什么什么必须要在Ubuntu下运行，看的我真的是一脸懵逼，怎么可能这么复杂而且又有这么多说法呢？？</p><p>我基本都试了一次，嗯，如同预期一般，非常的不靠谱。</p><p>但最后还是找到了解决方案，在github找到了可以直接使用的dockerfile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/konoui/kurento-coturn-docker.git</span><br></pre></td></tr></table></figure><p>然后去运行它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /kurento-coturn-docker/coturn/</span><br><span class="line">//使用dockerfile,记住加点</span><br><span class="line">sudo docker build --tag coturn .</span><br><span class="line">//后台运行coturn</span><br><span class="line">sudo docker run -p 3478:3478 -p 3478:3478/udp coturn</span><br><span class="line">//别忘了开完全组</span><br></pre></td></tr></table></figure><p>然后是网上博客都有讲到的有效性测试，这个大家自己看吧。</p><p>然后需要编辑Kurento：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入镜像</span></span><br><span class="line">docker exec -it kms /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta">#</span><span class="bash">进入配置文件夹</span></span><br><span class="line">cd /etc/kurento/modules/kurento/</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑配置文件</span></span><br><span class="line">vim WebRtcEndpoint.conf.ini</span><br></pre></td></tr></table></figure><p>配置打洞服务器，配置文件应该改成这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stunServerAddress=you_url</span><br><span class="line">stunServerPort=you_port</span><br><span class="line">turnURL=kurento:kurento@you_url?transport=tcp</span><br></pre></td></tr></table></figure><p>一般情况下，坑到这里应该也就完了，但是你可以在试试，还是跑不通！！！！</p><p>这又是为什么呢？？？？</p><p>最后我想了想，为什么本地配置就完全没问题呢？就算连接公网需要turn，但是代码层面却没有任何提示啊，这不应该，所以，接下来就是最坑的了，你甚至需要去打开源代码，修改并连接turn服务器！！！！</p><p>我敢说，绝大多数人都会和我一样，觉得这不应该，你特么本地的代码例子完全就是摆着看的嘛。</p><p>做法如下：</p><p>打开index.js</p><p>在函数function uiStart()里，增加一个叫iceservers的变量，格式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iceservers=&#123;</span><br><span class="line">   <span class="string">"iceServers"</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">         urls:<span class="string">"stun:139.198.123.138:3478"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         urls:[<span class="string">"turn:139.198.123.138:3478"</span>]</span><br><span class="line">           username:<span class="string">"kurento"</span>,</span><br><span class="line">           credential: <span class="string">"kurento"</span></span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再修改底下的options变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   localVideo: uiLocalVideo,</span><br><span class="line">   remoteVideo: uiRemoteVideo,</span><br><span class="line">   mediaConstraints: &#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">   onicecandidate: <span class="function">(<span class="params">candidate</span>) =&gt;</span> sendMessage(&#123;</span><br><span class="line">     id: <span class="string">'ADD_ICE_CANDIDATE'</span>,</span><br><span class="line">     candidate: candidate,</span><br><span class="line">   &#125;),</span><br><span class="line">     configuration: iceservers <span class="comment">//修改在这里，增加了一个configuration的key</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>暂时不写了。。。头痛</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kurento </tag>
            
            <tag> turn </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Nginx进行前后端分离项目部署-ruoyi</title>
      <link href="/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/"/>
      <url>/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Nginx进行前后端分离项目部署"><a href="#利用Nginx进行前后端分离项目部署" class="headerlink" title="利用Nginx进行前后端分离项目部署"></a>利用Nginx进行前后端分离项目部署</h2><p>首先需要这个项目，利用git去仓库克隆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/y_project/RuoYi-Vue.git</span><br></pre></td></tr></table></figure><p>然后我们就获得了这个项目，你可以看到，这个项目分为：</p><ul><li>ruoyi</li><li>ruoyi-ui</li></ul><p>这两个文件夹，一个是后端，一个是前端。</p><p>根据正常的操作使用说明，我们先使用idea打开这个项目，更改一下项目的目标地址。一般都是在application.yml 文件上：</p><p>比如你可以改localhost，或者是其他的ip地址，我就改了ip地址。</p><p>当然，如果你仅仅需要部署到单个服务器上，其他的都别管，直接使用maven打包就行了。</p><p><strong>后端的打包和运行很简单，这里不多赘述了</strong></p><h3 id="开始准备"><a href="#开始准备" class="headerlink" title="开始准备"></a>开始准备</h3><p>我这里准备了三台虚拟机：</p><ol><li>192.168.78.128</li><li>192.168.78.129</li><li>192.168.78.130</li></ol><p>第二台和第三台虚拟机都是部署后端的jar包，我们准备使用Nginx进行负载均衡，这里我后端的数据库是连接前端的128的ip，因为只有同一个数据库才好进行负载均衡。</p><p>首先需要在128部署好docker，docker下安装好MySQL和Redis。</p><p>启动docker镜像，启动两个后端，紧接着我们来到前端进行部署。</p><h3 id="安装Nodejs和Nginx"><a href="#安装Nodejs和Nginx" class="headerlink" title="安装Nodejs和Nginx"></a>安装Nodejs和Nginx</h3><h4 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h4><p>我这⾥下载的是 node-v12.16.3-linux-x64.tar.xz 安装包，并将其直接放在了 root ⽬录下。</p><p>1、在 /usr/local/ 下创建 node ⽂件夹并进⼊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir node</span><br><span class="line">cd node</span><br></pre></td></tr></table></figure><p>2、将 Node 的安装包解压到 /usr/local/node 中即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost node]# tar -xJvf /root/node-v12.16.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>解压完之后， /usr/local/node ⽬录中会出现⼀个 node-v12.16.3-linux-x64 的⽬录</p><p><strong>配置NODE系统环境变量</strong></p><p>编辑 ~/.bash_profile ⽂件，在⽂件末尾追加如下信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Nodejs</span></span><br><span class="line">export PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATH</span><br></pre></td></tr></table></figure><p>刷新环境变量，使之⽣效即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p><strong>检查安装结果</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>这⾥下载的是 nginx-1.17.10.tar.gz 安装包，并将其直接放在了 root ⽬录下</p><p>1、在 /usr/local/ 下创建 nginx ⽂件夹并进⼊:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br></pre></td></tr></table></figure><p>2、将 Nginx 安装包解压到 /usr/local/nginx 中即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# tar zxvf /root/nginx-1.17.10.tar.gz -C ./</span><br></pre></td></tr></table></figure><p>解压完之后， /usr/local/nginx ⽬录中会出现⼀个 nginx-1.17.10 的⽬录</p><p><strong>预先安装额外的依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><p><strong>编译安装NGINX</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.17.10</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后，Nginx的可执⾏⽂件位置位于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p><strong>启动NGINX</strong></p><p>直接执⾏如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>如果想停⽌Nginx服务，可执⾏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p>如果修改了配置⽂件后想重新加载Nginx，可执⾏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>注意其配置⽂件位于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h3><p>把ruoyi-ui放在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/workspace/ruoyi-ui/</span><br></pre></td></tr></table></figure><p>文件夹下，并使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --unsafe-perm --registry=https:registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>–unsafe-perm：是为了更高的权限</p><p>–registry=https:registry.npm.taobao.org：拥有更快的镜像源</p><p>然后等待执行完毕。</p><p>执行完毕后，可以看到多了一个node模块。</p><p>接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>开始建立，建立完成后，可以看到多了一个dist文件夹，这表示我们基本完成了环境的构建。</p><h3 id="使用Nginx代理服务器完成部署"><a href="#使用Nginx代理服务器完成部署" class="headerlink" title="使用Nginx代理服务器完成部署"></a>使用Nginx代理服务器完成部署</h3><p>打开配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>把最上的user注释改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user  root;</span><br></pre></td></tr></table></figure><p>以此获得最大的权限。</p><p>接着，定位到：location /，并将其改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /root/workspace/ruoyiui/dist;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果页面发生了404错误，那么可以在这里修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root ...</span><br><span class="line">    index ...</span><br><span class="line">    try_files $uri $uri/ /index.html; ---解决页面刷新404问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这句话的意思是，当访问uri没有的时候 尝试访问 index.html 由于vue是单页模式，所以入口都是index.html 无论访问什么连接都由vue本身接管</strong></p><p>可以看到的是，这里的root路径，就是我们的前端路径。</p><p>启动nginx，然后我们可以打开节点：192.168.78.128</p><p>我们却发现，它出现了一点错误（暂时无图）</p><p>这个错误是地址引用错误，在验证码这个url错误，原因是正确的地址是：192.168.78.128/prod-api/xxxx</p><p>这表示，我们遗失了 prod-api 这个路径，那怎么办呢？</p><p>我们回到Nginx配置文件，添加一项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       location /prod-api/ &#123;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://192.168.78.129:8080/;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>/usr/local/nginx/sbin/nginx -s reload ，重启Nginx，便可以了。</p><p>这里的前四段是标准写法，不用太多思考，最后的一段才是真正后端地址</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>需要在任意一个位置加上upstream：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   upstream ruoyi&#123;</span><br><span class="line">server 192.168.78.129:8080 weight=5;</span><br><span class="line">server 192.168.78.130:8080 weight=3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>并且把location /prod-api/ ，改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   location /prod-api/ &#123;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://ruoyi/;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>/usr/local/nginx/sbin/nginx -s reload，重启Nginx，这样Nginx便会自动的实现负载均衡。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 项目 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Redis（二）</title>
      <link href="/2020/06/09/redis4/"/>
      <url>/2020/06/09/redis4/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的数据库"><a href="#Redis的数据库" class="headerlink" title="Redis的数据库"></a>Redis的数据库</h2><h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>redis和mysql类似，redis也有自己不同的数据库。但是和mysql不一样的是，redis的数据库是自发产生的，redis会根据服务器状态，自行的确定数据库的数量。默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000421.jpg" alt=""></p><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line">redis&gt; SELECT <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line">(<span class="literal">nil</span>)</span><br><span class="line">redis[<span class="number">2</span>]&gt; SET msg<span class="string">"another world"</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line"><span class="string">"another world"</span></span><br></pre></td></tr></table></figure><h4 id="谨慎处理多数据库程序"><a href="#谨慎处理多数据库程序" class="headerlink" title="谨慎处理多数据库程序"></a>谨慎处理多数据库程序</h4><p>如果你在其他语言的客户端中执行Redis命令，并且该客户端没有像redis-cli那样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。</p><h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p>如我们执行一下命令：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; RPUSH alphabet <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line">(integer)<span class="number">3</span></span><br><span class="line">redis&gt; HSET book name <span class="string">"Redis in Action"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book author <span class="string">"Josiah L. Carlson"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book publisher <span class="string">"Manning"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后的模型就是这样：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000028.jpg" alt=""></p><h5 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h5><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">date</span> <span class="string">"2013.12.1"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000391.jpg" alt=""></p><h5 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h5><p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p><h5 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h5><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p><h5 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h5><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</p><h5 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h5><p>除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。</p><p>比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p><p>另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。</p><h5 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h5><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之内</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之后</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。</p><p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">1000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) <span class="number">997</span></span><br><span class="line">redis&gt; SET another_key another_value</span><br><span class="line">OK</span><br><span class="line">redis&gt; TIME</span><br><span class="line"><span class="number">1</span>)<span class="string">"1377333070"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"761687"</span></span><br><span class="line">redis&gt; EXPIREAT another_key <span class="number">1377333100</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL another_key</span><br><span class="line">(integer) <span class="number">10</span></span><br></pre></td></tr></table></figure><p>如果是：EXPIREAT another_key 1385877600000，这表示数据库键过期时间为1385877600000（2013年12月1日零时）。</p><h5 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h5><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li>EXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl秒。</li><li>PEXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl毫秒。</li><li>EXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li><li>PEXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p><h5 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h5><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h5 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h5><p>PERSIST命令可以移除一个键的过期时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PEXPIREAT message <span class="number">1391234400000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">13893281</span></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>ERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><h5 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h5><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT alphabet <span class="number">1385877600000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL alphabet</span><br><span class="line">(integer) <span class="number">8549007</span></span><br><span class="line">redis&gt; PTTL alphabet</span><br><span class="line">(integer) <span class="number">8549001011</span></span><br></pre></td></tr></table></figure><h5 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h5><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><p>1）检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</p><p>2）检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</p><h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><p>我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是：如果一个键过期了，那么它什么时候会被删除呢？</p><p>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p><p>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><p>例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。</p><p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。</p><p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p><p>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</p><p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p> 从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li><li>惰性删除浪费太多内存，有内存泄漏的危险。</li><li>定期删除策略是前两种策略的一种整合和折中：</li><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li><li>定期删除策略的难点是确定删除操作执行的时长和频率：</li><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p><h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h5 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h5><p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><h5 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h5><p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><h4 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h4><p>我们将探讨过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p><h5 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h5><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><h5 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h5><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h5 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h5><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><ul><li>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：</li><li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。</li><li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。</li><li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。</li><li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。</li><li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El。</li></ul><p>关于数据库通知功能的详细用法，以及notify-keyspace-events选项的更多设置，Redis的官方文档已经做了很详细的介绍，这里不再赘述。</p><h5 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h5><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type,<span class="keyword">char</span> *event,robj *key,<span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。</p><p>event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。</p><p>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h5 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h5><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span></span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(server.notify_keyspace_events &amp; type):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment">#内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment">#内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyevent@&#123;dbid&#125;__:&#123;event&#125;"</span>.format(dbid=dbid,event=event)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure><p>notifyKeyspaceEvent函数执行以下操作：</p><p>1）server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</p><p>2）如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</p><p>3）最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</p><h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</li><li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li><li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li><li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li><li>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</li><li>Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li><li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li></ul><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p><p>比如：一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000211.jpg" alt=""></p><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p><p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><h5 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h5><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</p><p>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000002.jpg" alt=""></p><h5 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h5><p>前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。</p><p>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p><h5 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h5><p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。</p><p>首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</p><p>其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</p><p>最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：</p><ul><li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li><li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li></ul><p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p><h5 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h5><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h5 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h5><p>在上一节，我们介绍了SAVE命令和BGSAVE的实现方法，并且说明了这两个命令在实现方面的主要区别：SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会。</p><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h5 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h5><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件。</p><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h5><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul><p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p><h5 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h5><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>我们将对RDB文件本身进行介绍，并详细说明文件各个部分的结构和意义。</p><p>图展示了一个完整RDB文件所包含的各个部分:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000011.jpg" alt=""></p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。本章只介绍第六版RDB文件的结构。</p><p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p><p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h5 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h5><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000074.jpg" alt=""></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000121.jpg" alt=""></p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p><p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h5 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h5><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p><p>带有过期时间的键值对在RDB文件中的结构：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000025.jpg" alt=""></p><p>带有过期时间的键值对中的TYPE、key、value三个部分的意义，和前面介绍的不带过期时间的键值对的TYPE、key、value三个部分的意义完全相同，至于新增的EXPIRETIME_MS和ms，它们的意义如下：</p><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h5 id="Value的编码"><a href="#Value的编码" class="headerlink" title="Value的编码"></a>Value的编码</h5><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><p><strong>1.字符串对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。</p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p><strong>2.列表对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象<img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000184.jpg" alt=""></p><p><strong>3.集合对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象.。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000320.jpg" alt=""></p><p><strong>4.哈希表对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象。</p><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000410.jpg" alt="img"></p><p><strong>5.有序集合对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000423.jpg" alt="img"></p><p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。</p><p>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><p><strong>6.INTSET编码的集合</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p><p>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><p><strong>7.ZIPLIST编码的列表、哈希表或者有序集合</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p><p>1）将压缩列表转换成一个字符串对象。</p><p>2）将转换所得的字符串对象保存到RDB文件。</p><p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><p>1）读入字符串对象，并将它转换成原来的压缩列表对象。</p><p>2）根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</p><h4 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h4><h5 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h5><p>根据之前学习的RDB文件结构知识，当一个RDB文件没有包含任何数据库数据时，这个RDB文件将由以下四个部分组成：</p><ul><li>·五个字节的”REDIS”字符串。</li><li>·四个字节的版本号（db_version）。</li><li>·一个字节的EOF常量。</li><li>·八个字节的校验和（check_sum）。</li></ul><p>从od命令的输出中可以看到，最开头的是“REDIS”字符串，之后的0006是版本号，再之后的一个字节377代表EOF常量，最后的334 263 C 360 Z 334 362 V八个字节则代表RDB文件的校验和。</p><h5 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h5><p>根据之前学习的数据库结构知识，当一个数据库被保存到RDB文件时，这个数据库将由以下三部分组成：</p><ul><li>·一个一字节长的特殊值SELECTDB。</li><li>·一个长度可能为一字节、两字节或者五字节的数据库号码（db_number）。</li><li>·一个或以上数量的键值对（key_value_pairs）。</li></ul><p>观察od命令打印的输出，RDB文件的最开始仍然是REDIS和版本号0006，之后出现的376代表SELECTDB常量，再之后的\0代表整数0，表示被保存的数据库为0号数据库。</p><h5 id="包含带有过期时间的字符串键的RDB文件"><a href="#包含带有过期时间的字符串键的RDB文件" class="headerlink" title="包含带有过期时间的字符串键的RDB文件"></a>包含带有过期时间的字符串键的RDB文件</h5><p>根据之前学习的键值对结构知识，一个带有过期时间的键值对将由以下部分组成：</p><ul><li>·一个一字节长的EXPIRETIME_MS特殊值。</li><li>·一个八字节长的过期时间（ms）。</li><li>·一个一字节长的类型（TYPE）。</li><li>·一个键（key）和一个值（value）。</li></ul><h5 id="包含一个集合键的RDB文件"><a href="#包含一个集合键的RDB文件" class="headerlink" title="包含一个集合键的RDB文件"></a>包含一个集合键的RDB文件</h5><p>以下是RDB文件各个部分的意义：</p><ul><li>·REDIS0006：RDB文件标志和版本号。</li><li>·376\0：切换到0号数据库。</li><li>·002 004 L A N G：002是常量REDIS_RDB_TYPE_SET（这个常量的实际值为整数2），表示这是一个哈希表编码的集合键，004表示键的长度，LANG是键的名字。</li><li>·003：集合的大小，说明这个集合包含三个元素。</li><li>·004 R U B Y：集合的第一个元素。</li><li>·004 J A V A：集合的第二个元素。</li><li>·001 C：集合的第三个元素。</li><li>·377：代表常量EOF。</li><li>·202 312 r 352 346 305*023：代表校验和。</li></ul><h4 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li><li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li><li>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li><li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000442.jpg" alt="img"></p><p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。</p><p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容。</p><h5 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h5><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p><h5 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h5><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p><strong>文件的写入和同步</strong></p><p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><p><strong>AOF持久化的效率和安全性</strong></p><p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li></ul><h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><p>1）创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</p><p>2）从AOF文件中分析并读取出一条写命令。</p><p>3）使用伪客户端执行被读出的写命令。</p><p>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p><p>当完成以上步骤之后，AOF文件所保存的数据库状态就会被完整地还原出来</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000420.jpg" alt=""></p><h4 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p><p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p><h4 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li><li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li><li>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li><li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li><li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li><li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h5 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h5><p>文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000316.jpg" alt=""></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p><p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><h5 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I/O多路复用程序的实现"></a>I/O多路复用程序的实现</h5><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><h5 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h5><p>I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li><li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li></ul><p>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p><p>ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p><p>ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li>·如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li><li>·如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li><li>·如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li><li>·如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li></ul><p>ae.c/aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p><p>ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p><p>ae.c/aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p><p>ae.c/aeGetApiName函数返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p><h5 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h5><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li>·为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>·为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>·为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>·当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><p><strong>1.连接应答处理器</strong></p><p>networking.c/acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p><p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000266.jpg" alt="img"></p><p><strong>2.命令请求处理器</strong></p><p>networking.c/readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。</p><p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000331.jpg" alt="img"></p><p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p><p><strong>3.命令回复处理器</strong></p><p>networking.c/sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p><p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000250.jpg" alt="img"></p><p>当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件之间的关联。</p><p><strong>4.一次完整的客户端与服务器连接事件示例</strong></p><p>让我们来追踪一次Redis客户端与服务器进行连接并发送命令的整个过程，看看在过程中会产生什么事件，而这些事件又是如何被处理的。</p><p>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p><p>如果这时有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p><p>之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p><p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000008.jpg" alt="img"></p><p>#####　时间事件</p><p>Redis的时间事件分为以下两类：</p><ul><li>·定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>·周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>·id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>·when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li><li>·timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>·如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>·如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p><p>#####　实现</p><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><p>图展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件：因为新的时间事件总是插入到链表的表头，所以三个时间事件分别按ID逆序排序，表头事件的ID为3，中间事件的ID为2，表尾事件的ID为1。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000382.jpg" alt="img"></p><p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p><p>无序链表并不影响时间事件处理器的性能</p><p>在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p><h5 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h5><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>·更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>·清理数据库中的过期键值对。</li><li>·关闭和清理连接失效的客户端。</li><li>·尝试进行AOF或RDB持久化操作。</li><li>·如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>·如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p><p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。</p><p>从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。</p><h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>从事件处理的角度来看，Redis服务器的运行流程可以用流程图：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000428.jpg" alt=""></p><p>以下是事件的调度和执行规则：</p><p>1）aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</p><p>2）因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</p><p>3）对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</p><p>4）因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</p><h4 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li><li>文件事件处理器是基于Reactor模式实现的网络通信程序。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li><li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li><li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p><p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><ol><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值（flag）。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li></ol><h4 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h4><p>客户端状态包含的属性可以分为两类：</p><p>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</p><p>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</p><h5 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h5><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符。</p><p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p><ul><li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。</li><li>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数。</li></ul><h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p><h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态</p><p>每个标志使用一个常量表示，一部分标志记录了客户端的角色：</p><p>·在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</p><p>·REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。</p><p>·REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</p><p>而另外一部分标志则记录了客户端目前所处的状态：</p><p>·REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</p><p>·REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</p><p>·REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。</p><p>·REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来，不再阻塞。REDIS_UNBLOCKED标志只能在REDIS_BLOCKED标志已经打开的情况下使用。</p><p>·REDIS_MULTI标志表示客户端正在执行事务。</p><p>·REDIS_DIRTY_CAS标志表示事务使用WATCH命令监视的数据库键已经被修改，REDIS_DIRTY_EXEC标志表示事务在命令入队时出现了错误，以上两个标志都表示事务的安全性已经被破坏，只要这两个标记中的任意一个被打开，EXEC命令必然会执行失败。这两个标志只能在客户端打开了REDIS_MULTI标志的情况下使用。</p><p>·REDIS_CLOSE_ASAP标志表示客户端的输出缓冲区大小超出了服务器允许的范围，服务器会在下一次执行serverCron函数时关闭这个客户端，以免服务器的稳定性受到这个客户端影响。积存在输出缓冲区中的所有内容会直接被释放，不会返回给客户端。</p><p>·REDIS_CLOSE_AFTER_REPLY标志表示有用户对这个客户端执行了CLIENT KILL命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端，然后关闭客户端。</p><p>·REDIS_ASKING标志表示客户端向集群节点（运行在集群模式下的服务器）发送了ASKING命令。</p><p>·REDIS_FORCE_AOF标志强制服务器将当前执行的命令写入到AOF文件里面，REDIS_FORCE_REPL标志强制主服务器将当前执行的命令复制给所有从服务器。执行PUBSUB命令会使客户端打开REDIS_FORCE_AOF标志，执行SCRIPT LOAD命令会使客户端打开REDIS_FORCE_AOF标志和REDIS_FORCE_REPL标志。</p><p>·在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送这个命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY标志，否则发送操作会被拒绝执行。</p><p>以上提到的所有标志都定义在redis.h文件里面。</p><p><strong>PUBSUB命令和SCRIPT LOAD命令的特殊性</strong></p><p>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。<br>以上规则适用于绝大部分Redis命令，但PUBSUB命令和SCRIPT LOAD命令是其中的例外。PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。因此，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。SCRIPT LOAD命令的情况与PUBSUB命令类似：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。</p><h5 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求</p><h5 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h5><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。</p><p>argc属性则负责记录argv数组的长度。</p><h5 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h5><p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p><h5 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h5><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p><p>·固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</p><p>·可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</p><h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证</p><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>最后，客户端还有几个和时间有关的属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><h4 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h4><p>服务器使用不同的方式来创建和关闭不同类型的客户端，本节将介绍服务器创建和关闭客户端的方法。</p><h5 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h5><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器（在第12章有介绍），为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p><h5 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h5><p>一个普通客户端可以因为多种原因而被关闭：</p><p>·如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</p><p>·如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</p><p>·如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</p><p>·如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS_MASTER标志），从服务器（打开了REDIS_SLAVE标志），正在被BLPOP等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</p><p>·如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</p><p>·如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</p><p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。</p><p>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><p>·硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</p><p>·软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</p><h5 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h5><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisClient *lua_client;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h5><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端.</p><h4 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li><li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li><li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li><li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li><li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li><li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li><li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li><li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li><li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li></ul><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h4 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h4><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。</p><h5 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h5><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p><h5 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h5><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p><p>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</p><p>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p>3）调用命令执行器，执行客户端指定的命令。</p><h5 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h5><p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p><p>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息，表记录了这个结构的各个主要属性的类型和作用：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000095.jpg" alt=""></p><h5 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h5><p>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：</p><p>·检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</p><p>·根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</p><p>·检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</p><p>·如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</p><p>·如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</p><p>·如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</p><p>·如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</p><p>·如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</p><p>·如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</p><p>·如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</p><h5 id="命令执行器（3）：调用命令的实现函数"><a href="#命令执行器（3）：调用命令的实现函数" class="headerlink" title="命令执行器（3）：调用命令的实现函数"></a>命令执行器（3）：调用命令的实现函数</h5><p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// client</span><br><span class="line">是指向客户端状态的指针</span><br><span class="line">client-&gt;cmd-&gt;proc(client);</span><br></pre></td></tr></table></figure><h5 id="命令执行器（4）：执行后续工作"><a href="#命令执行器（4）：执行后续工作" class="headerlink" title="命令执行器（4）：执行后续工作"></a>命令执行器（4）：执行后续工作</h5><p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p><p>·如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</p><p>·根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</p><p>·如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</p><p>·如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</p><p>当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了</p><h5 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h5><p>前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p><h5 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h5><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端）</p><h5 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h5><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h5 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h5><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p><p>·服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</p><p>·对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</p><h5 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h5><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">// 用于计算键的空转（idle）时长。</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h5><p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看</p><h5 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h5><p>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h5><p>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGTERM信号的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    redisLogFromHandler(REDIS_WARNING,<span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</span><br><span class="line">    <span class="comment">// 打开关闭标识</span></span><br><span class="line">    server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h5><p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p><p>·如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。</p><p>·如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</p><h5 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h5><p>serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</p><h5 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h5><p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p><h5 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h5><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGSAVE，</span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;                <span class="comment">/* PID of RDB saving child */</span></span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGREWRITEAOF，    </span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;                <span class="comment">/* PID if rewriting process */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p><p>·如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</p><p>·如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</p><p>另一方面，如果rdb_child_pid和aof_child_pid两个属性的值都为-1，那么表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：</p><p>1）查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作（这就是上一个小节我们说到的检查）。</p><p>2）检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了）。</p><p>3）检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000328.jpg" alt=""></p><h5 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h5><p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</p><h5 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h5><p>在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端</p><h5 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h5><p>服务器状态的cronloops属性记录了serverCron函数执行的次数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// serverCron函数的运行次数计数器</span></span><br><span class="line">    <span class="comment">// serverCron函数每执行一次，这个属性的值就增一。</span></span><br><span class="line">    <span class="keyword">int</span> cronloops;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能。</p><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h5 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h5><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置服务器的运行id </span></span><br><span class="line">    getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);</span><br><span class="line">    <span class="comment">// 为运行id加上结尾字符</span></span><br><span class="line">    server.runid[REDIS_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 设置默认配置文件路径</span></span><br><span class="line">    server.configfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器频率</span></span><br><span class="line">    server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line">    <span class="comment">// 设置服务器的运行架构</span></span><br><span class="line">    server.arch_bits = (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器端口号</span></span><br><span class="line">    server.port = REDIS_SERVERPORT;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是initServerConfig函数完成的主要工作：</p><p>·设置服务器的运行ID。</p><p>·设置服务器的默认运行频率。</p><p>·设置服务器的默认配置文件路径。</p><p>·设置服务器的运行架构。</p><p>·设置服务器的默认端口号。</p><p>·设置服务器的默认RDB持久化条件和AOF持久化条件。</p><p>·初始化服务器的LRU时钟。</p><p>·创建命令表。</p><p>initServerConfig函数设置的服务器状态属性基本都是一些整数、浮点数、或者字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象这些数据结构在之后的步骤才会被创建出来。</p><h5 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h5><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p><h5 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h5><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p><p>·server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</p><p>·server.db数组，数组中包含了服务器的所有数据库。</p><p>·用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</p><p>·用于执行Lua脚本的Lua环境server.lua。</p><p>·用于保存慢查询日志的server.slowlog属性。</p><p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p><p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p><p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p><p>·为服务器设置进程信号处理器。</p><p>·创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</p><p>·打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</p><p>·为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</p><p>·如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</p><p>·初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备。</p><h5 id="原数据库状态"><a href="#原数据库状态" class="headerlink" title="原数据库状态"></a>原数据库状态</h5><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p><p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p><p>·如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</p><p>·相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</p><h5 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h5><p>在初始化的最后一步，服务器将打印出日志。</p><h4 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h4><p>一个命令请求从发送到完成主要包括以下步骤：</p><ul><li>1）客户端将命令请求发送给服务器；</li><li>2）服务器读取命令请求，并分析出命令参数；</li><li>3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li><li>4）服务器将命令回复返回给客户端。</li></ul><p>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</p><p>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ul><li>1）初始化服务器状态；</li><li>2）载入服务器配置；</li><li>3）初始化服务器数据结构；</li><li>4）还原数据库状态；</li><li>5）执行事件循环。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Redis（一）</title>
      <link href="/2020/06/02/redis3/"/>
      <url>/2020/06/02/redis3/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>在深入学习Springboot之后，我想，对于各个部件的使用，不应该仅仅局限于它的外部API，如果可以深入的去了解它的构造，想必以后也会有很多收获吧。</p><p>首先，我们来阐述一下Redis的概念，我们一般使用Redis，都是把它作为一个缓存来用，那么这是一个用于什么类型的缓存呢，是图片？视频？还是什么？答案是字符串。其实Redis可以从狭义上来理解，Redis就是用来存储字符串的。你可不要小看这样的字符串，字符串可是信息的基本组成，也是数据的基石。</p><p>而Redis，则是由C语言来编写的，一个高速缓存器。</p><p>Redis自己构建了一种名为简单动态字符串的抽象类型，名为SDS。当我们加入一个字符串缓存时，Redis会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS。</p></li><li><p>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。</p></li></ul><p>如果客户端执行命令:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fruits <span class="string">"apple"</span> <span class="string">"banana"</span> <span class="string">"cherry"</span></span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串“fruits”的SDS。</li><li>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串“apple”，第二个SDS保存着字符串“banana”，第三个SDS保存着字符串“cherry”。</li></ul><h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><p>SDS是一个由C语言写成的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000134.jpg" alt=""></p><ul><li><p>free属性的值为0，表示这个SDS没有分配任何未使用空间。</p></li><li><p>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</p></li><li><p>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、’e’、’d’、’i’、’s’五个字符，而最后一个字节则保存了空字符’\0’。</p></li></ul><h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h4><p>根据传统，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000112.jpg" alt=""></p><h5 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h5><p>因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000075.jpg" alt=""></p><p>和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000014.jpg" alt=""></p><h5 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h5><p>除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p><p>如已经存在：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000041.jpg" alt=""></p><p>将s1的内容修改为”Redis Cluster”，但粗心的他却忘了在执行strcat之前为s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2保存的内容被意外地修改：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000051.jpg" alt=""></p><p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p><p>sdscat将在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接”Cluster”之后，sdscat就会先扩展s的空间，然后才执行拼接”Cluster”的操作：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000065.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000149.jpg" alt=""></p><p>sdscat不仅对这个SDS进行了拼接操作，它还为SDS分配了13字节的未使用空间，并且拼接之后的字符串也正好是13字节长，这种现象既不是bug也不是巧合，它和SDS的空间分配策略有关。</p><h5 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h5><p>C字符串并不记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。</li></ul><p>但是Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响。</p><p>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。</p><p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><p><strong>1.空间预分配</strong></p><p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。</p><ul><li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。</li><li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</li></ul><p>比如说：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000158.jpg" alt=""></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, <span class="string">" Cluster"</span>);</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000178.jpg" alt=""></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, <span class="string">" Tutorial"</span>)</span><br></pre></td></tr></table></figure><p>那么这次sdscat将不需要执行内存重分配，因为未使用空间里面的13字节足以保存9字节的”Tutorial”，执行sdscat之后的SDS。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000411.jpg" alt=""></p><p><strong>2.惰性空间释放</strong></p><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p><h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><p>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p><p>如果有一种使用空字符来分割多个单词的特殊数据格式，那么这种格式就不能使用C字符串来保存，因为C字符串所用的函数只会识别出其中的”Redis”，而忽略之后的”Cluster”。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000018.jpg" alt=""></p><p>使用SDS来保存之前提到的特殊数据格式就没有任何问题，因为SDS使用len属性的值而不是空字符来判断字符串是否结束。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000127.jpg" alt=""></p><h5 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h5><p>虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000119.jpg" alt=""></p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><p>比如说：以下展示的integers列表键包含了从1到1024共一千零二十四个整数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; LLEN integers</span><br><span class="line">(integer) <span class="number">1024</span></span><br><span class="line">redis&gt; LRANGE integers <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"4"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"5"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"6"</span></span><br><span class="line"><span class="number">7</span>)<span class="string">"7"</span></span><br><span class="line"><span class="number">8</span>)<span class="string">"8"</span></span><br><span class="line"><span class="number">9</span>)<span class="string">"9"</span></span><br><span class="line"><span class="number">10</span>)<span class="string">"10"</span></span><br><span class="line"><span class="number">11</span>)<span class="string">"11"</span></span><br></pre></td></tr></table></figure><p>integers列表键的底层实现就是一个链表，链表中的每个节点都保存了一个整数值。</p><h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="　链表和链表节点的实现"></a>　链表和链表节点的实现</h4><p>使用了一个数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000312.jpg" alt=""></p><p>并且为了方便进行管理，使用了一个list的结构去持有链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li></ul><p>于是乎，图形如下：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000235.jpg" alt=""></p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。</p><p>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p><p>举个例子，website是一个包含10086个键值对的哈希键，这个哈希键的键都是一些数据库的名字，而键的值就是数据库的主页网址：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HLEN website</span><br><span class="line">(integer) <span class="number">10086</span></span><br><span class="line">redis&gt; HGETALL website</span><br><span class="line"><span class="number">1</span>)<span class="string">"Redis"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"Redis.io"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"MariaDB"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"MariaDB.org"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"MongoDB"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"MongoDB.org"</span></span><br></pre></td></tr></table></figure><h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>哈希表的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000397.jpg" alt=""></p><h5 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h5><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><ul><li>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</li><li>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000345.jpg" alt=""></p><h5 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h5><p>Redis中的字典的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    in trehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>以此，根据上面的结构，我们可以推出一个完整的字典：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000368.jpg" alt=""></p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>比如这是一个空的字典：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000087.jpg" alt=""></p><p>然后我们会计算出kv0的哈希值，在使用哈希值去计算索引值，索引值所指的就是我们这个数据列的索引。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000096.jpg" alt=""></p><h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。</p><p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p>这里和Java中HashMap的处理方法非常的一致。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000221.jpg" alt=""></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><p>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：</p><p>·如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）；</p><p>·如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。</p><p>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p><p>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p><h5 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h5><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><p>1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</p><p>2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</p><p>对于一个大小为512，包含256个键值对的哈希表来说，这个哈希表的负载因子为：load_factor = ht[0].used / ht[0].size＝0.5</p><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。这样做的原因在于，一次性将这些键值对全部rehash的话，庞大的计算量可能会导致服务器在一段时间内停止服务。</p><p>因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p><p>以下是哈希表渐进式rehash的详细步骤：</p><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</p><p>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p><p>3）在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</p><p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</p><p>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p><h5 id="渐进式rehash执行期间的哈希表操作"><a href="#渐进式rehash执行期间的哈希表操作" class="headerlink" title="渐进式rehash执行期间的哈希表操作"></a>渐进式rehash执行期间的哈希表操作</h5><p>因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE fruit-price <span class="number">0</span> <span class="number">2</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>)<span class="string">"banana"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"5"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"cherry"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"6.5"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"apple"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"8"</span></span><br><span class="line">redis&gt; ZCARD fruit-price</span><br><span class="line">(integer)<span class="number">130</span></span><br></pre></td></tr></table></figure><h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000365.jpg" alt=""></p><ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>ength：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p>位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><ul><li>层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><h5 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h5><p>节点的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><strong>1.层</strong></p><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000126.jpg" alt=""></p><p><strong>2.前进指针</strong></p><p>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000188.jpg" alt=""></p><p>1）迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</p><p>2）在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</p><p>3）在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</p><p>4）当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p><p><strong>3.跨度</strong></p><p>层的跨度（level[i].span属性）用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p><strong>4.后退指针</strong></p><p>节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p><strong>5.分值和成员</strong></p><p>节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000207.jpg" alt=""></p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><p>举个例子，如果我们创建一个只包含五个元素的集合键，并且集合中的所有元素都是整数值，那么这个集合键的底层实现就会是整数集合：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line"><span class="string">"intset"</span></span><br></pre></td></tr></table></figure><h4 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h4><p>就好似如intset这个数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p><p>length属性记录了整数集合包含的元素数量，也即是contents数组的长度。</p><p>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：</p><ul><li>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767）。</li><li>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647）。</li><li>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000181.jpg" alt=""></p><ul><li>encoding属性的值为INTSET_ENC_INT16，表示整数集合的底层实现为int16_t类型的数组，而集合保存的都是int16_t类型的整数值。</li><li>length属性的值为5，表示整数集合包含五个元素。</li><li>contents数组按从小到大的顺序保存着集合中的五个元素。</li><li>因为每个集合元素都是int16_t类型的整数值，所以contents数组的大小等于sizeof（int16_t）<em>5=16</em>5=80位。</li></ul><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><p>1）根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</p><p>2）将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</p><p>3）将新元素添加到底层数组里面。</p><h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4><p>整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。</p><h5 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h5><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。</p><p>例如，我们一般只使用int16_t类型的数组来保存int16_t类型的值，只使用int32_t类型的数组来保存int32_t类型的值，诸如此类。</p><p>但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活。</p><h5 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h5><p>当然，要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值，最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。不过这样一来，即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值，数组都需要使用int64_t类型的空间去保存它们，从而出现浪费内存的情况。</p><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH lst <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">10086</span> <span class="string">"hello"</span> <span class="string">"world"</span></span><br><span class="line">(integer)<span class="number">6</span></span><br><span class="line">redis&gt; OBJECT ENCODING lst</span><br><span class="line"><span class="string">"ziplist"</span></span><br></pre></td></tr></table></figure><p><strong>注意：3.2版本的listTypePush会根据不同的编码调用不同数据结构的API，而4.0直接调用了quicklist的API，以前的编码转换的机制已经不存在了。</strong></p><h4 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h4><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000044.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000059.jpg" alt=""></p><h4 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h4><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种：</p><ul><li>长度小于等于63（2 6–1）字节的字节数组；</li><li>长度小于等于16383（2 14–1）字节的字节数组；</li><li>长度小于等于4294967295（2 32–1）字节的字节数组；</li></ul><p>而整数值则可以是以下六种长度的其中一种：</p><ul><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长的有符号整数；</li><li>3字节长的有符号整数；</li><li>nt16_t类型整数；</li><li>int32_t类型整数；</li><li>int64_t类型整数。</li></ul><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p><h5 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h5><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><h5 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h5><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度：</p><ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；</li></ul><h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000274.jpg" alt=""></p><ul><li>编码的最高两位00表示节点保存的是一个字节数组；</li><li>编码的后六位001011记录了字节数组的长度11；</li><li>content属性保存着节点的值”hello world”。</li></ul><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000305.jpg" alt=""></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N 2）。</p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O（N），在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p><p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p><h4 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>对象的type属性记录了对象的类型，这个属性的值可以是表列出的常量的其中一个。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000182.jpg" alt=""></p><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>TYPE命令在面对不同类型的值对象时所产生的输出。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000197.jpg" alt=""></p><h5 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h5><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表列出的常量的其中一个。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000377.jpg" alt=""></p><p>每种类型的对象都至少使用了两种不同的编码:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000128.jpg" alt=""></p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello wrold"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line"><span class="string">"embstr"</span></span><br><span class="line">redis&gt; SET story <span class="string">"long long long long long long ago ..."</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line">redis&gt; SADD numbers <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line"><span class="string">"intset"</span></span><br><span class="line">redis&gt; SADD numbers <span class="string">"seven"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure><p>不同编码的对象所对应的OBJECT ENCODING命令输出:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000419.jpg" alt=""></p><p>在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000396.jpg" alt=""></p><ul><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li><li>可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。</li></ul><p>在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。</p><h5 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。</p><p>因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。</p><h5 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h5><p>因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的:<img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000151.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000099.jpg" alt=""></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</p><h5 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h5><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</li></ul><h5 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h5><p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000093.jpg" alt=""></p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><h5 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h5><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</li></ul><h5 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h5><p>因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000436.jpg" alt=""></p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p><h5 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码。</p><h5 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h5><p>因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000437.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000009.jpg" alt=""></p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p><p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p><h4 id="为什么有序集合需要同时使用跳跃表和字典来实现？"><a href="#为什么有序集合需要同时使用跳跃表和字典来实现？" class="headerlink" title="为什么有序集合需要同时使用跳跃表和字典来实现？"></a>为什么有序集合需要同时使用跳跃表和字典来实现？</h4><p>在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。</p><p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000216.jpg" alt=""></p><h5 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><p>有序集合保存的元素数量小于128个；</p><p>有序集合保存的所有元素成员的长度都小于64字节；</p><p>不能满足以上两个条件的有序集合对象将使用skiplist编码。</p><h5 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h5><p>因为有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000329.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000332.jpg" alt=""></p><h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。</p><p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p><h5 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h5><p>从上面发生类型错误的代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。</p><p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li><li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li></ul><h5 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h5><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1；</li><li>当对象被一个新程序使用时，它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000194.jpg" alt=""></p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象，如图8-20所示。</p><p>如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有以下两种做法：</p><p>1）为键B新创建一个包含整数值100的字符串对象；</p><p>2）让键A和键B共享同一个字符串对象；</p><p>以上两种方法很明显是第二种方法更节约内存。</p><p>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p><p>1）将数据库键的值指针指向一个现有的值对象；</p><p>2）将被共享的值对象的引用计数增一。</p><h4 id="为什么Redis不共享包含字符串的对象？"><a href="#为什么Redis不共享包含字符串的对象？" class="headerlink" title="为什么Redis不共享包含字符串的对象？"></a>为什么Redis不共享包含字符串的对象？</h4><p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：</p><ul><li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）；</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N 2）。</li></ul><p>因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p><h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p>redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"># </span><br><span class="line">等待一小段时间</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">20</span></span><br><span class="line"># </span><br><span class="line">等待一阵子</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">180</span></span><br><span class="line">#</span><br><span class="line">访问msg</span><br><span class="line">键的值</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line"># </span><br><span class="line">键处于活跃状态，空转时长为<span class="number">0</span> </span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。</p><p>除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Redis数据库中的每个键值对的键和值都是一个对象。</p><p>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</p><p>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</p><p>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</p><p>Redis会共享值为0到9999的字符串对象。</p><p>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用tess4j实现简单图像识别</title>
      <link href="/2020/05/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB1/"/>
      <url>/2020/05/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB1/</url>
      
        <content type="html"><![CDATA[<h2 id="利用tess4j把PDF转化为文字"><a href="#利用tess4j把PDF转化为文字" class="headerlink" title="利用tess4j把PDF转化为文字"></a>利用tess4j把PDF转化为文字</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="Java运行环境"><a href="#Java运行环境" class="headerlink" title="Java运行环境"></a>Java运行环境</h4><p>在cmd输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -v</span><br></pre></td></tr></table></figure><p>JDK最好为8。</p><h4 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h4><p>利用tess4j需要训练集和资源库，在这里我把资源库地址给写死了。</p><p>请把tessdata这个文件夹放在：E：/temp/ </p><p>这个文件夹下面，没有则创建一个，仅仅手动操作这个便可以。</p><h4 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h4><p>在拿出Jar包，放在任意位置都可以，然后使用cmd 切换到目标地址下输入指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar to.jar</span><br></pre></td></tr></table></figure><p>便可以运行了，然后打开：localhost：8888。访问或者使用。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="PDF操作"><a href="#PDF操作" class="headerlink" title="PDF操作"></a>PDF操作</h4><p>这里运用了maven，在pom文件下加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.tess4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tess4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便引入了对PDF的依赖，然后在后端的控制层加入：@RequestParam(“file”) MultipartFile file 去绑定所提交的PDF文件。</p><p>然后通过将pdf分解为图片，在使用tess4j去识别图片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PDDocument doc = PDDocument.load(multipartFileToFile(file));</span><br><span class="line">PDFRenderer renderer = <span class="keyword">new</span> PDFRenderer(doc);</span><br><span class="line"><span class="keyword">int</span> pageCount = doc.getNumberOfPages();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pageCount; i++) &#123;</span><br><span class="line">    BufferedImage image = renderer.renderImageWithDPI(i, <span class="number">144</span>); </span><br><span class="line">    String fn[];</span><br><span class="line">    fn=fileName.split(<span class="string">"\\."</span>);</span><br><span class="line">    File my=<span class="keyword">new</span> File(filePath + <span class="string">"\\"</span> + fn + <span class="string">"_"</span> + (i + <span class="number">1</span>) + <span class="string">"."</span> + <span class="string">"jpg"</span>);</span><br><span class="line">    ImageIO.write(image, <span class="string">"jpg"</span>, my);</span><br><span class="line">    tesspdf(my,i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的tesspdf方法便是将图片转化为文字。</p><h4 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h4><p>在通过路劲获得了图片文件后，主要的操作方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tessreact.doOCR(imageFile);</span><br></pre></td></tr></table></figure><p>它会读取相应的图片文件，然后进行转化，它的流程是：</p><p>1、先使用：public StringBuilder() {    super(16);}，对字符串进行构建和识别，防止空串。</p><p>2、再使用：AbstractStringBuilder(int capacity) {    value = new char[capacity];}，进行构建。</p><blockquote><p>3、再对识别出的字符串进行拼串，为什么要这么做呢？那是因为有着:<code>\\</code>，这样的特殊的转义字符。具体方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、它会向tessOCR返回一个字符串表示收到，并开始构建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doOCR</span><span class="params">(File var1)</span> <span class="keyword">throws</span> TesseractException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doOCR((File)var1, (Rectangle)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、从字符串的路径中找到图片：ImageIOHelper.getImageFile(var1);</p><p>6、然后通过一个方法获取到图像的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getImageFileFormat</span><span class="params">(File var0)</span> </span>&#123;</span><br><span class="line">    String var1 = var0.getName();</span><br><span class="line">    String var2 = var1.substring(var1.lastIndexOf(<span class="number">46</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (var2.matches(<span class="string">"(pbm|pgm|ppm)"</span>)) &#123;</span><br><span class="line">        var2 = <span class="string">"pnm"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2.matches(<span class="string">"(jp2|j2k|jpf|jpx|jpm)"</span>)) &#123;</span><br><span class="line">        var2 = <span class="string">"jpeg2000"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、借助ImageIO这个类，对图像进行读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Iterator&lt;ImageReader&gt;</span><br><span class="line">        getImageReadersByFormatName(String formatName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (formatName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"formatName == null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator iter;</span><br><span class="line">        <span class="comment">// Ensure category is present</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            iter = theRegistry.getServiceProviders(ImageReaderSpi<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">new</span> <span class="title">ContainsFilter</span>(<span class="title">readerFormatNamesMethod</span>,</span></span><br><span class="line"><span class="class">                                                       <span class="title">formatName</span>),</span></span><br><span class="line"><span class="class">                                                <span class="title">true</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImageReaderIterator(iter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>8、可以从7看到，它返回的是迭代器，然后把这个迭代器的值转化为ImageReader</p><p>9、而这个ImageReader，已经拥有了对图片进行处理的能力，它会调用：readAll方法进行读取，主要方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IIOImage <span class="title">readAll</span><span class="params">(<span class="keyword">int</span> imageIndex, ImageReadParam param)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageIndex &lt; getMinIndex()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"imageIndex &lt; getMinIndex()!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferedImage im = read(imageIndex, param);</span><br><span class="line"></span><br><span class="line">        ArrayList thumbnails = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> numThumbnails = getNumThumbnails(imageIndex);</span><br><span class="line">        <span class="keyword">if</span> (numThumbnails &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            thumbnails = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numThumbnails; j++) &#123;</span><br><span class="line">                thumbnails.add(readThumbnail(imageIndex, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IIOMetadata metadata = getImageMetadata(imageIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IIOImage(im, thumbnails, metadata);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法隐藏了很多细节，可以看到它返回的是IIOImage，而这个IIOImage，就是我们最终要得到的数据了。</p><p>10、然后使用doOCR方法进行字符串转化，也可看到这里填入的正是IIOImage类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doOCR</span><span class="params">(IIOImage var1, String var2, Rectangle var3, <span class="keyword">int</span> var4)</span> <span class="keyword">throws</span> TesseractException </span>&#123;</span><br><span class="line">    String var5 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setImage(var1.getRenderedImage(), var3);</span><br><span class="line">        var5 = <span class="keyword">this</span>.getOCRText(var2, var4);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">        logger.warn(var7.getMessage(), var7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> tess4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析项目：微人事</title>
      <link href="/2020/05/22/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C2/"/>
      <url>/2020/05/22/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C2/</url>
      
        <content type="html"><![CDATA[<h2 id="分析项目：微人事"><a href="#分析项目：微人事" class="headerlink" title="分析项目：微人事"></a>分析项目：微人事</h2><p>这次我们来分析一下这个名为：”微人事“ 的项目的功能以及各个模块的实现。</p><p>这个项目分为两个大模块，分别是server模块和mail模块，这个项目的作者也已经很久没有更新了，我们先忽略掉mail这个模块，来看看server这个模块有着什么。</p><p>点击进入到server模块内，可以得知这个server模块又被切分为了四个小的模块，分别是mapper、model、service和web。</p><p>显然，这个web模块，就是我们主要学习的内容了。</p><p>之后根据经验之谈，一般在config这个包内的，基本上都是security的配置相关。</p><h3 id="Security配置"><a href="#Security配置" class="headerlink" title="Security配置"></a>Security配置</h3><p>配置中有一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O object)</span> </span>&#123;</span><br><span class="line">    object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">    object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来决定security的设置，而这两个设置，是被自定义的构造了出来。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>这个配置主要设置了两个选择，一个是在登录的时候，根据用户名去搜索数据库，根据用户名来得到用户的权限，从而跳转到该角色所能访问的页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomUrlDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute configAttribute : configAttributes) &#123;</span><br><span class="line">            String needRole = configAttribute.getAttribute();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"ROLE_LOGIN"</span>.equals(needRole)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"尚未登录，请登录!"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">                <span class="keyword">if</span> (authority.getAuthority().equals(needRole)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"权限不足，请联系管理员!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求分析"><a href="#请求分析" class="headerlink" title="请求分析"></a>请求分析</h4><p>这个类的作用，主要是根据用户传来的请求地址，分析出请求需要的角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilterInvocationSecurityMetadataSource</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuService menuService;</span><br><span class="line">    AntPathMatcher antPathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        String requestUrl = ((FilterInvocation) object).getRequestUrl();</span><br><span class="line">        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();</span><br><span class="line">        <span class="keyword">for</span> (Menu menu : menus) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(menu.getUrl(), requestUrl)) &#123;</span><br><span class="line">                List&lt;Role&gt; roles = menu.getRoles();</span><br><span class="line">                String[] str = <span class="keyword">new</span> String[roles.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roles.size(); i++) &#123;</span><br><span class="line">                    str[i] = roles.get(i).getName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> SecurityConfig.createList(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SecurityConfig.createList(<span class="string">"ROLE_LOGIN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有可以值得思考的地方是，作者的security为每一个成功或者失败的Handler，都做了自己处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        Hr hr = (Hr) authentication.getPrincipal();</span><br><span class="line">        hr.setPassword(<span class="keyword">null</span>);</span><br><span class="line">        RespBean ok = RespBean.ok(<span class="string">"登录成功!"</span>, hr);</span><br><span class="line">        String s = <span class="keyword">new</span> ObjectMapper().writeValueAsString(ok);</span><br><span class="line">        out.write(s);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">                    .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        RespBean respBean = RespBean.error(<span class="string">"登录失败!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="层次的结合"><a href="#层次的结合" class="headerlink" title="层次的结合"></a>层次的结合</h3><p>如果说单单security的设置的话，可能很多人自认为自己可以耐心一点，慢慢写，也可以做到很详细的配置。但是我还看到了别的地方。</p><p>我们来看到Controller层，这里有着：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/system/config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuService menuService;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/menu"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getMenusByHrId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuService.getMenusByHrId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出一点不太符合逻辑的东西，这里的方法明显是在展示一个菜单，为什么service的方法名有一个ByHrId？我们却没有在任何一点地方看到传入Hr的信息啊？</p><p>我们点进去看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getMenusByHrId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现是获取到security的权限表的一个ID，也就是说，它的菜单栏会根据Hr的ID在展现。</p><p>为什么要这么做呢？那是因为为了方便以后更方便扩展，可以拥有更高的权限去解锁更多的选项栏，从现在这样的一对多关系延伸到多对多关系。</p><h4 id="规范的写法"><a href="#规范的写法" class="headerlink" title="规范的写法"></a>规范的写法</h4><p>我们还可以从Controller层看到，这里返回的是自定义的类RespBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RespBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">ok</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">200</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">ok</span><span class="params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">200</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">error</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">500</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">error</span><span class="params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">500</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以更规范的去使用，便于让前端明白是什么类型，而不是非常粗暴的使用HashMap，使用HashMap有很多不好的地方。这里暂时不说明</p><h4 id="自定义处理"><a href="#自定义处理" class="headerlink" title="自定义处理"></a>自定义处理</h4><p>还有，自己定义对时间的类型的处理，时间类型的绑定往往会是前后端解耦比较麻烦的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运用缓存"><a href="#运用缓存" class="headerlink" title="运用缓存"></a>运用缓存</h4><p>在service层上也运用了缓存的功能，我们可以使用缓存区缓解压力，就例如像菜单这样的设置，完全可以使用CacheConfig去设置一个缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"menus_cache"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuMapper menuMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuRoleMapper menuRoleMapper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getMenusByHrId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getAllMenusWithRole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getAllMenusWithRole();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getAllMenus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getAllMenus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getMidsByRid</span><span class="params">(Integer rid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getMidsByRid(rid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateMenuRole</span><span class="params">(Integer rid, Integer[] mids)</span> </span>&#123;</span><br><span class="line">        menuRoleMapper.deleteByRid(rid);</span><br><span class="line">        <span class="keyword">if</span> (mids == <span class="keyword">null</span> || mids.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer result = menuRoleMapper.insertRecord(rid, mids);</span><br><span class="line">        <span class="keyword">return</span> result==mids.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追溯到底层，我们可以看到GetALlMenusWithRole这样的方法的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="getAllMenusWithRole" resultMap="MenuWithRole"&gt;</span><br><span class="line">  <span class="keyword">select</span> m.*,r.<span class="string">`id`</span> <span class="keyword">as</span> rid,r.<span class="string">`name`</span> <span class="keyword">as</span> rname,r.<span class="string">`nameZh`</span> <span class="keyword">as</span> rnameZh <span class="keyword">from</span> menu m,menu_role mr,<span class="keyword">role</span> r <span class="keyword">where</span> m.<span class="string">`id`</span>=mr.<span class="string">`mid`</span> <span class="keyword">and</span> mr.<span class="string">`rid`</span>=r.<span class="string">`id`</span> <span class="keyword">order</span> <span class="keyword">by</span> m.<span class="string">`id`</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>像类似于这样的SQL语句完全可以进行一定的缓存封装，从而减少压力。</p><h3 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h3><p>这样项目就这么完美，没有差错吗？也不尽然，从以往的眼光来看，我们看这个项目就算是一个SSM项目的经典类型。这个项目不涉及云服务也不涉及应用监控相关的内容，但仅仅是用于自己的毕业设计的话，也就是足够了。</p><p>当然，我本身在测试这个项目的时候还发现一些这个项目错误的地方，现今指出来：</p><p>比如在使用Search功能的时候出现的keyword错误，需要把Mapper的SQL修改一下，改为 name</p><p>其次就是在使用导出数据的时候，作者还没有配置相关数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/export"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; exportData() &#123;</span><br><span class="line">    List&lt;Employee&gt; list = (List&lt;Employee&gt;) employeeService.getEmployeeByPage(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,<span class="keyword">null</span>).getData();</span><br><span class="line">    <span class="keyword">return</span> POIUtils.employee2Excel(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，这个项目非常适合一些学了知识却又不知道怎么运用的初学者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> SpringBoot+ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ElasticSearch搜索服务器做全文检索</title>
      <link href="/2020/05/18/spring16/"/>
      <url>/2020/05/18/spring16/</url>
      
        <content type="html"><![CDATA[<h2 id="使用ElasticSearch做全文检索"><a href="#使用ElasticSearch做全文检索" class="headerlink" title="使用ElasticSearch做全文检索"></a>使用ElasticSearch做全文检索</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于ElasticSearch网络上有很多的教程。但是这些教程，讲的都不是很好，大多数都仅讲了，它是一个搜索服务器，一个搜索引擎，这种比较抽象的话，并没有解释他的是一个什么样的结构，这让我在当初学习的时候，有中无从下手的感觉。但如今对他有了一定的了解，于是乎，我打算把这些功能比较形象的写出来。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>这个概念比较关键，如果你能理解它的概念，那么你也能理解他的大部分逻辑了。</p><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>首先你要明白搜索引擎这个概念。我们平常用的搜索引擎如，百度，谷歌等等。他们是怎么样在这上亿的数据量中快速的搜索到我们需要的内容呢？如果仅仅依靠数据库。，那么，会给数据库造成很大的压力，而且曾经上万的人可能在同一时间使用搜索引擎去搜索内容。数据库怎么可能承担了如此之多的数据量的访问呢？</p><p>那么我们根据之前所学的概念。我们可以尝试用的缓存去解决这个问题。对！把需要读取的需要读取的东西放入缓存中。如果需要再从缓存当中去读取。那么就不会给数据库造成很大压力了。但之前的缓存像Redis，它是一种类似于key- value的类型。那么对于千奇百怪的搜索内容，不同编码的字符串，redis是怎么能够能中搜索到呢？就算他能够实现。但是缓存这种东西。一般来说是不会把它设置为永久存在的。缓存一般有他的存活时间，他也没有像数据库那么稳定。所以单单是使用缓存去解决这个问题，明显不是最优的选择。</p><p>另外一个比较重要的一点就是，在一个商城中。我们一般都会实现搜索这种功能。但搜索功能是直接去访问数据库的。如果很多人进行搜索，那么海量的请求会给我们数据库造成极大的压力。所以我们也需要把这种东西拆分成两部分。用别的东西去代替搜索，或者说不直接从数据库访问数据。但是仅仅是Redis缓存明显不能够承担这种任务。</p><p>于是乎便诞生了ElasticSearch，这种NoSQL类型特殊的数据库型缓存。对，<strong>就是数据库类型的缓存。</strong></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>他的工作流程主要是：当用户需要某一个数据时，先从数据库里读取，再把这个数据加入到这个特殊的缓存当中。然后当我们需要某些内容的，他们就能够去这个特殊的缓存中读取数据。这种读取速度的方法跟一般的缓存不同的是，会根据内容关键词去进行搜索，只会的搜索出所需要的内容。</p><p>之后如若遇到有相同的关键词，就会去这个搜索服务器中搜索。将它的值或数据类型，返回给用户。而当我们这关键词在这搜索服务器中所显示数据量太少，或者说没有这个数据时，才会去数据库中再次读取数据。再补充到到搜索服务器当中。这个工作流程和Redis缓存非常的类似。但主要的区别在于，它是一个能够搜索和存储的数据库型缓存。</p><h4 id="和Redis的主要区别"><a href="#和Redis的主要区别" class="headerlink" title="和Redis的主要区别"></a>和Redis的主要区别</h4><p>那这是不是代表了这个搜索服务器完全可以取代Redis这个缓存呢？其实这是不一样的。因为我们的这个搜索服务器，他虽然能对关键是进行搜索，但这搜索的效率相对缓存那样的key-value直接取值而言，并不是特别高，虽然说比数据库要快，但是单单论缓存的速度而言，是远远的比不上Redis的。</p><p>所以，当我们需要搜索的时候才会用这个搜索服务器。我们一般仅仅是使用缓存的话还是Redis比较快速。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>就一个商城项目而言，当我们需要去搜索的时候，就用这个搜索服务器，快速的将关键词拆分进搜索，然后返回出相应的内容，但是这些内容并不包含所有的信息。他只包含了一些比较关键的信息，就例如它的头标题或者是特定的图片等等。</p><p>然后等用户点进的这个链接。我们才会去从数据库中另外读取数据，或者说去Redis中读取数据。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>接下来我们就来进行一个实验，来尝试的使用这个搜索服务器。</p><p>但是这个东西操作有点困难，所以你必须先掌握docker的使用</p><p>譬如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">要求熟练掌握</span></span><br><span class="line">ip addr</span><br><span class="line">service network restart</span><br><span class="line">service docker start</span><br><span class="line">docker pull xxx</span><br><span class="line">docker images</span><br><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br><span class="line">docker run xxx</span><br><span class="line">docker kill xxx</span><br><span class="line">docker rm xxx</span><br><span class="line">docker rename xxx yyy</span><br><span class="line">docker image rm xxx</span><br><span class="line">docker restart xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">了解</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim xxx</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:xxx </span><br><span class="line"><span class="meta">#</span><span class="bash">必须带版本号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动</span></span></span><br><span class="line">docker run -d -e ES_JAVA_POTS="-Xms256m -Xmx256m"  -e "discovery.type=single-node" -p 9200:9200 -p 9300:9300 --name es01 f29a1ee41030</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>如果你的云服务器内存不足1G的话，则使用</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find / -name jvm.options</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#使用此指令找到es的jvm设置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#使用</span></span></span><br><span class="line">vim /var/lib/docker/overlay2/973a5c6a4450ab59e64d6ba7e78ed6622512c142e0a2f8164653b11e8b66baa9/diff/usr/share/elasticsearch/config/jvm.options</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">进入，将-xms和-xmx参数，改为256m</span></span><br></pre></td></tr></table></figure><p>否则可能会出现：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/0-1.png" alt=""></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.searchbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个依赖还包括其他东西。我们一般是用这个jest方法去使用elasticsearch。</p><h5 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">jest:</span></span><br><span class="line">      <span class="attr">uris:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">http://192.168.78.128:9200</span>  <span class="comment"># ES服务器的地址！</span></span><br><span class="line">      <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">763638353551774166L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_NAME = <span class="string">"index_entity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE = <span class="string">"tstype"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(Entity entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(List&lt;Entity&gt; entityList)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Entity&gt; <span class="title">searchEntity</span><span class="params">(String searchContent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JestClient jestClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(Entity entity)</span> </span>&#123;</span><br><span class="line">        Index index = <span class="keyword">new</span> Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jestClient.execute(index);</span><br><span class="line">            LOGGER.info(<span class="string">"ES 插入完成"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量保存内容到ES</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(List&lt;Entity&gt; entityList)</span> </span>&#123;</span><br><span class="line">        Bulk.Builder bulk = <span class="keyword">new</span> Bulk.Builder();</span><br><span class="line">        <span class="keyword">for</span>(Entity entity : entityList) &#123;</span><br><span class="line">            Index index = <span class="keyword">new</span> Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br><span class="line">            bulk.addAction(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jestClient.execute(bulk.build());</span><br><span class="line">            LOGGER.info(<span class="string">"ES 插入完成"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在ES中搜索内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Entity&gt; <span class="title">searchEntity</span><span class="params">(String searchContent)</span></span>&#123;</span><br><span class="line">        SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//searchSourceBuilder.query(QueryBuilders.queryStringQuery(searchContent));</span></span><br><span class="line">        <span class="comment">//searchSourceBuilder.field("name");</span></span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"name"</span>,searchContent));</span><br><span class="line">        Search search = <span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                .addIndex(Entity.INDEX_NAME).addType(Entity.TYPE).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JestResult result = jestClient.execute(search);</span><br><span class="line">            System.out.println(result.toString());</span><br><span class="line">            <span class="keyword">return</span> result.getSourceAsObjectList(Entity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来到了重点，详细说一说。</p><p>先说saveEntity方法，这里要注意的就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index index = <span class="keyword">new</span> Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br></pre></td></tr></table></figure><p>他到底做了什么呢？我们可以从index和type这两个，看到它是在为一个entity类实例建立一个索引名和索引类型，将两者绑定在一起，作为一个索引类型被执行。调用的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.source = source;</span><br><span class="line">    <span class="keyword">this</span>.id(AbstractAction.getIdFromSource(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它没有对Entity做改动，而仅仅是加上一部分属于他的内容。</p><p>我们还可以从中获取到，这个index 类型还附带一个url：uri=index_entity/tstype,method=POST</p><p>将这个索引类型发送到我们的ES服务器当中。</p><p>接着，我们来看到下面的Search方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"name"</span>,searchContent));</span><br></pre></td></tr></table></figure><p>这个方法一开始就建立了一个对象，我们可以看到：QueryBuilders.matchQuery(“name”,searchContent)是对要搜索的内容，进行了一定程度的转换，那么转换成什么样子了呢？</p><p>我们使用一个例子：entityController/search?name=北京 为例。进行搜索，我们来看看这个searchSourceBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span> : &#123;</span><br><span class="line">    <span class="string">"match"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : &#123;</span><br><span class="line">        <span class="string">"query"</span> : <span class="string">"北京"</span>,</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"boolean"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变为了一个Json型对象，记住，他将要搜索的内容：北京，变为了一个Json对象。然后通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Search search = <span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                .addIndex(Entity.INDEX_NAME).addType(Entity.TYPE).build();</span><br></pre></td></tr></table></figure><p>封装成一个Url，发送到ES服务器。它里面的内容是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri=index_entity/tstype/_search,method=POST</span><br></pre></td></tr></table></figure><p>和添加类似，返回进了服务器当中。</p><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/entityController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService cityESService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/save"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(<span class="keyword">long</span> id, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save 接口"</span>);</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">0</span> &amp;&amp; StringUtils.isNotEmpty(name)) &#123;</span><br><span class="line">            Entity newEntity = <span class="keyword">new</span> Entity(id,name);</span><br><span class="line">            List&lt;Entity&gt; addList = <span class="keyword">new</span> ArrayList&lt;Entity&gt;();</span><br><span class="line">            addList.add(newEntity);</span><br><span class="line">            cityESService.saveEntity(addList);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Bad input value"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/search"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Entity&gt; <span class="title">save</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        List&lt;Entity&gt; entityList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(name)) &#123;</span><br><span class="line">            entityList = cityESService.searchEntity(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层比较随意，接收参数，调用接口便可。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们可以安装ES-Head可视化插件，帮助我们查看里面的内容。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-123940.jpg" alt=""></p><p>我们打开PostMan，输入 localhost:8888/entityController/save?id=1&amp;name=北京长城，为其添加内容。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-124151.jpg" alt=""></p><p>想这样子，添加很多内容</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-124505.jpg" alt=""></p><p>之后，可以使用方法进行搜索操作，搜到到的值，会以JSON形式，返回给我们，方便我们绑定对象实例。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-150806.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue和Element-UI的基本使用</title>
      <link href="/2020/05/09/vue1/"/>
      <url>/2020/05/09/vue1/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue和Element-UI的基本使用"><a href="#Vue和Element-UI的基本使用" class="headerlink" title="Vue和Element-UI的基本使用"></a>Vue和Element-UI的基本使用</h2><p>现在的前端项目都是使用vue去写的，因为vue构成的前端项目可和后端实现完全的解耦。虽然本人并非专攻于前端，但还是需要去了解他们的基本使用的。</p><p>在学习vue之前，还需要了解几个步骤，这些步骤可能有点繁杂。</p><h3 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h3><p>首先你必须要安装Nodejs，我在此先介绍一下什么是nodejs：</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Node.js 是能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。Node.js 由 Node.js Foundation持有和维护，亦为 Linux 基金会的项目。</p><p>Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。</p><p>Node.js大部分基本模块都用JavaScript语言编写。在Node.js出现之前，JavaScript通常作为客户端程序设计语言使用，以JavaScript写出的程序常在用户的浏览器上运行。Node.js的出现使JavaScript也能用于服务端编程。Node.js含有一系列内置模块，使得程序可以脱离Apache HTTP Server或IIS，作为独立服务器运行。</p><p>但我们并不注重于Nodejs本身，安装Node之后，会自动安装npm。这个npm才是我们最经常使用的工具。</p><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>npm是Node.js默认的、用JavaScript编写的软件包管理系统，需要安装Node.js才能使用npm。</p><p>npm会随着Node.js自动安装。npm模块仓库提供了一个名为“registry”的查询服务，用户可通过本地的npm命令下载并安装指定模块。此外用户也可以通过npm把自己设计的模块分发到registry上面。</p><p>之后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>查看的到npm版本，就代表安装成功了。</p><p>但是这里之所以提一下，是因为国外的镜像源速度都很慢，所以可以去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\nodejs\node_modules\npm\lib\config\defaults.js</span><br></pre></td></tr></table></figure><p>更改你的镜像源，增加速度。</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>要安装vue，还需要先安装webpack</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p>Webpack 是一个开源的前端打包工具。Webpack 提供了前端开发缺乏的模块化开发方式，将各种静态资源视为模块，并从它生成优化过的代码。[1]</p><p>Webpack可以从终端、或是更改 webpack.config.js 来设置各项功能。</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure><p>全局安装webpack。</p><h4 id="安装vue"><a href="#安装vue" class="headerlink" title="安装vue"></a>安装vue</h4><p>然后再使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><p>全局安装vue框架，概念之后再提。</p><h4 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h4><p>Yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码， 或者分享自己的代码。</p><p>代码通过 包（package） (或者称为 模块（module）) 的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。</p><p>通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g -verbose</span><br></pre></td></tr></table></figure><p>安装yarn，之后再使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set XXXXX</span><br></pre></td></tr></table></figure><p>设置你的快速镜像源。</p><p>之后，就可以使用 vue -v，查看vue版本，表示成功。</p><h3 id="Vue概念"><a href="#Vue概念" class="headerlink" title="Vue概念"></a>Vue概念</h3><p>vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>组件是Vue最为强大的特性之一。为了更好地管理一个大型的应用程序，往往需要将应用切割为小而独立、具有复用性的组件。在Vue中，组件是基础HTML元素的拓展，可方便地自定义其数据与行为。下方的代码是Vue组件的一个示例，渲染为一个能计算鼠标点击次数的按钮。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>Vue使用基于HTML的模板语法，允许开发者将DOM元素与底层Vue实例中的数据相绑定。所有Vue的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析。在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应式系统，在应用状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。[12]</p><p>此外，Vue允许开发者直接使用JSX语言作为组件的渲染函数，以代替模板语法。 以下为可计算点击次数的按钮的JSX渲染版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'buttonclicked'</span>, &#123;</span><br><span class="line">  props: [<span class="string">"initial_count"</span>],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> q = &#123;<span class="string">"count"</span>: <span class="number">0</span>&#125;; <span class="keyword">return</span> q;&#125; ,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">'button'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          click: <span class="keyword">this</span>.onclick</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'Clicked '</span> + <span class="keyword">this</span>.count + <span class="string">' times'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="string">"onclick"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.count = <span class="keyword">this</span>.initial_count;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><p>响应式是指MVC模型中的视图随着模型变化而变化。在Vue中，开发者只需将视图与对应的模型进行绑定，Vue便能自动观测模型的变动，并重绘视图。这一特性使得Vue的状态管理变得相当简单直观。</p><h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4><p>Vue在插入、更新或者移除DOM时，提供多种不同方式的应用过渡效果。 包括以下工具:</p><ul><li>在CSS过渡和动画中自动应用class</li><li>可以配合使用第三方CSS动画库，如Animate.css</li><li>在过渡钩子函数中使用JavaScript直接操作DOM</li><li>可以配合使用第三方JavaScript动画库，如Velocity.js</li></ul><h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h4><p>为了更好地适应复杂的项目，Vue支持以.vue为扩展名的文件来定义一个完整组件，用以替代使用Vue.component注册组件的方式。开发者可以使用 Webpack或Browserify等构建工具来打包单文件组件。</p><h4 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h4><p>在你存放信息的文件夹内，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack</span><br><span class="line">vue init webpack xxx</span><br></pre></td></tr></table></figure><p>注意，最好先使用第一个命令，我看网上很多都是直接使用第二个命令的，虽然直接搭建vue项目这个命令没有错，但是你会发现下载速度非常的慢，所以建议使用我的方法来。</p><p>然后继续：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd xxx</span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>安装包的依赖，在使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>就可以在localhost：8888查看vue项目了。</p><h3 id="vue结合Element-UI"><a href="#vue结合Element-UI" class="headerlink" title="vue结合Element-UI"></a>vue结合Element-UI</h3><p>Element-UI是国内的一套开源项目，可以非常快捷的开发项目。</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>我们在项目内，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add element-ui</span><br></pre></td></tr></table></figure><p>安装框架，之后打开项目，你可以使用vscode去打开，也可以使用webstorm去打开。在main.js改为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>增加ElementUI的使用。</p><h4 id="使用Element-ui"><a href="#使用Element-ui" class="headerlink" title="使用Element-ui"></a>使用Element-ui</h4><p>我们打开helloworld.vue，加入一个element按钮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;primary&quot;&gt;主要按钮&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure><p>再重启vue项目查看，就有一个vue按钮了</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-154904.jpg" alt=""></p><h4 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h4><h5 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h5><p>新建一个vue项目：Login.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page&quot; &gt;</span><br><span class="line">      &lt;h2&gt;Login Page&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;Login&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h5><p>打开index.js，添加三个路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/views/Login'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/views/Home'</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">'@/views/404'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   path: '/',</span></span><br><span class="line">    <span class="comment">//   name: 'HelloWorld',</span></span><br><span class="line">    <span class="comment">//   component: HelloWorld</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/404'</span>,</span><br><span class="line">      name: <span class="string">'notFound'</span>,</span><br><span class="line">      component: NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再打开localhost：8080，就可以在URL尝试访问这三个页面。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-161014.jpg" alt=""></p><h3 id="安装SCSS"><a href="#安装SCSS" class="headerlink" title="安装SCSS"></a>安装SCSS</h3><p>Sass是一个将脚本解析成CSS的脚本语言，即SassScript。Sass包括两套语法。最开始的语法叫做“缩进语法”，与Haml类似，使用缩进来区分代码块，并且用回车将不同规则分隔开。而较新的语法叫做“SCSS”，使用和CSS一样的块语法，即使用大括号将不同的规则分开，使用分号将具体的样式分开。</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">第一步</span></span><br><span class="line">yarn add css-loader style-loader sass-loader -D</span><br><span class="line">yarn config set sass-binary-site http://npm.taobao.org/mirrors/node-sass</span><br><span class="line">yarn add node-sass -D</span><br></pre></td></tr></table></figure><p>然后在：\build\webpack.base.conf.js 中，写入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,   </span><br><span class="line">    loaders: [<span class="string">'style'</span>, <span class="string">'css'</span>, <span class="string">'sass'</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以在style标签上更改了，比如404：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;site-wrapper site-page--not-found&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;site-content__wrapper&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;site-content&quot;&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&quot;not-found-title&quot;&gt;404&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p class&#x3D;&quot;not-found-desc&quot;&gt;抱歉！您访问的页面&lt;em&gt;失联&lt;&#x2F;em&gt;啦 ...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;$router.go(-1)&quot;&gt;返回上一页&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; class&#x3D;&quot;not-found-btn-gohome&quot; @click&#x3D;&quot;$router.push(&#39;&#x2F;&#39;)&quot;&gt;进入首页&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    &#x2F;&#x2F; name: &#39;404&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">.site-wrapper.site-page--not-found &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 60px;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    .site-content__wrapper &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">      background-color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .site-content &#123;</span><br><span class="line">      position: fixed;</span><br><span class="line">      top: 15%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      z-index: 2;</span><br><span class="line">      padding: 30px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      transform: translate(-50%, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    .not-found-title &#123;</span><br><span class="line">      margin: 20px 0 15px;</span><br><span class="line">      font-size: 8em;</span><br><span class="line">      font-weight: 500;</span><br><span class="line">      color: rgb(55, 71, 79);</span><br><span class="line">    &#125;</span><br><span class="line">    .not-found-desc &#123;</span><br><span class="line">      margin: 0 0 30px;</span><br><span class="line">      font-size: 26px;</span><br><span class="line">      text-transform: uppercase;</span><br><span class="line">      color: rgb(118, 131, 143);</span><br><span class="line">      &gt; em &#123;</span><br><span class="line">        font-style: normal;</span><br><span class="line">        color: #ee8145;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .not-found-btn-gohome &#123;</span><br><span class="line">      margin-left: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>此刻可以重新运行一遍，来看看结果。</p><p>这里填一个坑，我运行的时候报错了，需要更改sass-loader的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader@7.3.1</span><br></pre></td></tr></table></figure><p>最后，查看结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-171719.jpg" alt=""></p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。这和ajax非常的类似，我们来看看区别：</p><h4 id="ajax和axios的区别"><a href="#ajax和axios的区别" class="headerlink" title="ajax和axios的区别"></a>ajax和axios的区别</h4><h5 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h5><p>ajax：</p><p>1.本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>2.基于原生的XHR开发，XHR本身的架构不清晰。<br>3.JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）<br>4.不符合关注分离（Separation of Concerns）的原则<br>5.配置和调用方式非常混乱，而且基于事件的异步模型不友好。<br>PS:MVVM(Model-View-ViewModel), 源自于经典的 Model–View–Controller（MVC）模式。MVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。</p><h5 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a>axios</h5><p>1.从浏览器中创建 XMLHttpRequest<br>2.支持 Promise API<br>3.客户端支持防止CSRF<br>4.提供了一些并发请求的接口（重要，方便了很多的操作）<br>5.从 node.js 创建 http 请求<br>6.拦截请求和响应<br>7.转换请求和响应数据<br>8.取消请求<br>9.自动转换JSON数据<br>PS:防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p><h4 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h4><p>执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><p>然后修改Home.vue:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Home Page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;testAxios()&quot;&gt;测试Axios调用&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Home&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    testAxios() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#39;).then(res &#x3D;&gt; &#123; alert(res.data) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-172615.jpg" alt=""></p><h3 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Mock.js是一个模拟数据生成器，帮助前端开发和原型与后端进度分离，减少一些单调，特别是在编写自动化测试时。</p><p>提供了以下模拟功能：</p><ol><li><p>根据数据模板生成模拟数据</p></li><li><p>模拟 Ajax 请求，生成并返回模拟数据</p></li></ol><p>为什么我们要用Mock.js?</p><ol><li>开发时，后端还没完成数据输出，前端也能根据模拟的数据开发。</li><li>想要尽可能还原真实的数据。</li><li>图片,url格式数据难以模拟。</li></ol><h4 id="安装与使用-1"><a href="#安装与使用-1" class="headerlink" title="安装与使用"></a>安装与使用</h4><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add mockjs</span><br></pre></td></tr></table></figure><p>然后，我们可以在src目录下新建一个mock目录，创建mock.js，在里面模拟两个接口，分别拦截用户和菜单的请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span></span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">'http://localhost:8080/user'</span>, &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'@name'</span>, <span class="comment">// 随机生成姓名</span></span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'@email'</span>, <span class="comment">// 随机生成邮箱</span></span><br><span class="line">    <span class="string">'age|1-10'</span>: <span class="number">5</span>, <span class="comment">// 年龄1-10之间</span></span><br><span class="line">&#125;)</span><br><span class="line">Mock.mock(<span class="string">'http://localhost:8080/menu'</span>, &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'@increment'</span>, <span class="comment">// id自增</span></span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'menu'</span>, <span class="comment">// 名称为menu</span></span><br><span class="line">    <span class="string">'order|1-20'</span>: <span class="number">5</span>, <span class="comment">// 排序1-20之间</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回到Home页面，添加两个按钮，修改页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Home Page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;testAxios()&quot;&gt;测试Axios调用&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getUser()&quot;&gt;获取用户信息&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getMenu()&quot;&gt;获取菜单信息&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import mock from &#39;@&#x2F;mock&#x2F;mock.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Home&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    testAxios() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#39;).then(res &#x3D;&gt; &#123; alert(res.data) &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getUser() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#39;).then(res &#x3D;&gt; &#123; alert(JSON.stringify(res.data)) &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getMenu() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;menu&#39;).then(res &#x3D;&gt; &#123; alert(JSON.stringify(res.data)) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在测试一下，获取用户信息，便可以看到结果了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-173554.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> Element-UI </tag>
            
            <tag> SCSS </tag>
            
            <tag> axios </tag>
            
            <tag> Mock.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义spring-boot-starter</title>
      <link href="/2020/05/07/spring19/"/>
      <url>/2020/05/07/spring19/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h3 id="1、starter启动原理"><a href="#1、starter启动原理" class="headerlink" title="1、starter启动原理"></a>1、starter启动原理</h3><ul><li>starter-pom引入 autoconfigurer 包</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1354552/1606995919308-b2c7ccaa-e720-4cc5-9801-2e170b3102e1.png" alt="img"></p><ul><li><p>autoconfigure包中配置使用 <strong>META-INF/spring.factories</strong> 中 <strong>EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类</strong></p></li><li><p><strong>可以编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</strong></p></li><li><ul><li><strong>@Configuration</strong></li><li><strong>@Conditional</strong></li><li><strong>@EnableConfigurationProperties</strong></li><li><strong>@Bean</strong></li><li>……</li></ul></li></ul><p><strong>然后，引入starter</strong> <strong>— xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —-</strong> <strong>配置项</strong></p><h3 id="自定义starter-1"><a href="#自定义starter-1" class="headerlink" title="自定义starter"></a>自定义starter</h3><p>首先需要准备好两个项目</p><p>空工程：</p><p><strong>hello-spring-boot-starter（启动器）</strong></p><p>空SpringBoot工程</p><p><strong>hello-spring-boot-starter-autoconfigure（自动配置包）</strong></p><p>其中自动配置包里面有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认不要放在容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix() + <span class="string">"："</span>+userName+<span class="string">"》"</span>+helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有加入组件，没有任何注解</p><p>然后再写一个自动配置的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)  //默认<span class="title">HelloProperties</span>放在容器中</span></span><br><span class="line"><span class="class">//@<span class="title">ConditionalOnMissingBean</span>(<span class="title">HelloProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloServiceAutoConfiguration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HelloService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">HelloService</span> <span class="title">helloService</span>()</span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ConditionalOnMissingBean(HelloProperties.class)</strong>是当容器中没有HelloProperties.class这个类的时候，这个类才会生效，起到防止覆盖的作用。</p><p><strong>@EnableConfigurationProperties(HelloProperties.class)</strong>的作用是自动配置我们的hello组件</p><p>这个配置主要的作用就是将其保存入我们的组件</p><h4 id="使用启动器"><a href="#使用启动器" class="headerlink" title="使用启动器"></a>使用启动器</h4><p>之后便是使用启动器,先配置xml，然后使用maven的clean和install进打入我们的本地仓库当中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.my<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>然后再创建一个测试的springboot组件：</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.my<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就会引入这个自定义。但是发现不能像spring引入其他依赖一样，被自动注入生效</p><p>然后，在autoconfigure包中配置引用 <strong>META-INF/spring.factories</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">com.atguigu.hello.auto.HelloServiceAutoConfiguration</span><br></pre></td></tr></table></figure><p>然后再重新打包clean 和install</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>我们在新项目中写一个controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String s = helloService.sayHello(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现自动注入成功了，</p><p>但是我们的helloservice是有前后缀的，如果需要使用，则需要在配置文件当中写入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hello.prefix=my</span></span><br><span class="line"><span class="string">hello.suffix=88888</span></span><br></pre></td></tr></table></figure><p>接着再继续测试，发现输出结果正好是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my：张三 88888</span><br></pre></td></tr></table></figure><p>.</p><p>.</p><p>.</p><p>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Guava Cache作为本地缓存</title>
      <link href="/2020/05/05/spring15/"/>
      <url>/2020/05/05/spring15/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Guava-Cache作为本地缓存"><a href="#利用Guava-Cache作为本地缓存" class="headerlink" title="利用Guava Cache作为本地缓存"></a>利用Guava Cache作为本地缓存</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然我们一般都用Redis缓存但是，在一些小的项目中可以不使用Redis，而是利用Guava Cache来做本地缓存，这么做本地缓存的速度会比Redis要快一点。</p><p>虽然Spring Boot默认使用的是 SimpleCacheConfiguration。但是这个Guava Cache在其基础上，有了不同程度的优化。所以在做一些小项目的时候呢，可以用这个来做缓存。</p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>Guava Cache使用 ConcurrentMapCacheManager来实现的缓存</p><p>Guava Cache 与 ConcurrentMap二者很相似,但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素,直到显式地移除。相对地,Guava Cache 为了限制内存占用,通常都设定为自动回收元素。在某些场景下,尽管 LoadingCache 不回收元素,它也是很有用的,因为它会自动加载缓存。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>Redis自不用说，是一个在多个服务器之间能够实现集群和哨兵的缓存，相比之下，Guava Cache就稍稍弱了些。</p><p>如果数据量不大，且多个服务之间没有相互同步数据的需要，则使用Guava Cache是非常理想的，它使用简单且性能很好。如果需要缓存的数据量很大或者多个服务之间需要共享缓存数据，则redis是理想的选择，虽然读取性能对比Guava Cache满了很多，但是绝对值并不大，大多数情况下满足我们的需要。</p><p>还有一点比较大区别就是他们的拷贝程度不同。</p><h5 id="Redis-缓存是深拷贝"><a href="#Redis-缓存是深拷贝" class="headerlink" title="Redis 缓存是深拷贝"></a>Redis 缓存是深拷贝</h5><p>从 Redis 中获取缓存时，系统中的数据对象是 Redis 缓存的副本。对该对象的任何操作都不会影响 Redis 中的缓存，后续再次获取还是修改之前的数据。除非执行Redis的更新操作。</p><h5 id="Guava本地缓存直接获取则是浅拷贝"><a href="#Guava本地缓存直接获取则是浅拷贝" class="headerlink" title="Guava本地缓存直接获取则是浅拷贝"></a>Guava本地缓存直接获取则是浅拷贝</h5><p>以获取一个MAP为例：如果直接从缓存中取，则是浅拷贝。<br>对缓存数据的任何操作都会同时修改缓存中的数据，下次从缓存中获取则是修改之后的数据。一般不会修改从缓存中获取到的数据，但如果要修改，则需注意Redis和Guava的不同。</p><p>所以如果只是做一个比较小的项目。就不用特地去连接redis。还是使用我们本地的缓存更为快速。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>27.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuavaCacheManager cacheManager = <span class="keyword">new</span> GuavaCacheManager();</span><br><span class="line">        cacheManager.setCacheBuilder(</span><br><span class="line">                CacheBuilder.newBuilder().</span><br><span class="line">                        expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS).</span><br><span class="line">                        maximumSize(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化一个对象并设置它的存活时间等等。我们把这个方法注入到spring的上下文当中。而每当我们需要去数据库读取数据时，spring就会先返回这个缓存的实体，将数据先存入到本地缓存当中。</p><p>这里我们设置它的存活时间是十秒。</p><h4 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h4><p>首先需要一个实体类和与其对应的数据表。这也就只列出实体类，大家可以自己对应一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然。还有配置文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*Mapper.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.guavacache.pojo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springtest?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><p>然后就是服务层，要实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">(String userName )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">( User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>, key = <span class="string">"#userName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">( String userName )</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.getUsersByName( userName );</span><br><span class="line">        System.out.println( <span class="string">"从数据库读取，而非读取缓存！"</span> );</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>( value = <span class="string">"/getusersbyname"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">geUsersByName</span><span class="params">(@RequestBody User user )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"-------------------------------------------"</span> );</span><br><span class="line">        System.out.println(<span class="string">"call /getusersbyname"</span>);</span><br><span class="line">        System.out.println(cacheManager.toString());</span><br><span class="line">        List&lt;User&gt; users = userService.getUsersByName( user.getUserName() );</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层使用这个方法去调用，以便用于测试。</p><p>最后还有在主类上加上一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.guavacache.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavacacheApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GuavacacheApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样子就完成了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们可以打开这个PostMan，使用 localhost:8888/getusersbyname 发起POST请求，就可以测试出结果了。</p><p>但由于比较简单，这里就不放图了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> GuavaCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由网关——Zuul</title>
      <link href="/2020/05/02/cloud4/"/>
      <url>/2020/05/02/cloud4/</url>
      
        <content type="html"><![CDATA[<h2 id="路由网关——Zuul"><a href="#路由网关——Zuul" class="headerlink" title="路由网关——Zuul"></a>路由网关——Zuul</h2><p>Springloud中API网关是Zuul。对于网关而言，存在两个作用：第一个作用将请求的地址映射为真实服务器的地址。</p><p>例如，用户请求<a href="http://localhost/user/1获取用户id为1的信息，而真实的服务是http://localhost:800l/user/I和http://localhost:8002/user/1都可以获取用户的信息，这时就可以通过网关使得localhost/user映射为对应真实服务器的地址。" target="_blank" rel="noopener">http://localhost/user/1获取用户id为1的信息，而真实的服务是http://localhost:800l/user/I和http://localhost:8002/user/1都可以获取用户的信息，这时就可以通过网关使得localhost/user映射为对应真实服务器的地址。</a></p><p>然这个作用就起到路由分发的作用，从而降低单个节点的负载。从这点来说，可以把称为服务端负载均衡。从高可用的角度来说，则一个请求地址可以映射到多台服务上，如果单点出现障，则其他节点也能提供服务，这样这就是一个高可用的服务了。</p><p>Zuul网关的第二个作用是过滤服务，在互联网中，服务器可能面临各种攻击，Zuul提供了过滤器，通过它过那些恶意或者无效的请求，把它们排除在服务网站之外，这样就可以降低网站服务的风险。</p><h3 id="构建Zuul网关"><a href="#构建Zuul网关" class="headerlink" title="构建Zuul网关"></a>构建Zuul网关</h3><p>首先，有引入依赖是必要的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着就是在主要执行的程序上加一个注解：@EnableZuulProxy。</p><p>这个注解会启动Zuul网关。</p><p>我们来看一看这个注解的构成吧:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(&#123;ZuulProxyMarkerConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableZuulProxy</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看其实有点不清晰，其实以下的注解包含了两种类型的过滤器。</p><h4 id="pre类型过滤器"><a href="#pre类型过滤器" class="headerlink" title="pre类型过滤器"></a>pre类型过滤器</h4><p>PreDecorationFilter：该过滤器根据提供的RouteLocator确定路由到的地址，以及怎样去路由。该路由器也可为后端请求设置各种代理相关的header。</p><h4 id="route类型过滤器"><a href="#route类型过滤器" class="headerlink" title="route类型过滤器"></a>route类型过滤器</h4><p>(1) RibbonRoutingFilter：该过滤器使用Ribbon，Hystrix和可插拔的HTTP客户端发送请求。serviceId在RequestContext.getCurrentContext().get(“serviceId”)中。该过滤器可使用不同的HTTP客户端，例如</p><p>Apache HttpClient：默认的HTTP客户端</p><p>SquareupOkHttpClient v3：如需使用该客户端，需保证com.squareup.okhttp3的依赖在classpath中，并设置ribbon.okhttp.enabled = true。</p><p>Netflix Ribbon HTTP client：设置ribbon.restclient.enabled = true即可启用该HTTP客户端。需要注意的是，该客户端有一定限制，例如不支持PATCH方法，另外，它有内置的重试机制。</p><p>(2) SimpleHostRoutingFilter：该过滤器通过Apache HttpClient向指定的URL发送请求。URL在RequestContext.getRouteHost()中。</p><p>并且，他已经引入了断路机制。之所以引入断路机制，是因为在请求不到的时候会进行断路，以避免网关发生球无法释放的场景，导致微服务瘫痪。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/,http://localhost:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/u/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://localhsot:9002/</span></span><br><span class="line">    <span class="attr">product-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/p/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">product</span></span><br></pre></td></tr></table></figure><p>这个配置是将Zuul网关注册给服务治理中心，这样它就能够获取各个微服务的服务ID了看到用户微服务映射的配置，这里采用  zuul.routes.<key>.path  和zuul.routes.&lt;key＞url  配置，其中path是请求路径，这里使用了ANT风格的通配  “/u/**” ，而旧l代表转发地址，也就是满足path通配的时候，请求就会转发给端口为9002的用户微服务。</p><p>但是，这样配置有一个弊端，因为我们的用户微服务有两个节点，一个是9002端口，另一个是9003端口，这里只能映射到9002端口的微服务，而映射不到9003端口的微服务。</p><p>为了解决这个问题，Zuul还提供了面向服务的配置。再看到代码中的产品微服务映射配置，这里使用了zuul.routes.<key>.path和zuul.routes.<key>.serviceld进行配置，其中path的配置可参考用户微服务，而serviceld这里配置为“product”，这是一个产品微服务的名称，由产品微服务的属性spring.application.name配置。</p><p>这样配置后，Zuul会自动实现负载均衡，也就是会将请求转发到某个服务的节点上。</p><p>这里可以打开:<a href="http://localhost/p/product/ribbon。查看结果。" target="_blank" rel="noopener">http://localhost/p/product/ribbon。查看结果。</a></p><h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p>上面只是将请求转发到具体的服务器或者具体的微服务上，但是有时候还希望网关功能更强大一些。</p><p>例如，监测用户登录、黑名单用户、购物验证码、恶意刷请求攻击等场景。如果这些在过滤器内判断失，那么就不再把请求转发到其他微服务上，以保护微服务的稳定。下面模拟这样的一个场景。</p><p>假设当前需要提交一个表单，而每一个表单都存在一个序列号(seria!Number），并且这个序列对应个验证码（verficationCode），在提交表单的时候，这两个参数都会一并提交到Zuul网关。</p><p>对于Redis服务器会以序列（seriaNumber）为键（key），而以验证码（verificationCode）为值（value）进行存储。</p><p>当路由网关过滤器判用户提交的验证码与Redis服务器保存不一致的时候，则不再转发请求到微服务。</p><h4 id="测试过滤器"><a href="#测试过滤器" class="headerlink" title="测试过滤器"></a>测试过滤器</h4><p>这里验证码使用Redis进行存储，所以会比使用数据库快得多，这有助于性能的提高，避免造成瓶颈。由于使用了Redis，因此需要在Zuul网关中引入Redis的依赖：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/,http://localhost:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/u/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://localhsot:9002/</span></span><br><span class="line">    <span class="attr">product-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/p/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">product</span></span><br></pre></td></tr></table></figure><p>Zuul存在一个抽象类，那就是ZuulFilter。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Zuul/1.jpg" alt=""></p><p>这里需要注意的是，只是画出了抽象类ZuulFilter自定义的抽象方法和接口ZuulFilter定义的抽类，也就是说，当需要定义一个非抽象的Zuul过滤器的时候，需要实现这4个抽象方法，在重写这4个抽象方法前，我们很有必要知道它们的作用。</p><ol><li><p>shouldFilter：返回boolean值，如果为true，则执行这个过滤器的run方法。</p></li><li><p>run：运行过滤逻辑，这是过滤器的核心方法。</p></li><li><p>filterType：过滤器类型，它是一字符串，可以配置为以下4种。</p><p>pre：请求行之前filter。</p><p>route：处理请求，进行路由。</p><p>post：请求处理完成后执行的filter。</p><p>error：出现错误时执行的filter。</p></li><li><p>filterOrder：指定过滤器顺序，值越小则越优先。</p></li></ol><h4 id="使用过滤器判定验证码"><a href="#使用过滤器判定验证码" class="headerlink" title="使用过滤器判定验证码"></a>使用过滤器判定验证码</h4><p>我们可以在Reddit中生成一个验证码。当用户提交的验证码与Redis不一致时，就会被Zuul网关给拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyZuulFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入StringRedisTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate residTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否过滤</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 请求上下文</span></span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line"><span class="comment">// 获取HttpServletRequest对象</span></span><br><span class="line">HttpServletRequest req = ctx.getRequest();</span><br><span class="line"><span class="comment">// 取出表单序列号</span></span><br><span class="line">String serialNumber = req.getParameter(<span class="string">"serialNumber"</span>);</span><br><span class="line"><span class="comment">// 如果存在验证码返回为true，启用过滤器</span></span><br><span class="line"><span class="keyword">return</span> !StringUtils.isEmpty(serialNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器逻辑方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest req = ctx.getRequest();</span><br><span class="line"><span class="comment">// 取出表单序列号和请求验证码</span></span><br><span class="line">String serialNumber = req.getParameter(<span class="string">"serialNumber"</span>);</span><br><span class="line">String reqCode = req.getParameter(<span class="string">"verificationCode"</span>);</span><br><span class="line"><span class="comment">// 从Redis中取出验证码</span></span><br><span class="line">String verifCode = residTemplate.opsForValue().get(serialNumber);</span><br><span class="line"><span class="comment">// Redis验证码为空或者与请求不一致，拦截请求报出错误</span></span><br><span class="line"><span class="keyword">if</span> (verifCode == <span class="keyword">null</span> || !verifCode.equals(reqCode)) &#123;</span><br><span class="line"><span class="comment">// 不再转发请求</span></span><br><span class="line">ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置HTTP响应码为401（未授权）</span></span><br><span class="line">ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line"><span class="comment">// 设置响应类型为JSON数据集</span></span><br><span class="line">ctx.getResponse().setContentType(MediaType.APPLICATION_JSON_UTF8.getType());</span><br><span class="line"><span class="comment">// 设置响应体</span></span><br><span class="line">ctx.setResponseBody(<span class="string">"&#123;'success': false, "</span> + <span class="string">"'message':'Verification Code Error'&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一致放过</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器类型为请求前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器排序，数字越小优先级越高</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>述代码中在类上标注了＠Component，这样Spring就会扫描它，将其装配到IoC容器中。为继承了抽象类ZuulFilter，所以Zuul自动将它识别为过滤器。filterType方法返回了“pre，则过滤器会在路由之前执行。</p><p>filterOrder返回为0，这个方法在指定多个过滤器顺序才有意义，数字越小，则越优先，这里只有一个过滤器，所以就返回0。</p><p>然后在shouldFilter中判断是否存在序列号参数，如果存在，则返回住时，这就意味着将启用这个过滤器，否则就不再启用这个过滤器。run方法是过滤器的核心，它首先获取请求中的序列号和验证码，跟着使用StringRedisTemplate通过序列号获取Redis服务器上的验证码。</p><p>然后将Redis的验证码与请求的验证码进行比较，如果匹配不一致，则设置再转发请求到微服系统，并且将晌应码设置为401，响应类型为JSON数据集，最后还会设置响应体的内容；如果一致，则返回null，放行服务。</p><p>这样用户提交的验证码与Redis保存的不一致时，请求就会在Zuul网关中被过滤器拦截，而不会转发到微服务中</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里可以举一个例子：用户服务提供一个登录接口，用户名密码正确后返回一个Token，此Token作为用户服务的通行证，那么用户登录成功后返回的Token就需要进行加密或者防止篡改处理。在到达用户服务其他接口前，就需要对Token进行校验，非法的Token就不需要转发到用户服务中了，直接在网关层返回信息即可。</p><p>那么，我们再来看一张图：</p><p><img src="https://cdn.jdon.com/simgs/springcloud/zuulfilter.png" alt=""></p><p>上图显示这几种过滤器的前后调用顺序，第一个是pre过滤器然后是Route过滤器，最后响应是post过滤器。</p><p>这样</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Zuul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务熔断——Hystrix</title>
      <link href="/2020/04/28/cloud3/"/>
      <url>/2020/04/28/cloud3/</url>
      
        <content type="html"><![CDATA[<h2 id="服务熔断——Hystrix"><a href="#服务熔断——Hystrix" class="headerlink" title="服务熔断——Hystrix"></a>服务熔断——Hystrix</h2><p>在分布式中，因为存在网络延迟或者故障，所以一些服务调用无法及时响应。如果此时服务消费者还在大量地调用这些网络延迟或者故障的服务提供者，那么很快消费者也会为大量的等待，造成积压，最终导致其自身出现服务瘫痪。</p><p>为了克服这个问题，SpringCloud引入了Netflix的开源框架Hystrix来处理这些问题。当服务提供者应延迟或者故障时，就会使得服务消费者长期得不到响应，Hystrix就会对这些延迟或者故障的服务进行处理。这如同电路负荷过大，保险丝会烧毁从而保障用电安全一样，于是大家就形象地称之为断路器。</p><p>这样，当服务消费者长期得不到服务提供者响应时，就可以进行降级、服务断路、线程和信号隔离、请求缓存或者合并等处理。</p><h3 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h3><p>在互联网中，可能存在某一个微服务的某个时刻压力变大导致服务缓慢，甚至出现故障，导致服务不能响应。这里假设用户微服务请求中出现压力过大，服务响应速度变缓，进入瘫痪状态，而这时产品微服务响应还是正常响应。</p><p>但是如果出现产品微服务大量调用用户微服务，就会出现大量的等待，如果还是持续量请求的积压，导致产品微服务最终不可用。</p><p>可见在分布式中，如果一个服务不可用，而其他微服务还大量地调用这个不可用的微服务，也会导致其自身不可用，其自身不可用之后又可能继续蔓延到其他与之相关的微服务上，这样就会使得更多的微服务不可用，最终导致分布式服务瘫痪</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Hystrix/3.jpg" alt=""></p><p>为了防止这样的蔓延，微服务提出了断路器的概念。</p><p>断路器就如同电路中的保险丝，如果电器耗电大，导致电流过大，那么保险丝就会熔断，从而保证用电的安全。</p><p>同样地，在微服务系统之间大量调用可能导致服务消费者自身出现瘫痪的情况下，断路器就会将这些积压的大量请求“熔断”，来保证其自身服务可用，而不会蔓延到其他微服务系统上。通过这样的断路机制可以保持各个微服务持续可用。</p><h3 id="使用降级服务"><a href="#使用降级服务" class="headerlink" title="使用降级服务"></a>使用降级服务</h3><p>处理限制请求的方式的策略很多，如限流、缓存等。这里主要介绍最为常用的降级服务。</p><p>所谓降级服务，就是当请求其他微服务出现超时（timeout）或者发生故障时，就会使用自身服务其他的方法进行响应。下面模拟这样请求超时的场景在SpringCloud中断路器是由NetFlix的Hystrix实现的，它默认监控微服务之间的调用超时时间为2000ms(2s），如果超过这个超时时间，它就会根据你的配置使用其他方法进行响应。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>下面我们就在用户的服务端开始增加模拟的超时方法，以便用于测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/timeout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个3000之内的随机数</span></span><br><span class="line">    <span class="keyword">long</span> ms = (<span class="keyword">long</span>)(<span class="number">3000L</span>*Math.random());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 程序延迟，有一定的概率超过2000毫秒</span></span><br><span class="line">        Thread.sleep(ms);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"熔断测试"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用便是模拟服务端超时。他会有一定概率有超过两千毫秒的延迟。而一旦发生了这个延迟。服务就会使用降级策略。</p><p>然后我们在产品微服务端中加入Hystrix依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在主执行程序中，使用注解@EnableCircuitBreaker开启熔断器。</p><p>接下来继续定义Feign接口以便用于测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用用户微服务的timeout请求</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/timeout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testTimeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="断路机制"><a href="#断路机制" class="headerlink" title="断路机制"></a>断路机制</h4><p>接下来便需要用到这个注解@HystrixCommand。这个@HystrixCommand会在方法上使用，标注这个方法会使用延迟断路机制。默认的延迟时间是两秒，也就是两千毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ribbon断路</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/circuitBreaker1"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"error"</span>, commandProperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"3000"</span>) &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">circuitBreaker1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER/timeout"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feign断路测试</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/circuitBreaker2"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">circuitBreaker2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.testTimeout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降级服务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"超时出错。"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超过两千毫秒服务的降级策略就会使用。此刻会使用error方法。作用响应请求，从而避免请求的积压，保证微服务的的高可用性,并且还可以设置超时的时间。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Hystrix/4.jpg" alt=""></p><p>我们还可看看@HystrixCommand还能做些什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HystrixCommand &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HystrixCommand 命令所属的组的名称：默认注解方法类的名称</span></span><br><span class="line">            <span class="function">String <span class="title">groupKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HystrixCommand 命令的key值，默认值为注解方法的名称</span></span><br><span class="line">            <span class="function">String <span class="title">commandKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程池名称，默认定义为groupKey</span></span><br><span class="line">            <span class="function">String <span class="title">threadPoolKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">            <span class="comment">// 定义回退方法的名称, 此方法必须和hystrix的执行方法在相同类中</span></span><br><span class="line">            <span class="function">String <span class="title">fallbackMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">            <span class="comment">// 配置hystrix命令的参数</span></span><br><span class="line">            HystrixProperty[] commandProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">            <span class="comment">// 配置hystrix依赖的线程池的参数</span></span><br><span class="line">             HystrixProperty[] threadPoolProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。我们也可以通过此方法定义哪些需要忽略的异常</span></span><br><span class="line">            Class&lt;? extends Throwable&gt;[] ignoreExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义执行hystrix observable的命令的模式，类型详细见ObservableExecutionMode</span></span><br><span class="line">            <span class="function">ObservableExecutionMode <span class="title">observableExecutionMode</span><span class="params">()</span> <span class="keyword">default</span> ObservableExecutionMode.EAGER</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。此方法定义需要抛出的异常</span></span><br><span class="line">            HystrixException[] raiseHystrixExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义回调方法：但是defaultFallback不能传入参数，返回参数和hystrix的命令兼容</span></span><br><span class="line">            <span class="function">String <span class="title">defaultFallback</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="启用Hystrix仪表盘"><a href="#启用Hystrix仪表盘" class="headerlink" title="启用Hystrix仪表盘"></a>启用Hystrix仪表盘</h3><p>对于Hystrix,SpringCloud还提供了一个仪表盘（Dashboard）进行监控断路的情况，从而让开发者监控可能出现的问题。</p><p>这就又需要新建一个工程，再引入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置仪表盘"><a href="#配置仪表盘" class="headerlink" title="配置仪表盘"></a>配置仪表盘</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hystrix</span></span><br></pre></td></tr></table></figure><p>并且还需要在启动类上增加一个注解：@EnableHystrixDashboard</p><p>接着可以打开 6001/hystrix 查看。</p><p>从Hystrix仪表盘首页可以看，支持3种监控，前两种是基于Turbine的，一种是默认集群，另一种是指定集群，第三种是单点监控。</p><p>这里就简单地讨论一下单点监控。这里还有两个框，个是轮询时间，也就是隔多少时间轮询一次；另一个是标题，也就是仪表盘页面的标题是什么。</p><p>从单监控的说明可以看出，只需要给 http: //hystrix-app:port/hystrix.stream 格式的URL给仪表盘即可。</p><p>上面已经在产品微服务中使用了Hystrix，只是还需要引入SpringBoot的监控才可以，所以在产品微服务中先引入spring-boot-starter-actuator的依赖。但是，这样还不够，因为对于Actuator端点是不暴露的，为了使端点暴露，需要在产微服务的application.properties上添加属性：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">healtg,info,hystrix.stream</span></span><br></pre></td></tr></table></figure><p>这里的management.endpoints.web.exposure.include代表Actuator监控对外露的端点，在默认情况下，它只暴露health和info端点，这里增加了hystrix.stream端点，这样仪表盘才能读到HTTP协议下的hystrix信息流。</p><p>然后，在打开这个窗口：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Hystrix/1.jpg" alt=""></p><p>点击按钮，仪表盘就会进行监控了。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>访问：<a href="http://localhost:9001/product//circuitBreaker2。" target="_blank" rel="noopener">http://localhost:9001/product//circuitBreaker2。</a></p><p>再去观察仪表盘：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Hystrix/2.jpg" alt=""></p><p>至此，己经完成了让仪表盘监控断路机制的任务。当发生断路的时候，监控就会给予具体的统计和分析。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务实现负载均衡</title>
      <link href="/2020/04/25/cloud2/"/>
      <url>/2020/04/25/cloud2/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务实现负载均衡"><a href="#微服务实现负载均衡" class="headerlink" title="微服务实现负载均衡"></a>微服务实现负载均衡</h2><p>在微服务的开发中，会将一个大的系统拆分为多个微服务系统，而各个微服务系统之间需要相互协作才能完成业务需求。</p><p>每一个微服务系统可能存在多个节点，当一个微服务（服务消费者）调用另外一个微服务（服务提供者）时，服务提供者需要负载均衡算法提供一个节点进行响。</p><p>而负载均衡是分布式必须实施的方案例如，系统在某个时刻存在3万笔务请求，使用单点服务器就很可能出现超负载，导致服务器瘫痪，进而使得服务不可用。而使用3台服务节点后，通过负载均衡的算法使得每个节点能够比较平均地分摊请求这样每个点服务只是需要处理1笔请求，这样就可以分摊服务的压力，及时响应。</p><p>除此之外，在服务的过程中，可能出现某个节点故障的风险，通过均衡负载的算法就可以将故节点排除，使后续请求分散到其他可用节点上，这就体现了SpringCloud的高可用。</p><p>上面己经把产品和用户两个微服务注册到服务治理中心了。对于业务，则往往需要各个微服务之间相互地协助才能完成。例如，可能把产品交易信息放到产品服务中，而在交易时，有时需要根据用户的等级来决定某些商品的折扣，如白银会员是9折、黄金会员是8.5折、钻石会员是8折等。也就是说分布式系统在执行交易逻辑时，还需要使得产品微服务得到用户信息才可以决定产品的折扣，而用户的信息则是放置在用户微服务中的。</p><p>为了方便从用户微服务中获取用户信息，用户微服务会以REST风格提供一个请求URL这样对于产品微服务就可以通过阻ST请求获取用户服务。除了处理获取其他服务的数据外，这里还需要注意务节点之间的负载均衡。</p><p>毕竟一个微服务可以由多个节点提供服务。不过这些都不困难，因为SpringCloud提供了Rbbon和Feign组件来帮助我们完成这些功能。</p><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>SpringCloud己经屏蔽了一些底层的细节，它只需要一个简单的＠LoadBalance注解就以提供负载均衡的算法。这十分合SpringBoot的原则，提供默认的实现方式，减少开发的情况下，它会提供轮询的负载均衡算法。</p><p>我们就在用户的微服务上加一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2535737897308758054L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">// 1-银级会员，2-黄金会员。3-钻石会员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> note;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建一个控制层,实现获取用户信息的服务:</p><h4 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="comment">// 日志</span></span><br><span class="line"><span class="keyword">private</span> Logger log = Logger.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务发现客户端</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPo <span class="title">getUserPo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">ServiceInstance service = discoveryClient.getInstances(<span class="string">"USER"</span>).get(<span class="number">0</span>);</span><br><span class="line">log.info(<span class="string">"【"</span> + service.getServiceId() + <span class="string">"】:"</span> + service.getHost() + <span class="string">":"</span> + service.getPort());</span><br><span class="line">UserPo user = <span class="keyword">new</span> UserPo();</span><br><span class="line">user.setId(id);</span><br><span class="line"><span class="keyword">int</span> level = (<span class="keyword">int</span>) (id % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">user.setLevel(level);</span><br><span class="line">user.setUserName(<span class="string">"user_name_"</span> + id);</span><br><span class="line">user.setNote(<span class="string">"note_"</span> + id);</span><br><span class="line">System.out.println(<span class="string">"port=9002"</span>);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>discoveryClient是spring自己创建的。他会在方法中打印出用户的id和服务器主机的端口。这样有利于后续监控和对负载均衡的研究,当然我们也在后面的打印出了端口，以便于在命令行查看。</p><p>接着，就是在产品中加入依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在主文件中设置restTemplate的初始化。让其实现自动的多节点负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化RestTemplate</span></span><br><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">// 多节点负载均衡</span></span><br><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"restTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">initRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解的作用是让其实现负载均衡，它会自动分配给用户的微服务。</p><p>接着我们再产品端，调用用户的服务来测试。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入RestTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/ribbon"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPo <span class="title">testRibbon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UserPo user = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 循环10次，然后可以看到各个用户微服务后台的日志打印</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">//// 注意这里直接使用了USER这个服务ID，代表用户微服务系统</span></span><br><span class="line"><span class="comment">//// 该ID通过属性spring.application.name来指定</span></span><br><span class="line"><span class="comment">//user = restTemplate.getForObject("http://USER/user/" + (i + 1), UserPo.class);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">        user=restTemplate.getForObject(<span class="string">"http://USER/user/"</span> +<span class="number">1</span>, UserPo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们给打开网址<a href="http://localhost:9001/product/ribbon。" target="_blank" rel="noopener">http://localhost:9001/product/ribbon。</a></p><p>然后在我们的控制台中，看到我们端点的运行，然后我们会发现，端点的服务是交替着执行的。这样就实现了我们最初步的负载均衡。</p><p>但是调用RestTemplate的方法。显示有些复杂，因为这些参数的组装和结果要返回等操作，其实并没有必要显示的表达出来。于是乎，SpringCloud还引入了Feign。</p><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>对于REST风格的调用，如果使用RestTemplate会比较烦琐，可读性不高。为了简化多次调用的复杂度，SpringCloud提供了接口式的声明服务调用编程，它就是Feigna。</p><p>通过它请求其他做服务时，就如同调度本地服务的Java接口一样，从而在多次调用的情况下可以简化开发者的编程，提高代码的可读性。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>首先依然是引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就在走项目中加入注解@EnableFeignClients， 启动Feign。</p><h4 id="重点逻辑"><a href="#重点逻辑" class="headerlink" title="重点逻辑"></a>重点逻辑</h4><p>接着就是到了。这个逻辑最为关键的地方，他首先需要定一个接口，然后再用这个接口，去调用一个服务。</p><p>这服务就来自于用户的服务。定义该微服务的来源，就能够使用该微服务的功能了。而功能的具体实现。并不需要在消费者端完成，而是在用户端就准备好了。</p><p>首先需要首先需要定义好一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定服务ID（Service ID）</span></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 指定通过HTTP的GET方法请求路径</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="comment">// 这里会采用Spring MVC的注解配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPo <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是＠FeignClient（”user”），它代表这是一个Feign客户端，而配置的“user”是一个服务的ID(ServiceID），它指向了用户微服务，这样Feign就会知道向用户微服务请求，并会实现负载均衡。</p><p>这里的注解@GetMapping代表启用HTTP的GET请求用户微服务，而方法中的注解＠PathVariable代表从URL中获取参数。</p><p>然后在需要的地方调用这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入Feign接口</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/feign"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPo <span class="title">testFeign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UserPo user = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 循环10次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">Long id = (<span class="keyword">long</span>) (i + <span class="number">1</span>);</span><br><span class="line">user = userService.getUser(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里先是注入UserService接口对象，然后通过循环10次，调用声明的接口方法，这样也可以完成对用户微服务的调用。在该请求方法后，你也可以看到两个用户微服务后台均会打出相关的日志，因为Feign提供了负载均衡算法。</p><p>与Ribbon相比，Feign屏蔽掉了RestTemplate的使用，提供了接口声明式的调用，使得程序可读性更高，同时在多次调用中更为方便。</p><h3 id="多次测试"><a href="#多次测试" class="headerlink" title="多次测试"></a>多次测试</h3><p>之后的逻辑也与其类似，我们只需要仿照着以上逻辑的方式去写其他内容就好了。</p><p>比如，我们就在用户的服务端继续增加需要的服务功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 新增用户，POST请求，且以请求体(body)形式传递</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">insertUser</span><span class="params">(@RequestBody UserPo user)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="string">"message"</span>, <span class="string">"插入用户信息【"</span> +user.getUserName() + <span class="string">"】成功"</span>);</span><br><span class="line">System.out.println(<span class="string">"9002"</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改用户名，POST请求，其中用户编号使用请求头的形式传递</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/update/&#123;userName&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">updateUsername</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable(<span class="string">"userName"</span>)</span> String userName,</span></span><br><span class="line"><span class="function">        @<span class="title">RequestHeader</span><span class="params">(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="string">"message"</span>, <span class="string">"更新用户【"</span> +id +<span class="string">"】名称【"</span> +userName + <span class="string">"】成功"</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们继续回到产品端，将以上方法的名字和返回类型以及需要的参数，写到产品微服务的接口当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POST方法请求用户微服务</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">addUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           // 请求体参数</span></span></span><br><span class="line"><span class="function"><span class="params">           @RequestBody UserPo user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST方法请求用户微服务</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/update/&#123;userName&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">updateName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           // URL参数</span></span></span><br><span class="line"><span class="function"><span class="params">           @PathVariable(<span class="string">"userName"</span>)</span> String userName,</span></span><br><span class="line"><span class="function">           <span class="comment">// 请求头参数</span></span></span><br><span class="line"><span class="function">           @<span class="title">RequestHeader</span><span class="params">(<span class="string">"id"</span>)</span> Long id)</span>;</span><br></pre></td></tr></table></figure><p>然后我们继续在产品端的控制层在对他们测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/feign2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testFeign2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; result = <span class="keyword">null</span>;</span><br><span class="line">UserPo user = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">Long id = (<span class="keyword">long</span>) i;</span><br><span class="line">user = <span class="keyword">new</span> UserPo();</span><br><span class="line">user.setId(id);</span><br><span class="line"><span class="keyword">int</span> level = i % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">user.setUserName(<span class="string">"user_name_"</span> + id);</span><br><span class="line">user.setLevel(level);</span><br><span class="line">user.setNote(<span class="string">"note_"</span> + i);</span><br><span class="line">result = userService.addUser(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/feign3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testFeign3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">Long id = (<span class="keyword">long</span>) (i + <span class="number">1</span>);</span><br><span class="line">String userName = <span class="string">"user_name_"</span> + id;</span><br><span class="line">result = userService.updateName(userName, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是我们进去只需要调用接口里面的方法就可以了，具体的实现并不用在服务端完成,这样极大地解开了各个模块之间的耦合度，同时也方便于服务的治理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Ribbon </tag>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务治理和服务发现——Eureka</title>
      <link href="/2020/04/20/cloud1/"/>
      <url>/2020/04/20/cloud1/</url>
      
        <content type="html"><![CDATA[<p>按照现今互联网的开发，高井发、大数据、快响应己经是普遍的要求。为了支撑这样的需求，互联网系统也开始引入分布式的开发。为了实现分式的开发，Spring推出了一套组件，那就是SpringCloud。</p><p>当前SpringCloud已经成为构建分布式微服务的热门技术。它并不是自己独自造轮子，而是将目前各家公司已经开发好的、经过实践考验较为成熟的技术组合起来，并且通过SpringBoot风格进行再次封装，从而屏敲掉了复杂的配置和实现原理，为开发者提供了一套简单易懂、易部署和维护的分布式系统开发包。</p><p>分布式是非常复杂的，在大部分情况下非超大型企业很难开发自己的分布式框架，因为研发成本较高，而且周期很长，这时SpringCloud就为这些企业提供了一个开源井且免费的解决方案。首先，SpringCloud是一套组件，可以细分为多种组件，如服务发现、配置中心、消息总线、负载均衡、断路器和数据监控等。</p><h2 id="服务治理和服务发现——Eureka"><a href="#服务治理和服务发现——Eureka" class="headerlink" title="服务治理和服务发现——Eureka"></a>服务治理和服务发现——Eureka</h2><p>SpringCloud中主要是使用NtfliEureka作为服务治理的，SpringCloud对其进行了一次封装，使得开发者可以以SpringBoot的风格使用它，这样就为它的使用带来了极大的便利。通过服务注册将单个微服务节点注册给服务治理中心，这样服务治理中心可以治理单个微服务节点。服务发现则是微服务节点可以对服务治理中心发送消息，使得服务治理中心可以将新的微服务节点纳入管理。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Eureka/4.jpg" alt=""></p><h3 id="配置服务治理的节点"><a href="#配置服务治理的节点" class="headerlink" title="配置服务治理的节点"></a>配置服务治理的节点</h3><p>SpringCloud的服务治理是使用Netflix的Eureka作为服务治理器的，它是我们构建SpringCloud分布式最为核心和最为基础的模块，它的作用是注册和发现各个SpringBoot微服务，并且提供监控和管理的功能。搭建服务治理节点并不是很复杂，甚至可以说很简单，为此先搭建一个注册中心。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的引入依赖不建议直接复制粘贴，建议使用springio去构建，而且必须注意的是，SpringCloud的版本要和SpringBoot的版本相符合，版本对应从：<a href="https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies。中去寻找。" target="_blank" rel="noopener">https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies。中去寻找。</a></p><h4 id="启动Eureka"><a href="#启动Eureka" class="headerlink" title="启动Eureka"></a>启动Eureka</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里仅仅只需要加上一个注解便可以了。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/</span></span><br></pre></td></tr></table></figure><ul><li>属性eureka.client.register-with-eureka配置为false，是因为在默认的情况下，项目会自动地查找服务治理中心去注册。这里目自身就是服务治理中心，所以取消掉注册服务中心。</li><li>属性Eureka.client.fetch-registry配置为false，它是一个检索服务的功能，因为服务治理中心是维护服务实例的，所以也不需要这个功能，即设置为了false。</li><li>属性eureka.client.serviceUrl.defaultZone代表服务中心域，将来可以提供给别的微服务注册。后面的微服务还会使用到它。</li></ul><p>接下来，我们便打开<a href="http://localhost:7001/eureka/端口看一看吧。" target="_blank" rel="noopener">http://localhost:7001/eureka/端口看一看吧。</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Eureka/1.jpg" alt=""></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>注册中心配置好了之后，我们来制作一个服务发现者，他可以是用户这种消费者，也可以是生产者，但仍然需要建立一个新的模块。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，服务发现者并不用加注解，便可以直接使用。</p><p>但同样的，也需要配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>加上prefer-ip-address，注册ip的时候使用服务的ip地址。</p><p>这里使用了9001端口，而应用名称为product，这个微服务名称将会注册给服务治理中心。而这个应用就会作为这个名称为RODUCTC注意大写〉服务的一个节点。治理客户端服务域则是通过属性eureka.client.serviceUrl.defaultZone进行配置的，它也配置了服务治理中心同样的地址，这样它就能够注册到之前所配置的服务治理中心。假设服务治理中心已经开启，然后启动这个产品微服务，再次看到服务治理中心的网址，就可以看到注册成功的页面。</p><p>同样的，一个注册中心也会支持多个发现者去注册，我们便再建立一个模块User去注册吧。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Eureka/2.jpg" alt=""></p><p>看到这里可能很多人会有一些疑问。它们为什么要这样做？其实它很简单，在一些大型的网站中，就可以通过这种方式一步一步增加新的模块。而不用等所有模块都建好了，在上线部署。</p><h3 id="高可用的服务治理中心"><a href="#高可用的服务治理中心" class="headerlink" title="高可用的服务治理中心"></a>高可用的服务治理中心</h3><p>Eureka Server 的高可用实际上就是将自己作为服务想其它服务注册中心注册自己，这样就形成了一组互相注册的服务中心。</p><p>这样如果出现，如果有一个服务中心突然发生故障的话，那么其他的服务中心也可以支持消费者的使用。</p><p>要实施这样的功能非常的简单。</p><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    register-with-eureka: false</span></span><br><span class="line"><span class="comment">#    fetch-registry: false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7002/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="comment">#    register-with-eureka: false</span></span><br><span class="line"><span class="comment">#    fetch-registry: false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/</span></span><br></pre></td></tr></table></figure><p>那就是将两个服务中心互相定位到对方的地址，这样他们就会将彼此注册进去。</p><p>同时，我们也要将消费者的服务地址，加上这两处注册中心。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/,http://localhost:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们可以继续打开之前的网址，查看</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Eureka/3.jpg" alt=""></p><p>这样一个完整的服务中心就完成了。而且，Eureka还能够自我的实现负载均衡，那就是利用Ribbon和Feign。相同的服务可以交替被消费者访问，大大的减少数据流对单个业务端的压力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍一些常用的IDEA插件</title>
      <link href="/2020/04/12/%E6%8F%92%E4%BB%B62/"/>
      <url>/2020/04/12/%E6%8F%92%E4%BB%B62/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍一些常用的IDEA插件"><a href="#介绍一些常用的IDEA插件" class="headerlink" title="介绍一些常用的IDEA插件"></a>介绍一些常用的IDEA插件</h2><p>介绍一些常用的插件吧，这些插件是我在实际使用的时候觉得好用的插件。（部分图片来自于网络）</p><p><strong>Rainbow Brackets</strong></p><p>这个插件是一个彩虹色的括弧。他可以在我们使用很多括弧的时候，对不同层级的括弧给予不同的色号。让我们很清晰地能找到我们所包裹的这个括弧是属于哪个函数实体的内容</p><p><img src="https://img2018.cnblogs.com/blog/1825757/201912/1825757-20191202154819590-1192501650.png;%20charset=UTF-8" alt=""></p><p><img src="https://img2018.cnblogs.com/blog/1825757/201912/1825757-20191202154823062-1243015982.gif;%20charset=UTF-8" alt=""></p><p><strong>Lombok</strong></p><p>这个插件可以很方便的省略掉，我们去编写set和get方法，虽然说我们也能用别的方式都去实现，但是我们只要加入这个注解就可以省略掉有很多步骤而且还不会出错。但是要注意的是它生产的构造器是所有元素的默认构造器。如果需要定制的话，还是要自己编写内容的。</p><ul><li>@NonNull : 注解在参数上, 如果该类参数为 null , 就会报出异常, throw new NullPointException(参数名)</li><li>@Cleanup : 注释在引用变量前, 自动回收资源 默认调用 close() 方法</li><li>@Getter/@Setter : 注解在类上, 为类提供读写属性</li><li>@Getter(lazy=true) :</li><li>@ToString : 注解在类上, 为类提供 toString() 方法</li><li>@EqualsAndHashCode : 注解在类上, 为类提供 equals() 和 hashCode() 方法</li><li>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor : 注解在类上, 为类提供无参,有指定必须参数, 全参构造函数</li><li>@Data : 注解在类上, 为类提供读写属性（get,set）, 此外还提供了 equals()、hashCode()、toString() 方法</li><li>@Value :</li><li>@Builder : 注解在类上, 为类提供一个内部的 Builder</li><li>@SneakThrows :</li><li>@Synchronized : 注解在方法上, 为方法提供同步锁</li><li>@Log :</li><li>@Log4j : 注解在类上, 为类提供一个属性名为 log 的 log4j 的日志对象</li><li>@Slf4j : 注解在类上, 为类提供一个属性名为 log 的 log4j 的日志对象</li></ul><p><strong>Easy Code</strong></p><p>这个插件和之前讲的插件类似，这个插件可以。使用我们的数据源快速的生成相应的类文件。并且能够在此右上构造默认的注解。对于不同的连接池需要实现的注解都可以用这个默认模板就实现。省掉很多重复和不必要的步骤。</p><p><img src="https://upload-images.jianshu.io/upload_images/14226414-9426d5d10eb698cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1066/format/webp" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14226414-440d8fa96585bdaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/14226414-c16f4257fc98b322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/832/format/webp" alt=""></p><p><strong>Statistic</strong></p><p>这个插件可以统计在文件里所有代码的代码量和代码长度，最大长度，以代码所含内容等等。可以很方便地计算出我们的大小以及各种各样的数据。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/something/statistic.jpg" alt=""></p><p><strong>Restservices</strong></p><p>这个插件可以直接展示出我们控制层中的所有接口和各个接口的方法名，我们可以通过这个插件快速的定位到我们所需要的结果，而省略了在不同的文件中一遍一遍查找需要的接口和方法所花费的时间。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/something/restservices.jpg" alt=""></p><p><strong>Alibaba coding guideline</strong></p><p>还有一个就是一个叫做阿里巴巴代码规范的插件，这种插件可以在你编写任意代码时。你显示指出你这个代码所不包含规范的地方。但这种提示也只是相对而言，并不一定有绝对效力，也不强制。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/something/alibabacodingguideline.jpg" alt=""></p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>以上就是我经常使用的插件，这种插件可以快速形成着我们所需要的业务和代码。但同时要注重自己水平的提高，否则被淘汰也只是迟早的事情了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍一些读过的书籍</title>
      <link href="/2020/04/07/%E4%B9%A6%E7%B1%8D/"/>
      <url>/2020/04/07/%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍一些读过的书籍"><a href="#介绍一些读过的书籍" class="headerlink" title="介绍一些读过的书籍"></a>介绍一些读过的书籍</h2><p>讲一些我看过的书。</p><h3 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h3><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/something/book1.jpg" alt=""></p><p>今天来说说我看过一些。在编程方面的书籍。</p><p>首先看的是一个叫c++primer的书，这本书的前半部分呢，讲的是一些基本语法结构和还有些练习题。我就看到了智能指针那一部分，总得有人非常的详细。让人很清楚的了解这个编程语言的特性。我基本也算看的差不多，这个编程语言非常的复杂， 我觉得自己很难灵活的运用。后面那一部分呢是找一些库函数和一些算法。所以说它不是最新版本的语法，但是基本上也将这个编程语言特点讲的差不多了。我觉得，如果要认真的学编程语言的话，从c++开始入门是一个很不错的选择。</p><p>接下来是一个叫做Linux鸟哥的私房菜。这本书非常的厚。今晚是从Linux的安装到系统操作原理和方法底层以及一些操作系统权限啊，安全，磁盘等等。实现讲的非常非常的彻底了。但是我觉得，如果不从事运维这个行业的话，其实也没有太必要的读完这份书籍。但还是需要非常熟悉运用一些命令行的操作。。</p><p>接下来这本书讲的是关于TCP ip协议的。这本书把一些抽象的TCP ip协议方法。用更加形象的例子以图片的形式展现给大家。比如说ISO7层模型TCP4层模型等等，以及一些报文的格式，发送的方法，各字段的类型， 用图片这种让人比较好理解的方式展现出来。我觉得看完了这本书，基本上也就理解TCP ip协议。大部分的工作流程了。但是如果想深入学习的话，还是需要看一本叫做计算机网络自顶向下的书。</p><p>接下来蓝色这本书呢，讲的是Java，这个编程语言的各个规范和一些特别的用法。就比如的这本书第一个讲到的用静态方法去代替构造方法， 用于降低类和类之间的的耦合度，就是一个非常不错的例子。但是其实我实际感觉而言， 在做一些开发的时候是用不到这些，或者说你是想不到要这么做的。或者说你开发软件的时候不按这本书的规范去写，其实影响也不是很大。但如果你再做一些基本功能的时候遇到一些瓶颈不能再优化的时候，可以从这本书找一找灵感。</p><p>这本书讲的是关于HTTP协议的，关于这个协议的三次握手和四次挥手，还有滑动窗口等等功能比较形象地展示出来。虽然比较短，但总体上还不错，在面试的时候，可以派上用场。</p><h3 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h3><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/something/book2.jpg" alt=""></p><p>这个项目实战我觉得不是很好。他并没有很清晰的说各个功能是怎么做出来的，也没有介绍到各个技术的要点。就算单从项目本体而言也不是特别好，像复制粘贴一样做成一本书。总体而言不不是很建议新手去看。</p><p>这本叫做Java虚拟机的书非常的好，可以说是这个编程语言的《圣经》。这本书他没有讲Java的语法，而是把Java的诞生。Java的跨平台性，Java虚拟机是如何自动的回收内存？，虚拟机处理数据的算法虚拟机的调优。和Java类是怎么被加载到虚拟机中的，等等这些非常基础的东西讲的非常的透彻。他不能够让你学会这语言的各种用法。但它可以很清晰地让你了解这个语言的底层机制，现在很多的大公司都在面试的时候都很喜欢问有关于虚拟机的问题，并且他对你在学习的过程中，也会让你得到很多的收获。</p><p>接下来这本是关于spring的教程。这本书在前几章讲IOC和aop的原理讲的特别好，后面就是在简单的介绍一下各个技术的用法。前面算深入，后面算浅出。关于spring的各类技术，虽然也仅是浅尝截止，但也说到了点上，而且介绍技术也非常的多。不仅仅包含了spring的基础架构，还包含了一些微服务相关的知识，技术也比较新。可以作为一个入门书籍去好好的研读。</p><p>接下来这个高并发程序设计我觉得讲的要比那本叫作并发编程实战的书好。这本书的作者也是一个讲师，他用了几个非常简单的例子，去解释一下什么是并发，并发之间会发生什么错误，会产生什么不可见的问题，信号量阻塞和唤醒，以及如何提高并发的效率和死锁等等。我觉得入门多线程的话要先看这本书。多线程这个类型或者说这个领域可以说是未来趋势。我觉得很有必要去好好的了解。它在未来二三十年都不会过时。</p><p>这本书写的有点虎头蛇尾。这本书在介绍多线程的时候没有什么目标性，也让人很难以理解。总体而言知识比较散乱，但都是比较核心的东西，面试的时候可以紧急的复习一下，但就以去学习知识而言，不是很合格。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisCodeHelper-Pro的介绍和使用</title>
      <link href="/2020/04/03/%E6%8F%92%E4%BB%B61/"/>
      <url>/2020/04/03/%E6%8F%92%E4%BB%B61/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatisCodeHelper-Pro的介绍和使用"><a href="#MyBatisCodeHelper-Pro的介绍和使用" class="headerlink" title="MyBatisCodeHelper-Pro的介绍和使用"></a>MyBatisCodeHelper-Pro的介绍和使用</h2><p>这次要介绍的是一款名为mybatiscodehelper的插件，这款插件非常强大，而且灵活，主要的功能是能自动帮我们实现一些基本的业务代码。在我们使用这个idea编写crud代码的时候，能发挥出巨大的作用。</p><p>阅读本文需要点基础。你先对mybatis有一些基本的认知，或者熟练使用mybatis等功能之后。在开始使用这个插件。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>我们首先打开idea。从右边找到数据源这个选项。先用这个数据源测试一下和MySQL的连接。这个连接还需要下载一些jar包。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/2.jpg" alt=""></p><p>等连接成功后，我们就能在软件中看到数据库的样式。这就代表着我们连接数据库成功了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/1.jpg" alt=""></p><p>然后我们先新建一个类，在类中输入我们需要的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer userid;</span><br><span class="line"></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工资明细</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BigDecimal salary;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再使用快捷键ALT加insert。打开插件。<br>我们可以利用这个插件使该类生成相应的SQL语句。同时也能选择是否生成索引等等。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/3.jpg" alt=""></p><p>这样生成的SQL文件就会在我们这个类文件的下面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_mybatishelper(</span><br><span class="line">userid <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'userid'</span>,</span><br><span class="line">username <span class="built_in">VARCHAR</span> (<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'username'</span>,</span><br><span class="line">birth DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1000-01-01 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'birth'</span>,</span><br><span class="line">salary <span class="built_in">DECIMAL</span> (<span class="number">13</span>,<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">-1</span> <span class="keyword">COMMENT</span> <span class="string">'工资明细'</span>,</span><br><span class="line"><span class="keyword">INDEX</span> <span class="string">`ix_username_salary`</span>(username,salary),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (userid)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span> <span class="string">'user_mybatishelper'</span>;</span><br></pre></td></tr></table></figure><p>这个SQL文件再按快捷键ctrl+enter。可以执行这个文件，让他在我们的数据库生成相应的数据库表。<br>这样一来数据库表就生成了。</p><p>然后我们再右击选择这个数据库表。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/4.jpg" alt=""></p><p>打开这个选项。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/7.jpg" alt=""></p><p>这个选项有非常多的功能，我们只需要填好对你的路径，就能够生成所需要的mapper文件。并且还能选择是否生成服务层接口和服务层。以及是否添加实体类的注解。</p><p>选择了之后我们就能看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMybatishelperMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Integer userid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(UserMybatishelper record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(UserMybatishelper record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserMybatishelper <span class="title">selectByPrimaryKey</span><span class="params">(Integer userid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(UserMybatishelper record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(UserMybatishelper record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个插件已经自动为我们生成了相应的接口，并且已经实现了基本的增加，删除，修改更新等功能。</p><p>并且，我们还能够从mapper快速跳转到目标接口。<br>我们打开resource。文件写好了SQL还实现了基本的功能，我们只需要调用这个接口就能实现大部分的业务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.mybatiscodehelper.mapper.UserMybatishelperMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.example.mybatiscodehelper.domain.UserMybatishelper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@Table user_mybatishelper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"userid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"userid"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birth"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span> <span class="attr">property</span>=<span class="string">"birth"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"salary"</span> <span class="attr">jdbcType</span>=<span class="string">"DECIMAL"</span> <span class="attr">property</span>=<span class="string">"salary"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    userid, username, birth, salary</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByPrimaryKey"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">    from user_mybatishelper</span><br><span class="line">    where userid = #&#123;userid,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteByPrimaryKey"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    delete from user_mybatishelper</span><br><span class="line">    where userid = #&#123;userid,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">keyColumn</span>=<span class="string">"userid"</span> <span class="attr">keyProperty</span>=<span class="string">"userid"</span> <span class="attr">parameterType</span>=<span class="string">"com.example.mybatiscodehelper.domain.UserMybatishelper"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    insert into user_mybatishelper (username, birth, salary</span><br><span class="line">      )</span><br><span class="line">    values (#&#123;username,jdbcType=VARCHAR&#125;, #&#123;birth,jdbcType=TIMESTAMP&#125;, #&#123;salary,jdbcType=DECIMAL&#125;</span><br><span class="line">      )</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">keyColumn</span>=<span class="string">"userid"</span> <span class="attr">keyProperty</span>=<span class="string">"userid"</span> <span class="attr">parameterType</span>=<span class="string">"com.example.mybatiscodehelper.domain.UserMybatishelper"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    insert into user_mybatishelper</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        username,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birth != null"</span>&gt;</span></span><br><span class="line">        birth,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"salary != null"</span>&gt;</span></span><br><span class="line">        salary,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birth != null"</span>&gt;</span></span><br><span class="line">        #&#123;birth,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"salary != null"</span>&gt;</span></span><br><span class="line">        #&#123;salary,jdbcType=DECIMAL&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByPrimaryKeySelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.example.mybatiscodehelper.domain.UserMybatishelper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    update user_mybatishelper</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birth != null"</span>&gt;</span></span><br><span class="line">        birth = #&#123;birth,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"salary != null"</span>&gt;</span></span><br><span class="line">        salary = #&#123;salary,jdbcType=DECIMAL&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where userid = #&#123;userid,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByPrimaryKey"</span> <span class="attr">parameterType</span>=<span class="string">"com.example.mybatiscodehelper.domain.UserMybatishelper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@mbg.generated--&gt;</span></span><br><span class="line">    update user_mybatishelper</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birth = #&#123;birth,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      salary = #&#123;salary,jdbcType=DECIMAL&#125;</span><br><span class="line">    where userid = #&#123;userid,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/6.jpg" alt=""></p><p>当然还得实际工作效果远远不止如此。我们再返回相应的接口层。我们可以自己去编写相关的描述文字就能够在mapper文件里添加相应的SQL。<br>作为相关的描述文字是怎么回事呢？我们来演示一遍：</p><p><strong>findByUsernameAndUserid</strong></p><p>比如说输入这个寻找用户名和用户id。再右键Alt和enter便能够生成相应的业务。这种文字描述不仅具有记忆联想功能，而且还有各种语法补全。他可以很方便的实现你想要的功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUsernameAndUserid"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from user_mybatishelper</span><br><span class="line">  where username=#&#123;username,jdbcType=VARCHAR&#125; and userid=#&#123;userid,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外，我们还可以选择是否检验输入的值为空等等相关操作。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/plugins/mybatiscodehelper/5.jpg" alt=""></p><p>并且在此基础上还可以实现很多SQL的语法。比如while between等等相关功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findFirstByUseridAndUsernameBetweenOrderBySalaryDescAndUseridDesc"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from user_mybatishelper</span><br><span class="line">  where userid=#&#123;userid,jdbcType=INTEGER&#125; and username &lt;![CDATA[&gt;]]&gt; #&#123;minUsername,jdbcType=VARCHAR&#125; and username</span><br><span class="line">  &lt;![CDATA[&lt;]]&gt; #&#123;maxUsername,jdbcType=VARCHAR&#125; order by salary desc, userid desc limit 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而实现这种功能仅仅需只需要用语言去描述便可以了。并且他还在原有的基础上增加了检验，关键字是否错误，自动绑定，判空，验证值是否存在连接和依赖<br>并且我们还可以对单接口进行测试，我们可以右键选择它的测试，然后他就会新建一个测试类给我们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMybatishelperMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UserMybatishelperMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.BeforeClass</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpMybatisDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory builder = new SqlSessionFactoryBuilder().build(UserMybatishelperMapperTest.class.getClassLoader().getResourceAsStream("mybatisTestConfiguration/UserMybatishelperMapperTestConfiguration.xml"));</span><br><span class="line">        <span class="comment">//you can use builder.openSession(false) to not commit to database</span></span><br><span class="line">        mapper = builder.getConfiguration().getMapper(UserMybatishelperMapper<span class="class">.<span class="keyword">class</span>, <span class="title">builder</span>.<span class="title">openSession</span>(<span class="title">true</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByUsernameAndUserid</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        mapper.findByUsernameAndUserid(<span class="string">"Jack"</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用在连接测试看数据库是否相关的值，或者是值传达是否错误等等。</p><p>这个插件可以极大提高我们的工作效率。</p><p>但是这种插件说到底也是对我们一些基本的功能实现而已。很多实际生活场景中使用到那些业务不仅仅只有这些。所以还是需要好好学习</p>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Jsoup爬取网站数据</title>
      <link href="/2020/03/30/%E7%88%AC%E8%99%AB1/"/>
      <url>/2020/03/30/%E7%88%AC%E8%99%AB1/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Jsoup爬取网站数据"><a href="#利用Jsoup爬取网站数据" class="headerlink" title="利用Jsoup爬取网站数据"></a>利用Jsoup爬取网站数据</h2><p>最近在做项目的时候，老师说项目的数据量太少了，并且说可以利用爬虫去爬取一些数据来填充自己项目的数据库。于是乎，我又动了一些歪心思。:call_me_hand:</p><p>虽然自己也自学过Python，但是手上的笔记本没有安装pycharm，为了实现一项功能而去特意安装一个软件，实在是有一点本末倒置。于是乎，就使用了Java的一个名为Jsoup的包，去实现网络爬虫，爬取数据。</p><h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><p>虽然这东西有官方文档，但是说真的，看的有点乱，脑阔痛，于是就没看文档，直接看别人写的爬虫寻找逻辑。</p><p>看了一下别人写的爬虫，感觉挺长却又很没有营养。所以在理解了getElementsByClass和select的用法后，便决定自己一步一步写。所以，我写了一个很短却又效果很棒的爬虫。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">douban</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">    <span class="comment">//"https://movie.douban.com/chart"</span></span><br><span class="line">        Document doc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = Jsoup.connect(url).userAgent(<span class="string">"Mozilla"</span>).get();<span class="comment">//模拟火狐浏览器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里根据在网页中分析的类选择器来获取电影列表所在的节点</span></span><br><span class="line">        Elements div = doc.getElementsByClass(<span class="string">"indent"</span>);</span><br><span class="line">        Elements table = div.select(<span class="string">"table"</span>);<span class="comment">//查找table标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element tb : table) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);<span class="comment">//让线程操作不要太快</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取所有电影详情的链接所在的节点</span></span><br><span class="line">            Elements tr = tb.select(<span class="string">"tr"</span>);</span><br><span class="line">            Elements img=tr.select(<span class="string">"img"</span>);</span><br><span class="line">            String imgUrl = img.get(<span class="number">0</span>).attr(<span class="string">"abs:src"</span>);</span><br><span class="line">            System.out.println(imgUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个爬虫能够直接返回豆瓣网页图片的URL路径，可以非常快的把这些图片作为自己的数据源。</p><p>这里就简单的解释一下他们的用法，首先使用的是getElementsByClass，选中需要进行爬取的class标签，这个class标签的选取，最好越精确越好，即不要直接选取整个页面都使用的class，也不要选取很多细碎的文字样式的class，最佳的选取是选择一个盒模型中模块的class。作为我们的第一次筛选。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jsoup/1.png" alt=""></p><p>第一次筛选过后，我们可以看到，每一个电影都被一个名为table的标签所包裹，于是乎，根据下面的foreach，不难推测的出我们第二次选取的是每个独立电影的标签。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jsoup/2.png" alt=""></p><p>第二是筛选过后，剩下来的就是一个独立电影模块的所有内容了之后再不断利用select来选择标签，选出自己想要的内容。我们可以在选到了最后想要的标签后，使用attr（“abs:src”） ，来获取这个标签内的内容。当然，如果是文字内容的话，则使用  .text()。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jsoup/3.png" alt=""></p><p>————————————</p><p>下面是我实际操作的用来补充数据库的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String q=<span class="string">"鞋子"</span>;</span><br><span class="line">    String url=<span class="string">"http://www.shihuo.cn/running/list?page_size=60&amp;scene=跑步鞋&amp;sort=hot&amp;c=跑鞋#qk=shaixuan"</span>;</span><br><span class="line"></span><br><span class="line">    Document doc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doc = Jsoup.connect(url).userAgent(<span class="string">"Mozilla"</span>).get();<span class="comment">//模拟火狐浏览器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里根据在网页中分析的类选择器来获取列表所在的节点</span></span><br><span class="line">    Elements div = doc.getElementsByClass(<span class="string">"list-main"</span>);</span><br><span class="line">    Elements ul = div.select(<span class="string">"ul.list-ul"</span>);</span><br><span class="line">    Elements lis = ul.select(<span class="string">"li"</span>);<span class="comment">//查找标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Element li : lis) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);<span class="comment">//让线程操作不要太快  时间自己设置，主要是模拟人在点击</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取所有详情的链接所在的节点</span></span><br><span class="line">        Product product=<span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        Elements img=li.select(<span class="string">"img"</span>);</span><br><span class="line">        String imgUrl = img.get(<span class="number">0</span>).attr(<span class="string">"abs:src"</span>);</span><br><span class="line">        product.setImg(imgUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置名字</span></span><br><span class="line">        Elements title=li.select(<span class="string">"a"</span>);</span><br><span class="line">        product.setProductName(title.get(<span class="number">1</span>).text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置价格</span></span><br><span class="line">        String price=li.select(<span class="string">"b"</span>).get(<span class="number">0</span>).text();</span><br><span class="line">        product.setPrice(Double.parseDouble(price.substring(<span class="number">1</span>,price.length())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置类别</span></span><br><span class="line">        product.setCategory(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        product.setNote(<span class="string">"一双"</span>+q);</span><br><span class="line">        product.setStock(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        productService.add(product);</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">50</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不做补充说明，但是可以作为第二个阶段，供给大家学习。</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>当这个爬虫，遇到类出现空格的时候，getbyclass就不管用了，这时候需要使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elements div = doc.getElementsByAttributeValue(<span class="string">"class"</span>,<span class="string">"gl-warp clearfix"</span>);</span><br></pre></td></tr></table></figure><p>来实现我们的获取class方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis在SpringBoot中的一些特殊用法</title>
      <link href="/2020/03/27/redis2/"/>
      <url>/2020/03/27/redis2/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis在SpringBoot中的一些特殊用法"><a href="#Redis在SpringBoot中的一些特殊用法" class="headerlink" title="Redis在SpringBoot中的一些特殊用法"></a>Redis在SpringBoot中的一些特殊用法</h2><p>Redis除了操作那些数据类型的功能外，还能支持事务、流水线、发布订阅和Lua脚本等功能，这也是Redis常用的功能。在高并发的场景中，往往我们需要保证数据的一致性，这时考虑使用Redis务或者利用Redis执行Lua的原子性来达到数据一致性的目的，所以这里让我们对它们展开讨论。需要大批量执行Redis命令的时候，我们可以使用流水线来执行命令，这样可以极大地提Redis执行的速度。</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>首先Redis是支持一定事务能力的NoSQL，在Redis中使用事务，通常的命令组合是watch…multi…exec，也就是要在一个Redis连接中执行多个命令，这时我们可以考虑使用SessionCallback接口来达到这个目的。</p><p>其中，watch命令是可以监控Redis的一些键multi命令是开始事务，开始事务，该客户端的命令不会马上被执行，而是存放在一个队列里，这点是需要注意的地方，也就是在这时我们执行一些堪回数据的命令，Redis也是不会马上执行的，而是把命令放到一个队列里，所以时调用Redis的命令，结果都是返回null，这是初学者容易犯的错误：exe命令的意义在于执行事，只是它在队列命令执行前会判断被watch监控的Redis的键的数据是否发生过变化（即使赋予与前相同的值也会被认为是变化过〉，如果它认为发生了变化，那么Redis就会取消事务，否则就会行事务，Redis在执行事务时，要么全部执行，要么全部不执行，而且不会被其他客户端打断，这就保证了Redis事务下数据的一致性。</p><p>如图，这就是Redis事务的执行流程：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1009.jpg" alt=""></p><p>下面我们来测试一下这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    List list = (List) redisTemplate.execute((RedisOperations operations) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置要监控key1</span></span><br><span class="line">        operations.watch(<span class="string">"key1"</span>);</span><br><span class="line">        <span class="comment">// 开启事务，在exec命令执行前，全部都只是进入队列</span></span><br><span class="line">        operations.multi();</span><br><span class="line">        operations.opsForValue().set(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        operations.opsForValue().increment(<span class="string">"key1"</span>, <span class="number">1</span>);<span class="comment">// ①</span></span><br><span class="line">        <span class="comment">// 获取值将为null，因为redis只是把命令放入队列，</span></span><br><span class="line">        Object value2 = operations.opsForValue().get(<span class="string">"key2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"命令在队列，所以value为null【"</span> + value2 + <span class="string">"】"</span>);</span><br><span class="line">        operations.opsForValue().set(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">        Object value3 = operations.opsForValue().get(<span class="string">"key3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"命令在队列，所以value为null【"</span> + value3 + <span class="string">"】"</span>);</span><br><span class="line">        <span class="comment">// 执行exec命令，将先判别key1是否在监控后被修改过，如果是不执行事务，否则执行事务</span></span><br><span class="line">        <span class="keyword">return</span> operations.exec();<span class="comment">// ②</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来做两种测试：</p><p>1：在Redis客户端清空key2和key3两个键的数据，然后在②处设置断点，在调试的环境下让请求达到断点，此时在Redis上修改keyl的值，然后再跳过断点，在请求完成后在Redis上查询key2和key3值，可以发现key2、key3返回的值都为空（nil），因为程序中先使得Redis的watch命令监控了keyl的值，而后的multi让之后的命令进入队列，而在exec方法运行前我们修改了keyl，根据Redis事务的规则，它在exec方法后会探测keyl是否被修改过，如果没有则会执行事务，否则就取消事务，所以key2和key3没有被保存到Redis服务器中。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2001.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2002.jpg" alt=""></p><p>2：续把key2和key3两个值清空，把①处的注释取消，让代码可以运行，因为key1是一个字符串，所以这里的代码是对字符串加一，这显然是不能运算的。同样地，我们运行这段代码后，可以看到服务器抛出了异常，然后我们去Redis服务器查询key2和key3，可以看到它们已经有了值。注意，这就是Redis事务和数据库事务的不一样，对于Redis事务是先让命令进入队列，所以一开始它并没有检测这个加一命令是否能够成功，只有在exec命令执行的时候，才能发现错误，对于出错的命令Redis只是报出错误，而错误后面的命令依旧被执行，所以key2和key3都存在数据，这就是Redis事务的特点，也是使用Redis事务需要特别注意的地方。为了克服这个问题，一般我们要在执行Redis事务前，严格地检查数据，以避免这样的情况发生。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2003.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2004.jpg" alt=""></p><h3 id="使用Redis流水线"><a href="#使用Redis流水线" class="headerlink" title="使用Redis流水线"></a>使用Redis流水线</h3><p>默认的情况下，Redis客户端是一条条命令发送给Redis服务器的，这样显然性能不高。在关系数据库中我们可以使用批量，也就是只有需要执行SQL时，才一次性地发送所有的SQL去执行，这样性能就提高了许多。对于Redis也是可以的，这便是流水线（pipline）技术，在很多情况下并不是Redis性能不佳，而是网络传输的速度造成瓶颈，使用流水线后就可以大幅度地在需要执行很多命令时提升Redis的性能。</p><p>接下来我们就来试试使用了SessionCallBack接口的，单流水线性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line">    List list = (List) redisTemplate.executePipelined((RedisOperations operations) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            operations.opsForValue().set(<span class="string">"pipeline_"</span> + i, <span class="string">"value_"</span> + i);</span><br><span class="line">            String value = (String) operations.opsForValue().get(<span class="string">"pipeline_"</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">100000</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"命令只是进入队列，所以值为空【"</span> + value + <span class="string">"】"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"耗时："</span> + (end - start) + <span class="string">"毫秒。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2005.jpg" alt=""></p><p>这里还是沿用SessionCallback接口执行写入和读出各10万次Redis命令，只是修改为了Lambda表达式而己如果你的JDK达不到8的版本以上，那么只能采用匿名类的形式来改写这段代码了。</p><p>为了测试性能，这里记录了开始执行时间和结束执行时间，并且打出了耗时。在我的测试中，这10万次读写基本在300～600ms，大约平均值在400～500ms，也就是不到ls就能执行10万次读和写命令，这个速度还是十分快的。在使用非流水线的情况下，我的测试大约每秒只能执行2～3万条命令，可见使用流水线后可以提升大约10倍的速度，它十分适合大数据量的执行。</p><p>但是需要注意以下两点：</p><ul><li>此代码只是运用于测试，在运行如此多的命令时，需要考虑的另外一个问题是内存空间的消耗，因对于程序而言，它最终会返一个List象，如果过的命令执行返回的结果都保存到这个List中，显然会造成内存消耗过大，尤其在那些高并发的网站中就很容易造成川、内存溢出的异常，这个时候应该考虑使用迭代的方法执行Redis命令。</li><li>与事务一样，使用流水线的过程中，有的命令也只是进入队列而没有执行，所以执行的命令返回值也为空，这也是需要注意的地方。</li></ul><h3 id="使用Redis发布订阅"><a href="#使用Redis发布订阅" class="headerlink" title="使用Redis发布订阅"></a>使用Redis发布订阅</h3><p>发布订阅是消息的一种常用模式。例如，在企业分配任务之后，可以通过邮件、短信或者微信通知到相关的责任人，这就是一种典型的发布订阅模式。首先是Redis提供一个渠道，让消息能够发送到这个渠道上，而多个系统可以监听这个渠道，如短信、微信和邮件系统都可以监昕这个渠道，当一条消息发送到渠道，渠道就会通知它的监昕者，这样短信、微信邮件系统就能够得到这个渠道给它们的消息了，这些监听者会根据自己的需要去处理这个消息，于是我们就可以得到各种各样的通知了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1010.jpg" alt=""></p><p>为了接收到Redis发送过来的消息，我们需要定义一个消息监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 消息体</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        <span class="comment">// 渠道名称</span></span><br><span class="line">        String topic = <span class="keyword">new</span> String(pattern); </span><br><span class="line">        System.out.println(body);</span><br><span class="line">        System.out.println(topic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的onMessage方法是得到消息后的处理方法，其中message参数代表Redis发送过来的消息，pattern是渠道名称，。且也在Message方法里打印了它们的内容。这里因为标注了＠Component注解，所以在SpringBoot扫描后，会把它自动装配到IoC容器中。</p><p>此外，还需要监听容器的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis连接工厂</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisConnectionFactory connectionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis消息监听器</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MessageListener redisMsgListener = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务池</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskScheduler taskScheduler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建任务池，运行线程等待处理Redis的消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">initTaskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (taskScheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line">taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">taskScheduler.setPoolSize(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Redis的监听容器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 监听容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">initRedisContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line"><span class="comment">// Redis连接工厂</span></span><br><span class="line">container.setConnectionFactory(connectionFactory);</span><br><span class="line"><span class="comment">// 设置运行任务池</span></span><br><span class="line">container.setTaskExecutor(initTaskScheduler());</span><br><span class="line"><span class="comment">// 定义监听渠道，名称为topic1</span></span><br><span class="line">Topic topic = <span class="keyword">new</span> ChannelTopic(<span class="string">"topic1"</span>);</span><br><span class="line"><span class="comment">// 使用监听器监听Redis的消息</span></span><br><span class="line">container.addMessageListener(redisMsgListener, topic);</span><br><span class="line"><span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里RedisTemplate和RedisConnectionFactory象都是SpringBoot自动创建的，所以这里只是把它们注入进来，只需要使用＠Autowired解即。然后定义了一个任务池，并设置了任务池大小为20，这样它将可以运行线程，井进行阻塞，等待Redis消息的传入。</p><p>接着再定义了一个Redis消息听的容器RedisMessageListenerContainer，并且往容器设置了Redis连接工厂和指定运行消息的线程池，定义了接收“topicl”渠道的消息，这样系统就可以监听Redis关于“topicl＂渠道的消息了。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2007.jpg" alt=""></p><h3 id="使用Lua脚本"><a href="#使用Lua脚本" class="headerlink" title="使用Lua脚本"></a>使用Lua脚本</h3><p>Redis中有很多的命令，但是严格来说Redis提供的计算能力还是比较有限的。为了增强Redis计算能力，Redis在2.6版本后提供了Lua脚本的支持，而且执行Lua脚本在Redis中还具备原子性，所以在需要保证数据一致性的高并发环境中，我们也可以使用Redis的Lua语言来保证数据的一致性，且Lua脚本具备更加强大的运算功能，在高并发需要保证数据一致性时，Lua脚本方案比使用Redis自身提供的事务要更好一些。</p><p>在Redis中有两种运行Lua的方法，一种是直接发送Lua到Redis服务器去执行，另一种是先把Lua发送给Redis,Redis对Lua脚本进行缓存，然后返回一个SHAl的32位编码回来，之后只需要发送SHAl相关参数给Redis便可以执行了。这里需要解释的是为什么会存在通过32位编码执行的方法。如果Lua脚本很长，那么就需要通过网络传递脚本给Redis去执了，而现实的情况是网络的传递速度往往跟不上Redis的执行速度，所以网络就会成为Redis执行的瓶颈。如果只是传递32位编码参数，那么需要传递的消息就少了许多，这样就可以极大地减少网络传输的内容，从而提高系统的性能。</p><p>为了支持Redis的Lua脚本，Spring供了RedisScript接口，与此同时也有一个DefaultRedisScript实现类。让我们先来看看RedisScript接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisScript</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取脚本的sha1</span></span><br><span class="line">    <span class="function">String <span class="title">getSha1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取脚本的返回值</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getResultType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取脚本的字符串</span></span><br><span class="line">    <span class="function">String <span class="title">getScriptAsString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">returnsRawValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getResultType() == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript&lt;T&gt; <span class="title">of</span><span class="params">(String script)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisScript(script);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript <span class="title">of</span><span class="params">(String script, Class&lt;T&gt; resultType)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(script, <span class="string">"Script must not be null!"</span>);</span><br><span class="line">        Assert.notNull(resultType, <span class="string">"ResultType must not be null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisScript(script, resultType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript&lt;T&gt; <span class="title">of</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(resource, <span class="string">"Resource must not be null!"</span>);</span><br><span class="line">        DefaultRedisScript&lt;T&gt; script = <span class="keyword">new</span> DefaultRedisScript();</span><br><span class="line">        script.setLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> script;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript&lt;T&gt; <span class="title">of</span><span class="params">(Resource resource, Class&lt;T&gt; resultType)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(resource, <span class="string">"Resource must not be null!"</span>);</span><br><span class="line">        Assert.notNull(resultType, <span class="string">"ResultType must not be null!"</span>);</span><br><span class="line">        DefaultRedisScript&lt;T&gt; script = <span class="keyword">new</span> DefaultRedisScript();</span><br><span class="line">        script.setResultType(resultType);</span><br><span class="line">        script.setLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> script;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Spring会将Lua脚本发送到Redis服务器进行缓存，而此时Redis服务器会返回一个32位的SHAl编码，这时候通过getShal方法就可以得到Redis返回的这个编码了；getResultType方法是获取Lua脚本返回的Java类型getScriptAsString是返回脚本的字符串，以便我们观看脚本。</p><p>下面我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultRedisScript&lt;String&gt; redisScript=<span class="keyword">new</span> DefaultRedisScript&lt;String &gt;();</span><br><span class="line">    <span class="comment">//设置脚本</span></span><br><span class="line">    redisScript.setScriptText(<span class="string">"return 'i love you'"</span>);</span><br><span class="line">    <span class="comment">//定义返回类型</span></span><br><span class="line">    redisScript.setResultType(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    RedisSerializer&lt;String &gt; redisSerializer=redisTemplate.getStringSerializer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行脚本</span></span><br><span class="line">    String s=(String)redisTemplate.execute</span><br><span class="line">            (redisScript,redisSerializer,redisSerializer,<span class="keyword">null</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后一行打一个断点，开始测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2008.jpg" alt=""></p><p>这里的代码，首先Lua只是定义了一个简单的字符串，然后就返回了，而返回类型则定义为宇符串。这里必须定义返回类型，否则对于Spring不会把脚本执行的结果返回。接着获取了由RedisTemplate自动创建的字符串序列化器，而后使用RedisTemplate的execute方法执行了脚本。在RedisTemplate中，execute方法执行脚本的方法有两种，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scriptExecutor.execute(script, keys, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisScript&lt;T&gt; script, RedisSerializer&lt;?&gt; argsSerializer, RedisSerializer&lt;T&gt; resultSerializer, List&lt;K&gt; keys, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scriptExecutor.execute(script, argsSerializer, resultSerializer, keys, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个方法中，从参数的名称可以知道，script就是我们定义的RedisScript接口对象，keys代表Redis的键，args是这段脚本的参数。两个方法最大区别是一个存在序列化器的参数，另外个不存在。对于不存在序列化参数的方法，Spring将采用RedisTemplate提供的valueSerializer序列化器对传递的键和参进行序列化。这里我们采用了第二个方法调度脚本，并且设置为字符串序列化器，其中第一个序列化器是键的序列化器，二个是参数序列化器，这样键和参数就在字符串序列化器下被序列化了。</p><p>下面我们再来测试一下带参数的Lua吧：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2009.jpg" alt=""></p><p>这里的脚本中使用了两个键去保存两个参数，然后对这两个参数进行比较，如果相等则返回］,否则返回0。注意脚本中kYS[l］和kYS[2］的写法，它们表客户端传递的第一个键和第二键，而ARGV[1］和ARGV[2则表示客户端传递第一个和第二个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String key1=<span class="string">"this"</span>,key2=<span class="string">"like"</span>;</span><br><span class="line">    String value1=<span class="string">"not"</span>,value2=<span class="string">"yourself"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String lua=<span class="string">"redis.call('set',KEYS[1],ARGV[1]) \n"</span></span><br><span class="line">            +<span class="string">"redis.call('set',KEYS[2],ARGV[2]) \n"</span></span><br><span class="line">            +<span class="string">"local str1=redis.call('get',KEYS[1]) \n"</span></span><br><span class="line">            +<span class="string">"local str2=redis.call('get',KEYS[2]) \n"</span></span><br><span class="line">            +<span class="string">"if str1==str2 then \n"</span></span><br><span class="line">            +<span class="string">"return 1 \n"</span></span><br><span class="line">            +<span class="string">"end \n"</span></span><br><span class="line">            +<span class="string">"return 0 \n"</span>;</span><br><span class="line">    System.out.println(lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果为Long</span></span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript=<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;();</span><br><span class="line">    redisScript.setScriptText(lua);</span><br><span class="line">    redisScript.setResultType(Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//采用字符串序列化器</span></span><br><span class="line">    RedisSerializer&lt;String&gt; stringRedisSerializer=redisTemplate.getStringSerializer();</span><br><span class="line">    <span class="comment">//定义key参数</span></span><br><span class="line">    List&lt;String&gt; keyList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    keyList.add(key1);</span><br><span class="line">    keyList.add(key2);</span><br><span class="line">    <span class="comment">//传递两个参数，第一个序列化器是key的序列化器</span></span><br><span class="line">    <span class="comment">//第二个是参数的序列化器</span></span><br><span class="line">    Long result=(Long) redisTemplate.execute</span><br><span class="line">            (redisScript,stringRedisSerializer,stringRedisSerializer,keyList,value1,value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用keyList保存了各个键，然后通过Redis的execute方法传递，参数则可以使用可变化的方式传递，且设置了给键和参数的序列化器都为字符串序列化器，这样便能够运行这段脚本了。我们的脚本返回为一个数字，这里值得注意的是，因为Java会把整数当作长整型（Long），所以这里返回值设置为Long型。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2010.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis在SpringBoot中的基础实现</title>
      <link href="/2020/03/23/redis1/"/>
      <url>/2020/03/23/redis1/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis在SpringBoot中的基础实现"><a href="#Redis在SpringBoot中的基础实现" class="headerlink" title="Redis在SpringBoot中的基础实现"></a>Redis在SpringBoot中的基础实现</h2><p>之前在讲SpringBoot整合Redis的时候，仅仅只是说了简单而又直观的运用，现在，我们来看看Redis在SpringBoot中，到底还有哪些操作。为此，我们仍然需要建立一个工程，其中的Redis使用的是Jedis驱动去连接，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1004.jpg" alt=""></p><p>从图可以看出，在Spring中是通过RedisConnection接口操作Redis的，而RedisConnection则对原生的Jedis进行封装。要获取RedisConnection接口对象，是通过RedisConnectionFactory接口去生成的，所以第一步要配置的便是这个工厂了，而配置这个工厂主要是配置Redis的连接池，对于连接池可以限定其最大连接数、超时时间等属性。下面开发一个简单的RedisConnectionFactory接口对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory connectionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"redisConnectionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">initConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connectionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.connectionFactory;</span><br><span class="line">        &#125;</span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        <span class="comment">// 最大空闲数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 最大连接数</span></span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 最大等待毫秒数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 创建Jedis连接工厂</span></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory(poolConfig);</span><br><span class="line">        <span class="comment">// 配置Redis连接服务器</span></span><br><span class="line">        RedisStandaloneConfiguration rsc = connectionFactory.getStandaloneConfiguration();</span><br><span class="line">        rsc.setHostName(<span class="string">"localhost"</span>);</span><br><span class="line">        rsc.setPort(<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//        rsc.setPassword(RedisPassword.of("123456"));</span></span><br><span class="line">                <span class="keyword">this</span>.connectionFactory = connectionFactory;</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Redis的配置，当然，你也可以在application.yml文件中把配置写入，由SpringBoot去自动完成，他们之间并没有什么区别。</p><h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><p>我们在SpringBoot当中，所使用Redis最多的类是RedisTemplate，RedisTemplate是一个强大的类，首先它会自动从RedisConnectionFactory工厂中获取连接，然后执行对应的Redis命令，在最后还会关闭Redis的接。这些在RedisTemplate都被封装了，所以并不需要开发者关注Redis连接的闭合问题。</p><p>我们可以创建一个RedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object,Object&gt; redisTemplate=<span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(initConnectionFactory());</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从上述代码中得知，每当RedisTemplate需要被使用时，它就会创建一个工厂实例，去初始化这个RedisTemplate，让它获取这个连接的能力，可能很多人看到这里有点疑惑，为什么他们需要这么麻烦呢？直接拥有连接不就好了吗？别着急，其实它们这样做是为了进一步的解耦，使得我们的Redis连接不被固有化，同时，这样的行为还有定制的作用，为什么呢？接着往下看。</p><p>我们开始对这个Redis进行一个实验，来看看它们是否真的成功了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> AnnotationConfigApplicationContext(RedisConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    RedisTemplate redisTemplate=context.getBean(RedisTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"ket1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    redisTemplate.opsForHash().put(<span class="string">"hash"</span>,<span class="string">"field"</span>,<span class="string">"hvalue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码过后，我们可以从Redis控制台看到结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1001.jpg" alt=""></p><p>我想很多人一定很疑惑，为什么它们的键值，是这样的呢？这是因为，<strong>Redis是一种基于字符串存储的NoSQL，而Java是基于对象的语言</strong>，熟悉Java虚拟机的都知道，一个对象包含的东西太多了，包括了对象头等等，非常复杂的事物，所以无法直接被转化为字符串，而这并不是没有办法，只要类实现了java.io.Serializable接口，就能将类的对象序列化，通过这个原理，也能够反序列化。</p><p>于是乎，我们便可以在Redis中，实现序列化器：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1005.jpg" alt=""></p><p>对于序列化器，Spring提供了RedisSerializer接口，它有两个方法。这两个方法，一个是serialize，它能把那些可以序列化的对象转换为二进制字符串；另一个是deserialize,它能够通过反序列化把二进制字符串转换为Java对象。图中的JacksonJsonRedisSerializer因为API过时，己经不推荐使用，我们这里主要讨论StringRedisSerializer和JdkSerializationRedisSerializer,其中JdkSerializationRedisSerializer是RedisTemplate默认的序列化器，代码清单的味etl”这个字符串就是被它序列化变为一个比较奇怪的宇符串的，原理如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1006.jpg" alt=""></p><p>RedisTemplate还有以下的属性可以配置：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1011.jpg" alt=""></p><p>所以，我们便可以在原来的代码当中，使用字符串序列化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">initRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(initConnectionFactory());</span><br><span class="line">    RedisSerializer&lt;String&gt; stringRedisSerializer = redisTemplate.getStringSerializer();</span><br><span class="line">    redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setHashValueSerializer(stringRedisSerializer);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1002.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1003.jpg" alt=""></p><p>另外，我们可以从代码中看出一些值得注意的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">"ket1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">redisTemplate.opsForHash().put(<span class="string">"hash"</span>,<span class="string">"field"</span>,<span class="string">"hvalue"</span>);</span><br></pre></td></tr></table></figure><p>它们还存在一些值得我们探讨的细节。例如，上述的两个操作并不是在同一个Redis的连接下完成的，什么意思？让我们更加详细地阐述代码运行的过程，首先在操作ket1时，redisTemplate会先从连接工厂（RedisConnectionFactory）中获取一个连接，然后执行对应的Redis命令，再关闭这条连接，其次在操作hash时，它也是从连接工厂中获取另条连接，然后执行命令，再关闭该连接。所以我们可以看到这个过程是两条连接的操作，这样显然存在资源的浪费，我们更加希望是在同一连接中就执行两个命令。为了克服这个问题，Spring为我们提供了RedisCallback和SessionCallback个接口。不过在此之前我们需要了解Spring对Redis数据类型的封装。</p><p>Redis使用得最多的是字符串，因此在spring-data-redis项中，还提供了一个StringRedisTemplate，这个类继承RedisTemplate，只是提供了字符串的操作而己，对于复杂Java对象还需要自行处理。</p><h3 id="SpringBoot对Redis数据类型操作的封装"><a href="#SpringBoot对Redis数据类型操作的封装" class="headerlink" title="SpringBoot对Redis数据类型操作的封装"></a>SpringBoot对Redis数据类型操作的封装</h3><p>Redis能够支持7种类型的数据结构，这7种类型是字符串、散列、列表（链表）、集合、有序集合、基数和地理位置。为此Spring针对每一种数据结构的操作都提供了对应的操作接口:</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1012.jpg" alt=""></p><p>它们都可以通过RedisTemplate得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">／／获取地理位置操作接口</span><br><span class="line">    redisTemplate.opsForGeo();</span><br><span class="line">／／获取散列操作接口</span><br><span class="line">    redisTemplateopsForHash();</span><br><span class="line">／／获取基数操作接口</span><br><span class="line">    redisTemplate.opsForHyperLogLog();</span><br><span class="line">／／获取列表操作接口</span><br><span class="line">    redisTemplate.opsForList();</span><br><span class="line">／／获取集合操作接口</span><br><span class="line">    redisTemplate.opsForSet();</span><br><span class="line">／／获取字符串操作接口</span><br><span class="line">    redisTemplate.opsForValue();</span><br><span class="line">／／获取有序集合操作接口</span><br><span class="line">    redisTemplate.opsForZSet();</span><br></pre></td></tr></table></figure><p>这样就可以通过各类的操作接口来操作不同的数据类型了，当然这需要你熟悉Redis的各种命令。有时我们可能需要对某一个键值对（key”value）做连续的操作，例如，有时需要连续操作一个散列数据类型或者列表多次，这时Spring也提供支持，它提供了对应的BoundXXXOperations接口：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1013.jpg" alt=""></p><p>同样的，也有对应的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">／／获取地理位置绑定键操作接口</span><br><span class="line">redisTemplate.boundGeoOps（”geo”）;</span><br><span class="line">／／获取散列绑定键操作接口</span><br><span class="line">redisTemplate.boundHashOps(”hash”);</span><br><span class="line">／／获取列表（链表）绑定键操作接口</span><br><span class="line">redisTemplate.boundListops(”list&quot;);</span><br><span class="line">／／获取集合绑定键操作接口</span><br><span class="line">redisTemplate.boundSetOps（”set”）；</span><br><span class="line">／／获取字符串绑定键操作接口</span><br><span class="line">redisTemplate.boundValueOps(&quot;string”),</span><br><span class="line">／／获取有序集合绑定键操作接口</span><br><span class="line">redisTemplate.boundZSetOps(”zset&quot;);</span><br></pre></td></tr></table></figure><p>获取其中的操作接口后，我们就可以对某个键的数据进行多次操作，这样我们就知道如何有效地通过Spring操作Redis的各种数据型了。</p><h3 id="SessionCallback和RedisCallback接口"><a href="#SessionCallback和RedisCallback接口" class="headerlink" title="SessionCallback和RedisCallback接口"></a>SessionCallback和RedisCallback接口</h3><p>们的作用是让RedisTemplate进行回调，通过它们可以在同一条连接下执行多个Redis命令。其中SessionCallback提供了良好的封装，对于开发者比较友好，因此在实际的开发中应该优先选择使用它；相对而言，RedisCallback接口比较底层，需要处理的内容也比较多，可读性较差，所以在非必要的时候尽量不选择使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//// 需要处理底层的转换规则，如果不考虑改写底层，尽量不使用它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useRedisCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> RedisCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection rc)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            rc.set(<span class="string">"key1"</span>.getBytes(), <span class="string">"value1"</span>.getBytes());</span><br><span class="line">            rc.hSet(<span class="string">"hash"</span>.getBytes(), <span class="string">"field"</span>.getBytes(), <span class="string">"hvalue"</span>.getBytes());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//// 高级接口，比较友好，一般情况下，优先使用它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSessionCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations ro)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            ro.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            ro.opsForHash().put(<span class="string">"hash"</span>, <span class="string">"field"</span>, <span class="string">"hvalue"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们采用了匿名类的方式去使用它们。从代码中可以看出，RedisCallback接口井不是那么友好，但是它能够改写一些底层的东西，如序列化的问题，所以在需要改写那些较为底层规则时，可以使用它。使用SessionCallback接口则比较友好，这也是我在大部分情况下推荐使用的接口，它提供了更为高级的API，使得我们的使用更为简单，可读性也更佳。如果采用的是Java8或者以上的版本，则还可以使用Lambda表达式改写上述代码，这样代码就会更加清爽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useRedisCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute((RedisConnection rc) -&gt; &#123;</span><br><span class="line">        rc.set(<span class="string">"key1"</span>.getBytes(), <span class="string">"value1"</span>.getBytes());</span><br><span class="line">        rc.hSet(<span class="string">"hash"</span>.getBytes(), <span class="string">"field"</span>.getBytes(), <span class="string">"hvalue"</span>.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSessionCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute((RedisOperations ro) -&gt; &#123;</span><br><span class="line">        ro.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        ro.opsForHash().put(<span class="string">"hash"</span>, <span class="string">"field"</span>, <span class="string">"hvalue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们再清除掉所有缓存，重新测试一遍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(RedisConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        RedisTemplate redisTemplate = ctx.getBean(RedisTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//redisTemplate.opsForValue().set("key1", "value1");</span></span><br><span class="line"><span class="comment">//redisTemplate.opsForHash().put("hash", "field", "hvalue");</span></span><br><span class="line">        useSessionCallback(redisTemplate);</span><br><span class="line"><span class="comment">//useRedisCallback(redisTemplate);</span></span><br><span class="line">        ctx.close();</span><br></pre></td></tr></table></figure><p>结果是成功的。</p><h3 id="SpringBoot中使用Redis"><a href="#SpringBoot中使用Redis" class="headerlink" title="SpringBoot中使用Redis"></a>SpringBoot中使用Redis</h3><p>虽然我们在整合Redis的时候，已经使用过注解了，但是这样的方法，并不能直观的学习到它的用法，于是乎，我们便一步一步的手动去操作一遍吧。</p><p>首先便是使用application.yml去代替Config：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>这里我们配置了连接池和服务器的属性，用以连接Redis服务器，这样SpringBoot的自动装配机制就会读取这些配置来生成有关Redis的操作对象，这里它会自动生成RedisConnectionFactory、RedisTemplate、StringRedisTemplate等常用的Redis对象。我们知道，RedisTemplate会默认使用JdkSerializationRedisSerializer进行序列化键值，这样便能够存储到Redis服务器中。</p><p>如果这样，Redis服务器存入的便是一个经过序列化后的特殊字符串，有时候对于我们跟踪并不是很友好。如果我们在Redis只是使用字符串，那么使用其自动生成的StringRedisTemplate即可，但是这样就只能支持字符串了，并不能支持Java对象的存储。为了克服这个问题，可以通过设置RedisTemplate的序列化器来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义自定义后初始方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initRedisTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置template序列化器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisSerializer serializer=redisTemplate.getStringSerializer();</span><br><span class="line">        redisTemplate.setKeySerializer(serializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(serializer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略redisCacheManager</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过＠Autowired注入由SpringBoot根据配置生成的RedisTemplate对象，然后利用SpringBean生命周期的特性使用注解＠PostConstruct自定义后初始化方法。在这个方法里，把RedisTemplate中的键序列化器修改为StringRedisSerializer。</p><p>因为之前我们讨论过，在RedisTemplate中它会默认地定义了一个StringRedisSerializer对象，所以这里我并没有自己创建一个新的StringRedisSerializer对象，而是从RedisTemplate中获取。然后把RedisTemplate关于键和其散列数据类型的filed都修改为了使用StringRedisSerializer进行序列化，这样我们在Redis服务器上得到的键和散列的field就都以宇符串存储了。</p><p>那么接下来，我们就在测试中，测试一下我们存储各种数据类型的情况吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"int_key"</span>,<span class="string">"1"</span>);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"int"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">//使用运算</span></span><br><span class="line">    stringRedisTemplate.opsForValue().increment(<span class="string">"int"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取底层jedis连接</span></span><br><span class="line">    Jedis jedis=(Jedis)stringRedisTemplate.getConnectionFactory()</span><br><span class="line">            .getConnection().getNativeConnection();</span><br><span class="line">    <span class="comment">//减一操作，这个命令需要获得底层连接才能操作</span></span><br><span class="line">    jedis.decr(<span class="string">"int"</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String&gt; hash=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hash.put(<span class="string">"field1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    hash.put(<span class="string">"field2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">    <span class="comment">//存入一个散列数据类型</span></span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(<span class="string">"hash"</span>,hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增一个字段</span></span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">"hash"</span>,<span class="string">"field3"</span>,<span class="string">"value3"</span>);</span><br><span class="line">    <span class="comment">//绑定散列操作的Key，这样可以连续对同一个散列数据类型进行操作</span></span><br><span class="line">    BoundHashOperations hashOperations=stringRedisTemplate.boundHashOps(<span class="string">"hash"</span>);</span><br><span class="line">    <span class="comment">//删除两个字段</span></span><br><span class="line">    hashOperations.delete(<span class="string">"field1"</span>,<span class="string">"field2"</span>);</span><br><span class="line">    <span class="comment">//新增一个字段</span></span><br><span class="line">    hashOperations.put(<span class="string">"field4"</span>,<span class="string">"value4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的＠Autowired注入了SpringBoot为我们自动初始化RedisTemplate和StringRedisTemplate对象。看到testStringAndHash法，先是存入了一个“key1”的数据，然后是“int_key”但是请注意这个“int_key”存入到Redis服务器中，因为采用了JDK序列化器，所以在Redis服务器中它不是整数，而是一个被JDK序列化器序列化后的二进制字符串，是没有办法使用Redis命令进行运算的。</p><p>为了克服这个问题，这里使用StringRedisTemplate对象保存了一个键为“int”的整数，这样就能够运算了。接着进行了加一运算，但是因为RedisTemplate并不能支持底层所有的Redis命令，所以这里先获取了原始的Redis连接的Jedis对象，用它来做减一运算。</p><p>然后是操作散列数据类型，在插入多个散列的field时可以采用Map，然后为了方便对同一个数据操作，这里代码还获取了BoundHashOperations对象进行操作，这样对同一个数据操作就方便许多了。</p><p>测试结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1014.jpg" alt=""></p><p>列表也是常用的数据类型。在Redis中列表是一种链表结构，这就意味着查询性能不高，而增删节点的性能高，这是它的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入两个列表</span></span><br><span class="line">    <span class="comment">//链表从左到右顺序为：v10、v8、v6...</span></span><br><span class="line">    stringRedisTemplate.opsForList().leftPushAll(<span class="string">"List1"</span>,<span class="string">"v2"</span>,<span class="string">"v4"</span>,<span class="string">"v6"</span>,<span class="string">"v8"</span>,<span class="string">"v10"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表从右到左顺序为：v1,v2,v3...</span></span><br><span class="line">    stringRedisTemplate.opsForList().rightPushAll(<span class="string">"List2"</span>,<span class="string">"v1"</span>,<span class="string">"v2"</span>,<span class="string">"v3"</span>,<span class="string">"v4"</span>,<span class="string">"v5"</span>,<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定链表操作</span></span><br><span class="line">    BoundListOperations listOperations=stringRedisTemplate.boundListOps(<span class="string">"List2"</span>);</span><br><span class="line">    <span class="comment">//从右边弹出一个成员</span></span><br><span class="line">    Object result1=listOperations.rightPop();</span><br><span class="line">    <span class="comment">//获取定位元素，从下标0开始算，这里为v2</span></span><br><span class="line">    Object result2=listOperations.index(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//从左边插入链表</span></span><br><span class="line">    listOperations.leftPush(<span class="string">"v0"</span>);</span><br><span class="line">    <span class="comment">//求链表长度</span></span><br><span class="line">    Long size=listOperations.size();</span><br><span class="line">    <span class="comment">//求链表下标区间成员，整个链表下标范围为0，到size-1，这里不取最后一个元素</span></span><br><span class="line">    List elements=listOperations.range(<span class="number">0</span>,size-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object a:elements) &#123;</span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>述操作是基于StringRedisTemplate的，所以保存到Redis服务器的都是字符串类型，只是这里有两点需要注意。首先是列表元素的顺序问题，是从左到右还是从右到左，这是容易弄糊涂的问题：其次是下标问题，在Redis中是以0开始的，这与Java中的数组类似。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1015.jpg" alt=""></p><p>接着是集合。对于集合，在Redis中是不允许成员重复的，它在数据结构上是一个散列表的结构，所以对于它而言是无序的，对于两个或者以上的集合，Redis还提供了交集、并集和差集的运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//重复两次v1，因为集合不允许重复，所以结果还是5个值</span></span><br><span class="line">     stringRedisTemplate.opsForSet().add(<span class="string">"set1"</span>,<span class="string">"v1"</span>,<span class="string">"v1"</span>,<span class="string">"v2"</span>,<span class="string">"v3"</span>,<span class="string">"v4"</span>,<span class="string">"v5"</span>);</span><br><span class="line">     stringRedisTemplate.opsForSet().add(<span class="string">"set2"</span>,<span class="string">"v2"</span>,<span class="string">"v4"</span>,<span class="string">"v6"</span>,<span class="string">"v8"</span>);</span><br><span class="line">     <span class="comment">//绑定集合</span></span><br><span class="line">     BoundSetOperations setOperations=stringRedisTemplate.boundSetOps(<span class="string">"set1"</span>);</span><br><span class="line">     <span class="comment">//增加两个元素</span></span><br><span class="line">     setOperations.add(<span class="string">"v6"</span>,<span class="string">"v7"</span>);</span><br><span class="line">     <span class="comment">//删除</span></span><br><span class="line">     setOperations.remove(<span class="string">"v1"</span>,<span class="string">"v7"</span>);</span><br><span class="line">     <span class="comment">//返回所有元素</span></span><br><span class="line">     Set set=setOperations.members();</span><br><span class="line">     <span class="comment">//求成员数量</span></span><br><span class="line">     Long size=setOperations.size();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//求交集</span></span><br><span class="line">     setOperations.intersectAndStore(<span class="string">"set2"</span>,<span class="string">"inter"</span>);</span><br><span class="line">     <span class="comment">//求差集</span></span><br><span class="line">     setOperations.diff(<span class="string">"set2"</span>);</span><br><span class="line">     <span class="comment">//求差集并保存</span></span><br><span class="line">     setOperations.diffAndStore(<span class="string">"set2"</span>,<span class="string">"diff"</span>);</span><br><span class="line">     <span class="comment">//求并集</span></span><br><span class="line">     Set union=setOperations.union(<span class="string">"set2"</span>);</span><br><span class="line">     <span class="comment">//求并集并保存</span></span><br><span class="line">     setOperations.unionAndStore(<span class="string">"set2"</span>,<span class="string">"union"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>添加集合set1时，存在两个v1一样的元素。因为集合不允许重复，所以实际上在集合只算是一个元素。然后可以看到对集合各类操作，在最后还有交集、差集和并集的操作，这些是集合最常用的操作。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1016.jpg" alt=""></p><h3 id="TypedTuple接口"><a href="#TypedTuple接口" class="headerlink" title="TypedTuple接口"></a>TypedTuple接口</h3><p>在一些网站中，经常会有排名，如最热门的商品或者最大的购买买家，都是常常见到的场景。对于这类排名，刷新往往需要及时，也涉及较大的统计，如果使用数据库会太慢。为了支持集合的排序，Redis还提供了有序集合（zset）。有序集合与集合的差异并不大，它也是一种散列表存储的方式，同时它的有序性只是靠它在数据结构中增加一个属性–score（分数）得以支持。为了支持这个变化，Spring提供了TypedTuple接口，它定义了两个方法，并且Spring还提供了其默认的实现类DefaultTypedTuple，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1007.jpg" alt=""></p><p>在TypedTuple接口的设计中，value是保存有序集合的值，score则是保存分数，Redis是使用分数来完成集合的排序的，这样如果把买家作为一个有序集合，而买家花的钱作为分数，就可以使用Redis进行快速排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">9</span> ; i++) &#123;</span><br><span class="line">         <span class="comment">//分数</span></span><br><span class="line">         <span class="keyword">double</span> score=i*<span class="number">0.1</span>;</span><br><span class="line">         <span class="comment">//创建一个TypedTuple对象，存入值和分数</span></span><br><span class="line">         ZSetOperations.TypedTuple&lt;String&gt; typedTuple=</span><br><span class="line">                 <span class="keyword">new</span> DefaultTypedTuple&lt;String&gt;(<span class="string">"value"</span>+i,score);</span><br><span class="line">         typedTuples.add(typedTuple);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//往有序集合插入元素</span></span><br><span class="line">     stringRedisTemplate.opsForZSet().add(<span class="string">"zset1"</span>,typedTuples);</span><br><span class="line">     <span class="comment">//绑定属性</span></span><br><span class="line">     BoundZSetOperations&lt;String ,String &gt; zSetOperations=</span><br><span class="line">             stringRedisTemplate.boundZSetOps(<span class="string">"zset1"</span>);</span><br><span class="line">     <span class="comment">//增加一个元素</span></span><br><span class="line">     zSetOperations.add(<span class="string">"value10"</span>,<span class="number">0.26</span>);</span><br><span class="line">     Set&lt;String &gt; setRange=zSetOperations.range(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">     Set&lt;String &gt; setScore=zSetOperations.rangeByScore(<span class="number">0.2</span>,<span class="number">0.6</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//定义值范围</span></span><br><span class="line">     RedisZSetCommands.Range range=<span class="keyword">new</span> RedisZSetCommands.Range();</span><br><span class="line">     range.gt(<span class="string">"value3"</span>);<span class="comment">// 大于value3</span></span><br><span class="line">     <span class="comment">// range.gte("value3");// 大于等于value3</span></span><br><span class="line">     <span class="comment">// range.lt("value8");// 小于value8</span></span><br><span class="line">     range.lte(<span class="string">"value8"</span>);<span class="comment">// 小于等于value8</span></span><br><span class="line">     <span class="comment">// 按值排序，请注意这个排序是按字符串排序</span></span><br><span class="line">     Set&lt;String&gt; setLex = zSetOperations.rangeByLex(range);</span><br><span class="line">     <span class="comment">// 删除元素</span></span><br><span class="line">     zSetOperations.remove(<span class="string">"value9"</span>, <span class="string">"value2"</span>);</span><br><span class="line">     <span class="comment">// 求分数</span></span><br><span class="line">     Double score = zSetOperations.score(<span class="string">"value8"</span>);</span><br><span class="line">     <span class="comment">// 在下标区间下，按分数排序，同时返回value和score</span></span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; rangeSet = zSetOperations.rangeWithScores(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="comment">// 在分数区间下，按分数排序，同时返回value和score</span></span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; scoreSet = zSetOperations.rangeByScoreWithScores(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="comment">// 按从大到小排序</span></span><br><span class="line">     Set&lt;String&gt; reverseSet = zSetOperations.reverseRange(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码中使用了TypedTuple保存有序集合的元素，在默认的情况下，有序集合是从小到大地排序的，按下标、分数和值进行排序获取有序集合的元素，或者连同分数一起返回，有时候还可以进行从大到小的排序，只是在使用值排序时，我们可以使用Spring为我们创建的Range类，它可以定义值的范围，还有大于、等于、大于等于、小于等于等范围定义，方便我们筛选对应的元素。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1017.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（九）类加载机制全解析</title>
      <link href="/2020/03/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA9/"/>
      <url>/2020/03/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA9/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载机制全解析"><a href="#类加载机制全解析" class="headerlink" title="类加载机制全解析"></a>类加载机制全解析</h2><p>我们所编写的Java代码，在经过编译器的编译后，会把我们的.java 文件编译成可以被系统所识别的机器码，而虚拟机便会读取这些文件来运行，就算平台有所不同，也不受影响，这也就是Java的跨平台性。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1001.jpg" alt=""></p><p>那么，这么类文件是怎么被加载到JVM中使用的呢？我们自己随便改个Class后缀行不行？我们复写了JDK里面了根类，JVM又会运行哪个呢？现在，我们就来解读这个问题。</p><p>再看一下jvm的大致物理结构图</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1002.jpg" alt=""></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1003.jpg" alt=""></p><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p> 这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</p><ul><li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li><li>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li></ul><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。<strong>也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。</strong></p><p>类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p>加载.class文件的方式有:</p><ul><li>1). 从本地系统中直接加载</li><li>2). 通过网络下载.class文件</li><li>3). 从zip，jar等归档文件中加载.class文件 </li><li>4). 从专有数据库中提取.class文件 </li><li>5). 将Java源文件动态编译为.class文件</li></ul><p>这些便是类的加载方式，了解了这些加载方式后，再来谈谈加载阶段，到底做了些什么。</p><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><p><strong>1、通过一个类的全限定名来获取其定义的二进制字节流。</strong></p><p>这个全限定名，在之前讲述类文件结构的时候出现过，那个点可能很多人都没有看懂，这里再次被拿了出来。它的意思就是类的名字，就这么简单。</p><p><strong>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p><p><strong>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</strong></p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，<strong>也可以自定义自己的类加载器来完成加载</strong>，后面会提到类加载器是什么东西。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>  当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。<strong>类连接又可分为如下3个阶段：验证、准备、解析。</strong></p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p><ul><li>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li><li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li><li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li></ul><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p> 1、这时候进行内存分配的<strong>仅包括类变量（static）</strong>，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>这很明显，有时候你加载一个类并不代表就一定要实例化它，有可能你仅仅是利用了反射去加载这个类，没有创建出实例。</p><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p><p> 假设一个类变量的定义为：public static int value = 3；这是一个类里面的静态值，我们的JVM会为其分配相应的内存空间，但是并不会赋予值。 </p><p>变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器 <strong><clinit>（）</strong>方法之中的，所以<strong>把value赋值为3的动作将在初始化阶段才会执行。</strong></p><p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1005.jpg" alt=""></p><p>这里还需要注意如下几点：</p><ol><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ol><p>3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，<strong>那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</strong></p><p>  假设上面的类变量value被定义为：public static final int value = 3； 编译时Javac将会为value生成ConstantValue属性，<strong>在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。</strong></p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p> <strong>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</strong></p><p>这里先说一下什么是符号引用，什么是直接引用：</p><ul><li>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。</li><li>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。<br> <strong>1、类或接口的解析：</strong>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p><p> <strong>2、字段解析：</strong>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1006.jpg" alt=""></p><p>从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了super类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了父类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了子类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(Child.m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>  执行了super类静态语句块<br>  执行了父类静态语句块<br>  33<br>  如果注释掉Father类中对m定义的那一行，则输出结果如下：</p><p>  执行了super类静态语句块<br>  11</p><p>最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：<br><strong>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m都匹配System.out.println(Child.m)^1 错误</strong></p><p> <strong>3、类方法解析：</strong>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p><p>  <strong>4、接口方法解析：</strong>与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p> 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源， 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量时指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤:</p><ul><li>1)、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3)、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。<br> 这里简单说明下<clinit>（）方法(类构造器方法)的执行规则:</p><ol><li><p><clinit>（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</p></li><li><p><clinit>（）方法与实例构造器<init>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>（）方法执行之前，父类的<clinit>（）方法已经执行完毕。因此，在虚拟机中第一个被执行的<clinit>（）方法的类肯定是java.lang.Object。</p></li><li><p><clinit>（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>（）方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<clinit>（）方法。但是接口鱼类不同的是：执行接口的<clinit>（）方法不需要先执行父接口的<clinit>（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>（）方法。</p></li><li><p>虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>（）方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>（）方法完毕。如果在一个类的<clinit>（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p><p>下面给出一个简单的例子，以便更清晰地说明如上规则：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(Child.b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行上面的代码，会打印出2，也就是说b的值被赋为了2。</p><p>我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用<clinit>（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的<clinit>（）方法，根据规则2，在此之前，要先执行完其父类Father的<clinit>（）方法，又根据规则1，在执行<clinit>（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，<strong>因此当触发执行Father的<clinit>（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的<clinit>（）方法，这样便会将b的赋值为2。</strong></p><p>  如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的<clinit>（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。</p><p> 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</p><h4 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h4><p>在以下情况的时候，Java虚拟机会结束生命周期：</p><ol><li><p>执行了System.exit()方法</p></li><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p></li></ol><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。</p><ul><li><p>1、创建类的实例，也就是new一个对象</p></li><li><p>2、访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>3、访问类的静态方法</p></li><li><p>4、反射如(Class.forName(“my.xyz.Test”))</p></li><li><p>5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</p></li><li><p>6、虚拟机启动时，定义了main()方法的那个类先初始化</p><p>除此之外，下面几种情形需要特别指出：</p><p>对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p></li></ul><p>以上情况称为称对一个类进行<strong>“主动引用”</strong>，除此种情况之外，均不会触发类的初始化。</p><p><strong>而称为“被动引用” 接口的加载过程与类的加载过程稍有不同。</strong>接口中不能使用static{}块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。</p><p><strong>被动引用例子</strong></p><ul><li>1、子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化.</li><li>2、通过数组定义来引用类，不会触发类的初始化</li><li>3、 访问类的常量，不会初始化类</li></ul><p>如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"superclass init"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(SubClass.value);<span class="comment">// 被动应用1  </span></span><br><span class="line">        SubClass[] sca = <span class="keyword">new</span> SubClass[<span class="number">10</span>];<span class="comment">// 被动引用2  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出 superclass init 123 从上面的输入结果证明了被动引用1与被动引用2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"ConstClass init"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);<span class="comment">// 调用类常量  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果只有 hello world 从上面的输出结果证明了被动引用3</p><p>上面很详细的介绍了类的加载时机和类的加载过程，通过上面的理论来分析一些题目吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        count1++;  </span><br><span class="line">        count2++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> singleTon;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();  </span><br><span class="line">        System.out.println(<span class="string">"count1="</span> + singleTon.count1);  </span><br><span class="line">        System.out.println(<span class="string">"count2="</span> + singleTon.count2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:<br>1 : SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化</p><p>2 : 类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null count1=0,count2=0</p><p>3 : 类初始化化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法</p><p>4 : 调用类的构造方法后count=1;count2=1</p><p>5 : 继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0</p><h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>现在我们知道什么时候触发类的初始化了，他精确地写在Java语言规范中。但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。事实上很多核心Java面试题和SCJP问题都是基于这些概念，下面是类初始化的一些规则：</p><ul><li><p>1.类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</p></li><li><p>2.超类早于子类和衍生类的初始化</p></li><li><p>3.如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的</p></li><li><p>4.初始化即使静态域被子类或子接口或者它的实现类所引用。</p></li><li><p>5.接口初始化不会导致父接口的初始化。</p></li><li><p>6.静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</p></li><li><p>7.非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类</p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h4><p> 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识，<strong>这个唯一标识就是类的全限定名。</strong></p><blockquote><p>例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。</p></blockquote><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。<br>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</p><ul><li><p>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</p></li><li><p>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p></li></ul><p><strong>启动类加载器：Bootstrap ClassLoader</strong>：又叫根类加载器。跟上面相同，它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p>下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urls)&#123;</span><br><span class="line">System.out.println(url.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>file:/D:/JAVA/jdk1.8/jre/lib/resources.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/rt.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/sunrsasign.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/jsse.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/jce.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/charsets.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/jfr.jar<br>file:/D:/JAVA/jdk1.8/jre/classes</p></blockquote><p><strong>扩展类加载器：Extension ClassLoader</strong>：该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器：Application ClassLoader</strong>：该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p> 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p> 1）在执行非置信代码之前，自动验证数字签名。</p><p> 2）动态地创建符合用户特定需要的定制化构建类。</p><p> 3）从特定的场所取得java class，例如数据库中和网络中。</p><p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>这几种类加载器的层次关系如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1004.jpg" alt=""></p><p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p><p>  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。<br>在rt.jar包中的java.lang.ClassLoader类中，我们可以查看类加载实现过程的代码，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">    <span class="comment">// 首先检查该name指定的class是否有被加载  </span></span><br><span class="line">    Class c = findLoadedClass(name);  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果parent不为null，则调用parent的loadClass进行加载  </span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// parent为null，则调用BootstrapClassLoader进行加载  </span></span><br><span class="line">                c = findBootstrapClass0(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">            <span class="comment">// 如果仍然无法加载成功，则调用自身的findClass进行加载  </span></span><br><span class="line">            c = findClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">        resolveClass(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p><p><strong>当然，除了双亲委派之外，类的加载还有两种机制：全盘负责和缓存。</strong></p><h4 id="全盘负责"><a href="#全盘负责" class="headerlink" title="全盘负责"></a>全盘负责</h4><p>所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。除此之外，ClassLoader 还负责加载 Java 应用所需的资源，如图像文件和配置文件等，ClassLoader 中与加载类相关的方法如下：</p><p>方法说明 getParent()  返回该类加载器的父类加载器。</p><p>loadClass(String name) 加载名称为 二进制名称为name 的类，返回的结果是 java.lang.Class 类的实例。</p><p>findClass(String name) 查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</p><p>findLoadedClass(String name) 查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</p><p>resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。</p><p>注意：在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。</p><p>在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果)。例子代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 一、ClassLoader加载类的顺序 </span></span><br><span class="line"><span class="comment">     *  1.调用 findLoadedClass(String) 来检查是否已经加载类。 </span></span><br><span class="line"><span class="comment">     *  2.在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。 </span></span><br><span class="line"><span class="comment">     *  3.调用 findClass(String) 方法查找类。 </span></span><br><span class="line"><span class="comment">     * 二、实现自己的类加载器 </span></span><br><span class="line"><span class="comment">     *  1.获取类的class文件的字节数组 </span></span><br><span class="line"><span class="comment">     *  2.将字节数组转换为Class类的实例 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> lei 2011-9-1 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;  </span><br><span class="line">            <span class="comment">//新建一个类加载器  </span></span><br><span class="line">            MyClassLoader cl = <span class="keyword">new</span> MyClassLoader(<span class="string">"myClassLoader"</span>);  </span><br><span class="line">            <span class="comment">//加载类，得到Class对象  </span></span><br><span class="line">            Class&lt;?&gt; clazz = cl.loadClass(<span class="string">"classloader.Animal"</span>);  </span><br><span class="line">            <span class="comment">//得到类的实例  </span></span><br><span class="line">            Animal animal=(Animal) clazz.newInstance();  </span><br><span class="line">            animal.say();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"hello world!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//类加载器的名称  </span></span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="comment">//类存放的路径  </span></span><br><span class="line">        <span class="keyword">private</span> String path = <span class="string">"E:\\workspace\\Algorithm\\src"</span>;  </span><br><span class="line">        MyClassLoader(String name) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">        MyClassLoader(ClassLoader parent, String name) &#123;  </span><br><span class="line">            <span class="keyword">super</span>(parent);  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 重写findClass方法 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) &#123;  </span><br><span class="line">            <span class="keyword">byte</span>[] data = loadClassData(name);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, data, <span class="number">0</span>, data.length);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                name = name.replace(<span class="string">"."</span>, <span class="string">"//"</span>);  </span><br><span class="line">                FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path + name + <span class="string">".class"</span>));  </span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                    baos.write(b);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> baos.toByteArray();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>类加载器双亲委派模型是从JDK1.2以后引入的，并且只是一种推荐的模型，不是强制要求的，因此有一些没有遵循双亲委派模型的特例：(了解)</p><p>(1).在JDK1.2之前，自定义类加载器都要覆盖loadClass方法去实现加载类的功能，JDK1.2引入双亲委派模型之后，loadClass方法用于委派父类加载器进行类加载，只有父类加载器无法完成类加载请求时才调用自己的findClass方法进行类加载，因此在JDK1.2之前的类加载的loadClass方法没有遵循双亲委派模型，因此在JDK1.2之后，自定义类加载器不推荐覆盖loadClass方法，而只需要覆盖findClass方法即可。</p><p>(2).双亲委派模式很好地解决了各个类加载器的基础类统一问题，越基础的类由越上层的类加载器进行加载，但是这个基础类统一有一个不足，当基础类想要调用回下层的用户代码时无法委派子类加载器进行类加载。为了解决这个问题JDK引入了ThreadContext线程上下文，通过线程上下文的setContextClassLoader方法可以设置线程上下文类加载器。</p><p>JavaEE只是一个规范，sun公司只给出了接口规范，具体的实现由各个厂商进行实现，因此JNDI，JDBC,JAXB等这些第三方的实现库就可以被JDK的类库所调用。线程上下文类加载器也没有遵循双亲委派模型。</p><p>(3).近年来的热码替换，模块热部署等应用要求不用重启java虚拟机就可以实现代码模块的即插即用，催生了OSGi技术，在OSGi中类加载器体系被发展为网状结构。OSGi也没有完全遵循双亲委派模型。</p><h3 id="动态加载Jar-amp-amp-ClassLoader-隔离问题"><a href="#动态加载Jar-amp-amp-ClassLoader-隔离问题" class="headerlink" title="动态加载Jar &amp;&amp; ClassLoader 隔离问题"></a><strong>动态加载Jar &amp;&amp; ClassLoader 隔离问题</strong></h3><h4 id="动态加载Jar"><a href="#动态加载Jar" class="headerlink" title="动态加载Jar"></a>动态加载Jar</h4><p>Java 中动态加载 Jar 比较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:libs/jar1.jar"</span>)&#125;;  </span><br><span class="line">URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls, parentLoader);</span><br></pre></td></tr></table></figure><p>表示加载 libs 下面的 jar1.jar，其中 parentLoader 就是上面1中的 parent，可以为当前的 ClassLoader。</p><h4 id="ClassLoader-隔离问题"><a href="#ClassLoader-隔离问题" class="headerlink" title="ClassLoader 隔离问题"></a>ClassLoader 隔离问题</h4><p>大家觉得一个运行程序中有没有可能同时存在两个包名和类名完全一致的类？ JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，这就是 ClassLoader 隔离。 如 Android 中碰到如下异常 [java] view plain copy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.support.v4.view.ViewPager can not be cast to android.support.v4.view.ViewPager</span><br></pre></td></tr></table></figure><p>当碰到这种问题时可以通过 instance.getClass().getClassLoader(); 得到 ClassLoader，看 ClassLoader 是否一样。</p><h4 id="加载不同-Jar-包中公共类"><a href="#加载不同-Jar-包中公共类" class="headerlink" title="加载不同 Jar 包中公共类"></a>加载不同 Jar 包中公共类</h4><p>现在 Host 工程包含了 common.jar, jar1.jar, jar2.jar，并且 jar1.jar 和 jar2.jar 都包含了 common.jar，我们通过 ClassLoader 将 jar1, jar2 动态加载进来，这样在 Host 中实际是存在三份 common.jar，如下图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1007.jpg" alt=""></p><p>我们怎么保证 common.jar 只有一份而不会造成上面3中提到的 ClassLoader 隔离的问题呢，其实很简单，在生成 jar1 和 jar2 时把 common.jar 去掉，只保留 host 中一份，以 host ClassLoader 为 parentClassLoader 即可。</p><h4 id="总结：一道面试题"><a href="#总结：一道面试题" class="headerlink" title="总结：一道面试题"></a><strong>总结：一道面试题</strong></h4><p>能不能自己写个类叫java.lang.System？<br>答案：通常不可以，但可以采取另类方法达到这个需求。<br>解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。<br>但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（八）Class文件基本组织结构</title>
      <link href="/2020/03/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA8/"/>
      <url>/2020/03/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA8/</url>
      
        <content type="html"><![CDATA[<h2 id="Class文件基本组织结构"><a href="#Class文件基本组织结构" class="headerlink" title="Class文件基本组织结构"></a>Class文件基本组织结构</h2><p>关于类和对象，已经是老生常谈的事情了。关于对象的结构，在讲述Synchronized的时候，大致的讲述了一遍，而现在开始学习，关于Class文件的结构。</p><p>我们先放一个示意图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/2020%E5%B9%B43%E6%9C%8811%E6%97%A5142543.png" alt=""></p><p>这就是Class文件的组织结构，下面我们一步一步讲解，它们是什么。</p><h4 id="魔数-magic"><a href="#魔数-magic" class="headerlink" title="魔数(magic)"></a>魔数(magic)</h4><p>当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p><p>可以看作为，这是一个最基本的保险，它会对文件进行基本的验证，以致于不会随便改一个后缀名，就能入JVM的法眼。</p><h4 id="版本号-minor-version-major-version"><a href="#版本号-minor-version-major-version" class="headerlink" title="版本号(minor_version,major_version)"></a>版本号(minor_version,major_version)</h4><p>Java有很多不同的版本，不同的JDK里面，Class的结构多少都会有着轻微的调动，面对这样情况，Java虚拟机会让每一个类文件中包含自己的JDK版本。</p><p>主版本号和次版本号在class文件中各占两个字节，副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p> 一个 JVM实例只能支持特定范围内的主版本号 （Mi 至Mj） 和 0 至特定范围内 （0 至 m） 的副版本号。假设一个 Class 文件的格式版本号为 V， 仅当Mi.0 ≤ v ≤ Mj.m成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件，反之则不成立。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号 &lt; class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的<strong>“java.lang.UnsupportedClassVersionError: Bad version number in .class file “</strong> Error 错误；反之，JVM会认为可以加载此class文件，继续加载此class文件。</p><h4 id="常量池计数器-constant-pool-count"><a href="#常量池计数器-constant-pool-count" class="headerlink" title="常量池计数器(constant_pool_count)"></a>常量池计数器(constant_pool_count)</h4><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。 常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器constant_pool_count 的值 =constant_pool表中的成员数+ 1。constant_pool表的索引值只有在大于 0 且小于constant_pool_count时才会被认为是有效的。</p><h4 id="常量池数据区-constant-pool-contstant-pool-count-1"><a href="#常量池数据区-constant-pool-contstant-pool-count-1" class="headerlink" title="常量池数据区(constant_pool[contstant_pool_count-1])"></a>常量池数据区(constant_pool[contstant_pool_count-1])</h4><p>常量池，constant_pool是一种表结构,它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，称为 “tag byte” 。常量池的索引范围是 1 至constant_pool_count−1。</p><h4 id="访问标志-access-flags"><a href="#访问标志-access-flags" class="headerlink" title="访问标志(access_flags)"></a>访问标志(access_flags)</h4><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/2020%E5%B9%B43%E6%9C%8811%E6%97%A5142550.png" alt=""></p><h4 id="类索引-this-class"><a href="#类索引-this-class" class="headerlink" title="类索引(this_class)"></a>类索引(this_class)</h4><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口。通俗点讲，它表示的就是类本身的名字。</p><h4 id="父类索引-super-class"><a href="#父类索引-super-class" class="headerlink" title="父类索引(super_class)"></a>父类索引(super_class)</h4><p>对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p><p>对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p><h4 id="接口计数器-interfaces-count"><a href="#接口计数器-interfaces-count" class="headerlink" title="接口计数器(interfaces_count)"></a>接口计数器(interfaces_count)</h4><p>接口计数器，interfaces_count的值表示当前类或接口的直接父接口数量。</p><h4 id="接口信息数据区-interfaces-interfaces-count"><a href="#接口信息数据区-interfaces-interfaces-count" class="headerlink" title="接口信息数据区(interfaces[interfaces_count])"></a>接口信息数据区(interfaces[interfaces_count])</h4><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i]  必须为 CONSTANT_Class_info类型常量，其中 0 ≤ i &lt;interfaces_count。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h4 id="字段计数器-fields-count"><a href="#字段计数器-fields-count" class="headerlink" title="字段计数器(fields_count)"></a>字段计数器(fields_count)</h4><p> 字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。这是Java的特性，可以以任意一个类作为数组，这是C++所不具有的。</p><h4 id="字段信息数据区-fields-fields-count"><a href="#字段信息数据区-fields-fields-count" class="headerlink" title="字段信息数据区(fields[fields_count])"></a>字段信息数据区(fields[fields_count])</h4><p> 字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><h4 id="方法计数器-methods-count"><a href="#方法计数器-methods-count" class="headerlink" title="方法计数器(methods_count)"></a>方法计数器(methods_count)</h4><p>  方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><h4 id="方法信息数据区-methods-methods-count"><a href="#方法信息数据区-methods-methods-count" class="headerlink" title="方法信息数据区(methods[methods_count])"></a>方法信息数据区(methods[methods_count])</h4><p> 方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。 method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法方法和类或接口初始化方法方法 。methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。</p><h4 id="属性计数器-attributes-count"><a href="#属性计数器-attributes-count" class="headerlink" title="属性计数器(attributes_count)"></a>属性计数器(attributes_count)</h4><p> 属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。attributes表中每一项都是一个attribute_info 结构的数据项。</p><h4 id="属性信息数据区-attributes-attributes-count"><a href="#属性信息数据区-attributes-attributes-count" class="headerlink" title="属性信息数据区(attributes[attributes_count])"></a>属性信息数据区(attributes[attributes_count])</h4><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p> 在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses  、 EnclosingMethod 、 Synthetic  、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>  对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p><p>以上就是类文件结构了，可以概括为以下的一张图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/2020%E5%B9%B43%E6%9C%8811%E6%97%A5142555.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目设计：一个服装定制商城</title>
      <link href="/2020/03/09/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C1/"/>
      <url>/2020/03/09/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<h2 id="服装定制商城"><a href="#服装定制商城" class="headerlink" title="服装定制商城"></a>服装定制商城</h2><p>最近，花七天做了一个商城的项目，是一个服装定制商城，这个商城集合了我自己所学习的大部分技术。我先列一下这个商城用到的技术：</p><ol><li>springmvc</li><li>thymeleaf</li><li>mybatis</li><li>webSecurity</li><li>WebSocket</li><li>rest风格</li><li>redis</li><li>docker</li></ol><p>这个商城的前端是来自一位GitHub的开发者，而后端则是完全由自己完成的，在这个过程中，以我的角度来说，三分之二的时间都在写thymeleaf和Controller。尤其是在写的时候一遍又一遍的体会thymeleaf的各种语法，以及把DAO层的一些数据拿到Controller层进行转发，当然，都进行了REST风格化。而还有三分之一的时间在mybatis和Security身上，对mybatis的各种获取数据和Security的对各个页面的权限，其实最让我满意的就是这一部分了。</p><p>在这个项目过程中，我主要做对了一件事情，就是先进行了对Security的设计，而做错了很多事情，那就是没有先设计好数据库和页面，对页面跳转的各种方法，非常的粗糙，但这也让我领悟到了很关键的一层，一开始有一个对系统架构的完整设计，是多么重要的事情，我们接到一个需求的时候，就先应该设计好数据库表，在去对各种功能的完善。</p><p>做这个项目难吗？我觉得，并不难，也许是我才学浅，大部分的时间都浪费在了CRUD身上，不过，确实很多程序员都是干CRUD的:happy:。</p><p>在一些技术的运用，例如Security，Socket，本人认为并没有什么差错，倒是简单的SpringMVC，运用的有些糟糕，但我也从中吸取到了很多教训，比如前端的很多请求，最好都使用POST表单提交，而少使用一些 直接定位的GET请求，而后端在控制器层最好少使用一些对数据库的采集，最好反复利用Session。</p><p>下面我开始简单的讲述一下，这个服装定制商城。</p><p>这个项目在设计之初，我就想到了要做前台和后台，这样的Security是必不可少的，我首先列出了有哪一些用户，然后将数据库的用户进行了分开的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        UserModel user = userService.getUserName(s);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(user.getUsername() ,user.getPassword(),</span><br><span class="line">                createAuthority(user.getRoles()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是将数据库的角色分割，构造GrantedAuthority</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title">createAuthority</span><span class="params">(String roles)</span> </span>&#123;</span><br><span class="line">        String[] roleArray = roles.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String role : roleArray) &#123;</span><br><span class="line">            authorityList.add(<span class="keyword">new</span> SimpleGrantedAuthority(role));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorityList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基于Security的特性，权限都是：ROLE_USER 这样的类型，然后会 割开“_”，来选择权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>).permitAll()<span class="comment">//允许/、/login的访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>).hasRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/user下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line"><span class="comment">//                .anyRequest().authenticated()//其它所有访问都拦截</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()<span class="comment">//添加登陆</span></span><br><span class="line">                .loginPage(<span class="string">"/login"</span>).permitAll()<span class="comment">//登陆页面“/login"允许访问</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/"</span>)<span class="comment">//成功默认跳转 url</span></span><br><span class="line">                .usernameParameter(<span class="string">"user"</span>)</span><br><span class="line">                .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling().accessDeniedPage(<span class="string">"/error"</span>);</span><br><span class="line"></span><br><span class="line">        http.rememberMe();</span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有着Security的帮助，从某种程度而言，也是一个架构的雏形呢，起码一个CRUD操作，不会越写越乱。</p><p>然后，就是把图片与本地的数据库分离，进一步降低数据库的压力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 华南机房,配置自己空间所在的区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> com.qiniu.storage.<span class="function">Configuration <span class="title">qiniuConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.qiniu.storage.Configuration(Zone.zone2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个七牛上传工具实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UploadManager <span class="title">uploadManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UploadManager(qiniuConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认证信息实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Auth <span class="title">auth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Auth.create(qiniuProperties.getAccessKey(), qiniuProperties.getSecretKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建七牛空间管理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BucketManager <span class="title">bucketManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BucketManager(auth(), qiniuConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Gson <span class="title">gson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以流的形式上传图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回访问路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"upload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(@RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qiniuService.uploadFile(file.getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"delete/&#123;key&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">deleteFile</span><span class="params">(@PathVariable String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qiniuService.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这方面，有着各自的接口是辅助实现。</p><p>然后，是在思考如何生成一个全局唯一的ID，那时候想了很久，最后在网络上找到了，雪花算法。</p><p>并且，算是会熟练的使用MyBatis写SQL语句了吧。下面列一些拙劣的操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 展示产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"showProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from product_table</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--获取单个产品--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from product_table where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--获取图片群--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getimgs"</span> <span class="attr">resultType</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">select * from item_table where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--增加产品--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addProduct"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag"><span class="attr">parameterType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">insert into product_table(product_name, stock,price,version,note,img)</span><br><span class="line">values(#&#123;productName&#125;,#&#123;stock&#125;,#&#123;price&#125;,#&#123;version&#125;,#&#123;note&#125;,#&#123;img&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 减少产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from product_table where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--搜索功能  =--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"searchProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from product_table where product_name LIKE CONCAT('%',#&#123;productname&#125;,'%' )</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，这些操作并没有多么的出彩，甚至可以说是污点。</p><p>当然，我也有很多自以为是的骚操作：</p><p>比如，实现聊天信息的字符串拼接，每当有一句话被写回到后端时，不急于写进数据库，而是将它们给拼进session中，等聊天结束了，再某一个页面，写回数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (session.getAttribute(<span class="string">"msg"</span>)==<span class="keyword">null</span>)&#123;</span><br><span class="line">    session.setAttribute(<span class="string">"msg"</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String text=username+<span class="string">":"</span>+msg+<span class="string">"。"</span>+<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">session.setAttribute(<span class="string">"msg"</span>,session.getAttribute(<span class="string">"msg"</span>)+text);</span><br></pre></td></tr></table></figure><p>当然本人也有自己的职业操守的，比如@PathVariable这个注解，就使用了很多，时刻注意的规范。</p><p>同时，也伴随着一些失败的操作，比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = <span class="string">'/user/design/'</span>+[[$&#123;product.getId()&#125;]];</span><br></pre></td></tr></table></figure><p>过多的使用了直接定位，这使得网页的传参变得不那么安全。</p><p>以及为了急于放行，对数据库表的设计，非常的混乱，这也是必须注意的一个点。虽然它也就做了七天。</p><p>最后，再放一下这个项目的源码吧：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树索引和算法</title>
      <link href="/2020/03/01/mysql4/"/>
      <url>/2020/03/01/mysql4/</url>
      
        <content type="html"><![CDATA[<h2 id="B-树索引和算法"><a href="#B-树索引和算法" class="headerlink" title="B+树索引和算法"></a>B+树索引和算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是在学习编程的过程中，必须越过的坎。很多数据结构理解起来并不会太难，但是要说到会灵活运用，那就有很长一段路需要走。</p><p>而现在要学习的，就是运用在MySQL数据库里面的数据结构——B+树。</p><p>但是在了解B+树之前，先说说它的来源。</p><h4 id="二叉查找法"><a href="#二叉查找法" class="headerlink" title="二叉查找法"></a>二叉查找法</h4><p>我们需要查询这个值的时，最基本的算法就是使用二叉查找法，它能在一个已排序好的数组中，极大的提高查找的效率，这种算法思想被广泛地运用到了生活的各个领域。但是值得注意的是，二叉查找法也仅仅是给众多人提供一个足够好的思路而已，它所衍生出来的各种算法，才是真正被运用的算法。</p><p>二叉查找法非常的简单，这里懒得讲了:sleeping:</p><h4 id="二叉查找树与平衡二叉树"><a href="#二叉查找树与平衡二叉树" class="headerlink" title="二叉查找树与平衡二叉树"></a>二叉查找树与平衡二叉树</h4><p>B+树，就是先通过二叉查找树，再通过平衡二叉树，所衍生出来的。</p><p>二叉搜索树也是一种树，适用与一般二叉树的全部操作，但二叉搜索树能够实现数据的快速查找。</p><p>性质：</p><ul><li>非空左子树的所有键值小于其根节点的键值</li><li>非空右子树的所有键值大于其根节点的键值</li><li>左右子树都是二叉查找树</li></ul><p>可以浅显的理解为，将一个排序好的数组，转为二叉树的形式，去查找。</p><p>但是，你也要想，如果这个树被广泛的使用后，添加了非常多，非常大的数字，那么这个二叉树的中心节点不变的话，岂不是形成了“右重左轻”的二叉树呢？</p><p>于是，便由这个思想，改进成了一个，平衡二叉树。</p><p>平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：</p><ul><li>平衡二叉树要么是一棵空树</li><li>要么保证左右子树的高度之差不大于 1</li><li>子树也必须是一颗平衡二叉树</li></ul><p>也就是说，树的两个左子树的高度差别不会太大，一旦有了新的节点加入，则会通过左旋或者是右旋的方式，去稳定的保持根节点必须为中心节点。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡二叉树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。</p><p><img src="https://box.kancloud.cn/eccb1d67a2b49c28bfdb9eee8e93c685_897x237.png" alt=""></p><p>可以看出，所有记录都在叶节点中，并且是顺序存放的，如果我们从最左边的叶节点开始顺序遍历，可以得到所有键值的顺序排序：5、10、15、20、25、30、50、55、60、65、75、80、85、90。</p><p>一个最形象的比喻是：把它看作为一个刻度尺，我们总是先看到厘米，再由厘米，找到毫米。</p><h5 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h5><p>B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法：</p><p><img src="https://box.kancloud.cn/2122478de5826e7d6581f0a441598087_903x400.png" alt=""></p><p>我们用实例来分析B+树的插入，我们插入28这个键值，发现当前Leaf Page和Index Page都没有满，我们直接插入就可以了。</p><p><img src="https://box.kancloud.cn/03518dfdb10771c4bda7bb4e472ea021_898x220.png" alt=""></p><p>这次我们再插入一条70这个键值，这时原先的Leaf Page已经满了，但是Index Page还没有满，符合表的第二种情况，这时插入Leaf Page后的情况为50、55、60、65、70。我们根据中间的值60拆分叶节点。</p><p><img src="https://box.kancloud.cn/1808b3e428e0aa74fd7e6cd2c976f6e1_836x294.png" alt=""></p><p>因为图片显示的关系，这次我没有能在各叶节点加上双向链表指针。最后我们来插入记录95，这时符合表5-1讨论的第三种情况，即Leaf Page和Index Page都满了，这时需要做两次拆分。</p><p><img src="https://box.kancloud.cn/938eab2179096474f075120bdb81663e_869x393.png" alt=""></p><p>可以看到，不管怎么变化，B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。</p><p>旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上。通常情况下，左兄弟被首先检查用来做旋转操作，这时我们插入键值70，其实B+树并不会急于去拆分叶节点，而是做旋转，50，55，55旋转。</p><p><img src="https://box.kancloud.cn/b193456c7db65d4257612f48a8064e17_901x225.png" alt=""></p><p>可以看到，采用旋转操作使B+树减少了一次页的拆分操作，而这时B+树的高度依然还是2。</p><h5 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h5><p>B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶节点中的记录依然排序，同插入一样，B+树的删除操作同样需要考虑如表5-2所示的三种情况，与插入不同的是，删除根据填充因子的变化来衡量。</p><p><img src="https://box.kancloud.cn/ba29654ad6ef9445a0fc01251198e620_903x246.png" alt=""></p><p>首先，删除键值为70的这条记录，该记录符合表5-2讨论的第一种情况，删除后。</p><p><img src="https://box.kancloud.cn/92e83659ef72c970cb6aed620dc33e56_905x393.png" alt=""></p><p>接着我们删除键值为25的记录，这也是表5-2讨论的第一种情况，但是该值还是Index Page中的值，因此在删除Leaf Page中25的值后，还应将25的右兄弟节点的28更新到Page Index中，最后可得到图。</p><p><img src="https://box.kancloud.cn/aa292aa7671d2859709bc1cae0e6b28f_897x401.png" alt=""></p><p>最后我们来看删除键值为60的情况，删除Leaf Page中键值为60的记录后，填充因子小于50%，这时需要做合并操作，同样，在删除Index Page中相关记录后需要做Index Page的合并操作，最后得到图。</p><p><img src="https://box.kancloud.cn/e65eff5a8a50f72ce99baf4a7b633c2f_795x289.png" alt=""></p><h3 id="InnoDB的B-树索引"><a href="#InnoDB的B-树索引" class="headerlink" title="InnoDB的B+树索引"></a>InnoDB的B+树索引</h3><p>B+树索引其本质就是B+树在数据库中的实现，但是B+索引在数据库中有一个特点就是其高扇出性，因此在数据库中，B+树的高度一般都在2～3层，也就是对于查找某一键值的行记录，最多只需要2到3次IO，这倒不错。因为我们知道现在一般的磁盘每秒至少可以做100次IO，2～3次的IO意味着查询时间只需0.02～0.03秒。</p><p>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助聚集索引（secondary index）辅助聚集索引有时也称非聚集索引（non-clustered index）。</p><p>但是不管是聚集还是非聚集的索引，其内部都是B+树的，即高度平衡的，叶节点存放着所有的数据。聚集索引与非聚集索引不同的是，叶节点存放的是否是一整行的信息。</p><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的叶节点成为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p><p>由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在许多情况下，查询优化器非常倾向于采用聚集索引，因为聚集索引能够让我们在索引的叶节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。</p><p>现在我们来看一张表，我们以人为的方式让其每个页只能存放两个行记录，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL [qiushibaike]&gt; create table t(</span><br><span class="line">    -&gt; a int not null, </span><br><span class="line">    -&gt; b varchar(8000),</span><br><span class="line">    -&gt; c int not null,</span><br><span class="line">    -&gt; primary key (a),</span><br><span class="line">    -&gt; key idx_c(c)</span><br><span class="line">    -&gt; )engine&#x3D;INNODB;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t select 1,repeat(&#39;a&#39;,7000),-1;</span><br><span class="line"></span><br><span class="line">insert into t select 2,repeat(&#39;a&#39;,7000),-2;</span><br><span class="line"></span><br><span class="line">insert into t select 3,repeat(&#39;a&#39;,7000),-3;</span><br><span class="line"></span><br><span class="line">insert into t select 4,repeat(&#39;a&#39;,7000),-4;</span><br></pre></td></tr></table></figure><p>可以看到，我们表的定义和插入方式使得目前每个页只能存放两个行记录，我们用py_innodb_page_info工具来分析表空间，可得：py_innodb_page_info.py-v mytest/t.ibd</p><p>page level为0000的即是数据页。我们要分析的是page level为0001的页，该页是B+树的根，我们来看看索引的根页中存放的数据。</p><p>我们直接通过页尾的Page Directory来分析，从00 63可以知道该页中行开始的位置。接着通过Recorder Header来分析，0xc063开始的值为69 6e 66 69 6d 75 6d 00，就代表infimum伪行记录。之前的5个字节01 00 02 00 1b就是Recorder Header，分析第4位到第8位的值1代表该行记录中只有一个记录（需要记住的是，InnoDB的Page Directory是稀疏的），即infimum记录本身。我们通过Recorder Header中最后的两个字节00 1b来判断下一条记录的位置，即c063+1b=c073，读取键值可得80 01，就是主键为1的键值（我们制定的INT是无符号的，因此二进制是0x8001，而不是0x0001），80 01后值00 00 00 04代表指向数据页的页号。以同样的方式，可以找到80 02和80 04这两个键值以及它们指向的数据页。</p><p>通过以上对于非数据页节点的分析，我们发现数据页上存放的是完整的行记录，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，而不是一个完整的行记录。因此我们构造的这颗二叉树大致如图所示。</p><p><img src="https://box.kancloud.cn/052bf51b4267db01fcee3330315327a4_717x367.png" alt=""></p><p>许多数据库的文档会这样告诉读者：聚集索引按照顺序物理地存储数据。但是试想，如果聚集索引必须按照特定顺序存放物理记录的话，则维护成本即显得非常之高了。所以，聚集索引的存储并不是物理上的连续，相反是逻辑上连续的。这其中有两点：一是我们前面说过的页通过双向链表链接，页按照主键的顺序排列。另一点是每个页中的记录也是通过双向链表进行维护，物理存储上可以同样不按照主键存储。</p><p>聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。叶节点的数据就是我们要查询的数据，如我们要查询一张注册用户的表，查询最后注册的10位用户，由于B+树索引是双向链表的，我们可以快速找到最后一个数据页，并取出10条记录，我们用Explain进行分析，可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from Profile order by id limit 10;</span><br></pre></td></tr></table></figure><p>另一个是范围查询（range query），如果要查找主键某一范围内的数据，通过叶节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可，又如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from Profile where id＞10 and id＜10000;</span><br></pre></td></tr></table></figure><p>Explain得到了MySQL的执行计划（execute plan），并且rows列给出了一个查询结果的预估返回行数。要注意的是，rows代表的是一个预估值，不是确切的值，如果我们实际进行这句SQL的查询，可以看到实际上只有9 946行记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from Profile where id＞10 and id＜10000;</span><br></pre></td></tr></table></figure><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>对于辅助索引（也称非聚集索引），叶级别不包含行的全部数据。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签（bookmark），该书签用来告诉InnoDB存储引擎，哪里可以找到与索引相对应的行数据。因为InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。显示了InnoDB存储引擎中辅助索引与聚集索引的关系。</p><p><img src="https://box.kancloud.cn/df601c6a557b2ed7a53ad0b5936493df_553x578.png" alt=""></p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。举例来说，如果在一颗高度为3的辅助索引树中查找数据，那么需要对这颗辅助索引遍历3次找到指定主键；如果聚集索引树的高度同样为3，那么还需要对聚集索引进行3次查找，才能最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO来访问最终的一个数据页。</p><p>对于其他的一些数据库，如Microsoft SQL Server数据库，其表类型有一种不是索引组织表，称为堆表。在数据的存放按插入顺序方面，与MySQL的MyISAM存储引擎有些类似。堆表的特性决定了堆表上的索引都是非聚集的，但是堆表没有主键。因此这时书签是一个行标识符（row identifier，RID），可以用如“文件号：页号：槽号”的格式来定位实际的行。</p><p>堆表的非聚集索引既然不需要再通过主键对聚集索引进行查找，那不是速度会更快吗？答案是也许，在某些只读的情况下，书签为行标识符方式的非聚集索引可能会比书签为主键方式的非聚集索引快。但是考虑在OLTP（OnLine Transaction Processing，在线事务处理）应用的情况下，表可能还需要发生插入、更新、删除等DML操作。当进行这类操作时，书签为行标识符方式的非聚集索引可能需要不断更新行标识符所指向数据页的位置，这时的开销可能就会大于书签为主键方式的非聚集索引了。</p><p>Microsoft SQL Server数据库DBA问过这样的问题，为什么在SQL Server上还要使用索引组织表？堆表的书签性使得非聚集查找可以比主键书签方式更快，并且非聚集可能在一张表中存在多个，我们需要对多个非聚集索引的查找。而且对于非聚集索引的离散读取，索引组织表上的非聚集索引会比堆表上的聚集索引慢一些。当然，在一些情况下，使用堆表的确会比索引组织表更快，但是我觉得大部分是由于存在于OLAP（On-Line Analytical Processing，在线分析处理）的应用。其次就是前面提到的，表中数据是否需要更新，并且更新会否影响到物理地址的变更。此外另一个不能忽视的是对于排序和范围查找，索引组织表可以通过B+树的中间节点就找到要查找的所有页，然后进行读取，而堆表的特性决定了这对其是不能实现的。最后，非聚集索引的离散读，的确是存在上述情况，但是一般的数据库都通过实现预读（read ahead）技术来避免多次的离散读操作。因此，具体是建堆表还是索引组织表，这取决于你的应用，不存在哪个更优的情况。这和InnoDB存储引擎好还是MyISAM存储引擎好的问题是一样的，具体情况具体分析。</p><p>接下来，我们通过阅读表空间文件来分析InnoDB存储引擎的非聚集索引，我们还是分析上一小节所用的表t。</p><p>不同的是，在表t上再建立一个列c，并对列c创建非聚集索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alter table t add c int not null;</span><br><span class="line"></span><br><span class="line">update t set c&#x3D;0-a;</span><br><span class="line"></span><br><span class="line">alter table t add key idx_c(c); </span><br><span class="line"></span><br><span class="line">show index from t;</span><br><span class="line"></span><br><span class="line">select a,c from t;</span><br></pre></td></tr></table></figure><p>然后用py_innodb_page_info工具来分析表空间，可得：py_innodb_page_info.py-v t.ibd</p><p>对比前一次我们的分析，可以看到这次多了一个页。分析page offset为4的页，该页为非聚集索引所在页，通过工具hexdump分析可得：</p><p>因为只有4行数据，并且列c只有4个字节，因此在一个非聚集索引页中即可完成，整理分析可得下图所示的关系：</p><p><img src="https://box.kancloud.cn/f8cf1eed60ff8ed1c451aa70cef3da1b_692x529.png" alt=""></p><p>显示了表t中辅助索引idx_c和聚集索引的关系。可以看到辅助索引的叶节点中包含了列c的值和主键的值。这里键值因为我特意设为负值，你会发现-1以7f ff ff ff的方式进行内部存储。7（0111）最高位为0，代表负值，实际的值应该取反后，加1，即得-1。</p><h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><p>索引的创建和删除可以通过两种方法，一种是ALTER TABLE，另一种是CREATE/DROP INDEX。ALTER TABLE创建索引的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line"></span><br><span class="line">|ADD&#123;INDEX|KEY&#125;[index_name]</span><br><span class="line"></span><br><span class="line">[index_type] (index_col_name，……) [index_option]……</span><br><span class="line"></span><br><span class="line">ALTER TABLE tbl_name</span><br><span class="line"></span><br><span class="line">DROP PRIMARY KEY</span><br><span class="line"></span><br><span class="line">|DROP &#123;INDEX|KEY&#125; index_name</span><br><span class="line"></span><br><span class="line">CREATE&#x2F;DROP INDEX的语法同样很简单：</span><br><span class="line"></span><br><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line"></span><br><span class="line">[index_type]</span><br><span class="line"></span><br><span class="line">ON tbl_name（index_col_name，……）</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON tbl_name</span><br></pre></td></tr></table></figure><p>索引可以索引整个列的数据，也可以只索引一个列的开头部分数据，如前面我们创建的表t，b列为varchar(8000)，但是我们可以只索引前100个字段，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add key idx_b (b(100));</span><br></pre></td></tr></table></figure><p>目前MySQL数据库存在的一个普遍问题是，所有对于索引的添加或者删除操作，MySQL数据库是先创建一张新的临时表，然后把数据导入临时表，删除原表，再把临时表重名为原来的表名。因此对于一张大表，添加和删除索引需要很长的时间。对于从Microsoft SQL Server或Oracle数据库的DBA来说，MySQL数据库的索引维护始终让他们非常苦恼。</p><p>InnoDB存储引擎从版本InnoDB Plugin开始，支持一种称为快速索引创建方法。当然这种方法只限定于辅助索引，对于主键的创建和删除还是需要重建一张表。对于辅助索引的创建，InnoDB存储引擎会对表加上一个S锁。在创建的过程中，不需要重建表，因此速度极快。但是在创建的过程中，由于上了S锁，因此创建的过程中该表只能进行读操作。删除辅助索引操作就更简单了，只需在InnoDB存储引擎的内部视图更新下，将辅助索引的空间标记为可用，并删除MySQL内部视图上对于该表的索引定义即可。</p><p>查看表中索引的信息可以使用SHOW INDEX语句。如我们来分析表t，之前先加一个联合索引，可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t add key idx_a_b(a,c);</span><br><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/22711aeae934f7f594f2ba9c5b8a8c1a_668x214.png" alt=""></p><p>因为在表t上有3个索引：一个主键索引，c列上的索引，和b列前100个字节构成的索引。</p><p>接着我们来具体讲解每个列的含义：</p><p><strong>Table</strong>：索引所在的表名。<br><strong>Non_unique</strong>：非唯一的索引，可以看到primary key是0，因为必须是唯一的。<br><strong>Key_name</strong>：索引的名称，我们可以通过这个名称来DROP INDEX。<br><strong>Seq_in_index</strong>：索引中该列的位置，如果看联合索引idx_a_b就比较直观了。<br><strong>Column_name</strong>：索引的列<br><strong>Collation</strong>：列以什么方式存储在索引中。可以是’A’或者NULL。B+树索引总是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶来存放索引数据，而不是对数据进行排序。<br><strong>Cardinality</strong>：非常关键的值，表示索引中唯一值的数目的估计值。Cardinality/表的行数应尽可能接近1，如果非常小，那么需要考虑是否还需要建这个索引。<br><strong>Sub_part</strong>：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示我们只索引b列的前100个字符。如果索引整个列，则该字段为NULL。<br><strong>Packed</strong>：关键字如何被压缩。如果没有被压缩，则为NULL。<br><strong>Null</strong>：是否索引的列含有NULL值。可以看到idx_b这里为Yes。因为我们定义的b列允许NULL值。<br><strong>Index_type</strong>：索引的类型。InnoDB存储引擎只支持B+树索引，所以这里显示的都是BTREE。<br><strong>Comment</strong>：注释。<br><strong>Cardinality</strong>值非常关键，优化器会根据这个值来判断是否使用这个索引。但是这个值并不是实时更新的，并非每次索引的更新都会更新该值，因为这样代价太大了。因此这个值是不太准确的，只是一个大概的值。上面显示的结果主键的Cardinality为2，但是很显然我们表中有4条记录，这个值应该是4。如果需要更新索引Cardinality的信息，可以使用ANALYZE TABLE命令。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br><span class="line"></span><br><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>这时的Cardinality的值就对了。不过，在每个系统上可能得到的结果不一样，因为ANALYZE TABLE现在还存在一些问题，可能会影响得到最后的结果。</p><p>另一个问题是MySQL数据库对于Cardinality计数的问题，在运行一段时间后，可能会看到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from Profile;</span><br></pre></td></tr></table></figure><p>Cardinality为NULL，在某些情况下可能会发生索引建立了、但是没有用到，或者explain两条基本一样的语句，但是最终出来的结果不一样。一个使用索引，另外一个使用全表扫描，这时最好的解决办法就是做一次ANALYZE TABLE的操作。因此我建议在一个非高峰时间，对应用程序下的几张核心表做ANALYZE TABLE操作，这能使优化器和索引更好地为你工作。</p><h3 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h3><h4 id="什么是Cardinality值"><a href="#什么是Cardinality值" class="headerlink" title="什么是Cardinality值"></a>什么是Cardinality值</h4><p>不是所有的查询条件出现的列都需要添加索引。对于什么时候添加B+树索引。一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，他们可取值范围很小，称为低选择性。如</p><p>SELECT * FROM student WHERE sex=’M’</p><p>按性别进行查询时，可取值一般只有M、F。因此SQL语句得到的结果可能是该表50%的数据(加入男女比例1:1)这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，属于高选择性。则此时使用B+树的索引是最合适的。例如对于姓名字段，基本上在一个应用中不允许重名的出现</p><p>怎样查看索引是否有高选择性？通过SHOW INDEX结果中的列Cardinality来观察。非常关键，表示所以中不重复记录的预估值，需要注意的是Cardinality是一个预估值，而不是一个准确值基本上用户也不可能得到一个准确的值，在实际应用中，Cardinality/n_row_in_table应尽可能的接近1，如果非常小,那用户需要考虑是否还有必要创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对于字段添加B+树索引是非常有必要的。如</p><p>SELECT * FROM member WHERE usernick=’David’;</p><p>表member大约有500W行数据,usernick字段上有一个唯一索引。这是如果查找用户名为David的用户，将得到如下执行计划:</p><p><img src="https://box.kancloud.cn/9f039a02e8b70586f3ea8e6fee66efc1_783x337.png" alt=""></p><p>可以看到使用了usernick这个索引。这也符合之前提到的高可选择性，即SQL语句取表中较少行的原则。</p><h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>建立索引的前提是高选择性。这对数据库来说才具有实际意义，那么数据库是怎样统计Cardinality的信息呢?因为MySQL数据库中有各种不同的存储引擎，而每种存储引擎对于B+树索引的实现又各不相同。所以对Cardinality统计时放在存储引擎层进行的</p><p>在生成环境中，索引的更新操作可能非常频繁。如果每次索引在发生操作时就对其进行Cardinality统计，那么将会对数据库带来很大的负担。另外需要考虑的是，如果一张表的数据非常大，如一张表有50G的数据，那么统计一次Cardinality信息所需要的时间可能非常长。这样的环境下，是不能接受的。因此，数据库对于Cardinality信息的统计都是通过采样的方法完成</p><p>在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：insert和update。InnoDB存储引擎内部对更新Cardinality信息的策略为:</p><p><strong><em>表中1/16的数据已发生了改变</em></strong></p><p>stat_modified_counter&gt;2000 000 000</p><p>第一种策略为自从上次统计Cardinality信息后，表中的1/16的数据已经发生过变化，这是需要更新Cardinality信息</p><p>第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，这时表中的数据实际并没有增加，实际发生变化的还是这一行数据，则第一种更新策略就无法适用这种情况，故在InnoDB存储引擎内部有一个计数器start_modified_counter,用来表示发生变化的次数,当start_modified_counter&gt;2 000 000 000 时，则同样更新Cardinality信息</p><p>接着考虑InnoDB存储引擎内部是怎样进行Cardinality信息统计和更新操作呢？同样是通过采样的方法。默认的InnoDB存储引擎对8个叶子节点Leaf Page进行采用。采用过程如下</p><p>取得B+树索引中叶子节点的数量，记为A</p><p>随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，即为P1，P2….P8</p><p>通过采样信息给出Cardinality的预估值: Cardinality=(P1+P2+…+P8)*A/8</p><p>根据上述的说明可以发现，在InnoDB存储引擎中，Cardinality值通过对8个叶子节点预估而得的。而不是一个实际精确的值。再者，每次对Cardinality值的统计，都是通过随机取8个叶子节点得到的，这同时有暗示了另外一个Cardinality现象，即每次得到的Cardinality值可能不同的，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM OrderDetails</span><br></pre></td></tr></table></figure><p>上述SQL语句会触发MySQL数据库对于Cardinality值的统计，第一次运行得到的结果如图:</p><p><img src="https://box.kancloud.cn/02290ed6797f9b0bb0cf39ec178f690e_836x121.png" alt=""></p><p>在上述测试过程中，并没有通过INSERT、UPDATE这类的操作来改变OrderDetails中的内容，但是当第二次运行SHOW INDEX FROM OrderDetails语句是，发生了变化，如图:</p><p><img src="https://box.kancloud.cn/3f3035101c02738ac7297c81edf8f474_830x134.png" alt=""></p><p>可以看到，当第二次运行SHOW INDEX FROM OrderDetails语句时，表OrderDetails索引中的Cardinality值发生了变化，虽然表OrderDetails本身并没有发生任何变化，但是由于Cardinality是随机取8个叶子节点进行分析，所以即使表没有发生变化，用户观察到索引Cardinality值还是会发生变化，这本身不是Bug,而是随机采样而导致的结果</p><p>当然，有一种情况可以使得用户每次观察到的索引Cardinality值是一样的。那就是表足够小，表的叶子节点树小于或者等于8个。这时即使随机采样，也总是会采取倒这些页，因此每次得到的Cardinality值是相同的</p><p>在InnoDB1.2版本之前，可以通过innodb_stats_sample_pages用来设置统计Cardinality时每次采样页的数量，默认为8.同时，参数innodb_stats_method用来判断如何对待索引中出现NULL值记录。该参数默认值为nulls_equal,表示将NULL值记录为相等的记录。其有效值还nulls_unequal,nulls_ignored,分别表示将NULL值记录视为不同的记录和忽略NULL值记录。例如某夜中索引记录为NULL、NULL、1、2、2、3、3、3,在参数innodb_stats_method默认设置下，该页的Cardinality为4；若参数innodb_stats_method为nulls_unequal,则该页的Cardinality为5，若参数innodb_stats_method为nulls_ignored，则Cardinality值为3</p><p>当执行ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX 以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎会重新计算索引Cardinality值，若表中的数据量非常大，并且表中存在多个辅助索引时，执行上述操作可能会非常慢，虽然用户可能并不希望去更新Cardinality值</p><p>InnoDB1.2版本提供了更多参数对Cardinality进行设置。如表:</p><p><img src="https://box.kancloud.cn/2911102ff7b234496670844748bd3919_846x451.png" alt=""></p><h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3><p>并不是在所有的查询条件下出现的列都需要添加索引。对于什么时候添加B+树索引，我的经验是访问表中很少一部分行时，使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，即低选择性。<br>对于性别，可取值的范围只有’M’、’F’。对上述SQL语句得到的结果可能是该表50%的数据（我们假设男女比例1：1），这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，即高选择性，则此时使用B+树索引是最适合的，例如姓名字段，基本上在一个应用中都不允许重名的出现。</p><p>因此，当访问高选择性字段并从表中取出很少一部分行时，对这个字段添加B+树索引是非常有必要的。但是如果出现了访问字段是高选择性的，但是取出的行数据占表中大部分的数据时，这时MySQL数据库就不会使用B+树索引了。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引 运用的是多个索引列。 创建方法跟单个索引一样。<br>这么做的好处就是</p><ul><li>第一：是使用了B+树索引</li><li>第二：已经对第二个键值进行排序了</li></ul><p>注意：但是对于单个列查询是不引起联合索引。<br>关联查询的查询语句: select * from 表名 where id = * * * and user=  * * *</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create table buy_log(</span><br><span class="line">userid int unsigned not null,</span><br><span class="line">    buy_date date</span><br><span class="line">)engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into buy_log values(1,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(2,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(3,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-02-01&#39;);</span><br><span class="line">insert into buy_log values(3,&#39;2009-02-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-03-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-04-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-05-01&#39;);</span><br><span class="line"></span><br><span class="line">alter table buy_log add key (userid);</span><br><span class="line">alter table buy_log add key (userid,buy_date);</span><br></pre></td></tr></table></figure><p>只对userid查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from buy_log where userid&#x3D;2</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/d97d0dfb5412d5c8e2087d611cc41812_942x76.png" alt=""></p><p>possible_keys 说明有两个索引可以用 userid,userid_2 但是优化器选择了userid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from buy_log where userid&#x3D;1 order by buy_date limit 3</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/155f7a727cc4a8d887744b92807bd11e_1141x90.png" alt=""></p><p>这里运用到了两个字段 所以优化器会选择userid_2 因为联合索引userid_2 已经排序好 buy_date</p><p>也可以 (a,b,c)当做联合索引但是如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from buy_log where a&#x3D;*** order by c</span><br></pre></td></tr></table></figure><p>这个情况就运行不了联合索引 因为c并不需要排序</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>InnoDB在1.0之后 或者 MySQL 在5.0或者以下的不支持覆盖索引。 就是从辅助索引中查询的记录，而不需要查询聚集索引中的记录。 好处就是辅助索引不包含整个行记录的所有信息，骨气大小远小于聚集索引。因此可以减少大量的IO操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select count(*) from buy_log;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/b238db7600c4433df4cead41a06b9b03_981x89.png" alt=""></p><p>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。</p><p>如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。</p><h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>当执行 explain命令进行sql语句分析时,就会发现优化器并没有选择索引去查找数据,而是通过扫描聚集索引,也就是直接进行全表的扫描来得到的数据。 这种情况多发生与范围查找、JOIN链接操作等情况下。<br>可以通过show index from 表名查询索引:</p><p><img src="https://box.kancloud.cn/8442efc72a4a11803041d60214dab52a_1421x266.png" alt=""></p><p>可以看出该表是有使用(OrderID,ProductID)的联合主键,此外还有OrderID的单个索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where orderid &gt; 10000 and orderid&lt;10200;s</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/52e0c6962730c212f6a3b362514791c4_1377x130.png" alt=""></p><p>选择的是聚集索引而非辅助索引,原因是:OrderID索引不能覆盖到我们要查询的信息。虽然OrderID索引数据是顺序存放，但是再次进行书签查找数据是无序的，因此变为磁盘上离散读操作。如果要求访问的数据量小，则优化器还是会选择辅助索引，但是数据大的时候（一般20%左右），优化器会选择通过聚集索引来查找数据。因为顺序读比离散读快，但是如果是固态硬盘，随机读猜中非常快，同时自信确定使用辅助索引可以带来更好的性能 可以使用关键词 FORCE INDEX 来强制使用摸个索引,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 force index(OrderID) where orderid &gt; 10000 and orderid&lt;10200;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/54698ca8ce531cecebb14dc70e8f2a7e_860x143.png" alt=""></p><h4 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h4><p>MySQL5.6版本开始 支持 Multi-Range Read (MRR)优化。其目的是为了减少磁盘的随机访问，并且将随机访问转化为顺序的数据访问 这对 IO-bound类型的SQL查询语句可带来性能极大的提升。MRR适用于range，ref，eq_ref类型的查询。</p><p>MRR优化有以下几个好处：<br>（1）MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。<br>（2）减少缓冲池中页被替换的次数。<br>（3）批量处理对键值的查询操作。</p><p>对InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作MRR工作方式如下：<br>（1）讲查询得到的辅助索引键值存放在一个缓存中，这时缓存重点数据是根据辅助索引键值排序的。<br>（2）将缓存中的键值根据RowID进行排序。<br>（3）根据RowID的排序顺序来访问实际的数据文件。<br>此外 混吃次不是足够大，不能放下一张表中的所有数据，此时离散读操作会导致缓存中的页被替换出缓冲池，然后又不断读入换冲池。若是安装主键访问，则可以将此重复行为降为最低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where key_part1 &gt;&#x3D;1000 and key_part1 &lt;2000 and key_part2 &#x3D;10000</span><br></pre></td></tr></table></figure><p>表中 ( key_part1,key_part2)的联合索引,因此索引根据key_part1,key_part2的位置关系排序 没有 MRR查询类型为Range,sql优化器会先将key_part1大于1000 且小于2000的数据都取出,即使key_part2不等于10000。取出后进行过滤。这导致无用数据被取出。 如果启用MRR 会使其性能大大的提升。<br>优化器会将查询条件拆分为（1000,10000）（1001,10000），….，（1999,10000），最后进行数据的查询。<br>速度也是相差很大的。<br>启动方法:optimizer_switch 中的标记(flag)来控制。 总是开启MRR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@optimizer_switch &#x3D; &#39;mrr&#x3D;on,mrr_cost_based&#x3D;off&#39;;</span><br></pre></td></tr></table></figure><p>read_rnd_buffer_size 用来控制键值的缓冲区大小,默认为256k;</p><p>查看命令: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@read_rnd_buffer_size\G;</span><br></pre></td></tr></table></figure><h4 id="Index-Condition-Pushdown-ICP-优化"><a href="#Index-Condition-Pushdown-ICP-优化" class="headerlink" title="Index Condition Pushdown( ICP )优化"></a>Index Condition Pushdown( ICP )优化</h4><p>需要在MySQL5.6版本支持这种根据索引进行查询的优化方式.之前的MySQL版本不支持Index Condition Pushdown, 首先是根据索引来查找记录,然后在根据where条件来过滤记录。 在支持Index Condition Pushdown后，MySQL数据库会取出索引的同时，判断是否进行where条件的过滤，也就是将where的部分过滤操作放在存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能。</p><p>Index Condition Pushdown( ICP )优化支持range，ref，eq_ref，ref_or_null类型的查询。当前支持MyISAM和InnoDB存储引擎。</p><p><img src="https://box.kancloud.cn/095a7816002971c6e7bbfb68910c5e4a_889x694.png" alt=""></p><p>Extra表示附加信息，常见的有如下几种（也按查询效率从高到低排列）：<br>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。<br>Using where：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where。如果type列是ALL或index，而没有出现该信息，则你有可能在执行错误的查询：返回所有数据。<br>Using filesort：不是“使用文件索引”的含义！filesort是MySQL所实现的一种排序策略，通常在使用到排序语句ORDER BY的时候，会出现该信息。<br>Using temporary：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</p><p>如果EXPLAIN出现后面两个信息（Using filesort，Using temporary），而rows又比较大，通常意味着你需要调整查询语句，或者需要添加索引，总之需要尽量消除这两个信息。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表 也称为散列表,用一个数组(即直接寻址表)T[0..m-1]表示动态集合,其中每个位置(或称槽或者桶)对应全域U中的一个关键字。图说明了这个方法k指向集合中的一个关键字为K的元素。如果集合中没有关键词k的元素 则T[k]=NULL;</p><p>元素h（k）利用哈希函数h，根据关键字k计算出槽位置。函数h将关键词域U映射到哈希T[0..m-1]的槽位上。但是两个关键词可能映射到同一个槽上。这种情况称为碰撞。链接法解决碰撞问题。</p><p><img src="https://box.kancloud.cn/eb96e30db568d22a2c90d0901e063380_602x339.png" alt=""></p><p>一般使用除法散列法：哈希函数：h（k）=k mod m；</p><p><img src="https://box.kancloud.cn/ca1c30861432f42005053893dd7aabd6_847x230.png" alt=""></p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引只能通过 等值条件查找如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where id_x&#x3D;1;</span><br></pre></td></tr></table></figure><p>通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/c4c3b890efa62b43f167dd97e40c9520_696x380.png" alt=""></p><p>通过参数 innodb_adaptive_hash_index来禁用和启动特性,默认为开启。</p><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>全文检索(full_test search)是将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。它可以根据需要获取全文中有关的章、节、段、句等信息，也可以进行各种统计和分析。<br>InnoDB在1.2.X开始之前支持全文检索，其支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。<br>如：select * from 表名 where title like ‘中午%’; 这个语句是可以通过 B+树索引进行查询<br>如：select * from 表名 where title like ‘%中午%’; 这个就不能用B+树能够更好的工作了</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文检索通常使用倒排索引（inverted index）来实现。倒排索引在辅助表（auxiliary table） 中存储了单词与单词自身在一个或者多个文档中所在位置之间的映射。利用相关数组实现，其拥有两种表现形式：<br>（1） inverted file index，其表现形式为{ 单词,单词所在的文档的ID}<br>（2）full inverted index,其表现形式为{ 单词,( 单词,单词所在的文档的位置)}</p><p><img src="https://box.kancloud.cn/dfcafde3dcbe4af20aed33c451d7a3a5_834x576.png" alt=""></p><p>对 inverted file index 其仅存文档id,而full inverted index存储的是对(pair),即(DocumentId,Position),因此存储的倒排索引如下图：</p><p><img src="https://box.kancloud.cn/d5d661bbb6a71ae614d259a2b7bbac7a_828x257.png" alt=""></p><p>full inverted index存储了单词所在的位置信息,但是同时也暂用了更多的空间,但是能更好的的定位数据。</p><h4 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h4><p>将(DocumentId,Position)视为一个“ilist”。因此全文检索的表中，有一个是word 字，另一个是ilist字段，并且word字段上设有索引。<br>由于Innodb 存储引擎在ilist 字段中存放了Position信息，故可以进行Proximity Search（邻近搜索），而MyISAM存储不支持改特性。</p><p>在InnoDB存储引擎中，为了提高全文检索的并行性能，共有6张Auxiliary Table（辅助表），目前每张表根据word的Latin编码进行分区<br>Auxiliary Table（辅助表）是持久表，存放磁盘上。在全文索引中，还有另一个重要的概念FTS Index Cache（全文索引索引缓存）来听全文检索的性能。<br>FTS Index Cache是一个红黑树结构，其中根据（word，ilist）进行排序。意味着插入的数据已经更新到对应的表，但是全文索引更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table 可能没有更新。 InnoDB存储索引会批量对Auxiliary Table 进行更新，而不是每次插入就更新一次Auxiliary Table。当对全文检索进行查询时，Auxiliary Table首先会对FTS Index Cache 中对应的word 字段合并到Auxiliary Table中在查询. 这种合并提高了InnoDB存储引擎的性能,并且由于红黑树排序后进行批量插入,其产生Auxiliary Table相对较小。</p><p>Innodb运行用户查看置顶倒排索引的Auxiliary Table种的分词信息，可以通过参数设置innodb_ft_aux_table 来观察倒排索引的Auxiliary Table。<br>test 架构下表fts_a的Auxiliary Table;<br>set global innodb_ft_aux_table = ‘test/fts_a’;</p><p>查询test架构下的表fts_a的分词信息select * from information_schema.INNODB_FT_INDEX_TABLE;</p><p>参数innodb_ft_cache_size 控制FTS Index Cache的大小,默认值为32M。当该缓存满时，会将掐中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大参该参数可以提高全文检索的性能，但是在宕机时，未同步到磁盘重点索引信息可能需要更长的时间恢复。</p><p>FTS Document ID 是另一种概念。Innodb存储引擎中，为了支持全文检索，必须有一个列与word进行映射，这个列为FTS_DOS_ID，类型必须是 BIGINT UNSIGNED NOT NULL,并且Innodb引擎会加入名为FTS_DOC_ID_INDEX 的Unique Index. 上述操作是有Innodb引擎自己完成的。 用户也可以自己在建表时自动添加FTS_DOC_ID，已经对应的Unique Index。但是类型必须是 BIGINT UNSIGNED NOT NULL</p><p>文档分词的插入是事务提交时完成的，而对于删除操作，其在事务提交时，不删除磁盘Auxiliary Table重点记录,而只是删除FTS Cache index中的记录,对于Auxiliary Table中被删除的记录,FTS Document ID,并将其保存在DELETED auxiliary table中.在 innodb_ft_aux_table设置之后,可以访问information_schema价格下的表innodb_ft_deleted 中观察删除的FTS Document ID。文档的DML操作并不能删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，用户可以手工将已经删除的记录从索引中彻底删除，改命令是OPTIMIZE TABLE。该命令可以做其他的操作 所以可以通过参数innodb_optimize_</p><p>_onle进行设置。如:<br>set global innodb_optimize_fulltext_onlt=1;<br>optimize tablefts_a;<br>可以通过innodb_ft_num_wird_optimize 进行限制分词数量。默认为2000。</p><p>当InnoDB存储引擎的全文检索还存在以下的限制：</p><ul><li><p>（1）一个表只能有一个全文检索的索引。</p></li><li><p>（2）有多列组成的全文检索的索引列必须使用相同的字符集与排序规则。</p></li><li><p>（3）不支持没有单词界定符（delimiter） 的语言。如中文、日语、韩语等。</p></li></ul><h4 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h4><p>MySQL 5.6.4里才添加了InnoDB引擎的Full-Text索引支持。</p><p>设置全文搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE  &#96;表名&#96; ADD FULLTEXT (</span><br><span class="line">&#96;字段名&#96;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>MySQL数据库之前全文检索(Full-Text Search)的查询，其语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,....) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line"> IN NATURAL LANGUAGE MODE </span><br><span class="line"> | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line"> | IN BOOLEAN MODE</span><br><span class="line"> |WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL 数据库通过MATCH()…AGAINST()语法支持全文检索的查询,MATCH指定了需要被查询的列,AGAINST指定了使用何种方法去进行查询。下面将对各种查询模式进行详细的介绍。</p><h5 id="Natural-Language"><a href="#Natural-Language" class="headerlink" title="Natural Language"></a>Natural Language</h5><p>全文检索沟通过MATCH函数进行查询，默认采用Natural Language模式，其表示查询带有指定word的文档。对于创建的表fts_a，查询body 字段中带有pease的文档，若不使用全文索引技术，则允许使用下述sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fts_a where body like &#39;%Pease%’;</span><br></pre></td></tr></table></figure><p>显然上述sql语句不能使用B+树索引.若采用全文检索技术,可以用下面的sql语句进行查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from fts_a </span><br><span class="line">where match(body)</span><br><span class="line">against (&#39;Pottidge&#39; in natural language mode);</span><br></pre></td></tr></table></figure><p>默认是in natural languagemode 所以可以省略:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cco_images where match(label) against (&#39;Romanesco&#39;);</span><br></pre></td></tr></table></figure><p>查询计划:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from cco_images where match(label) against (&#39;Romanesco&#39;);</span><br></pre></td></tr></table></figure><p>可以看到 type这列显示的是fulltext,即表示使用全文检索技术。同时，若表没有创建倒排索引，则只需match 函数会抛出类错误：Can’t find FULLTEXT index matching the column list 意思是:”找不到与列列表匹配的FULLTEXT索引”。<br>如果使用innodb搜索引擎里的mysql版本低于3.6.4时回报：the used table type doesn’t support fulltest indexes<br>翻译是：“使用的表类型不支持完整索引”</p><p>查询的范围结果是根据相关性（relevance）进行降序排序的，即相关性最高的结果放在第一位。相关性的值是一个非负的浮点数字，0表示没有任何的相关性。根据mysql官方文档可知，相关性计算根据以下四个条件：</p><ul><li>（1）word是否在文档中出现。</li><li>（2）word在文档中出现的次数。</li><li>（3）word在索引列中的数量。</li><li>（4）多少个文档包含该word。</li></ul><p><img src="https://box.kancloud.cn/d7a3190a95553023abeb14fe42e20335_826x267.png" alt=""></p><p>该查询没有经过相关性的排序 所以该查询的速度比常规的 match查询速度要快。</p><p>对于InnoDB存储引擎的全文检索，还需要考虑以下的因素：</p><ul><li>（1）查询的word在stopword列中。忽略该字符串的查询。</li><li>（2）查询的word的字符串长度是否在区间【innodb_ft_min_token_size,innodb_ft_max_token_size】内 InnoDB存储引擎中，参数innodb_ft_min_token_size默认是3，innodb_ft_max_token_size默认是84 如果不在范围内 这会忽略</li></ul><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>MySQL数据库允许使用IN BOOLEAN MODE修饰符来进行全文检索。当使用该修饰符时，查询字符串的前后字符会有特殊的含义，例如下面的语句要求查询有字符串Vitaminhaltig但没有Romanesco的文档，其中+和-分别表示这个单词必须出现，或者一定不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * fromselect * from cco_images where match(label) against (&#39;-Romanesco +Vitaminhaltig &#39; in boolean mode);</span><br></pre></td></tr></table></figure><p>Boolean 全文检索支持一下几种操作符:</p><p>（1）+表示该word必须存在。<br>（2）-表示该word必须被排除<br>（3）（no operator）表示该word是可选的，但是如果出现，其相关性会更高<br>（4）@distance 表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。这种全文检索的查询也称为Proximity Search。 如MATCH(label) AGAINST (‘“Pease pot”@30’ IN BOOLEAN MODE) 表示字符串Peace和pot之间的距离需在30字节以内。<br>（5）&gt;表示出现该单词时增加相关性。<br>（6）&lt;表示出现该单词时降低相关性。<br>（7）~表示允许出现该单词，但是出现是相关性为负（全文检索查询运行负相关性）。<br>（8）* 表示以该单词开头的单词，如lik*，表示可以是lik、like，又或者likes。<br>（9） “ 表示短语。</p><p>如果在against（里面添加上“”这表示该两个单词是一个短语） 如下：</p><p><img src="https://box.kancloud.cn/7987472fb2b45b36230ce3478a5050a1_689x75.png" alt=""></p><h5 id="query-Expansion"><a href="#query-Expansion" class="headerlink" title="query Expansion"></a>query Expansion</h5><p>mysql数据库支持扩展查询。 这种查询在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。<br>通过查询短句中添加with query expansion 或 in natural languange mode with query expansion 可以开启blind query expamsoin（又称 automaticrelevance feedback）。该查询分为两个阶段。</p><ul><li>（1）第一阶段 根据单词进行全文索引查询。</li><li>（2）第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SnowFlake算法生成全局唯一ID</title>
      <link href="/2020/02/26/%E7%AE%97%E6%B3%951/"/>
      <url>/2020/02/26/%E7%AE%97%E6%B3%951/</url>
      
        <content type="html"><![CDATA[<h2 id="SnowFlake算法生成全局唯一ID"><a href="#SnowFlake算法生成全局唯一ID" class="headerlink" title="SnowFlake算法生成全局唯一ID"></a>SnowFlake算法生成全局唯一ID</h2><p>“有这么一种说法，自然界中并不存在两片完全一样的雪花的。每一片雪花都拥有自己漂亮独特的形状、独一无二。”</p><p>有时候在等快递，想着刚买的火锅底料什么时候会到，就用那一长串的订单编号，去查询物流。在这过程中，我会想到(其实也没有)，订单编号是怎么在一个巨大的商城中保持唯一性的？</p><p>在我做一个开始制作一个订单表的时候，思考过订单编号这个问题，如果我每够买一个商品，下完单付款之后，就会在订单表写入商品信息和订单编号，那么这个时候订单的编号必定要全局唯一，想到全局唯一，那么我在前一个订单的订单编号上+1，保持这个订单编号的原子性，那不就好了？</p><p>但是也会诞生一个问题，比如你的订单编号一直都是以1、2、3、4、5、6这样的方式增长的话，那么别人也很容易猜到你当前的订单编号，而且如果把它作为一个奖券编号的话，那就很没逻辑性了。</p><p>所以，我想引入时间戳的方式，拼串，诞生一个全局唯一的ID，不过偶然间看到了Twitter上的雪花算法，便觉得很有意思，于是乎便拿来使用了。</p><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>雪花算法并不复杂，它的本体是一个64bit：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/sonw.jpeg" alt=""></p><h4 id="组成结构："><a href="#组成结构：" class="headerlink" title="组成结构："></a>组成结构：</h4><ul><li>1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</li><li>41位，用来记录时间戳（毫秒）。<ul><li>41位可以表示个数字，</li><li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 ，减1是因为可表示的数值范围是从0开始算的，而不是1。</li><li>也就是说41位可以表示个毫秒的值，转化成单位年则是年</li></ul></li><li>10位，用来记录工作机器id。<ul><li>可以部署在个节点，包括5位datacenterId和5位workerId</li><li>5位（bit）可以表示的最大正整数是，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</li></ul></li><li>12位，序列号，用来记录同毫秒内产生的不同id。<ul><li>12位（bit）可以表示的最大正整数是，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号</li></ul></li></ul><p>SnowFlake可以保证：</p><ul><li>所有生成的id按时间趋势递增</li><li>整个分布式系统内不会产生重复id</li></ul><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>标上了注释，后面会单独挑几个出来仔细说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter_Snowflake</span></span><br><span class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 开始时间截 (2015-01-01) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1420041600000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h4><p>上面大部分代码都是比较易读的，但是有一些涉及到了位运算的代码，单独拿出来说说，这到底是为什么。</p><h5 id="负数的二进制"><a href="#负数的二进制" class="headerlink" title="负数的二进制"></a>负数的二进制</h5><p>在计算机中，负数的二进制是用<code>补码</code>来表示的。</p><p>假设我是用Java中的int类型来存储数字的，int类型的大小是32个二进制位（bit），即4个字节（byte）。（1 byte = 8 bit），那么十进制数字<code>3</code>在二进制中的表示应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span></span><br><span class="line"><span class="comment">// 3的二进制表示，就是原码</span></span><br></pre></td></tr></table></figure><p>那数字-3在二进制中应该如何表示？</p><p>我们可以反过来想想，因为-3+3=0，在二进制运算中把-3的二进制看成未知数x来求解，<br>求解算式的二进制表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span> <span class="comment">//3，原码</span></span><br><span class="line">+  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx <span class="comment">//-3，补码</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line">   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>反推x的值，3的二进制加上什么值才使结果变成：00000000 00000000 00000000 00000000？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span> <span class="comment">//3，原码                         </span></span><br><span class="line">+  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111101</span> <span class="comment">//-3，补码</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line"> <span class="number">1</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>反推的思路是3的二进制数从最低位开始逐位加1，使溢出的1不断向高位溢出，直到溢出到第33位。然后由于int类型最多只能保存32个二进制位，所以最高位的1溢出了，剩下的32位就成了（十进制的）0。</p><p>补码的意义就是可以拿补码和原码（3的二进制）相加，最终加出一个“溢出的0”</p><p>以上是理解的过程，实际中记住公式就很容易算出来：</p><ul><li>补码 = 反码 + 1</li><li>补码 = （原码 - 1）再取反码</li></ul><p>因此-1的二进制应该这样算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> <span class="comment">//原码：1的二进制</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">//取反码：1的二进制的反码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//加1：-1的二进制表示（补码）</span></span><br></pre></td></tr></table></figure><h5 id="用位运算计算n个bit能表示的最大数值"><a href="#用位运算计算n个bit能表示的最大数值" class="headerlink" title="用位运算计算n个bit能表示的最大数值"></a>用位运算计算n个bit能表示的最大数值</h5><p>比如这样一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br></pre></td></tr></table></figure><p>上面代码换成这样看方便一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; <span class="number">5L</span>)</span><br></pre></td></tr></table></figure><p>上面那行代码中，运行顺序是：</p><ul><li>-1 左移 5，得结果a</li><li>-1 异或 a</li></ul><p>long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)的二进制运算过程如下：</p><p><strong>-1 左移 5，得结果a ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//-1的二进制表示（补码）</span></span><br><span class="line"><span class="number">11111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100000</span> <span class="comment">//高位溢出的不要，低位补0</span></span><br><span class="line">      <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100000</span> <span class="comment">//结果a</span></span><br></pre></td></tr></table></figure><p><strong>-1 异或 a ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//-1的二进制表示（补码）</span></span><br><span class="line">    ^   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100000</span> <span class="comment">//两个操作数的位中，相同则为0，不同则为1</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">        <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="comment">//最终结果31</span></span><br></pre></td></tr></table></figure><p>最终结果是31。</p><p>那既然现在知道算出来long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)中的maxWorkerId = 31，有什么含义？为什么要用左移5来算？如果你看过概述部分，请找到这段内容看看：</p><p>5位（bit）可以表示的最大正整数是，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId。</p><p><strong>-1L ^ (-1L &lt;&lt; 5L)结果是31，的结果也是31，所以在代码中，-1L ^ (-1L &lt;&lt; 5L)的写法是利用位运算计算出5位能表示的最大正整数是多少</strong></p><h5 id="用mask防止溢出"><a href="#用mask防止溢出" class="headerlink" title="用mask防止溢出"></a>用mask防止溢出</h5><p>还有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br></pre></td></tr></table></figure><p>分别用不同的值测试一下，你就知道它怎么有趣了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> seqMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; <span class="number">12L</span>); <span class="comment">//计算12位能耐存储的最大正整数，相当于：2^12-1 = 4095</span></span><br><span class="line">        System.out.println(<span class="string">"seqMask: "</span>+seqMask);</span><br><span class="line">        System.out.println(<span class="number">1L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">2L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">3L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4095L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4096L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4097L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4098L</span> &amp; seqMask);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        seqMask: 4095</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">        4095</span></span><br><span class="line"><span class="comment">        0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>这段代码通过位与运算保证计算的结果范围始终是 0-4095 ！</strong></p><p>这代表着它在一毫秒内生成ID的上限值就是4096个，如果超过这个值，则会阻塞至下一个毫秒。</p><h5 id="用位运算汇总结果"><a href="#用位运算汇总结果" class="headerlink" title="用位运算汇总结果"></a>用位运算汇总结果</h5><p>还有另外一段诡异的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">        (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">        (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure><p>为了弄清楚这段代码，首先 需要计算一下相关的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>; <span class="comment">//起始时间戳，用于用当前时间戳减去这个时间戳，算出偏移量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>; <span class="comment">//workerId占用的位数：5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>; <span class="comment">//datacenterId占用的位数：5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);  <span class="comment">// workerId可以使用的最大数值：31</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits); <span class="comment">// datacenterId可以使用的最大数值：31</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;<span class="comment">//序列号占用的位数：12</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdShift = sequenceBits; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits; <span class="comment">// 12+5 = 17</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; <span class="comment">// 12+5+5 = 22</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);<span class="comment">//4095</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>其次 写个测试，把参数都写死，并运行打印信息，方便后面来核对计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//---------------测试---------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = <span class="number">1505914988849L</span>;</span><br><span class="line">    <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">    <span class="keyword">long</span> datacenterId = <span class="number">17L</span>;</span><br><span class="line">    <span class="keyword">long</span> workerId = <span class="number">25L</span>;</span><br><span class="line">    <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"> </span><br><span class="line">    System.out.printf(<span class="string">"\ntimestamp: %d \n"</span>,timestamp);</span><br><span class="line">    System.out.printf(<span class="string">"twepoch: %d \n"</span>,twepoch);</span><br><span class="line">    System.out.printf(<span class="string">"datacenterId: %d \n"</span>,datacenterId);</span><br><span class="line">    System.out.printf(<span class="string">"workerId: %d \n"</span>,workerId);</span><br><span class="line">    System.out.printf(<span class="string">"sequence: %d \n"</span>,sequence);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.printf(<span class="string">"(timestamp - twepoch): %d \n"</span>,(timestamp - twepoch));</span><br><span class="line">    System.out.printf(<span class="string">"((timestamp - twepoch) &lt;&lt; 22L): %d \n"</span>,((timestamp - twepoch) &lt;&lt; <span class="number">22L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"(datacenterId &lt;&lt; 17L): %d \n"</span> ,(datacenterId &lt;&lt; <span class="number">17L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"(workerId &lt;&lt; 12L): %d \n"</span>,(workerId &lt;&lt; <span class="number">12L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"sequence: %d \n"</span>,sequence);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> result = ((timestamp - twepoch) &lt;&lt; <span class="number">22L</span>) |</span><br><span class="line">            (datacenterId &lt;&lt; <span class="number">17L</span>) |</span><br><span class="line">            (workerId &lt;&lt; <span class="number">12L</span>) |</span><br><span class="line">            sequence;</span><br><span class="line">    System.out.println(result);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 打印信息：</span></span><br><span class="line"><span class="comment">    timestamp: 1505914988849 </span></span><br><span class="line"><span class="comment">    twepoch: 1288834974657 </span></span><br><span class="line"><span class="comment">    datacenterId: 17 </span></span><br><span class="line"><span class="comment">    workerId: 25 </span></span><br><span class="line"><span class="comment">    sequence: 0 </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (timestamp - twepoch): 217080014192 </span></span><br><span class="line"><span class="comment">    ((timestamp - twepoch) &lt;&lt; 22L): 910499571845562368 </span></span><br><span class="line"><span class="comment">    (datacenterId &lt;&lt; 17L): 2228224 </span></span><br><span class="line"><span class="comment">    (workerId &lt;&lt; 12L): 102400 </span></span><br><span class="line"><span class="comment">    sequence: 0 </span></span><br><span class="line"><span class="comment">    910499571847892992</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代入位移的值得之后，就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure><p>对于尚未知道的值，我们可以先看看概述 中对SnowFlake结构的解释，再代入在合法范围的值，来了解计算的过程。</p><p>当然，由于我的测试代码已经把这些值写死了，那直接用这些值来手工验证计算结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timestamp = <span class="number">1505914988849L</span>;</span><br><span class="line"><span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"><span class="keyword">long</span> datacenterId = <span class="number">17L</span>;</span><br><span class="line"><span class="keyword">long</span> workerId = <span class="number">25L</span>;</span><br><span class="line"><span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设：timestamp  = <span class="number">1505914988849</span>，twepoch = <span class="number">1288834974657</span></span><br><span class="line"><span class="number">1505914988849</span> - <span class="number">1288834974657</span> = <span class="number">217080014192</span> (timestamp相对于起始时间的毫秒偏移量)，其(a)二进制左移<span class="number">22</span>位计算过程如下：                                </span><br><span class="line"> </span><br><span class="line">                        |&lt;--这里开始左右<span class="number">22</span>位                            ‭</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000</span>|<span class="number">00</span> <span class="number">00110010</span> <span class="number">10001010</span> <span class="number">11111010</span> <span class="number">00100101</span> <span class="number">01110000</span> <span class="comment">// a = 217080014192</span></span><br><span class="line"><span class="number">00001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="comment">// a左移22位后的值(la)</span></span><br><span class="line">                                               |&lt;--这里后面的位补<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设：datacenterId  = <span class="number">17</span>，其（b）二进制左移<span class="number">17</span>位计算过程如下：</span><br><span class="line"> </span><br><span class="line">                   |&lt;--这里开始左移<span class="number">17</span>位    </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0</span>|<span class="number">0000000</span> ‭<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010001</span> <span class="comment">// b = 17</span></span><br><span class="line"><span class="number">0000000</span>‭<span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0010001</span>|<span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="comment">// b左移17位后的值(lb)</span></span><br><span class="line">                                                    |&lt;--这里后面的位补<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设：workerId  = <span class="number">25</span>，其（c）二进制左移<span class="number">12</span>位计算过程如下：</span><br><span class="line"> </span><br><span class="line">             |&lt;--这里开始左移<span class="number">12</span>位    </span><br><span class="line">‭<span class="number">00000000</span> <span class="number">0000</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011001</span>‬ <span class="comment">// c = 25</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> <span class="number">1001</span>|<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">// c左移12位后的值(lc)                                                                 </span></span><br><span class="line">                                                          |&lt;--这里后面的位补<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设：sequence = <span class="number">0</span>，其二进制如下：</span><br><span class="line"> </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000</span>‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">// sequence = 0</span></span><br></pre></td></tr></table></figure><p>现在知道了每个部分左移后的值(la,lb,lc)，代码可以简化成下面这样去理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br><span class="line">-----------------------------</span><br><span class="line">           |</span><br><span class="line">           |简化</span><br><span class="line">          \|/</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="keyword">return</span> (la) |</span><br><span class="line">        (lb) |</span><br><span class="line">        (lc) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure><p>上面的管道符号 <strong>|</strong> 在Java中也是一个位运算符。其含义是：</p><p><strong>x的第n位和y的第n位 只要有一个是1，则结果的第n位也为1，否则为0，因此，我们对四个数的位或运算如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  |                    <span class="number">41</span>                        |  <span class="number">5</span>  |   <span class="number">5</span>  |     <span class="number">12</span>      </span><br><span class="line">    </span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">00000</span>|<span class="number">0</span> <span class="number">0000</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="comment">//la</span></span><br><span class="line">   <span class="number">0</span>|<span class="number">000000</span>‭<span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>|<span class="number">10001</span>|<span class="number">0</span> <span class="number">0000</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="comment">//lb</span></span><br><span class="line">   <span class="number">0</span>|<span class="number">0000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>|<span class="number">00000</span>|<span class="number">1</span> <span class="number">1001</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="comment">//lc</span></span><br><span class="line">or <span class="number">0</span>|<span class="number">0000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>|<span class="number">00000</span>|<span class="number">0</span> <span class="number">0000</span>|‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//sequence</span></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">10001</span>|<span class="number">1</span> <span class="number">1001</span>|‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//结果：910499571847892992</span></span><br></pre></td></tr></table></figure><p>结果计算过程：</p><p>1) 从至左列出1出现的下标（从0开始算）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>  <span class="number">1</span>   <span class="number">1</span>   <span class="number">00</span>  <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>  <span class="number">000</span>  <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span>   <span class="number">000</span> <span class="number">1</span> <span class="number">00</span> <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span>  <span class="number">0</span>   <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0000</span> <span class="number">1</span>   <span class="number">000</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">00</span>  <span class="number">1</span>‭   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">      <span class="number">59</span>  <span class="number">58</span>      <span class="number">55</span>     <span class="number">53</span>      <span class="number">49</span>     <span class="number">47</span>    <span class="number">45</span> <span class="number">44</span> <span class="number">43</span> <span class="number">42</span> <span class="number">41</span>   <span class="number">39</span>      <span class="number">35</span>   <span class="number">32</span>   <span class="number">30</span>     <span class="number">28</span> <span class="number">27</span> <span class="number">26</span>      <span class="number">21</span>       <span class="number">17</span> <span class="number">16</span> <span class="number">15</span>     <span class="number">12</span></span><br></pre></td></tr></table></figure><p>2) 各个下标作为2的幂数来计算，并相加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">2</span>^<span class="number">59</span>&#125;  : <span class="number">576460752303423488</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">58</span>&#125;  : <span class="number">288230376151711744</span>   </span><br><span class="line">    <span class="number">2</span>^<span class="number">55</span>&#125;  :  <span class="number">36028797018963968</span>    </span><br><span class="line">    <span class="number">2</span>^<span class="number">53</span>&#125;  :   <span class="number">9007199254740992</span>     </span><br><span class="line">    <span class="number">2</span>^<span class="number">49</span>&#125;  :    <span class="number">562949953421312</span>      </span><br><span class="line">    <span class="number">2</span>^<span class="number">47</span>&#125;  :    <span class="number">140737488355328</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">45</span>&#125;  :     <span class="number">35184372088832</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">44</span>&#125;  :     <span class="number">17592186044416</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">43</span>&#125;  :      <span class="number">8796093022208</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">42</span>&#125;  :      <span class="number">4398046511104</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">41</span>&#125;  :      <span class="number">2199023255552</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">39</span>&#125;  :       <span class="number">549755813888</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">35</span>&#125;  :        <span class="number">34359738368</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">32</span>&#125;  :         <span class="number">4294967296</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">30</span>&#125;  :         <span class="number">1073741824</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">28</span>&#125;  :          <span class="number">268435456</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">27</span>&#125;  :          <span class="number">134217728</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">26</span>&#125;  :           <span class="number">67108864</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">21</span>&#125;  :            <span class="number">2097152</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">17</span>&#125;  :             <span class="number">131072</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">16</span>&#125;  :              <span class="number">65536</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">15</span>&#125;  :              <span class="number">32768</span></span><br><span class="line">+   <span class="number">2</span>^<span class="number">12</span>&#125;  :               <span class="number">4096</span></span><br><span class="line">---------------------------------------- </span><br><span class="line">             <span class="number">910499571847892992</span></span><br></pre></td></tr></table></figure><p><strong>观察</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  |                    <span class="number">41</span>                        |  <span class="number">5</span>  |   <span class="number">5</span>  |     <span class="number">12</span>      </span><br><span class="line">    </span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|     |      |              <span class="comment">//la</span></span><br><span class="line">   <span class="number">0</span>|                                              |<span class="number">10001</span>|      |              <span class="comment">//lb</span></span><br><span class="line">   <span class="number">0</span>|                                              |     |<span class="number">1</span> <span class="number">1001</span>|              <span class="comment">//lc</span></span><br><span class="line">or <span class="number">0</span>|                                              |     |      |‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//sequence</span></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">10001</span>|<span class="number">1</span> <span class="number">1001</span>|‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//结果：910499571847892992</span></span><br></pre></td></tr></table></figure><p>上面的64位我按1、41、5、5、12的位数截开了，方便观察。</p><ul><li>纵向观察发现:<ul><li>在41位那一段，除了la一行有值，其它行（lb、lc、sequence）都是0，（我爸其它）</li><li>在左起第一个5位那一段，除了lb一行有值，其它行都是0</li><li>在左起第二个5位那一段，除了lc一行有值，其它行都是0</li><li>按照这规律，如果sequence是0以外的其它值，12位那段也会有值的，其它行都是0</li></ul></li><li>横向观察发现:<ul><li>在la行，由于左移了5+5+12位，5、5、12这三段都补0了，所以la行除了41那段外，其它肯定都是0</li><li>同理，lb、lc、sequnece行也以此类推</li><li>正因为左移的操作，使四个不同的值移到了SnowFlake理论上相应的位置，然后四行做 位或 运算（只要有1结果就是1），就把4段的二进制数合并成一个二进制数。</li></ul></li></ul><p>左移运算是为了将数值移动到对应的段(41、5、5，12那段因为本来就在最右，因此不用左移)。</p><p>然后对每个左移后的值(la、lb、lc、sequence)做位或运算，是为了把各个短的数据合并起来，合并成一个二进制数。</p><p>最后转换成10进制，就是最终生成的id</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现SpringBoot上传图片到七牛云</title>
      <link href="/2020/02/22/spring14/"/>
      <url>/2020/02/22/spring14/</url>
      
        <content type="html"><![CDATA[<h2 id="实现SpringBoot上传图片到七牛云"><a href="#实现SpringBoot上传图片到七牛云" class="headerlink" title="实现SpringBoot上传图片到七牛云"></a>实现SpringBoot上传图片到七牛云</h2><p>这是最近在制作项目的时候遇到的一个问题，这个项目是一个商城，我在对图片进行处理的时候，一般是把图片转化为Byte，再存入数据库的。步骤和方法都没错，但是考虑到我在阿里云租借的ECS云服务器硬盘大小只有40G，对之后的图片，可能出现容量不足的情况。</p><p>而且对一个只有2G内存的服务器，大量的对图片进行IO处理，恐怕会使得服务器效率低下，所以，便想到了，在存储图片的时候，直接上传到七牛云，并生成一个随机ID来代表图片的名称，之后读取的之后，只需要在数据库读到到这个ID值，并在页面实现拼串，就能够将图片显示出来了。</p><p>所以我们来实验一下：</p><h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><p>这里我直接选取了官网提供的依赖：</p><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--七牛配置依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 七牛云 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>[7.2.0, 7.2.99]<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>happy-dns-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要进行设置，获取到七牛云的外链和密钥：</p><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qiniu:</span><br><span class="line">  accessKey: xxxxxxxxxxxxxxx</span><br><span class="line">  secretKey: xxxxxxxxxxxxxx</span><br><span class="line">  bucket: imgof</span><br><span class="line">  prefix: www-xxxxxxxxx.com</span><br></pre></td></tr></table></figure><p>虽然我们在写入的时候 它会提示了 cannot configuration。。。，但是不用理他，那是因为这个依赖并不归属于Spring管理。</p><p>但是我们仍然需要将其加入容器中：</p><h4 id="QiniuProperties"><a href="#QiniuProperties" class="headerlink" title="QiniuProperties"></a>QiniuProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"qiniu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiniuProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个加入了以后，上方可能会提示你不能找到classpath，但是也不用管它。</p><p>因为我们使用的是yml，而不是properties，所以这个并不是报错。</p><p>但是配置还没有完，我们仅仅是定义了七牛云的连接属性，还需要对其连接的各个方式进行配置：</p><h4 id="QiniuFileConfig"><a href="#QiniuFileConfig" class="headerlink" title="QiniuFileConfig"></a>QiniuFileConfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(QiniuProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">QiniuFileConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QiniuProperties qiniuProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 华南机房,配置自己空间所在的区域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> com.qiniu.storage.<span class="function">Configuration <span class="title">qiniuConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> com.qiniu.storage.Configuration(Zone.zone2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个七牛上传工具实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UploadManager <span class="title">uploadManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UploadManager(qiniuConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证信息实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Auth <span class="title">auth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Auth.create(qiniuProperties.getAccessKey(), qiniuProperties.getSecretKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建七牛空间管理实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BucketManager <span class="title">bucketManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BucketManager(auth(), qiniuConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gson <span class="title">gson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这段代码并没有特别需要深究的地方，注意定义好自己的机房位置就行了，比如：华东是Z0，华北是Z1。</p><p>以上的基础配置可以通过复制粘贴的方式引入，并没有过多的定制化操作。</p><h3 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h3><p>之后，就是我们把这些服务实现的时候了，首先需要一个接口：</p><h4 id="QiniuService"><a href="#QiniuService" class="headerlink" title="QiniuService"></a>QiniuService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QiniuService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">uploadFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">uploadFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">delete</span><span class="params">(String key)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了上传和删除。</p><p>之后便是服务的实现，也是最重要的内容：</p><h4 id="QiniuServiceImpl"><a href="#QiniuServiceImpl" class="headerlink" title="QiniuServiceImpl"></a>QiniuServiceImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(QiniuProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">QiniuServiceImpl</span> <span class="keyword">implements</span> <span class="title">QiniuService</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QiniuProperties qiniuProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UploadManager uploadManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BucketManager bucketManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义七牛云上传的相关策略</span></span><br><span class="line">    <span class="keyword">private</span> StringMap putPolicy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以文件的形式上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> QiniuException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        Response response = <span class="keyword">this</span>.uploadManager.put(file, <span class="keyword">null</span>, getUploadToken());</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            response = <span class="keyword">this</span>.uploadManager.put(file, <span class="keyword">null</span>, getUploadToken());</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析结果</span></span><br><span class="line">        DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String return_path = qiniuProperties.getPrefix() + <span class="string">"/"</span> + putRet.key;</span><br><span class="line">        log.info(<span class="string">"文件名称=&#123;&#125;"</span>, return_path);</span><br><span class="line">        <span class="keyword">return</span> return_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以流的形式上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> QiniuException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        Response response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析结果</span></span><br><span class="line">        DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String return_path = qiniuProperties.getPrefix() + <span class="string">"/"</span> + putRet.key;</span><br><span class="line">        log.info(<span class="string">"文件名称=&#123;&#125;"</span>, return_path);</span><br><span class="line">        System.out.println(return_path);</span><br><span class="line">        <span class="keyword">return</span> return_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除七牛云上的相关文件</span></span><br><span class="line"><span class="comment">     * incompatible</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> QiniuException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">delete</span><span class="params">(String key)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        Response response = bucketManager.delete(qiniuProperties.getBucket(), key);</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            response = bucketManager.delete(qiniuProperties.getBucket(), key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putPolicy = <span class="keyword">new</span> StringMap();</span><br><span class="line">        putPolicy.put(<span class="string">"returnBody"</span>, <span class="string">"&#123;\"key\":\"$(key)\",\"hash\":\"$(etag)\",\"bucket\":\"$(bucket)\",\"width\":$(imageInfo.width), \"height\":$&#123;imageInfo.height&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">// 自定义文件名字</span></span><br><span class="line"><span class="comment">//        putPolicy.put("saveKey", "qqqqq");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上传凭证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUploadToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.auth.uploadToken(qiniuProperties.getBucket(), <span class="keyword">null</span>, <span class="number">3600</span>, putPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码比较长，我们就挑选出最为重要的一部分来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">    Response response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        retry++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析结果</span></span><br><span class="line">    DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String return_path = qiniuProperties.getPrefix() + <span class="string">"/"</span> + putRet.key;</span><br><span class="line">    log.info(<span class="string">"文件名称=&#123;&#125;"</span>, return_path);</span><br><span class="line">    System.out.println(return_path);</span><br><span class="line">    <span class="keyword">return</span> return_path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这个方法，以流的形式上传。我们会获取到一个文件的流，然后在调用七牛云的API，即uploadManager.put，将其上传到七牛云服务器。</p><p>至于那个retry和while，仅仅是为了防止上传失败的进行的重试而已，如果上传失败超过三次，则取消上传，删除也是如此。</p><p>之后的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>便是返回对图片上传的解析结果，解析结果里面包含了图片的名字，图片的上传的路径等等。</p><p>可能你会问，我将文件以流的形式上传了，但是在这个过程中，我并没有定义文件的名字啊？</p><p>对了，这里有一个误区就是上传的文件名字，就一定等于自己的文件名字，这个其实是错误的，如果你有两个口味相同，版本不同的奥利奥，该怎么办呢？那就拼串一个版本号，但是版本相同，口味不同的呢？难道你要不停的拼串吗？</p><p>那么说起来，上传的文件名字到底是什么呢？</p><p>这里还有一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putPolicy = <span class="keyword">new</span> StringMap();</span><br><span class="line">        putPolicy.put(<span class="string">"returnBody"</span>, <span class="string">"&#123;\"key\":\"$(key)\",\"hash\":\"$(etag)\",\"bucket\":\"$(bucket)\",\"width\":$(imageInfo.width), \"height\":$&#123;imageInfo.height&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">// 自定义文件名字</span></span><br><span class="line"><span class="comment">//        putPolicy.put("saveKey", "？？？");</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现这个afterPropertiesSet是一个重写的方法，而这个方法来自于接口InitializingBean。</p><p><strong>这个方法将在所有的属性被初始化后调用，但是会在init前调用。</strong></p><p>也就是说，在这个类中，通过这个方法来构造Bean容器，而我们的上传的文件，会自动执行初始化，对上传的图片进行定制，可以在定义图片的时候，使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putPolicy.put(<span class="string">"saveKey"</span>, <span class="string">"？？？"</span>);</span><br></pre></td></tr></table></figure><p>去定义图片的名字，而这个？？？可以是一个生成全局唯一ID的生成器。这样保证了图片的连接唯一性，保证不同图片的共存而不会覆盖。</p><p>而之后返回的图片地址，在存入数据就行了。</p><p>那么返回的图片地址怎么处理呢？那就归控制器管理了。</p><h4 id="QiniuController"><a href="#QiniuController" class="headerlink" title="QiniuController"></a>QiniuController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/qiniu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiniuController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QiniuService qiniuService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以流的形式上传图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回访问路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(@RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qiniuService.uploadFile(file.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"delete/&#123;key&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">deleteFile</span><span class="params">(@PathVariable String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qiniuService.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了，可以自制一个页面进行测试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（四）</title>
      <link href="/2020/02/18/spring13/"/>
      <url>/2020/02/18/spring13/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（四）"><a href="#SpringMVC详解（四）" class="headerlink" title="SpringMVC详解（四）"></a>SpringMVC详解（四）</h2><h3 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h3><p>视图是渲染数据模型展示给用户的组件，在SpringMVC中又分为逻辑视图和非逻辑视图。逻辑图是需要视图解析器（ViewResolver）进行进一步定位的。</p><p>现在我们来看看视图是如何设计和使用的。</p><h4 id="视图设计"><a href="#视图设计" class="headerlink" title="视图设计"></a>视图设计</h4><p>视图的类型有很多，比如前面的HTML页面就是最为经典的视图，但是也有很多其他的视图，比如JSON视图，JSP视图，当然不止仅有网络视图，连Excel、PDF也算作为一种视图。</p><p>视图都会现实SpringMVC中的View接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="comment">//响应状态属性</span></span><br><span class="line">    String RESPONSE_STATUS_ATTRIBUTE =View<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()+”.<span class="title">responseStatus</span>”</span>; </span><br><span class="line">    <span class="comment">//路径变盘</span></span><br><span class="line">    String PATH_VARIABLES=View<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()+”.<span class="title">pathVariables</span>”</span>;</span><br><span class="line">    <span class="comment">//选择内容类型</span></span><br><span class="line">    String SELECTED_CONTENT_TYPE=View<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()+”.<span class="title">selectedContentType</span>”</span>;</span><br><span class="line">    <span class="comment">//响应类型</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//渲染方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String,?&gt;model,HttpServletRequest request,HttpServletResponse response)</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>这段代码中有两个方法，其中getContentType方法是获取HTTP响应类型的，它可以返回的类型是文本、JSON数据集或者文件等，而rend巳r方法则是将数据模型渲染到视图的，这是视图的核心方法，所以有必要进一步地讨论它。</p><p>在它的参数中，model是数据模型，实际就是从控制器（或者由处理器自动绑定）返回的数据模型，这样render方法就可以把它渲染出来。</p><p>渲染视图是比较复杂的过程，为了简化视图渲染的开发，在SpringMVC中已经给开发者提供了许多开发好的视图类，所以在大部分的情况下并不需要自己开发自己的视图。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/4.png" alt=""></p><p>如图所示，SpringMVC中己经开发好了各种各样的视图，所以在大部分情况下，只需要定义如何将数据模型渲染到视图中展示给用户即可。</p><p>例如，之前看到的MappingJackson2JsonView视图，因为它不是逻辑视图，所以并不需要使用视图解析器（ViewResolver）去定位视图，它会将数据模型渲染为JSON数据集展示给用户查看；而常用的视图JstlView，则是一个逻辑视图，于是可以在控制器返回一个字符串，使用视图解析器去定位对应的JSP文件，就能够找到对应的JSP文件，将数据模型传递进入，Jst!View就会将数据模型渲染，展示数据给用户。对于PDF和Excel视图等类型的视图，它们只需要接收数据模型，然后通过自定义的渲染即可。为了说明视图的使用方法，下面将介绍如何使用PDF视图——AbstractPdtView。</p><h4 id="视图实例——导出PDF文件"><a href="#视图实例——导出PDF文件" class="headerlink" title="视图实例——导出PDF文件"></a>视图实例——导出PDF文件</h4><p>可以从字面意思上看出，AbstractPdtView是一个抽象类，而且，AbstractPdtView属于非逻辑视图，因此它不需要任何的视图解析器去定位。我们先来看看这个</p><h5 id="AbstractPdtView的源码的抽象方法："><a href="#AbstractPdtView的源码的抽象方法：" class="headerlink" title="AbstractPdtView的源码的抽象方法："></a>AbstractPdtView的源码的抽象方法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过数据模型自定义创建PDF文档女</span></span><br><span class="line"><span class="comment">＠param model数据模型</span></span><br><span class="line"><span class="comment">@param document iText Document代表一个PDF文档</span></span><br><span class="line"><span class="comment">@param writer PdfWriter PDF写入器</span></span><br><span class="line"><span class="comment">＠param request HttpServletRequest请求对象</span></span><br><span class="line"><span class="comment">@param response HttpServletResponse响应对象</span></span><br><span class="line"><span class="comment">@throws Exception异常*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPdfDocument</span><span class="params">(Map&lt;String,Object&gt; model,Document document,PdfWriter writer,HttpServletRequest request,HttpServletResponse response)</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>通过PDF视图的定义，就只需要实现这个抽象方法便可以将数据模型渲染为PDF。而这个方法中的参数，包含数据模型（model）对象、HTTP的请求（request）和响应（response）对象，通过这就可以得到数据模型和上下文环境的参数，此外方法中还有与PDF文档有关的参数（document和writer），通过它们就可以制PDF的格和数据的渲染。</p><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>当然也需要加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        PDF--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xhtmlrenderer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core-renderer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>R8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后便可以开始程序设计了</p><h5 id="定义PDF导出接口"><a href="#定义PDF导出接口" class="headerlink" title="定义PDF导出接口"></a>定义PDF导出接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PdfExportService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">(Map&lt;String, Object&gt; model, Document document,</span></span></span><br><span class="line"><span class="function"><span class="params">                     PdfWriter writer, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                     HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要继承这个接口，就能够自定义导出逻辑了。</p><p>接着是写一个类，让其继承AbstractPdfView的非抽象类。</p><h5 id="PDF导出视图类"><a href="#PDF导出视图类" class="headerlink" title="PDF导出视图类"></a>PDF导出视图类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfView</span> <span class="keyword">extends</span> <span class="title">AbstractPdfView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出服务接口</span></span><br><span class="line">    <span class="keyword">private</span> PdfExportService pdfExportService = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建对象的时候载入导出服务接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfView</span><span class="params">(PdfExportService pdfExportService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pdfExportService = pdfExportService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用接口实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildPdfDocument</span><span class="params">(Map&lt;String, Object&gt; model, Document document,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    PdfWriter writer, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用导出服务接口类</span></span><br><span class="line">        pdfExportService.make(model, document, writer, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，创建PDF对象的时候，便调用这个构造函数，而这个构造函数将调用AbstractPdfView接口的抽象方法，完成内部实现。</p><h5 id="由控制器导出PDF数据"><a href="#由控制器导出PDF数据" class="headerlink" title="由控制器导出PDF数据"></a>由控制器导出PDF数据</h5><p>接下来就是由控制器去导出PDF文件了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出接口</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/export/pdf"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">exportPdf</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查询用户信息列表</span></span><br><span class="line">List&lt;User&gt; userList = userService.findUsers(userName, note);</span><br><span class="line"><span class="comment">// 定义PDF视图</span></span><br><span class="line">View view = <span class="keyword">new</span> PdfView(exportService());</span><br><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="comment">// 设置视图</span></span><br><span class="line">mv.setView(view);</span><br><span class="line"><span class="comment">// 加入数据模型</span></span><br><span class="line">mv.addObject(<span class="string">"userList"</span>, userList);</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出PDF自定义</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> PdfExportService <span class="title">exportService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用Lambda表达式定义自定义导出</span></span><br><span class="line"><span class="keyword">return</span> (model, document, writer, request, response) -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// A4纸张</span></span><br><span class="line">document.setPageSize(PageSize.A4);</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">document.addTitle(<span class="string">"用户信息"</span>);</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">document.add(<span class="keyword">new</span> Chunk(<span class="string">"\n"</span>));</span><br><span class="line"><span class="comment">// 表格，3列</span></span><br><span class="line">PdfPTable table = <span class="keyword">new</span> PdfPTable(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 单元格</span></span><br><span class="line">PdfPCell cell = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 字体，定义为蓝色加粗</span></span><br><span class="line">Font f8 = <span class="keyword">new</span> Font();</span><br><span class="line">f8.setColor(Color.BLUE);</span><br><span class="line">f8.setStyle(Font.BOLD);</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"id"</span>, f8));</span><br><span class="line"><span class="comment">// 居中对齐</span></span><br><span class="line">cell.setHorizontalAlignment(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将单元格加入表格</span></span><br><span class="line">table.addCell(cell);</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"user_name"</span>, f8));</span><br><span class="line"><span class="comment">// 居中对齐</span></span><br><span class="line">cell.setHorizontalAlignment(<span class="number">1</span>);</span><br><span class="line">table.addCell(cell);</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"note"</span>, f8));</span><br><span class="line">cell.setHorizontalAlignment(<span class="number">1</span>);</span><br><span class="line">table.addCell(cell);</span><br><span class="line"><span class="comment">// 获取数据模型中的用户列表</span></span><br><span class="line">List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">"userList"</span>);</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">document.add(<span class="keyword">new</span> Chunk(<span class="string">"\n"</span>));</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(user.getId() + <span class="string">""</span>));</span><br><span class="line">table.addCell(cell);</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(user.getUserName()));</span><br><span class="line">table.addCell(cell);</span><br><span class="line">String note = user.getNote() == <span class="keyword">null</span> ? <span class="string">""</span> : user.getNote();</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(note));</span><br><span class="line">table.addCell(cell);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在文档中加入表格</span></span><br><span class="line">document.add(table);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法先通过查询后台数据得到用户列表，再放入模型和视图（ModelAndView）中，然后设置一个视图（PdfView）。而定义dfView时，使用Lambda表达式实现了导出服务接口，这样就可以很方便地让每一个控制器自定义样式和数据。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>打开浏览器，输入：<a href="http://localhost:8888/user/export/pdf?userName=张三&amp;note=人" target="_blank" rel="noopener">http://localhost:8888/user/export/pdf?userName=张三&amp;note=人</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/8.png" alt=""></p><h5 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h5><p>这其中有个最为常见的坑，那就是PDF不显示中文的现象，上述代码通过加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseFont Chinese = BaseFont.createFont(<span class="string">"C:\\Windows\\Fonts\\simsun.ttc,1"</span>,BaseFont.IDENTITY_H,BaseFont.NOT_EMBEDDED);</span><br><span class="line"><span class="comment">//使得：</span></span><br><span class="line">Font f8 = <span class="keyword">new</span> Font(Chinese);</span><br><span class="line"><span class="comment">//最后在cell和Paragraph构造中加入f8就行了</span></span><br></pre></td></tr></table></figure><p>截取部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Font f8 = <span class="keyword">new</span> Font(Chinese);</span><br><span class="line"><span class="comment">//.............</span></span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"id"</span>, f8));</span><br><span class="line"><span class="comment">//.................</span></span><br><span class="line">List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">"userList"</span>);</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">document.add(<span class="keyword">new</span> Chunk(<span class="string">"\n"</span>));</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(user.getId() + <span class="string">""</span>,f8));</span><br><span class="line"><span class="comment">//...................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>文件上传在web中可以说是必须有的操作了，SpringMVC也对其有着很好的支持。</p><h4 id="SpringMVC对文件上传的支持"><a href="#SpringMVC对文件上传的支持" class="headerlink" title="SpringMVC对文件上传的支持"></a>SpringMVC对文件上传的支持</h4><p>首先，DispatcherServlet会使用适配器模式，将HttpServletRequest接口对象转换为MultipartHttpServletRequest象。MultipartHttpServletRequest接口扩展了HttpServletRequest接口的所有方法，而且定义了一些操作文件的方法，这样通过这些方法就可以实现对上传文件的操作。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/5.png" alt=""></p><p>这里对于文件上传的场景，SpringMVC会将HttpServletRequest对象转化为MultipartHttpServlet­Request对象。</p><p>从MultipartHttpServletRequest接口的定义看，它存在许多的方法用来处理文件，这样SpringMVC中操作文件就十分便捷。只是在使用SpringMVC上传文件时，还需要配置MultipartHttpServletRequest，这个任务是通过MultipartResolver接口实现的。</p><p>对于MultipartResover接口，它又存在两个实现类，这两个实现类分是StandardServletMultipartResolver和CommonsMultipartResolver，可以使用它们中的任意一个来现文件上传。在默认的情况下Spring推荐使用的是StandardServletMultipartResolver，因为它只需要依赖于ServletAPI提供的包，而对于CommonsMultipartResolver，则需要依赖于Apache提供的第三方包来实，这然没有StandardServletMultipartResolver来实在。</p><p>从实用的角度来说，因为Spring3.1之后己经能够支持StandardServletMultipartR巳solver，所以CommonsMultipartResolver已经渐渐被废弃了，因此这里不再对其进行介绍。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/6.png" alt=""></p><h4 id="文件上传的配置"><a href="#文件上传的配置" class="headerlink" title="文件上传的配置"></a>文件上传的配置</h4><p>打开application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servlet:</span></span><br><span class="line">  <span class="attr">multipart:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#是否开启SpringMVC多分布上传功能</span></span><br><span class="line">    <span class="attr">file-size-threshold:</span> <span class="number">0</span> <span class="comment">#将文件写入磁盘阈值，值可以使用后缀“MB”或者是“KB”来表示兆字节大小</span></span><br><span class="line">    <span class="attr">location:</span> <span class="comment">#指定默认上传文件夹，一般不设置</span></span><br><span class="line">    <span class="attr">max-file-size:</span> <span class="string">5MB</span> <span class="comment">#设置单个文件最大值</span></span><br><span class="line">    <span class="attr">max-request-size:</span> <span class="string">100MB</span> <span class="comment">#设置所有文件最大值</span></span><br><span class="line">    <span class="attr">resolve-lazily:</span> <span class="literal">false</span> <span class="comment">#是否延迟多部件文件请求的参数和文件解析</span></span><br></pre></td></tr></table></figure><p>根据这些配置，SpringBoot会自动生成StandardServletMultipartResolv巳r对象这样就能够对上传的文件进行配置。对于文件的上传可以使用ServletAPI提供的Part接口或者SpringMVC提供的MultipartFile接作为参数。</p><h4 id="开发文件上传功能"><a href="#开发文件上传功能" class="headerlink" title="开发文件上传功能"></a>开发文件上传功能</h4><h5 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method&#x3D;&quot;post&quot;</span><br><span class="line">      action&#x3D;&quot;.&#x2F;part&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; value&#x3D;&quot;请选择上传的文件&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>注意，这里的的form表单的类型必须声明为： enctype=”multipart/form-data”。如果没有这个声明，SpringMVC就不能自动对其解析。</p><h5 id="FileController"><a href="#FileController" class="headerlink" title="FileController"></a>FileController</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开文件上传请求页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指向HTML的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用HttpServletRequest作为参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        MultipartHttpServletRequest mreq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 强制转换为MultipartHttpServletRequest接口对象</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartHttpServletRequest) &#123;</span><br><span class="line">            mreq = (MultipartHttpServletRequest) request;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取MultipartFile文件信息</span></span><br><span class="line">        MultipartFile mf = mreq.getFile(<span class="string">"file"</span>);</span><br><span class="line">        <span class="comment">// 获取源文件名称</span></span><br><span class="line">        String fileName = mf.getOriginalFilename();</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            mf.transferTo(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dealResultMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Spring MVC的MultipartFile类作为参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/multipart"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadMultipartFile</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        File dest = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(dest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dealResultMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/part"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadPart</span><span class="params">(Part file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取提交文件名称</span></span><br><span class="line">        String fileName = file.getSubmittedFileName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入文件</span></span><br><span class="line">            file.write(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dealResultMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理上传文件结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">dealResultMap</span><span class="params">(<span class="keyword">boolean</span> success, String msg)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        result.put(<span class="string">"success"</span>, success);</span><br><span class="line">        result.put(<span class="string">"msg"</span>, msg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中uploadPage方法用来映射上传文件的HTML页面，所以只需要请求它便能够打开上传文件的页面。</p><p>uploadRequest方法则将HttpServletRequest对象传递，从之前的分析可知，在调用控制器之前，DispatcherServlet会将其转换为MultipartHttpServletRequest对象，所以方法中使用了强制转换，从而得到MultipartHttpServletRequest对象，然后获取MultipartFile对象，接着使用MultipartFile对象的getOrigina!Filename方法就可以得到上传的文件名，而通过它的transferTo方法，就可以将文件保存到对应的路径中。</p><p>uploadMultipartFile则是直接使用MultipartFile对象获取上传的文件，从而进行操作。uploadPart方法是使用Servlet的API，可以使用其write方法直接写入文件，这种方式更为巧妙。</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/9.png" alt=""></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>虽然我们已经拥有Security来做我们的拦截器了，但是还是很有必要了解一下SpringMVC自带的拦截器。</p><p>在刚提起SpringMVC的时候，就说过DispatcherServlet，请求来到DispatcherServlet，它会根据HandlerMapping的机制找到处理器，这样就会返回一个HandlerExecutionChain对象，这个对象包含处理器和拦截器。这里的拦截器会对处理器进行拦截，这样通过截器就可以增强处理器的功能。</p><h4 id="拦截器的设计"><a href="#拦截器的设计" class="headerlink" title="拦截器的设计"></a>拦截器的设计</h4><p>所有的拦截器都继承了一个接口：HandlerInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理执行前</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理器处理方法后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理器完成方法后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程比较直观，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/7.png" alt=""></p><ol><li>执行preHandle方法，该方法会返回一个布尔值。如果为false，则结束所有流程：如果为true,则执行下一步。</li><li>执行处理器逻辑，它包含控制器的功能。</li><li>执行postHandle方法。</li><li>执行视图解析和视图渲染。</li><li>执行afterCompletion方法。</li></ol><p>因为这个接口是Java8的接口，所以3个方法都被声明为default，并且提供了空实现。当我们需要自己定义方法的时候，只需要实现HandlerInterceptor，覆盖其对应的方法即可。</p><h4 id="开发拦截器"><a href="#开发拦截器" class="headerlink" title="开发拦截器"></a>开发拦截器</h4><h5 id="拦截器实例"><a href="#拦截器实例" class="headerlink" title="拦截器实例"></a>拦截器实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器前方法"</span>);</span><br><span class="line">        <span class="comment">// 返回true，不会拦截后续的处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器后方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器完成方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码实现了Handlerlnterceptor，然后按照自己的需要重写了3具体的拦截器方法。在这些方法中都打印了一些信息，这样就可以定位拦截器方法的执行顺序。</p><p>其中这里的preHandle法返回的是true，也可以将其修改为返回false，再观察其不同。有了这个拦截器，SpringMVC并不会发现它，它还需要进行注册才能够拦截处理器，为此需要在配文件中实现WebMvcConfigurer接口：</p><h5 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMVCConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注册拦截器到Spring MVC机制，然后它会返回一个拦截器注册</span></span><br><span class="line">      InterceptorRegistration ir = registry.addInterceptor(<span class="keyword">new</span> Interceptor1());</span><br><span class="line">      <span class="comment">// 指定拦截匹配模式，限制拦截器拦截请求</span></span><br><span class="line">      ir.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里通过实现WebMvcConfigurer接口，重写其中的addlnterceptors方法，进而加入自定义拦截器一一Interceptor!，然后指定其拦截的模式，所以它只会拦截与正则式“／interceptor/*”匹配的请求。</p><h5 id="控制器和页面"><a href="#控制器和页面" class="headerlink" title="控制器和页面"></a>控制器和页面</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorController</span> </span>&#123;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/start"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行处理器逻辑"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"/welcome"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，现在进行测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里非常简单，不多赘述。</p><h5 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/10.png" alt=""></p><p>这里是后台信息，可以从这里看出，拦截器的运行流程。</p><h4 id="多个拦截器的顺序"><a href="#多个拦截器的顺序" class="headerlink" title="多个拦截器的顺序"></a>多个拦截器的顺序</h4><p>如果我们还有多个拦截器，那么它运行的顺序又是怎么样的呢？首先需要多个拦截器实例，当然和前面是一样的，这里仅仅列出来：</p><h5 id="多个拦截器实例"><a href="#多个拦截器实例" class="headerlink" title="多个拦截器实例"></a>多个拦截器实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulitiInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【"</span> + <span class="keyword">this</span>.getClass().getSimpleName()</span><br><span class="line">            +<span class="string">"】处理器前方法"</span>);</span><br><span class="line">        <span class="comment">// 返回true，不会拦截后续的处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【"</span> + <span class="keyword">this</span>.getClass().getSimpleName()</span><br><span class="line">            +<span class="string">"】处理器后方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【"</span> + <span class="keyword">this</span>.getClass().getSimpleName()</span><br><span class="line">            +<span class="string">"】处理器完成方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......省略同样的三个类</span></span><br></pre></td></tr></table></figure><p>然后，注册拦截器</p><h5 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册拦截器到Spring MVC机制中</span></span><br><span class="line"> InterceptorRegistration ir = registry.addInterceptor(<span class="keyword">new</span></span><br><span class="line">         MulitiInterceptor1());</span><br><span class="line"> <span class="comment">// 指定拦截匹配模式</span></span><br><span class="line"> ir.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line"> <span class="comment">// 注册拦截器到Spring MVC机制中</span></span><br><span class="line"> InterceptorRegistration ir2 = registry.addInterceptor(<span class="keyword">new</span></span><br><span class="line">         MulitiInterceptor2());</span><br><span class="line"> <span class="comment">// 指定拦截匹配模式</span></span><br><span class="line"> ir2.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line"> <span class="comment">// 注册拦截器到Spring MVC机制中</span></span><br><span class="line"> InterceptorRegistration ir3 = registry.addInterceptor(<span class="keyword">new</span></span><br><span class="line">         MulitiInterceptor3());</span><br><span class="line"> <span class="comment">// 指定拦截匹配模式</span></span><br><span class="line"> ir3.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br></pre></td></tr></table></figure><p>这些代码放在WebMVCConfiguration 下面。</p><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><p>同样的，我们直接去查看控制台：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/11.png" alt=""></p><p>我们发现，这个结果是责任链模式的规则，对于处理器前方法采用先注册先执行，而处理器后方法完成方法则是先注册后执行的规则。只是上述仅测试了处理器前（preHandle）方法返回为true的场景，在某些时候还可能返回为false，这个时候又如何呢？为此，可以将Mulitilnterceptor2的preHandle法修改返回为false，然后再进行测试，其日志如下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/12.png" alt=""></p><p>上面的日志可以看出，处理器前（preHandle）方法会执行，但是一旦返回false，则续的拦截器、处理器和l所有拦截器的处理器后（postHandle）方法都不会被执行。完成方法afterCompletion则不一样，它只会执行返回true的拦截器的完成方法，而且顺序是先注册后执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（三）</title>
      <link href="/2020/02/15/spring12/"/>
      <url>/2020/02/15/spring12/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（三）"><a href="#SpringMVC详解（三）" class="headerlink" title="SpringMVC详解（三）"></a>SpringMVC详解（三）</h2><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>前面在处理器逻辑中谈到了参数的转换，转换参数出来之后，紧跟着的往往需要验证参数的合法性，因此SpringMVC也提供了验证参数的机制。</p><p>一方面，它可以支持JSR-303注解验证，在默认的情况下SpringBoot会引入关于HibernateValidator机制来支持JSR-303验证规范；另外一方面，因为业务会比较复杂，所以需要自定义验证规则。</p><p>SpringMVC提供了相关的验证机制：</p><h4 id="JSR-303验证"><a href="#JSR-303验证" class="headerlink" title="JSR-303验证"></a>JSR-303验证</h4><p>JSR-303验证主要是通过注解的方式进行的。这里先定义一个需要验证的POJO，此时需要在其属性中加入相关的注解：</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorPojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line"><span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Future</span>(message = <span class="string">"需要一个将来日期"</span>) <span class="comment">// 只能是将来的日期</span></span><br><span class="line"><span class="comment">// @Past //只能去过去的日期</span></span><br><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>) <span class="comment">// 日期格式化转换</span></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 不能为空</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 不能为空</span></span><br><span class="line"><span class="meta">@DecimalMin</span>(value = <span class="string">"0.1"</span>) <span class="comment">// 最小值0.1元</span></span><br><span class="line"><span class="meta">@DecimalMax</span>(value = <span class="string">"10000.00"</span>) <span class="comment">// 最大值10000元</span></span><br><span class="line"><span class="keyword">private</span> Double doubleValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"最小值为1"</span>) <span class="comment">// 最小值为1</span></span><br><span class="line"><span class="meta">@Max</span>(value = <span class="number">88</span>, message = <span class="string">"最大值为88"</span>) <span class="comment">// 最大值88</span></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 不能为空</span></span><br><span class="line"><span class="keyword">private</span> Integer integer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Range</span>(min = <span class="number">1</span>, max = <span class="number">888</span>, message = <span class="string">"范围为1至888"</span>) <span class="comment">// 限定范围</span></span><br><span class="line"><span class="keyword">private</span> Long range;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邮箱验证</span></span><br><span class="line"><span class="meta">@Email</span>(message = <span class="string">"邮箱格式错误"</span>)</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Size</span>(min = <span class="number">20</span>, max = <span class="number">30</span>, message = <span class="string">"字符串长度要求20到30之间。"</span>)</span><br><span class="line"><span class="keyword">private</span> String size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的属性带着各种各样验证注解，并且代码己经在注释中说明其作用，JSR-303验证就是通过这些注解来执行验证的。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>为此需要一个页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试JSR-303<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载Query文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.0.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 请求验证的POJO</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> pojo = &#123;</span></span><br><span class="line"><span class="actionscript">                id : <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">                date : <span class="string">'2017-08-08'</span>,</span></span><br><span class="line">                doubleValue : 999999.09,</span><br><span class="line">                integer : 100,</span><br><span class="line">                range : 1000,</span><br><span class="line"><span class="actionscript">                email : <span class="string">'email'</span>,</span></span><br><span class="line"><span class="actionscript">                size : <span class="string">'adv1212'</span>,</span></span><br><span class="line"><span class="actionscript">                regexp : <span class="string">'a,b,c,d'</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            $.post(&#123;</span></span><br><span class="line"><span class="actionscript">                url : <span class="string">"./validate"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 此处需要告知传递参数类型为JSON，不能缺少</span></span></span><br><span class="line"><span class="actionscript">                contentType : <span class="string">"application/json"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 将JSON转化为字符串传递</span></span></span><br><span class="line"><span class="javascript">                data : <span class="built_in">JSON</span>.stringify(pojo),</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 成功后的方法</span></span></span><br><span class="line"><span class="actionscript">                success : <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再需要一控制器去响应这个Ajax请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">validPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"pojo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 解析验证参数错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vp —— 需要验证的POJO，使用注解<span class="doctag">@Valid</span> 表示验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> errors  错误信息，它由Spring MVC通过验证POJO后自动填充</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 错误信息Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/validate"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">validate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Valid @RequestBody ValidatorPojo vp, Errors errors)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; errMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取错误列表</span></span><br><span class="line">    List&lt;ObjectError&gt; oes = errors.getAllErrors();</span><br><span class="line">    <span class="keyword">for</span> (ObjectError oe : oes) &#123;</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 字段错误</span></span><br><span class="line">        <span class="keyword">if</span> (oe <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line">            FieldError fe = (FieldError) oe;</span><br><span class="line">            key = fe.getField();<span class="comment">// 获取错误验证字段名</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非字段错误</span></span><br><span class="line">            key = oe.getObjectName();<span class="comment">// 获取验证对象名称</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        msg = oe.getDefaultMessage();</span><br><span class="line">        errMap.put(key, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用＠RequestBody代表着接收一个JSON参数，这样Spring就会获页面通过Ajax提交的JSON请求体，然后＠Valid注解则表示启动验证机，这样Spring就会启用JSR-303验证机制进行验证。它会自动地将最后的验证结果放入Errors对象中，这样就可以从中得到相验证过后的信息。</p><p>在浏览器输入：<a href="http://localhost:8888/my/page" target="_blank" rel="noopener">http://localhost:8888/my/page</a></p><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/5.png" alt=""></p><p>显然这里的验证成功了。但是有时验证规则并不是那么简单，比如一些业务逻辑的验证。例如，假设需要验证购买商品的总价格，那么就应该是：总价格＝单价×数量，这样的逻辑验证就不能通过JSR-303验证了。为此Spring还提供了自己的验证机制，下面来介绍它。</p><h4 id="参数验证机制"><a href="#参数验证机制" class="headerlink" title="参数验证机制"></a>参数验证机制</h4><p>为了能够更加灵活地提供验证机制，Spring还提供自己的验证机制。在参数转换时，可以看到在SpringMVC中，存在WebDataBinder机制进行管理，在默认的情况下Spring会自动地根据上下文通过注册了的转换器转换出控制器所需的参数。在WebDataBinder中除了可以注册转换器外，还允许注册验证器（Validator）。</p><p>在Spring控制器中，它还允许使用注解＠InitBinder，这个注解的作用是允许在进入控制器方法前修改WebDataBinder机制。</p><p>下面在验证机制和日期格式绑定的场景下演示，不过在此之前，需要稍微认识一下SpringMVC的验证机制。</p><h5 id="Validator源码"><a href="#Validator源码" class="headerlink" title="Validator源码"></a>Validator源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Validator</span></span>&#123;</span><br><span class="line">    <span class="comment">/*判定当前验证器是否支持该Class类型的验证</span></span><br><span class="line"><span class="comment">        @param clazzPOJO类型</span></span><br><span class="line"><span class="comment">        @return当前验证都是否支持该POJO验证</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    booleansupports(Class&lt;?&gt;clazz);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果supports返回true，则这个方法执行验证逻辑*@paramtarget被验证POJO对象*@paramerrors错误对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Void <span class="title">validate</span><span class="params">(Object target,Errors errors)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Spring所定义的验证器接口，它定义了两个方法，其中supports方法参数为需要验证的POJO类型，如果该方法返回true，则Spring会使用当前验证器的validation方法去验证POJO。</p><p>而validation方法包含需要的target对象和l错误对象errors，其中target是参数绑定后的POJO，这样便可以通过这个参数对象进行业务逻辑的自定义验证。如果发现错误，则可以保存到errors对象中，然后返回给控制器。</p><p>下面以实例进行说明：</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>自定义用户验证器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该验证器只是支持User类验证</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> clazz.equals(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对象为空</span></span><br><span class="line"><span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 直接在参数处报错，这样就不能进入控制器的方法了</span></span><br><span class="line">errors.rejectValue(<span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"用户不能为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line">User user = (User) target;</span><br><span class="line"><span class="comment">// 用户名非空串</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(user.getUserName())) &#123;</span><br><span class="line"><span class="comment">// 增加错误，可以进入控制器方法</span></span><br><span class="line">errors.rejectValue(<span class="string">"userName"</span>, <span class="keyword">null</span>, <span class="string">"用户名不能为空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个验证器，Spring还不会自动启用它，因为还没有绑定给WebDataBinder机制。在SpringMVC中提供了一个注解＠TnitBinder，它的作用是在执行控制器方法前，处理器会先执行表@lnitBinder标注的方法。</p><p>这时可以将WebDataBinder对象作为参数传递到方法中，通过这层关系得到WebDataBinder对象，这个对象有一个setValidator方法，它可以绑定自定义的验证器，这样就可以在获取参数之后，通过自定义的验证器去验证参数，只是WebDataBinder除了可以绑定验证器外，还可以进行参数的自定义，例如，不使用＠DateTirneFormat获取日期参数。假设还继续使用StringToUserConverter转换器，再来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用控制器前先执行这个方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 绑定验证器</span></span><br><span class="line">binder.setValidator(<span class="keyword">new</span> UserValidator());</span><br><span class="line"><span class="comment">// 定义日期参数格式，参数不再需注解@DateTimeFormat，boolean参数表示是否允许为空</span></span><br><span class="line">binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> *            -- 用户对象用StringToUserConverter转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Errors</span></span><br><span class="line"><span class="comment"> *            --验证器返回的错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> *            -- 因为WebDataBinder已经绑定了格式，所以不再需要注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 各类数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/validator"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">validator</span><span class="params">(@Valid User user, Errors Errors, Date date)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"user"</span>, user);</span><br><span class="line">map.put(<span class="string">"date"</span>, date);</span><br><span class="line"><span class="comment">// 判断是否存在错误</span></span><br><span class="line"><span class="keyword">if</span> (Errors.hasErrors()) &#123;</span><br><span class="line"><span class="comment">// 获取全部错误</span></span><br><span class="line">List&lt;ObjectError&gt; oes = Errors.getAllErrors();</span><br><span class="line"><span class="keyword">for</span> (ObjectError oe : oes) &#123;</span><br><span class="line"><span class="comment">// 判定是否字段错误</span></span><br><span class="line"><span class="keyword">if</span> (oe <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line"><span class="comment">// 字段错误</span></span><br><span class="line">FieldError fe = (FieldError) oe;</span><br><span class="line">map.put(fe.getField(), fe.getDefaultMessage());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对象错误</span></span><br><span class="line">map.put(oe.getObjectName(), oe.getDefaultMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里的initBinder方法因为标注注解＠lnitBinder，因此会在控制器方法前被执行，并且将WebDataBinder对象传递进去，在这个方法里绑定了自定义的验证器UserValidator，而且设置了日期的格式，所以在控制器方法中己经不再需要使用＠DateTimeForrnat去定义日期格式化。</p><p>通过这样的自定义，在使用注解＠Valid标注User参数后，SpringMVC就会去遍历对应的验证器，当遍历到UserValidator时，会去执行它的supports方法。因为该方法会返回true，所以SpringMVC会用这个验证器去验证User类的数据。对于日期类型也指定了对应的格式，这样控制器的Date类型的参数也不需要再使用注解的协作。</p><p>这里还要关注一下控制器方法中的Errors参数。它是SpringMVC通过验证器验证后得到的错误信息，由SpringMVC执行完验证规则后进行传递。这里首先是判断是否存在错误，如果存在错误，则遍历错误，然后将错误信息放入Map中返回，因为方法标注了＠ResponseBody，所以最后会转化为ISON响应请求。</p><p>下面输<a href="http://localhost:8888/user/validator?user=1--note_1&amp;date=2018-01-01。" target="_blank" rel="noopener">http://localhost:8888/user/validator?user=1--note_1&amp;date=2018-01-01。</a></p><p>请注意，这里的userNam巳已经传递为空，所以在进行用户验证时会存在错误信息的显示这个请求的结果截图如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/6.png" alt=""></p><p>可以看到，用户名的验证己经成功，也就是说验证器己经起到作用，而且日期也是成功的，它返回了一个日期的Long型整数（时间参数与1970-01-0100:00:00之间的毫秒数）。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>上面只是谈到了参数的获取和转换，通过这些处理器终于可以调用控制器了。在SpringMVC流程中，控制器是业务逻辑核心内容，而控制器的核心内容之一就是对数据的处理。</p><p>可以得知的是：允许控制器自定义模型和视图（ModelAndView），其中模型是存放数据的地方，视图则是展示给用户。</p><p>这里暂时把视图放下，先来讨论数据模型的问题。数据模型的作用是绑定数据，为后面的视图渲染做准备。首先对SpringMVC使用的模型接口和类设计进行探讨，如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/3.png" alt=""></p><p>从图可以看到，在类ModelAndView中存在一个Mode!Map类型的属性，ModelMap继承了LinkedHashmap类，所以它具备Map接口的一切特性，除此之外它还可以增加数据属性。</p><p>在SpringMVC的应用中，如果在控制器方法的参数中使用ModelAndView、Model或者Mode!Map作为参数类型，SpringMVC会自动创建数据模型对象：</p><h4 id="使用数据模型"><a href="#使用数据模型" class="headerlink" title="使用数据模型"></a>使用数据模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/data"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataModelController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入用户服务类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试Model接口</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/model"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">useModel</span><span class="params">(Long id, Model model)</span> </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// 这里返回字符串，在Spring MVC中，会自动创建ModelAndView且绑定名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试modelMap类</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/modelMap"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">useModelMap</span><span class="params">(Long id, ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 设置视图名称</span></span><br><span class="line">        mv.setViewName(<span class="string">"user"</span>);</span><br><span class="line">        <span class="comment">// 设置数据模型，此处modelMap并没有和mv绑定，这步系统会自动处理</span></span><br><span class="line">        modelMap.put(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试ModelAndView</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/mav"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">useModelAndView</span><span class="params">(Long id, ModelAndView mv)</span> </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 设置数据模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// 设置视图名称</span></span><br><span class="line">        mv.setViewName(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中可以看出SpringMVC还是比较智能的。例如，useModel方法里，只是返回一个字符串，SpringMVC会自动生成对应的视图，并且绑定数据模型。又如，useModelMap方法，返回了ModelAndView对象，但是它没有绑定ModelMap对象，SpringMVC又会自动地绑定它。</p><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><p>首先需要一个视图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.note&#125;"</span>&gt;</span>note<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/7.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（二）</title>
      <link href="/2020/02/14/spring11/"/>
      <url>/2020/02/14/spring11/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（二）"><a href="#SpringMVC详解（二）" class="headerlink" title="SpringMVC详解（二）"></a>SpringMVC详解（二）</h2><p>SpringMVC开发中，控制器的开发是最为重要的一步，而开发控制器的第一步就是让控制器的方法能够与请求的URL对应起来，这就是注＠RequestMappi吨的功能，所以我们从这个注解开始讨论。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="处理器映射"><a href="#处理器映射" class="headerlink" title="处理器映射"></a>处理器映射</h4><p>正如前面所提及的，如果Web工程使用SpringMVC，那么它在启动阶段就会将注解@RequestMapping所配置的内容保存到处理器映射（HandlerMapping）机制中去，后等待请求的到来，通过拦截请求信息与HandlerMapping进行匹配，找到对应的处理器（它包含控制器的逻辑），并将处理器及其拦截器保到HandlerExecutionChain对象中，返回给DispatcherServlet，这样DispatcherServlet就可以运行它们了。</p><p>从论述中可以看到，HandlerMapping的主要任务是将请求定位到具体的处理器上。关于＠RequestMapping的配置项并不多，这里通过源码来学习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementTypeMETHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping&#123;</span><br><span class="line">    /／配置请求映射名称</span><br><span class="line">       <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span></span><br><span class="line"><span class="function">    ／／通过路径映射@<span class="title">AliasFor</span><span class="params">(”path<span class="string">")</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] value()default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">     ／／通过路径映射回path配置项目</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">     @AliasFor（”value”）</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] path() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">     ／／限定只响应HTTP请求类型，如GET,POST、HEAD、OPTIONS、PUT、TRACE等</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      ／／默认的情况下，可以响应所有的请求类型</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      RequestMethod[] method() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      ／／当存在对应的HTTP参数时才响应请求</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] params() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       ／／限定请求头存在对应的参数时才响应</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] headers() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        ／／限定HTTP请求体提交类型，如”applicat工on／〕son”、Htext/html”</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] consumes() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        ／／限定返回的内容类型，仅当HTTPi苛求头中的（Accept）类型中包含该指定类型时才返回</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">         String[] produces() default&#123;&#125;;</span></span></span></span><br></pre></td></tr></table></figure><p>这里可以通过配置项value或者path来设置请求URL。从而让对应的请求映射到控制器或其方法上，在此基础上还可以通过其他配置项来缩小请求映射的范围。</p><p>当然，配置项value和path也可以通过正则式来让方法匹配多个请求。</p><p>但是从现实的角度来说，如果不是有必要，尽量不要这么做。因为这样请求的匹配规则就复杂了，会对后续开发造成一定的困扰。</p><p>因此在能够明确场景下，都建议一个路径对应一个方法或者让正则式的匹配规则简单明了，这样就能够提高程序的可读性，以利于后续的维护和改造。</p><p>路径是必需的配置项，这里的method配置项可以限定HTTP的请求类型，这是最常用的配置项，可以区分HTTP的GET或者POST等不同的请求。</p><p>只是在Spring4.3的版本之后，为了简化method配置项的配置新增了几个注解，如＠GetMapping、＠PostMapping、＠PatchMapping、＠PutMapping和@DeleteMapping。</p><h4 id="获取控制器参数"><a href="#获取控制器参数" class="headerlink" title="获取控制器参数"></a>获取控制器参数</h4><p>处理器是对控制器的包装，在处理器运行的过程中会调度控制器的方法，只是它在进入控制器方法之前会对HTTP的参数和上下文进行解析，将它们转换为控制器所需的参数。这一步是处理器首先需要做的事情，只是在大部分的情况下不需要自己去开发这一步，因为SpringMVC已经提供了大量的转换规则，通过这些规则就能非常简易地获取大部分的参数。正如之前章节一样，在大部分情况下，我们并没有太在意如何获取参数，那是因为之前的场景都比较简单，在实际的开发中可能遇到一些复杂的场景，这样参数的获取就会变得复杂起来。例如，可能前端传递一个格式化的日期参数，又如需要传递复杂的对象给控制器，这个时候就需要对SpringMVC参数的获取做进一步的学习了。</p><h5 id="在无注解下获取参数"><a href="#在无注解下获取参数" class="headerlink" title="在无注解下获取参数"></a>在无注解下获取参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/my"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在无注解下获取参数，要求参数名称和HTTP请求参数名称一致.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intVal</span></span><br><span class="line"><span class="comment">     *            -- 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> longVal</span></span><br><span class="line"><span class="comment">     *            -- 长整形</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     *            --字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应JSON参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// HTTP GET请求</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/no/annotation"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">noAnnotation</span><span class="params">(Integer intVal, Long longVal, String str)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        paramsMap.put(<span class="string">"intVal"</span>, intVal);</span><br><span class="line">        paramsMap.put(<span class="string">"longVal"</span>, longVal);</span><br><span class="line">        paramsMap.put(<span class="string">"str"</span>, str);</span><br><span class="line">        <span class="keyword">return</span> paramsMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开浏览器，输入：<a href="http://localhost:8888/my/no/annotation?intVal=10&amp;longVal=200进行测试。" target="_blank" rel="noopener">http://localhost:8888/my/no/annotation?intVal=10&amp;longVal=200进行测试。</a></p><p>这里的表达很明确，就接收参数是什么，那填写的信息就必须是什么，这样的做法，在如今前后端分离的情况下非常不具有优势，很可能前后和后端需要的参数不同，所以，我们一般会使用注解的方式，来表达我们的值。</p><h5 id="在注解的情况下获取参数"><a href="#在注解的情况下获取参数" class="headerlink" title="在注解的情况下获取参数"></a>在注解的情况下获取参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/my"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过注解<span class="doctag">@RequestParam</span>获取参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intVal</span></span><br><span class="line"><span class="comment">     *            -- 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> longVal</span></span><br><span class="line"><span class="comment">     *            -- 长整形</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     *            --字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应JSON数据集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/annotation"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">requestParam</span><span class="params">(@RequestParam(<span class="string">"int_val"</span>)</span> Integer intVal,</span></span><br><span class="line"><span class="function">                                            @<span class="title">RequestParam</span><span class="params">(<span class="string">"long_val"</span>)</span> Long longVal, @<span class="title">RequestParam</span><span class="params">(<span class="string">"str_val"</span>)</span> String strVal) </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        paramsMap.put(<span class="string">"intVal"</span>, intVal);</span><br><span class="line">        paramsMap.put(<span class="string">"longVal"</span>, longVal);</span><br><span class="line">        paramsMap.put(<span class="string">"strVal"</span>, strVal);</span><br><span class="line">        <span class="keyword">return</span> paramsMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中可以看到，在方法参数处使用了注解＠RequestParam，目的是指定HTTP参数和方法参数的映射关系，这样处理器就会按照其配的映射关系来得到参数，然后调用控制器的方法。</p><p>启动SpringBoot应用后，在浏览器地址栏输入<a href="http://localhost:8888/my/annotation?intval=l&amp;longva1=2&amp;strval=str，就能够看到请求的结果了。" target="_blank" rel="noopener">http://localhost:8888/my/annotation?intval=l&amp;longva1=2&amp;strval=str，就能够看到请求的结果了。</a></p><p>但如果把个HTTP参数中的任意一个删去，就会得到异常信息，因为在默认的情况下＠RequestPara标注的参数是不能为空的，为了让它能够为空，可以配置其属性required为false。</p><h4 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h4><p>除了传递一些简单的值之外，还能够传递数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/requestArray"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">requestArray</span><span class="params">(<span class="keyword">int</span>[] intArr, Long[] longArr, String[] strArr)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    paramsMap.put(<span class="string">"intArr"</span>, intArr);</span><br><span class="line">    paramsMap.put(<span class="string">"longArr"</span>, longArr);</span><br><span class="line">    paramsMap.put(<span class="string">"strArr"</span>, strArr);</span><br><span class="line">    <span class="keyword">return</span> paramsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面上得到的数值的值，是通过逗号隔开的。</p><h4 id="传递JSON"><a href="#传递JSON" class="headerlink" title="传递JSON"></a>传递JSON</h4><p>JSON已经成为当今我的数据规范了，所以，我们来展示一下如何表达：前后端互相传递JSON的情况。</p><h5 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h5><p>首先需要建立一个表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载Query文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.0.js"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> userName = $(<span class="string">"#userName"</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> note = $(<span class="string">"#note"</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> ($.trim(userName)==<span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    alert(<span class="string">"用户名不能为空！"</span>);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> params = &#123;</span></span><br><span class="line">                    userName : userName,</span><br><span class="line">                    note : note</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                $.post(&#123;</span></span><br><span class="line"><span class="actionscript">                    url : <span class="string">"./insert"</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 此处需要告知传递参数类型为JSON，不能缺少</span></span></span><br><span class="line"><span class="actionscript">                    contentType : <span class="string">"application/json"</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 将JSON转化为字符串传递</span></span></span><br><span class="line"><span class="javascript">                    data : <span class="built_in">JSON</span>.stringify(params),</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 成功后的方法</span></span></span><br><span class="line"><span class="actionscript">                    success : <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="keyword">if</span> (result == <span class="literal">null</span> || result.id == <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                            alert(<span class="string">"插入失败"</span>);</span></span><br><span class="line"><span class="actionscript">                            <span class="keyword">return</span>;</span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="actionscript">                        alert(<span class="string">"插入成功"</span>);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin: 20px 0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"insertForm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userName"</span> <span class="attr">name</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"note"</span> <span class="attr">name</span>=<span class="string">"note"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里定义了一个简易的表单，它使用了jQuery进行Ajax提交。</p><p>注意它的JS代码，它指定了提交的请求地址Curl）、数据（data）、提交类型（contentType）和事后事件（success）。</p><p>从代码来看，这里先组织了一个JSON数据集，而且把提交类型也设置为了JSON类，然后才提交到控制器。</p><p>这样控制器就可以得到一个JSON数据集的请求体了为了打开这个表单，需要在UserController中编写一个add方法，它将返回一个字符串，映射到这个表单上，这样就能通过视图解析器（ViewResolver）找到它了。</p><p>然后再写一个相应新增用户的请求insert方法，它将从HTTP请求体中读出这个JSON。</p><h5 id="add和insert方法"><a href="#add和insert方法" class="headerlink" title="add和insert方法"></a>add和insert方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注入用户服务类</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开请求页面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字符串，指向页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> *            通过<span class="doctag">@RequestBody</span>注解得到JSON参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 回填id后的用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">insert</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">userService.insertUser(user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过请求add方法，就能请求到对应的HTML表单。接着录入表单，点击提交按钮，这样通过JavaScript脚本提交JSON消息，就可以请求到控制器的insert方法。</p><p>这个方法的参数标注为@RequestBody，意味着它将接收前提交的JSON请求体，而在JSON请求体与User类之间的属性名称是保持一致的，这样SpringMVC就会通过这层映射关系将JSON请求体转换为User对象。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/1.png" alt=""></p><h4 id="通过URL传递参数"><a href="#通过URL传递参数" class="headerlink" title="通过URL传递参数"></a>通过URL传递参数</h4><p>当然讲到传递参数，之前也提到了以REST风格的方式去传递参数，那么我们在这里就列出来先吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// &#123;...&#125;代表占位符，还可以配置参数名称</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="comment">// 响应为JSON数据集</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// @PathVariable通过名称获取参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在浏览器中直接输入 user/1 浏览器就会自动将这个 “1” 识别为id的值。</p><h4 id="获取格式化参数"><a href="#获取格式化参数" class="headerlink" title="获取格式化参数"></a>获取格式化参数</h4><p>一些应用中，往往需要格式化数据，其中最为典型的当属日期和货币。例如，在一些系统中日期格式约定为yyyy-MM-dd，金额约定为货币符号和用逗号分隔，如100万美元写作$1,000,000.00等。</p><p>同样地，SpringMVC也对此提供了良好的支持。对日期和数字类型的转换注解进行处理，分别是＠DateTimeFormat和＠NumberFormato其中@DateTimeFormat是针对日期进行格式化的，＠NumberFormat则是针对数字进行格式化的。</p><h5 id="测试日期表单"><a href="#测试日期表单" class="headerlink" title="测试日期表单"></a>测试日期表单</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>格式化<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"./commit"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>日期（yyyy-MM-dd）<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">value</span>=<span class="string">"2017-08-08"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>金额（#,###.##）<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"1,234,567.89"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单中有两个文本框，一个日期，一个金额。</p><h5 id="控制器打开页面和提交"><a href="#控制器打开页面和提交" class="headerlink" title="控制器打开页面和提交"></a>控制器打开页面和提交</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射HTML页面</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"formatter"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取提交参数</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/commit"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">format</span><span class="params">(Date date,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  @NumberFormat(pattern = <span class="string">"#,###.##"</span>)</span> Double number) </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    dataMap.put(<span class="string">"date"</span>, date);</span><br><span class="line">    dataMap.put(<span class="string">"number"</span>, number);</span><br><span class="line">    <span class="keyword">return</span> dataMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的showFormat方法，是将请求映射到HTML表单上。format方法的代码使用了注解@DateTimeFormat和＠NumberFormat，它们配置了格式化所约定的格式，所以Spring会根据约定的格式把数据转换出来，这样就可以完成参数的转换。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/2.png" alt=""></p><p>启动SpringBoot后，请求<a href="http://localhost:8080/my/form，就可以看到图所示的表单。" target="_blank" rel="noopener">http://localhost:8080/my/form，就可以看到图所示的表单。</a></p><p>提交表单后，就可以看到对应的JSON数据集输出，这样就可以获取那些格式化的参数了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/3.png" alt=""></p><p>在SpringBoot中，日期参数的格式化也可以不使用＠DateTimeFormat，而只在配置文件application.properties中加入如下配置项即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.date-format</span>=<span class="string">yyyy-MM-dd</span></span><br></pre></td></tr></table></figure><h3 id="自定义参数转换规则"><a href="#自定义参数转换规则" class="headerlink" title="自定义参数转换规则"></a>自定义参数转换规则</h3><p>根据上面所表述的内容，我们很容易就能够得出一个规律，传递参数的方法，很多时候仅仅只需要更换不同的注解，就能够实现相应的需求。</p><p>那么这些注解是怎么运作的呢？或者说，SpringMVC所实现的参数转换规则，是怎么样的呢？</p><p>HTTP的请求包含请求头（Header）、请求体CBody）、URL和参数等内容，服务器还包含其上下文环境和客户端交互会话（Session）机制，而这里的消息转换是指请求体的转换。下面我们讨论SpringMVC是如何从这些HTTP请求中获取参数的。</p><h4 id="处理器获取参数逻辑"><a href="#处理器获取参数逻辑" class="headerlink" title="处理器获取参数逻辑"></a>处理器获取参数逻辑</h4><p>一个请求来到时，在处理器执行的过程中，它首先会从HTTP请求和上下文环境来得到参数。如果是简易的参数它会以简单的转换器进行转换，而这些简单的转换器是SpringMVC自身己经提供了的。</p><p>但是如果是转换HTTP请求体（Body），它就会调用HttpMessageConverter接口的方法对请求体的信息进行转换，首先它会先判断能否对请求体进行转换，如果可以就会将其转换为Java类型。以下是对HttpMessageConverter接口的探讨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    ／／是否可读，其中clazz为Java型，ediaType为HTTP请求类型</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class＜?＞ clazz,MediaType mediaType)</span></span>;</span><br><span class="line">    ／／判断clazz类型是否能够转换为mediaT_rpe媒体类型</span><br><span class="line">        ／／其中clazzjava类型，mediaType为HTTP响应类型</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz,MediaType mediaType)</span></span>;</span><br><span class="line">    ／／可支持的媒体类型列表</span><br><span class="line">        <span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line">    ／／当canRead验证通过后，读入HTTP求信息</span><br><span class="line">        <span class="function">T <span class="title">read</span><span class="params">(Class&lt;?extendsT&gt; clazz,HttpinputMessage inputMessage)</span> <span class="keyword">throws</span> IOException,HttpMessage NotReadableException</span>;</span><br><span class="line">    ／／当canWrite方法验证通过后，写入响应</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(Tt,MediaType contentType,HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException,HttpMessage NotWritableException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中控制器方法的参数标注了＠RequestBody，所以处理器会采用请求体（Body）的内容进行参数转换。</p><p>而前端的请求体为JSON类型，所以首先它会调用canRead方法来确定请求体是否可读。</p><p>如果判定可读后，接着就是使用read方法，将前端提交的用户JSON类型的请求体转换为控制器的用户（User）类参数，这样控制器就能够得到参数了。</p><p>上面的HttpMessageConverter接口只是将HTTP的请求体转换为对应的Java对象，而对于HTTP参数和其他内容，还没有进行讨论。</p><p>例如，以性别参数来说前端可能传递给控制器的是一个整数，而控制器参数却是一个枚举，这样就需要提供自定义的参数转换规则。</p><p>为了讨论自定义的参数规则，很有必要先了解处理器转换参数的过程。在SpringMVC中，是通过WebDataBinder机制来获取参数的，它的主要作用是解析HTTP请求的上下文，然后在控制器的调用之前转换参数并且提供验证的功能，为调用控制器方法做准备。</p><p>处理器会从HTTP请求中读取数据，然后通过三种接口来进行各类参数转换，这种接口是Converter、Formatter和GenericConverter。</p><p>在SpringMVC的机制中这三种接口的实现类都采用了注册机的机制，默认的情况下SpringMVC己经在注册机内注册了许多的转换器，这样就可以实现大部分的数据类型的转换，所以在大部分的情况下无须开发者再提供转换器，</p><p>同样地，需要自定义转换规则时，需要在注册机上注册自己的转换器就可以了。</p><p>实际上，WebDataBinder机制还有一个重要的功能，那就是验证转换结果。关于验证机制，后面会再讨论。有了参数的转换和验证，最终控制器就可以得到合法的参数。得到这些参数后，就可以调用控制器的方法了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/1.png" alt=""></p><p>这个图严格来说是请求体转换的全流程，但是有些时候SpringMVC并不会走完全程，而是根据现实情况来处理消息的转换。</p><p>根据上面的讨论，可以看到控制器的参数是处理器通过Convert町、Formatter和GenericConverter这三个接口转换出来的。</p><p>这里先谈谈这三个接口的不同之处。</p><ol><li>首先，Converter是一个普通的转换器，例如，有一个Integer类型的控制器参数，而从HTTP对应的为字符串，对应的Converter就会将字符串转换为Integer类型：</li><li>其次，Formatter则是一个格式化转换器，类似那些日期字符串就是通过它按照约定的格式转换为日期的；</li><li>最后，GenericConverter转换器则将HTTP参数转换为数组。</li></ol><p>这就是上述例子可以通过比较简单的注解就能够得到各类参数的原因。</p><p>对于数据类型转换，SpringMVC提供了→个服务机制去管理，它就是ConversionService接口。在默认的情况下，会使用这个接口的子类DefaultFormattingConversionService对象来管理这些转换类。</p><p>其关系如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/2.png" alt=""></p><p>从图可以看出，Converter、Formatter和GenericConverter可以通过注册机接口进行注册，这样处理器就可以获取对应的转换器来实现参数的转换。上面讨论的是普通SpringMVC的参数转换规则，而在SpringBoot中还提供了特殊的机制来管理这些转换器。SpringBoot的自动配置类WebMvcAutoConfiguration还定义了一个内部类WebMvcAuto­ConfigurationAdapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册各类转换器，registry实际为DefaultFormattingConversionService对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistryregistry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//遍历IoC容器，找到Converter类型的Bean注册到服务类中</span></span><br><span class="line">        <span class="keyword">for</span>(Converter&lt;?,?&gt; converter:getBeansOfType(Converter<span class="class">.<span class="keyword">class</span>)) </span>&#123; </span><br><span class="line">            registry.addConverter(converter);</span><br><span class="line">     <span class="comment">//遍历IoC容器，找到GenericConverter类型的Bean注册到服务类中</span></span><br><span class="line">         <span class="keyword">for</span>(GenericConverter converter:getBeansOfType(GenericConverter<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                    registry.addConverter(converter);</span><br><span class="line">      <span class="comment">//遍历IoC容器，找到Formatter类型的Bean注册到服务类中</span></span><br><span class="line">         <span class="keyword">for</span>(Formatter&lt;?&gt; formatter:getBeansOfType(Formatter<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                            registry.addFormatter(formatter);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中加入了中文注释以利于理解，通过这个方法，可以看到在SpringBoot的初始化中，会将对应用户自定义的Converter、Formatter和GenericConverter的实现类所创建的SpringBean自动地注册到DefaultFormattingConversionService对象中。</p><p>这样对于开发者只需要自定义Converter、Formatter和GenericConverter的接口的Bean,SpringBoot就会通过这个方法将它们注册到ConversionService对象中。只是格式化Formatter接口，在实际开发中使用率比较低，所以不再论述。</p><h4 id="一对一转换器"><a href="#一对一转换器" class="headerlink" title="一对一转换器"></a>一对一转换器</h4><p>Converter是一对一的转化器，也就是从一种类型转换为另外一种类型，其接口定义十分简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Converter</span>&lt;<span class="title">S</span> ,  <span class="title">T</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="function">T  <span class="title">convert</span><span class="params">(S  source )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口的类型有源类型CS）和目标类型(T）两种，它们通过conv创方法进行转换。</p><p>例如，HTTP的类型为字符串（String）型，而控制器参数为Long型，那么就可以通过Spring内部提供的StringToNumber&lt;TextendsNumber＞进行转换。</p><p>假设前端要传递一个用户的信息，这个用户信息的格式是｛id}-{userName｝”｛note｝，而控制器的参数是User类对象。</p><p>因为这个格式比较特殊，Spring当前并没有对应的Converter进行转换，因此需要自定义转换器。这里需要的是一个从String转换为User的转换器：</p><h5 id="字符串用户转换器"><a href="#字符串用户转换器" class="headerlink" title="字符串用户转换器"></a>字符串用户转换器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义字符串用户转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String userStr)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        String []strArr = userStr.split(<span class="string">"-"</span>);</span><br><span class="line">        Long id = Long.parseLong(strArr[<span class="number">0</span>]);</span><br><span class="line">        String userName = strArr[<span class="number">1</span>];</span><br><span class="line">        String note = strArr[<span class="number">2</span>];</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        user.setNote(note);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的类标注为＠Component，并且实现了Converter接口，这样Spring就会将这个类扫描并装配到IoC容器中。对于SpringBoot，之前分析过它会在初始化时把这类自动地注册到转换机制中，所以注册这步并不需要人再处理。这里泛型指定为String和User，这样SpringMVC就会通过HTTP的参数类型（String）和控制器的数类型（User）进行匹配，就可以从注册机制中发现这个转换类，这样就能够将参数转换出来。下面写一个控制器方法对其进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/converter"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByConverter</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开浏览器，输入：<a href="http://localhost:8888/user/converter?user=9-谢广坤-路人" target="_blank" rel="noopener">http://localhost:8888/user/converter?user=9-谢广坤-路人   </a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/4.png" alt=""></p><p>可以发现，我们自动把这个字符串长段，转化为了User对象。</p><h4 id="GenericConverter集合和数组转换"><a href="#GenericConverter集合和数组转换" class="headerlink" title="GenericConverter集合和数组转换"></a>GenericConverter集合和数组转换</h4><p>GenericConverter是数组转换器。因为SpringMVC自身提供了一些数组转换器，需要自定义的不多，所以这里只介绍SpringMVC自定义的数组转换器。</p><p>假设需要同时新增多个用户，这样便需传递一个用户列表（List&lt;User＞）给控制器。此时SpringMVC会使用StringToCollectionConverter转它，这个类实现了GenericConverter接口，并且是SpringVC内部己经注册的数组转换器。</p><p>它首会把字符串用逗号分隔为个个的子宇符串，然后根据原类型泛型为String、目标类型泛型为User。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">list</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验方法和上面的一样，多个用户只需要使用逗号隔开就行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（一）</title>
      <link href="/2020/02/11/spring10/"/>
      <url>/2020/02/11/spring10/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（一）"><a href="#SpringMVC详解（一）" class="headerlink" title="SpringMVC详解（一）"></a>SpringMVC详解（一）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>SpringMVC就是我们常说的SSM中的“S”。</p><p>SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。</p><p>但是现在的SSM也可以看作为是SpringBoot+SpringMVC+MyBatis。毕竟Spring和SpringBoot并不具有本质上的区别，它们的核心IOC和AOP，还是一样的。</p><p>虽然之前在讲使用MyBatis和REST风格的时候，有提到的MVC的使用，但是总体而言并不具体，于是，这次我们就分两篇来说一说SpringMVC的使用和深入。</p><h4 id="SpringMVC框架设计"><a href="#SpringMVC框架设计" class="headerlink" title="SpringMVC框架设计"></a>SpringMVC框架设计</h4><p>先看一下框架流程图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/3.png" alt=""></p><p>每当有请求从页面发出来之后，就会从控制层进去，这里的控制层和前端还存在着一定程度的耦合，它们必须要知道各自的请求地址是什么。然后由控制层进入到后端，完成对业务的处理。</p><h3 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h3><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>SpringMVC的框架设计并不复杂，其实只要多看看程序，稍微思考一下，也很容易的出它们的规律。</p><p>所有SpringMVC最关键的则是它们的内部流程，内部流程被SpringMVC的隐藏，很多时候你知道如何使用了，但是还是不知道内部的细节流程。我们就来学习一下吧。</p><p>流程和组件是SpringMVC的核心，SpringMVC的流程是围绕DispatcherServlet而工作的，所以在SpringMVC中，patcherServlet就其最重要的内容。在DispatcherServlet的基础上，还存在其他的组件，掌握流程和组件就是SpringMVC开发的基础。</p><p>如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/4.png" alt=""></p><p>它是SpringMVC运行的全流程，其中图中的阿拉伯数字是其执行的流程，这是SpringMVC开发的基础。但是严格地说，SpringMVC处理请求并非一定需要经过全程，有时候一些流程并不存在。例如，在我们加入＠ResponseBody时，是没有经过视图解析器和视图渲染的。</p><p>这里我们先看一个简单的实例，对这个流程做更进一步论述。首先，在Web服务器启动的过程中，如果在SpringBoot机制下启用SpringMVC，它就开始初始化一些重要的组件，如DispatcherServlet、HandlerAdapter的实现RequestMappingHandlerAdapter等组件对象。关于这些组件的初始化，我们可以看到spring-webmvc-xxx.jar包的属性文件DispatcherServlet.properti，它定义的对象都是在SpringMVC开始时就初始化，并且存放在SpringIoC容器中。</p><h4 id="DispatcherServlet-properties"><a href="#DispatcherServlet-properties" class="headerlink" title="DispatcherServlet.properties"></a>DispatcherServlet.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#国际化解析器</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.LocaleResolver</span> = <span class="string">org . springframework.web.servlet.ilBn.AcceptHeade rLocaleResolver</span></span><br><span class="line"><span class="comment">#主题解析器</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.ThemeResolver</span>=<span class="string">org.springframework.web.servlet.theme.FixedThemeResolver</span></span><br><span class="line"><span class="comment">#handlerMapping实例</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span></span><br><span class="line"><span class="comment">#处理器实例</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span></span><br><span class="line"><span class="comment">#处理器异常解析器</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="string">org. springframework.web.servlet.mvc.method.annotation.ExceptionH andlerExceptionResolver</span></span><br><span class="line"><span class="meta">＃策略视图名称转换器，当你没有返回视图逻辑名称的时候，通过它可以生成默认的视图名称org.springframework.web.servlet.RequestToViewNameTranslator</span>=<span class="string">org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span></span><br><span class="line"><span class="meta">＃视图解析器org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResource飞liewResolver</span></span><br></pre></td></tr></table></figure><h4 id="基础依赖"><a href="#基础依赖" class="headerlink" title="基础依赖"></a>基础依赖</h4><p>我们在这里把所有基础依赖列出来，方便实验：</p><h5 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.springmvc.pojo</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springtest?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span></span><br></pre></td></tr></table></figure><h5 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(@Param(<span class="string">"userName"</span>)</span> String userName, @<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userDao.getUser(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userDao.findUsers(userName, note);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.springmvc.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">select id, user_name as userName, note from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">   select id, user_name as userName, note from t_user</span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span> and user_name like concat('%', #&#123;userName&#125;, '%')<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span> and note like concat('%', #&#123;note&#125;, '%')<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span></span></span><br></pre></td></tr></table></figure><h4 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h4><p>现在开始一步步的去解释这它们的运行流程。</p><p>首先需要一个控制层的控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/details"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.setViewName(<span class="string">"details"</span>);</span><br><span class="line">        <span class="comment">// 加入模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里的注解＠Controller表明这是一个控制器，然后＠RequestMapping代表请求路径和控制器（或其方法）的映射关系，它会在Web服务器启动SpringMVC时，就被扫描到HandlerMapping的机制中存储。</p><p>之后在用户发起请求被DispatcherServlet拦截后，通过URL和其他的条件，通过HandlerMapper机制就能找到对应的控制器（或其方法）进行响应。</p><p>只是通过HandlerMapping返回的是一个HandlerExecutionChain对象，这个对象的源码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//处理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="comment">//拦截器数组</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">    <span class="comment">//拦截器列表</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="comment">//拦截器下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中可以看出，HandlerExecutionChain对象包含个处理器（handler）。这里的处理器是对控制器（controller）的包装，因为我们的控制器方法可能存在参数，那么处理器就可以读入HTTP和上下文的相关参数，然后再传递给控制器方法。</p><p>而在控制器执行完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。从这段描述中可以看出，处理器包含了控制器方法的逻辑，此外还有处理器的拦截器（interceptor），这样就能够通过拦截处理器进一步地增强处理器的功能得到了处理器（handler），还需要去运行，但是我们有普通HTTP请求，也有按BeanName的请求，甚至是WebSocket的请求，所以它还需要一个适配器去运行HandlerExecutionChain对象包含的处理器，这就是HandlerAdapter接口定义的实现类。</p><p>在DispatcherServlet.properties中，我们可以看到在SpringMVC中最常用的HandlerAdapter的实现类，这便是HttpRequestHandlerAdaptero通过请求的类型，DispatcherServlet就会找到它来执行Web请求的HandlerExecutionChain对象包含的内，这样就能够执行我们的处理器（handler）了。</p><p>只是HandlerAdapter运行HandlerExecutionChain对象这还比较复杂，我们这里暂时不进行深入讨论，放到后面再谈。</p><p>在处理器调用控制器时，它首先通过模型层得到数据，再放入数据模型中，最后将返回模型和视图（ModelAndView）对象，这里控制器设置的视图名称设置为“user/details”，这样就走到了视图解析器（ViewResolver），去解析视图逻辑名称了。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>需要一个页面，使用thymeleaf语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>值<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.note&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，开始测试吧：</p><p>效果图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/1.png" alt=""></p><p>测试结果貌似不能直接说明出什么，我们再根据一张图，将它们结合到一起去理解它们是怎么运行的：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/5.png" alt=""></p><p>这便是它们的运行步骤。这里有添加jsp视图映射，但是我们使用的是thymeleaf，所以不会过度理会第五步，由于找不到合适的图，拿这个代替一下。</p><h4 id="JSON视图"><a href="#JSON视图" class="headerlink" title="JSON视图"></a>JSON视图</h4><p>我们知道，一般前端的需求都是JSON 数据，这里是通过了SpringMVC的内置机制，自动将它转化为的JSON视图，我们可以自己定义转换为JSON数据，来保证不会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detailsForJson"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="comment">// 模型和视图</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">// 生成JSON视图</span></span><br><span class="line">    MappingJackson2JsonView jsonView = <span class="keyword">new</span> MappingJackson2JsonView();</span><br><span class="line">    mv.setView(jsonView);</span><br><span class="line">    <span class="comment">// 加入模型</span></span><br><span class="line">    mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果也如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/6.png" alt=""></p><h4 id="定制SpringMVC初始化"><a href="#定制SpringMVC初始化" class="headerlink" title="定制SpringMVC初始化"></a>定制SpringMVC初始化</h4><p>如SpringBoot所承诺的那样，它会尽可能地配置Spring，对于SpringMVC也是如此，但是无论如何这些配置都可能满足不了我们的需要，需要进一步地对SpringMVC定制。</p><p>在S巳rvlet3.0范中，web刀nl再也不是一个必需的配置文件。为了适应这个规范，SpringMVC从3.1版本开始也进行了支持，也就是我们已经不再需要通过任何XML去配置SpringMVC的运行环境，正如SpringBoot的宗旨，消除XML的繁杂配置。</p><p>为了支持对于SpringMVC的配置，Spring提供了接口WebMvcConfigurer这是一个基于Java8的接口，所以其大部分方法都是default类型的，但是它们都是空实现，这样开发者只需要实现这个接口，重写需要自定义的方法即可，这样就很方便进行开发了。</p><p>在SpringBoot中，自定义是通过配置类WebMvcAutoConfiguration定义的，它有一个静态的内部类WebMvcAutoConfigurationAdapter通过它SpringBoot就自动配置了SpringMVC的初始化，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/7.png" alt=""></p><h4 id="SpringMVC可配置项"><a href="#SpringMVC可配置项" class="headerlink" title="SpringMVC可配置项"></a>SpringMVC可配置项</h4><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/2.png" alt=""></p><p>这些配置项将会被SpringBoot的机制读入，然后使用ebMvcAutoConfigurationAdapter去定制初始化。</p><p>一般而言，我们只需要配置少数的选项就能够使得SpringMVC工作了。</p><h3 id="SpringMVC实例"><a href="#SpringMVC实例" class="headerlink" title="SpringMVC实例"></a>SpringMVC实例</h3><p>在SpringBoot中开发SpringMVC还是比较简易的，正如之前我们的例子，SpringVC的开发核心是控制器的开发，控制器的开发又分为这么几个步骤，首先是定义请求分发，SpringMVC能够产生HandlerMapping,其次是接收请求获取参数，再次是处理业务逻辑获取数据模型，最后是绑定视图和数据模型。</p><p>视图将数据模型渲染则是视图定义的问题，不属于控制器开发的步骤。</p><p>下面我们演示一个用户列表查询的界面。假设可以通过用户名称CuserName）和备注（note)进行查询，但是一开始进入页面需要载入所有的数据展示给用户查看。</p><p>这里分为两种常见的场景，一种是刚进入页面时，一般来说是不允许存在异步请求的，因为异步请求会造成数据的刷新，对用户不友好：另一种是进入页面后的查询，这时可以考虑使用Ajax异步请求，只刷新数据而不刷新页面，这才是良好的UI体验设计。</p><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><p>贴出控制层代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springmvc.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.example.springmvc.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.json.MappingJackson2JsonView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/details"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">details</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.setViewName(<span class="string">"details"</span>);</span><br><span class="line">        <span class="comment">// 加入模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/detailsForJson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 生成JSON视图</span></span><br><span class="line">        MappingJackson2JsonView jsonView = <span class="keyword">new</span> MappingJackson2JsonView();</span><br><span class="line">        mv.setView(jsonView);</span><br><span class="line">        <span class="comment">// 加入模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/table"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        List&lt;User&gt; userList = userService.findUsers(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 定义模型视图</span></span><br><span class="line">        mv.setViewName(<span class="string">"table"</span>);</span><br><span class="line">        <span class="comment">// 加入数据模型</span></span><br><span class="line">        mv.addObject(<span class="string">"userList"</span>, userList);</span><br><span class="line">        <span class="comment">// 返回模型和视图</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">list</span><span class="params">(@RequestParam(value = <span class="string">"userName"</span>, required = <span class="keyword">false</span>)</span> String userName,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"note"</span>, required = <span class="keyword">false</span>)</span> String note) </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        List&lt;User&gt; userList = userService.findUsers(userName, note);</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是控制层，其实并没有什新的东西，按照已有的知识重复写就能够写出来。</p><h4 id="Html页面"><a href="#Html页面" class="headerlink" title="Html页面"></a>Html页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"../static/easyui/themes/default/easyui.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"../static/easyui/themes/icon.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"../static/easyui/demo/demo.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../static/easyui/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../static/easyui/jquery.easyui.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 定义事件方法</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">onSearch</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 指定请求路径</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> opts = $(<span class="string">'#dg'</span>).datagrid(<span class="string">"options"</span>);</span></span><br><span class="line"><span class="actionscript">            opts.url = <span class="string">"./list"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 获取查询参数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> userName = $(<span class="string">"#userName"</span>).val();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> note = $(<span class="string">"#note"</span>).val();</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 组织参数</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> params = &#123;&#125;;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (userName != <span class="literal">null</span> &amp;&amp; userName.trim() != <span class="string">''</span>) &#123;</span></span><br><span class="line">                params.userName = userName;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (note != <span class="literal">null</span> &amp;&amp; note.trim() != <span class="string">''</span>) &#123;</span></span><br><span class="line">                params.note = note;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">// 重新载入表格数据</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#dg"</span>).datagrid(<span class="string">'load'</span>, params);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin: 20px 0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"easyui-layout"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 350px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-options</span>=<span class="string">"region:'north'"</span> <span class="attr">style</span>=<span class="string">"height: 50px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"searchForm"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userName"</span> <span class="attr">name</span>=<span class="string">"userName"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">class</span>=<span class="string">"easyui-textbox"</span> <span class="attr">data-options</span>=<span class="string">"prompt:'输入用户名称...'"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">style</span>=<span class="string">"width: 100%; height: 32px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"note"</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">class</span>=<span class="string">"easyui-textbox"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">data-options</span>=<span class="string">"prompt:'输入备注...'"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 32px"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"easyui-linkbutton"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">data-options</span>=<span class="string">"iconCls:'icon-search'"</span> <span class="attr">style</span>=<span class="string">"width: 80px"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">onclick</span>=<span class="string">"onSearch()"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-options</span>=<span class="string">"region:'center',title:'用户列表',iconCls:'icon-ok'"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"dg"</span> <span class="attr">class</span>=<span class="string">"easyui-datagrid"</span></span></span><br><span class="line"><span class="tag">               ,</span></span><br><span class="line"><span class="tag">               <span class="attr">data-options</span>=<span class="string">"border:false,singleSelect:true,</span></span></span><br><span class="line"><span class="tag"><span class="string">fit:true,fitColumns:true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">data-options</span>=<span class="string">"field:'id'"</span> <span class="attr">width</span>=<span class="string">"80"</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">data-options</span>=<span class="string">"field:'userName'"</span> <span class="attr">width</span>=<span class="string">"100"</span>&gt;</span>用户名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">data-options</span>=<span class="string">"field:'note'"</span> <span class="attr">width</span>=<span class="string">"80"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用forEache渲染数据模型--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"u:$&#123;userList&#125;"</span> &gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;u.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;u.userName&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;u.note&#125;"</span>&gt;</span>note<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面中还定义了两个文本框，用来输入用户名和各注，然后通过查询按钮进行询。这里查询按钮的点击事件定义为onSearch，这样就能够找到onSearch函数来执行查询。</p><p>在这个函数中，首先定义DataGrid请求的URL，它指向了list方法，然后通过jQuery去获取两个文本框的参数值，再通过DataGrid的load方法，传递参数去后端查询，得到数据后重新载入DataGrid的数据，这样DataGrid就能够得到查询的数据了。</p><p>再看回list方法。首先它标注为了＠ResponseBody，这样SpringMVC就道最终需要把返回的结果转换为JSON。然后是获取参数，这里使用了注解＠RequestParam，通过指定参数名称使得HTTP请求的参数和方法的参数进行绑定，只是这个注解的默认规则是参数不能为空。为了克服这个问题，代码将其属性required设置为false即可，其意义就是允许参数为空。这样就可以测试这个请求了</p><p>最后再测试一下吧：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/8.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合WebSocket</title>
      <link href="/2020/02/10/spring9/"/>
      <url>/2020/02/10/spring9/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合WebSocket"><a href="#SpringBoot整合WebSocket" class="headerlink" title="SpringBoot整合WebSocket"></a>SpringBoot整合WebSocket</h2><p>”人不是一座孤岛，所有人的不幸皆是我的不幸“——出处未知</p><p>人不是一个喜欢独立个体，在上个世纪有短信，这个世纪有微信，可见，沟通在人们中占据了多么重要的地位，而我们今天，就来使用WebSocket，来打造一个聊天室。</p><p>在此之前，我想先说说WebJars，你如果明白，也可以直接跳到WebSocket。</p><h3 id="WebJars"><a href="#WebJars" class="headerlink" title="WebJars"></a>WebJars</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。</p><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp目录下的手工方式，这样做就无法对这些资源进行依赖管理。而且容易导致文件混乱、版本不一致等问题。那么WebJars就提供给我们这些前端资源的jar包形式，我们就可以进行依赖管理。</p><p>WebJars是将这些通用的Web前端资源打包成Java的Jar包，然后借助Maven工具对其管理，保证这些Web资源版本唯一性，升级也比较容易。关于webjars资源，有一个专门的网站<a href="http://www.webjars.org/，我们可以到这个网站上找到自己需要的资源，在自己的工程中添加入maven依赖，即可直接使用这些资源了。" target="_blank" rel="noopener">http://www.webjars.org/，我们可以到这个网站上找到自己需要的资源，在自己的工程中添加入maven依赖，即可直接使用这些资源了。</a></p><h4 id="怎么样"><a href="#怎么样" class="headerlink" title="怎么样"></a>怎么样</h4><p>可以在pom文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!--Webjars版本定位工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webjars-locator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Webjars的一个包，有各种资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars.npm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mdui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        wenjars的JQ库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了它们，就能够在Html页面上引入它们，就能够直接使用它们的样式和语法，节省了很多开发所需的依赖，使得我们前端引入更为方便。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/mdui/dist/css/mdui.css&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/jquery/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/mdui/dist/js/mdui.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Thymeleaf语法进行引用，这里是世界引用 /webjars的目录。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>现在，就来正式的讲一下，WebSocket的使用吧。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但RFC 6455规定：“WebSocket设计为通过80和443端口工作，以及支持HTTP代理和中介”，从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</p><p>WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术)" target="_blank" rel="noopener">Comet</a>之类的技术以非标准化的方式实现了类似的双向通信。</p><p>大多数浏览器都支持该协议，包括<a href="https://zh.wikipedia.org/wiki/Google_Chrome" target="_blank" rel="noopener">Google Chrome</a>、<a href="https://zh.wikipedia.org/wiki/Firefox" target="_blank" rel="noopener">Firefox</a>、<a href="https://zh.wikipedia.org/wiki/Safari" target="_blank" rel="noopener">Safari</a>、<a href="https://zh.wikipedia.org/wiki/Microsoft_Edge" target="_blank" rel="noopener">Microsoft Edge</a>、<a href="https://zh.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="noopener">Internet Explorer</a>和<a href="https://zh.wikipedia.org/wiki/Opera瀏覽器" target="_blank" rel="noopener">Opera</a>。</p><p>与HTTP不同，WebSocket提供全双工通信。此外，WebSocket还可以在TCP之上启用消息流。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><p>WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案，分别对应明文和加密连接。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。</p><p>使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架</p><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><p>WebSocket最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&action=edit&redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>“WebSocket”这个名字是Ian Hickson和Michael Carter之后在 #whatwg IRC聊天室创造的，随后由Ian Hickson撰写并列入HTML5规范，并在Michael Carter的Cometdaily博客上宣布。 2009年12月，Google Chrome 4是第一个提供标准支持的浏览器，默认情况下启用了WebSocket。协议的开发随后于2010年2月从W3C和WHATWG小组转移到IETF，并在Ian Hickson的指导下进行了两次修订。</p><p>该协议被多个浏览器默认支持并启用后，<a href="https://zh.wikipedia.org/wiki/RFC" target="_blank" rel="noopener">RFC</a>于2011年12月在Ian Fette下完成。</p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是在特定的的时间间隔（如每秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段列表" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，显然这样会消耗很多的带宽资源。</p><p>比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术)" target="_blank" rel="noopener">Comet</a>。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>在这种情况下，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><p>Websocket使用<code>ws</code>或<code>wss</code>的<a href="https://zh.wikipedia.org/wiki/统一资源标志符" target="_blank" rel="noopener">统一资源标志符</a>，类似于<a href="https://zh.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a>。其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com/wsapi</span><br><span class="line">wss://secure.example.com/wsapi</span><br></pre></td></tr></table></figure><p>Websocket与HTTP和HTTPS使用相同的TCP<a href="https://zh.wikipedia.org/wiki/TCP/UDP端口列表" target="_blank" rel="noopener">端口</a>，可以绕过大多数<a href="https://zh.wikipedia.org/wiki/防火墙" target="_blank" rel="noopener">防火墙</a>的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><p>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&action=edit&redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p>更好的二进制支持。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p>更好的压缩效果。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。</p></li></ul><h5 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h5><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 <a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>/1.1 协议的101<a href="https://zh.wikipedia.org/wiki/HTTP状态码" target="_blank" rel="noopener">状态码</a>进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“<a href="https://zh.wikipedia.org/wiki/握手_(技术)" target="_blank" rel="noopener">握手</a>”（handshaking）。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/1.png" alt=""></p><h4 id="Spring-WebSocket-解析"><a href="#Spring-WebSocket-解析" class="headerlink" title="Spring WebSocket 解析"></a>Spring WebSocket 解析</h4><h5 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h5><p>SpringBoot有自带的WebSocket API，我们在使用WebSocket的时候，可以直接引入这个依赖，也可以手动引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="创建服务器端点"><a href="#创建服务器端点" class="headerlink" title="创建服务器端点"></a>创建服务器端点</h5><p>开启WebSocket服务端的自动注册。</p><p>在对WebSocket的使用中，可以先通过Spring创建Java配置文件。在这个文件中，先新建ServerEndpointExporter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个Bean，就可以使用@ServerEndpoint定义一个端点服务类。在这个站点服务类中，还可以定义WebSocket的打开，关闭，错误和发送消息方法。</p><p>ServerEndpointExporter 是由Spring官方提供的标准实现，用于扫描ServerEndpointConfig配置类和@ServerEndpoint注解实例。使用规则也很简单：1.如果使用默认的嵌入式容器 比如Tomcat 则必须手工在上下文提供ServerEndpointExporter。2. 如果使用外部容器部署war包，则不要提供提供ServerEndpointExporter，因为此时SpringBoot默认将扫描服务端的行为交给外部容器处理。</p><h5 id="ServerEndpoint"><a href="#ServerEndpoint" class="headerlink" title="ServerEndpoint"></a>ServerEndpoint</h5><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/ws"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// concurrent包的线程安全Set，用来存放每个客户端对应的WebSocketServiceImpl对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServiceImpl&gt; </span><br><span class="line">            webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法*/</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="keyword">this</span>);     <span class="comment">// 加入set中</span></span><br><span class="line">        addOnlineCount();           <span class="comment">// 在线数加1</span></span><br><span class="line">        System.out.println(<span class="string">"有新连接加入！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(<span class="string">"有新的连接加入了！！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>);  <span class="comment">// 从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">// 在线数减1</span></span><br><span class="line">        System.out.println(<span class="string">"有一连接关闭！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"来自客户端的消息:"</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServiceImpl item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // 获取当前用户名称</span></span><br><span class="line"><span class="comment">                String userName = item.getSession()</span></span><br><span class="line"><span class="comment">                        .getUserPrincipal().getName();</span></span><br><span class="line"><span class="comment">                System.out.println(userName);</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                item.sendMessage(message); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发生错误"</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回在线数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当连接人数增加时</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServiceImpl.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当连接人数减少时</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServiceImpl.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过注解@OnOpen、@OnMessage、@OnClose、@OnError 来声明回调函数。</p><h5 id="回调函数将由JavaScript处理"><a href="#回调函数将由JavaScript处理" class="headerlink" title="回调函数将由JavaScript处理"></a>回调函数将由JavaScript处理</h5><p>回调函数将会被前端的JavaScript所使用，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 判断当前浏览器是否支持WebSocket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line"><span class="comment">// 创建WebSocket对象,连接服务器端点</span></span><br><span class="line">websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8888/ws"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">'Not support websocket'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接发生错误的回调方法</span></span><br><span class="line">websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">appendMessage(<span class="string">"error"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功建立的回调方法</span></span><br><span class="line">websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">appendMessage(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到消息的回调方法</span></span><br><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">appendMessage(event.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭的回调方法</span></span><br><span class="line">websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">appendMessage(<span class="string">"close"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，</span></span><br><span class="line"><span class="comment">// 防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息显示在网页上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = $(<span class="string">"#context"</span>).html() +<span class="string">"&lt;br/&gt;"</span> + message;</span><br><span class="line">$(<span class="string">"#context"</span>).html(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = $(<span class="string">"#message"</span>).val();</span><br><span class="line">websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看清楚大小写，这里的 webSocket是利用了在后端所声明的WebSocket对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(url);</span><br></pre></td></tr></table></figure><p>而 webSocket这个JS实例将能够调用回调函数，就如onmessage而言：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">appendMessage(event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能通过 （event），来获取到后端传进来的值。</p><p>那么值是从哪里被传进去的呢？</p><p>请看HTML页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    测试一下WebSocket站点吧</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"message"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"sendMessage()"</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"closeWebSocket()"</span>&gt;</span>关闭WebSocket连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"context"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里所只使用的 onclick=”sendMessage()” 正是在调用JS函数，而这个JS函数就是上面所提及的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = $(<span class="string">"#message"</span>).val();</span><br><span class="line">websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会将文本框中的message的值，通过 send(message)，发送到后端处理，由后端标注的@OnMessage函数处理完后，再被JS函数 websocket.onmessage = function(event) 所接收。</p><p>至于如何展示在页面上，则是由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将消息显示在网页上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = $(<span class="string">"#context"</span>).html() +<span class="string">"&lt;br/&gt;"</span> + message;</span><br><span class="line">$(<span class="string">"#context"</span>).html(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所决定的了。</p><p>当然，根据不同的情况，JS的代码可以被自行设计，所以这些代码仅供参考。我们必须记牢的，就是注解的含义：</p><table><thead><tr><th align="center">事件类型</th><th align="left">WebSocket回调函数</th><th align="left">事件描述</th></tr></thead><tbody><tr><td align="center">open</td><td align="left">webSocket.onopen</td><td align="left">当打开连接后触发</td></tr><tr><td align="center">message</td><td align="left">webSocket.onmessage</td><td align="left">当客户端接收服务端数据时触发</td></tr><tr><td align="center">error</td><td align="left">webSocket.onerror</td><td align="left">当通信异常时触发</td></tr><tr><td align="center">close</td><td align="left">webSocket.onclose</td><td align="left">当连接关闭时触发</td></tr></tbody></table><h3 id="打造一个在线聊天室"><a href="#打造一个在线聊天室" class="headerlink" title="打造一个在线聊天室"></a>打造一个在线聊天室</h3><p>明白了上述的用法之后，我们来做一个实战练习吧，那就是做一个聊天室。这么说可能有点复古，好像聊天室这个称呼，是上个世纪的产物，不过也无所谓，开始一段练习吧。</p><p>前面的实验中，最为关键的，想必就是回调函数的构成了，于是，我么就开始先写回调函数吧。不过在这之前，还要介绍一下一个JSON转换工具。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>先导入一些基本配置吧：</p><h5 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Webjars版本定位工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webjars-locator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Webjars的一个包，有各种资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars.npm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mdui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        wenjars的JQ库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pom依赖前面都讲过，在此不多赘述</p><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><p>yml文件不需要太多配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是必要的配置，前面也讲过。</p><h4 id="回调函数的编写"><a href="#回调函数的编写" class="headerlink" title="回调函数的编写"></a>回调函数的编写</h4><p>前面有引入JSON依赖，我们就使用JSON，来完善我们的信息传输，所以，先编写一个信息类吧。</p><h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 聊天消息类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENTER = <span class="string">"ENTER"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPEAK = <span class="string">"SPEAK"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">"QUIT"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;<span class="comment">//消息类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//发送人</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//发送消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> onlineCount; <span class="comment">//在线用户数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">jsonStr</span><span class="params">(String type, String username, String msg, <span class="keyword">int</span> onlineTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(<span class="keyword">new</span> Message(type, username, msg, onlineTotal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String type, String username, String msg, <span class="keyword">int</span> onlineCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.onlineCount = onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的jsonStr方法是一个静态方法，而且，这个静态方法返回的是一个自身类的一个构造方法。也就是说，将使用这个静态方法去代替构造方法。</p><p>这里的JSON是一个alibaba提供的类。在pom文件中导入过。</p><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>在服务端完成回调函数的编写，这里用到了Message类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/chat"</span>)<span class="comment">//标记此类为服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全部在线会话   基于场景考虑 这里使用线程安全的Map存储会话对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; onlineSessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端打开连接：1.添加会话对象 2.更新在线人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        onlineSessions.put(session.getId(), session);</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.ENTER, <span class="string">""</span>, <span class="string">""</span>, onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息：1.获取它的用户名和消息 2.发送消息给所有人</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *  这里约定传递的消息为JSON字符串 方便传递更多参数！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, String jsonStr)</span> </span>&#123;</span><br><span class="line">        Message message = JSON.parseObject(jsonStr, Message<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.SPEAK, message.getUsername(), message.getMsg(), onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当关闭连接：1.移除会话对象 2.更新在线人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        onlineSessions.remove(session.getId());</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.QUIT, <span class="string">""</span>, <span class="string">"下线了！"</span>, onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通信发生异常：打印错误日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共方法：发送信息给所有人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessageToAll</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        onlineSessions.forEach((id, session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们逐个逐个去分析各个函数的使用：</p><ol><li>public void onOpen(Session session)：每当有客户端连接到这个地址时，就会自动往这个函数传入Session，而我们使用HashMap去存储这个Session实例，当然，使用HashSet也可以，在存储了对象的同时，也需要更新实时在线的信息。</li><li>public void onMessage(Session session, String jsonStr)：在前端的JS使用了Send（），发送了信息后，onMessage函数就会自动接收到了一个文本框的String字符串和一个当前Session对象。这里直接把String字符串转化了Message类，再将这个Message转化为JSON的形式，再发送至前端。可能大家不太明白的，就是为什么要加ENTER和SPEAK，这是为了让前端能够判断这个消息到底是什么类型的，以便用于不同的地方。</li><li>public void onClose(Session session)：自然是在退出的时候，更新在线人数</li><li>public void onError(Session session, Throwable error)：错误处理</li><li>private static void sendMessageToAll(String msg)：可以看到这是一个静态方法，也是信息传输的主体，这里使用了只有JDK8才有的Lambda表达式和foreach，去将这个Map里面的Session对象，由这个Session对象去发送信息到前端。</li></ol><p>sendMessageToAll函数也有三点是需要注意的：</p><ul><li>Lambda表达式的用法</li><li>Session是WebSocket自己的Session类</li><li>session.getBasicRemote().sendText(msg);可以是一个固定表达，不用深究。</li></ul><h4 id="登录的编写"><a href="#登录的编写" class="headerlink" title="登录的编写"></a>登录的编写</h4><p>既然是聊天，当然得知道你是谁才能正常会话，于是也需要登录界面，但是这里就不引入Security了，太麻烦，这里直接使用HTML和JS完成登录页面</p><h5 id="login页面"><a href="#login页面" class="headerlink" title="login页面"></a>login页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登陆聊天<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/jquery/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span>省略。。。<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo_box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>登录聊天<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input_outer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"u_user"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"任意中文名"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input_outer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"us_uer"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"任意密码"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mb2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"act-but submit"</span> <span class="attr">onclick</span>=<span class="string">"login()"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这里引入webjar的JQ库，可以使用一些非常简便的函数和类。</p><h5 id="login-JavaScript"><a href="#login-JavaScript" class="headerlink" title="login-JavaScript"></a>login-JavaScript</h5><p>这一段的JS较为容易</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆聊天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        location.href = <span class="string">'/index?username='</span>+$(<span class="string">'#username'</span>).val();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ENTER登陆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>];</span><br><span class="line">        e.keyCode === <span class="number">13</span> &amp;&amp; login();</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>和HT页面相结合，完成用户名的输入。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 聊天界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index</span><span class="params">(String username, String password, HttpServletRequest request)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(username)) &#123;</span><br><span class="line">            username = <span class="string">"匿名用户"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"/chat"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"username"</span>, username);</span><br><span class="line">        mav.addObject(<span class="string">"webSocketUrl"</span>, <span class="string">"ws://"</span>+ InetAddress.getLocalHost().getHostAddress()+<span class="string">":"</span>+request.getServerPort()+request.getContextPath()+<span class="string">"/chat"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS的登录函数，将会被传入到这里，完成页面的跳转，较为简单。</p><h4 id="聊天室的编写"><a href="#聊天室的编写" class="headerlink" title="聊天室的编写"></a>聊天室的编写</h4><h5 id="chat页面"><a href="#chat页面" class="headerlink" title="chat页面"></a>chat页面</h5><p>我们也来编写聊天室的页面吧，这个页面开始引用webjar的资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket简单聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/mdui/dist/css/mdui.css&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/jquery/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/mdui/dist/js/mdui.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"mdui-theme-primary-indigo mdui-theme-accent-pink"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-toolbar mdui-color-theme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>menu<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-typo-title"</span>&gt;</span>简单聊天室<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-toolbar-spacer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>search<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>exit_to_app<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>more_vert<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container container_text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-12 mdui-col-sm-6"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-12 mdui-col-sm-10"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-textfield-floating-label"</span> <span class="attr">style</span>=<span class="string">"margin-top:15px"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>欢迎：<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-12 mdui-col-sm-10"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-textfield mdui-textfield-floating-label"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>textsms<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"mdui-textfield-label"</span>&gt;</span>发送内容<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"mdui-textfield-input"</span> <span class="attr">id</span>=<span class="string">"msg"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container"</span> <span class="attr">style</span>=<span class="string">"padding:20px 35px"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-color-theme-accent mdui-ripple"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">onclick</span>=<span class="string">"sendMsgToServer()"</span>&gt;</span>发送 (enter)</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-color-theme mdui-ripple"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">onclick</span>=<span class="string">"clearMsg()"</span>&gt;</span>清屏</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-6 mdui-col-sm-5"</span> <span class="attr">style</span>=<span class="string">"padding:10px 0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-chip"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-icon mdui-color-blue"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span><span class="symbol">&amp;#xe420;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-title"</span>&gt;</span>聊天内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-chip"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-icon mdui-color-blue"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>face<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-title"</span>&gt;</span>在线人数<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-title chat-num"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"message-container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Html页面的编写，比较繁琐，但是没有什么特别复杂的问题，这里在开头引入了 webjar，同时也引入了各种各样的CSS，此时的我们只需要去编写文字和放置class就可以了，省去了CSS文件的编写过程。</p><h5 id="chat-JavaScript"><a href="#chat-JavaScript" class="headerlink" title="chat-JavaScript"></a>chat-JavaScript</h5><p>接下来到了最为重要的JS的编写了，我们来一步步完成吧。</p><p>首先是要完成发送按钮：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="comment">/*[[$&#123;webSocketUrl&#125;]]*/</span> <span class="string">'ws://localhost:8888/chat'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过WebSocket对象发送消息给服务端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsgToServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $message = $(<span class="string">'#msg'</span>);</span><br><span class="line">        <span class="keyword">if</span> ($message.val()) &#123;</span><br><span class="line">            webSocket.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">username</span>: $(<span class="string">'#username'</span>).text(), <span class="attr">msg</span>: $message.val()&#125;));</span><br><span class="line">            $message.val(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先从获得了id为msg的文本框，将其变成一个值，如果这个值不为空，则将其发送到后端，进行处理。</p><p>为了有更好的可视性，我们将WebSocket由函数获取，改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = getWebSocket();</span><br></pre></td></tr></table></figure><p>然后在这个getWebSocket函数中完成编写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="comment">/*[[$&#123;webSocketUrl&#125;]]*/</span> <span class="string">'ws://localhost:8888/chat'</span>);</span><br><span class="line">    </span><br><span class="line">     webSocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'WebSocket收到消息：%c'</span> + event.data, <span class="string">'color:green'</span>);</span><br><span class="line">         <span class="comment">//获取服务端消息</span></span><br><span class="line">         <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(event.data) || &#123;&#125;;</span><br><span class="line">         <span class="keyword">var</span> $messageContainer = $(<span class="string">'.message-container'</span>);</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="keyword">if</span> (message.type === <span class="string">'SPEAK'</span>) &#123;</span><br><span class="line">             $messageContainer.append(</span><br><span class="line">                 <span class="string">'&lt;div class="mdui-card" style="margin: 10px 0;"&gt;'</span> +</span><br><span class="line">                 <span class="string">'&lt;div class="mdui-card-primary"&gt;'</span> +</span><br><span class="line">                 <span class="string">'&lt;div class="mdui-card-content message-content"&gt;'</span> + message.username + <span class="string">"："</span> + message.msg + <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">                 <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         $(<span class="string">'.chat-num'</span>).text(message.onlineCount);</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    省略onopen等等。。。。。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">            <span class="keyword">return</span> webSocket;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>它看起来复杂，其实也就三步走：</p><ol><li>首先，先通过var message = JSON.parse(event.data)，将传入的数据变为JSON类型。</li><li>然后，再获取到：$(‘.message-container’)这个class标签。</li><li>最后，若这个标签不为空，则使用append()，将消息类型和样式加入到其中。</li></ol><p>这样就完成了，简单明了。最后测试一下吧：</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>打开浏览器，输入localhost:8888</p><p>并输入任意用户名，点击登录：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/2.png" alt=""></p><p>再另外打开一个网页，登录：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/3.png" alt=""></p><p>互相发送消息试试:happy:</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/4.png" alt=""></p><p>源码地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/websocket">https://github.com/Antarctica000/SpringBoot/tree/master/websocket</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/2020/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"/>
      <url>/2020/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a><strong>设计模式六大原则</strong></h2><p>每个人都有自己的想法，所以面对同一种需求，设计出来的程序都不尽相同，但是不同还是其次，当我们开始对程序进行采纳的时候，总会有一些关于智商上的争吵，何为优劣？也是一个问题，所以，在设计程序的时候，有一个主要的原则，就显得极其重要。</p><p><strong>1.单一原则（Single Responsibility Principle）</strong>：一个类只负责一项职责，尽量做到类的只有一个行为原因引起变化；</p><p>　　a、业务对象（BO business object）、业务逻辑（BL business logic）拆分；</p><p><strong>2.里氏替换原则（LSP liskov substitution principle）</strong>：子类可以扩展父类的功能，但不能改变原有父类的功能；</p><p>　　（目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p><p><strong>3.依赖倒置原则（dependence inversion principle）</strong>：面向接口编程；（通过接口作为参数实现应用场景）</p><p>　　抽象就是接口或者抽象类，细节就是实现类</p><p>　　含义：</p><p>　　　　上层模块不应该依赖下层模块，两者应依赖其抽象；</p><p>　　　　抽象不应该依赖细节，细节应该依赖抽象；</p><p>【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】</p><p><strong>4.接口隔离（interface segregation principle）</strong>：建立单一接口；（扩展为类也是一种接口，一切皆接口）</p><p>　　　定义：</p><p>　　　　a.客户端不应该依赖它不需要的接口；</p><p>　　　　b.类之间依赖关系应该建立在最小的接口上；</p><p>　【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】　　　</p><p><strong>5.迪米特原则（law of demeter LOD）</strong>：最少知道原则，尽量降低类与类之间的耦合；</p><p>一个对象应该对其他对象有最少的了解</p><p><strong>6.开闭原则（open closed principle）</strong>：用抽象构建架构，用实现扩展原则；（总纲）</p><h3 id="设计模式六大原则（1）：单一职责原则"><a href="#设计模式六大原则（1）：单一职责原则" class="headerlink" title="设计模式六大原则（1）：单一职责原则"></a><strong>设计模式六大原则（1）：单一职责原则</strong></h3><p>定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。<br>问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p><p>解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p><p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</p><p>比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p><p>举例说明，用一个类描述动物呼吸这个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>牛呼吸空气</p><p>羊呼吸空气</p><p>猪呼吸空气</p><p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Terrestrial</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aquatic</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Terrestrial terrestrial = <span class="keyword">new</span> Terrestrial();</span><br><span class="line">terrestrial.breathe(<span class="string">"牛"</span>);</span><br><span class="line">terrestrial.breathe(<span class="string">"羊"</span>);</span><br><span class="line">terrestrial.breathe(<span class="string">"猪"</span>);</span><br><span class="line"></span><br><span class="line">Aquatic aquatic = <span class="keyword">new</span> Aquatic();</span><br><span class="line">aquatic.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>牛呼吸空气</p><p>羊呼吸空气</p><p>猪呼吸空气</p><p>鱼呼吸水</p><p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"鱼"</span>.equals(animal))&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">animal.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">animal.breathe2(<span class="string">"鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p><p>例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p><p>遵循单一职责原的优点有：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p><h3 id="设计模式六大原则（2）：里氏替换原则"><a href="#设计模式六大原则（2）：里氏替换原则" class="headerlink" title="设计模式六大原则（2）：里氏替换原则"></a><strong>设计模式六大原则（2）：里氏替换原则</strong></h3><p>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p><p>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p><p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p><p>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p><p>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><p>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>100-50=50</p><p>100-80=20</p><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加100。</li></ul><p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类B完成后，运行结果：</p><p>100-50=150</p><p>100-80=180</p><p>100+20+100=220</p><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p><p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</p><p>后果就是：你写的代码出问题的几率将会大大增加。</p><h3 id="设计模式六大原则（3）：依赖倒置原则"><a href="#设计模式六大原则（3）：依赖倒置原则" class="headerlink" title="设计模式六大原则（3）：依赖倒置原则"></a><strong>设计模式六大原则（3）：依赖倒置原则</strong></h3><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p><p>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p><p>解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">System.out.println(book.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>妈妈开始讲故事</p><p>很久很久以前有一个阿拉伯的故事……</p><p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"林书豪38+7领导尼克斯击败湖人……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。</p><p>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"林书豪17+9助尼克斯击败老鹰……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(IReader reader)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">System.out.println(reader.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">mother.narrate(<span class="keyword">new</span> Newspaper());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>妈妈开始讲故事</p><p>很久很久以前有一个阿拉伯的故事……</p><p>妈妈开始讲故事</p><p>林书豪17+9助尼克斯击败老鹰……</p><p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p><p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p><p>在实际编程中，我们一般需要做到如下3点：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有。</li><li>变量的声明类型尽量是抽象类或接口。</li><li>使用继承时遵循里氏替换原则。</li></ul><p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p><h3 id="设计模式六大原则（4）：接口隔离原则"><a href="#设计模式六大原则（4）：接口隔离原则" class="headerlink" title="设计模式六大原则（4）：接口隔离原则"></a><strong>设计模式六大原则（4）：接口隔离原则</strong></h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p><p>解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>举例来说明接口隔离原则：</p><p><img src="http://www.uml.org.cn/sjms/images/2012110231.jpg" alt=""></p><p>（图1 未遵循接口隔离原则的设计）</p><p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I的方法2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I的方法3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line"><span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line"><span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I的方法4"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I的方法5"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.depend1(<span class="keyword">new</span> B());</span><br><span class="line">a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line">c.depend1(<span class="keyword">new</span> D());</span><br><span class="line">c.depend2(<span class="keyword">new</span> D());</span><br><span class="line">c.depend3(<span class="keyword">new</span> D());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p><p><img src="http://www.uml.org.cn/sjms/images/2012110232.jpg" alt=""></p><p>（图2 遵循接口隔离原则的设计）</p><p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">i.method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">i.method3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I1的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I2的方法2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I2的方法3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">i.method4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">i.method5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I1的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I3的方法4"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I3的方法5"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="设计模式六大原则（5）：迪米特法则"><a href="#设计模式六大原则（5）：迪米特法则" class="headerlink" title="设计模式六大原则（5）：迪米特法则"></a><strong>设计模式六大原则（5）：迪米特法则</strong></h3><p>定义：一个对象应该对其他对象保持最少的了解。</p><p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p><p>解决方案：尽量降低类与类之间的耦合。</p><p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p><p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubEmployee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line"><span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(SubEmployee e:list1)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">CompanyManager e = <span class="keyword">new</span> CompanyManager();</span><br><span class="line">e.printAllEmployee(<span class="keyword">new</span> SubCompanyManager());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line"><span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(SubEmployee e:list)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">sub.printEmployee();</span><br><span class="line">List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="设计模式六大原则（6）：开闭原则"><a href="#设计模式六大原则（6）：开闭原则" class="headerlink" title="设计模式六大原则（6）：开闭原则"></a><strong>设计模式六大原则（6）：开闭原则</strong></h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p><p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p><p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p><p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p>说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。</p><p><img src="http://www.uml.org.cn/sjms/images/2012110233.jpg" alt=""></p><p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。</p><p><img src="http://www.uml.org.cn/sjms/images/2012110234.jpg" alt=""></p><p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p><p>参考文献：</p><p>《设计模式》</p><p>《设计模式之禅》</p><p>《大话设计模式》</p><p><a href="https://www.cnblogs.com/Sam-2018/p/principle.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sam-2018/p/principle.html</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></p><p><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档和Druid数据源</title>
      <link href="/2020/02/05/spring8/"/>
      <url>/2020/02/05/spring8/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合Swagger文档和Druid数据源"><a href="#SpringBoot整合Swagger文档和Druid数据源" class="headerlink" title="SpringBoot整合Swagger文档和Druid数据源"></a>SpringBoot整合Swagger文档和Druid数据源</h2><p>“你写的都是一堆垃圾代码！”</p><p>“你说的对，我走了，rm -rf /* “</p><h3 id="Swagger文档"><a href="#Swagger文档" class="headerlink" title="Swagger文档"></a>Swagger文档</h3><p>我们之前在对项目进行测试的时候，使用的都是PostMan，PostMan虽然提供了很多不同的测试接口以及类型，但是在使用的时候也需要很多的配置，写URL路径等等。而且，如果传过来的json数据过多，显然无法轻易的排查差错。</p><p>并且随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、先后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。<br>前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要，swagger就是一款让你更好的书写API文档的框架。</p><p>所以，就有了Swagger文档这个框架，帮助我们快捷排查错误和API文档查看。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><p>Swagger API项目由字典网站Wordnik的技术联合创始人[1] Tony Tam于2011年创建。在Wordnik产品的开发过程中，对API文档自动化和客户端SDK生成的需求成为造成挫败感的主要原因。Tam 基于REST架构风格的灵活性并使用为SOAP构建的许多工具功能，设计了API 的简单JSON表示形式协议。用户界面的概念由Ayush Gupta提出，他认为交互式用户界面将使希望“尝试”并根据API开发的最终用户受益。Ramesh Pidikiti领导了初始代码生成器的实现，而设计师/开发人员Zeke Sikilianos创造了Swagger这个名字。Swagger API项目于2011年9月成为开源项目。发布后不久，该项目中添加了许多新组件，包括独立的验证器，对Node.js的支持和Ruby on Rails。</p><p>在Swagger成立之初，小公司和独立开发商的吸引力不大。RESTful API通常没有机器可读的描述机制，而Swagger提供了一种简单且可发现的方式。Tam被邀请参加API行业一些思想领袖的会议，其中包括John Musser（ProgrammableWeb），Marsh Gardiner（Apigee，现在是Google产品），Marco Palladino（Kong）和Kin Lane（API传播者），讨论标准化工作。关于API说明。虽然会议没有为此制定具体计划，但它使Swagger成为了API领域的一项关键创新。</p><p>在使用Apache 2.0开源许可证的帮助下，许多产品和在线服务开始在其产品中包括Swagger，在Apigee，Intuit，Microsoft，IBM和其他开始公开认可Swagger项目的公司采用之后，这些产品和在线服务迅速加速。</p><p>在创建Swagger之后不久，便引入了用于描述RESTful API的替代结构，其中最受欢迎的是2013年4月的API Blueprint和2013 年9月的RAML。尽管这些竞争产品比Swagger具有更强的财务支持，但它们最初专注于Swagger的不同用例，截至2014年中，Swagger的兴趣增长速度超过了两者的结合[来源：Google趋势]。</p><p>2015年11月，维护Swagger的公司SmartBear Software宣布，它正在Linux基金会（称为OpenAPI Initiative）的赞助下，帮助创建一个新组织。包括Google，IBM和Microsoft在内的各种公司都是创始成员。[2]</p><p>在2016年1月1日，Swagger规范被重命名为OpenAPI规范，并被移至GitHub中的新存储库。虽然规范本身未更改，但重命名表示API描述格式和开源工具之间的区别。</p><p>根据托管存储库Sonatype和npm的数据，截至2017年7月，每天Swagger工具的下载量超过100,000次。</p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>Swagger的开源工具用法可以分为不同的用例：开发，与API的交互以及文档。</p><p><strong>开发API</strong><br>创建API时，可以使用Swagger工具根据代码本身自动生成Open API文档。这被非正式地称为代码优先或自底向上的API开发。尽管软件代码本身可以准确地表示Open API文档，但许多API开发人员[ 谁？]认为这是一种过时的技术，因为它在项目的源代码中嵌入了API描述，并且通常对于非开发人员来说很难做出贡献。</p><p>另外，使用Swagger Codegen，开发人员可以将源代码与Open API文档分离，并直接从设计中生成客户端和服务器代码。尽管被认为很复杂，但许多行业专家认为这是更现代的API工作流程[ 需要引用 ]，并且通过延迟编码方面来设计API时具有更大的自由度。</p><p><strong>与API交互</strong><br>使用Swagger Codegen项目，最终用户可以直接从OpenAPI文档中生成客户端SDK，从而减少了对人工生成的客户端代码的需求。截至2017年8月，Swagger Codegen项目支持50多种不同语言和格式的客户端SDK生成。</p><p><strong>文档API</strong><br>当由OpenAPI文档描述时，可使用Swagger开源工具通过Swagger UI与API直接交互。该项目允许通过基于HTML的交互式用户界面直接连接到实时API 。可以直接从UI和界面用户探索的选项发出请求。</p><h4 id="使用Swagger"><a href="#使用Swagger" class="headerlink" title="使用Swagger"></a>使用Swagger</h4><p>在一个项目的pom文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后再写一个，由前端URL请求到后端的json数据，…….这里省略。</p><p>打开浏览器：</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;swagger-ui.html#&#x2F;</span><br></pre></td></tr></table></figure><p>可以得到一个Swagger页面：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/3.png" alt=""></p><p>然后点击controller的一个方法，进行测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/1.png" alt=""></p><p>还能够看到各种状态信息</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/4.png" alt=""></p><p>也可以选择各种的测试</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/5.png" alt=""></p><h3 id="Druid数据源"><a href="#Druid数据源" class="headerlink" title="Druid数据源"></a>Druid数据源</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>druid，阿里巴巴数据库事业部出品，为监控而生的数据库连接池 。</p><p>它包括三部分： </p><ul><li>DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 </li><li>DruidDataSource 高效可管理的数据库连接池。 </li><li>SQLParser 。</li></ul><p>功能：</p><ul><li>可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。</li><li>替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。 </li><li>数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。 </li><li>SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。</li><li>扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter-Chain机制，很方便编写JDBC层的扩展插件。</li></ul><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><table><thead><tr><th>功能类别</th><th>功能</th><th>Druid</th><th>HikariCP</th><th>DBCP</th><th>Tomcat-jdbc</th><th>C3P0</th></tr></thead><tbody><tr><td>性能</td><td>PSCache</td><td>是</td><td>否</td><td>是</td><td>是</td><td>是</td></tr><tr><td>LRU</td><td>是</td><td>否</td><td>是</td><td>是</td><td>是</td><td></td></tr><tr><td>SLB负载均衡支持</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>稳定性</td><td>ExceptionSorter</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>扩展</td><td>扩展</td><td>Filter</td><td></td><td></td><td>JdbcIntercepter</td><td></td></tr><tr><td>监控</td><td>监控方式</td><td>jmx/log/http</td><td>jmx/metrics</td><td>jmx</td><td>jmx</td><td>jmx</td></tr><tr><td>支持SQL级监控</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>Spring/Web关联监控</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td></td><td>诊断支持</td><td>LogFilter</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>连接泄露诊断</td><td>logAbandoned</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>安全</td><td>SQL防注入</td><td>是</td><td>无</td><td>无</td><td>无</td><td>无</td></tr><tr><td>支持配置加密</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr></tbody></table><p>而我们Springboot默认使用的链接池是：<strong>HikariCP</strong></p><p>我们可以自行选择，面对不同的场景，是否使用Druid。</p><h4 id="使用Druid"><a href="#使用Druid" class="headerlink" title="使用Druid"></a>使用Druid</h4><p>首先先添加依赖：</p><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在yml中添加配置：</p><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">druidDataSource</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mango?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall,log4j,config</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="string">'x'</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-open-prepared-statements:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>stat：Druid内置提供一个StatFilter,用于统计监控信息。<br>wall：Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析。Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。<br>log4j：这个就是日志记录的功能，可以把sql语句打印到log4j供排查问题。</p><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><table><thead><tr><th>配置</th><th>缺省值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错。<a href="http://blog.csdn.net/lanmo555/article/details/41248763" target="_blank" rel="noopener">详情-点此处</a>。</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。<a href="https://github.com/alibaba/druid/wiki/使用ConfigFilter">详细看这里</a></td></tr><tr><td>driverClassName</td><td>根据url自动识别</td><td>这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxPoolPreparedStatementPerConnectionSize</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句，常用select ‘x’。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。</td></tr><tr><td>validationQueryTimeout</td><td></td><td>单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>keepAlive</td><td>false （1.0.28）</td><td>连接池中的minIdle数量以内的连接，空闲时间超过minEvictableIdleTimeMillis，则会执行keepAlive操作。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td>1分钟（1.0.14）</td><td>有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td>30分钟（1.0.14）</td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接保持空闲而不被驱逐的最小时间</td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td>根据dbType自动识别</td><td>当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p>可以自定义配置文件，对Druid进行自定义属性配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.druid"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDataSourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdbc</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// jdbc connection pool</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> initialSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxActive = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWait;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis;</span><br><span class="line"><span class="keyword">private</span> String validationQuery;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> poolPreparedStatements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">private</span> String filters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置Servlet和Filter"><a href="#配置Servlet和Filter" class="headerlink" title="配置Servlet和Filter"></a>配置Servlet和Filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;DruidDataSourceProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DruidDataSourceProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        druidDataSource.setDriverClassName(properties.getDriverClassName());</span><br><span class="line">        druidDataSource.setUrl(properties.getUrl());</span><br><span class="line">        druidDataSource.setUsername(properties.getUsername());</span><br><span class="line">        druidDataSource.setPassword(properties.getPassword());</span><br><span class="line">        druidDataSource.setInitialSize(properties.getInitialSize());</span><br><span class="line">        druidDataSource.setMinIdle(properties.getMinIdle());</span><br><span class="line">        druidDataSource.setMaxActive(properties.getMaxActive());</span><br><span class="line">        druidDataSource.setMaxWait(properties.getMaxWait());</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis());</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis());</span><br><span class="line">        druidDataSource.setValidationQuery(properties.getValidationQuery());</span><br><span class="line">        druidDataSource.setTestWhileIdle(properties.isTestWhileIdle());</span><br><span class="line">        druidDataSource.setTestOnBorrow(properties.isTestOnBorrow());</span><br><span class="line">        druidDataSource.setTestOnReturn(properties.isTestOnReturn());</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(properties.isPoolPreparedStatements());</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(properties.getMaxPoolPreparedStatementPerConnectionSize());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            druidDataSource.setFilters(properties.getFilters());</span><br><span class="line">            druidDataSource.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Servlet信息， 配置监控视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="title">druidServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean&lt;Servlet&gt;(<span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//白名单：</span></span><br><span class="line"><span class="comment">//        servletRegistrationBean.addInitParameter("allow","127.0.0.1,139.196.87.48");</span></span><br><span class="line">        <span class="comment">//IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page.</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"deny"</span>,<span class="string">"192.168.1.119"</span>);</span><br><span class="line">        <span class="comment">//登录查看信息的账号密码, 用于登录Druid监控后台</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"loginUsername"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"loginPassword"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">//是否能够重置数据.</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"resetEnable"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Filter信息, 监控拦截器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;Filter&gt;();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        filterRegistrationBean.addInitParameter(<span class="string">"exclusions"</span>, <span class="string">"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是注入属性和配置连接池相关的配置，如黑白名单，监控管理后台登录账户密码等。</p><p>@EnableConfigurationProperties：用于导入上一步的Druid配置信息</p><p> public ServletRegistrationBean<Servlet> druidServlet()：相当于Web Servlet配置</p><p>public FilterRegistrationBean<Filter> filterRegistrationBean()：相当于Web Filter配置</p><h5 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/2.png" alt=""></p><p>我们发现，编译出现了错误，根据错误信息，发现缺少了log4j依赖。</p><p>log4j</p><p><strong>简介</strong></p><p>Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 log4j是几种Java日志框架（英语：Java logging framework）之一。</p><p>Gülcü此后开创了SLF4J和Logback项目，意图成为log4j的继任者。</p><p>log4j团队创建了log4j的继任者，版本号为2.0的新版本。log4j 2.0着重于log4j 1.2、1.3、java.util.logging和logback中的问题，并解决这些框架中的架构问题。此外，log4j 2.0提供了一个插件架构，这使得其更可扩展。log4j 2.0不是与1.x向后兼容的版本[2]，虽然有一个“适配器”可用</p><p><strong>日志等级</strong></p><p>下表中定义的log4j 1的日志级别和消息，以严重性递减排序。左栏列出了log4j的日志级别定义，右列提供了每个日志级别的简要说明。</p><table><thead><tr><th align="center"><strong>级别</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><strong>OFF</strong></td><td align="center">最高级别，用于关闭日志记录。</td></tr><tr><td align="center"><strong>FATAL</strong></td><td align="center">导致应用程序提前终止的严重错误。一般这些信息将立即呈现在状态控制台上。</td></tr><tr><td align="center"><strong>ERROR</strong></td><td align="center">其他运行时错误或意外情况。一般这些信息将立即呈现在状态控制台上。</td></tr><tr><td align="center"><strong>WARN</strong></td><td align="center">使用已过时的API，API的滥用，潜在错误，其他不良的或意外的运行时的状况（但不一定是错误的）。一般这些信息将立即呈现在状态控制台上。</td></tr><tr><td align="center"><strong>INFO</strong></td><td align="center">令人感兴趣的运行时事件（启动/关闭）。一般这些信息将立即呈现在状态控制台上，因而要保守使用，并保持到最低限度。</td></tr><tr><td align="center"><strong>DEBUG</strong></td><td align="center">流经系统的详细信息。一般这些信息只记录到日志文件中。</td></tr><tr><td align="center"><strong>TRACE</strong></td><td align="center">最详细的信息。一般这些信息只记录到日志文件中。自版本1.2.12。</td></tr></tbody></table><p>这里暂时不对log4j进行研究，先完成Druid的测试。</p><h5 id="添加log4j-properties"><a href="#添加log4j-properties" class="headerlink" title="添加log4j.properties"></a>添加log4j.properties</h5><p>先添加pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resource目录下建立一个log4j.properties文件，并添加：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### set log levels ###    </span></span><br><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">INFO,DEBUG, console, infoFile, errorFile ,debugfile,mail </span></span><br><span class="line"><span class="attr">LocationInfo</span>=<span class="string">true    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.console</span> = <span class="string">org.apache.log4j.ConsoleAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span> = <span class="string">System.out  </span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span> = <span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m   %x %n </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.infoFile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.Threshold</span> = <span class="string">INFO  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.File</span> = <span class="string">C:/logs/log</span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.DatePattern</span> = <span class="string">'.'yyyy-MM-dd'.log'  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.layout</span> = <span class="string">org.apache.log4j.PatternLayout  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m  %x %n </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.errorFile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.Threshold</span> = <span class="string">ERROR  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.File</span> = <span class="string">C:/logs/error  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.DatePattern</span> = <span class="string">'.'yyyy-MM-dd'.log'  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.Append</span>=<span class="string">true  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.layout</span> = <span class="string">org.apache.log4j.PatternLayout  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m  %x %n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.debugfile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.Threshold</span> = <span class="string">DEBUG  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.File</span> = <span class="string">C:/logs/debug  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.DatePattern</span> = <span class="string">'.'yyyy-MM-dd'.log'  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.Append</span>=<span class="string">true  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.layout</span> = <span class="string">org.apache.log4j.PatternLayout  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m  %x %n</span></span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>在浏览器输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;druid&#x2F;login.html</span><br></pre></td></tr></table></figure><p>用户名和密码均为admin，登录</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/6.png" alt=""></p><p>打开数据源页，可以看到数据源的配置信息</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/7.png" alt=""></p><p>再输入<a href="http://localhost:8888/user/findAll，进行访问后，打开SQL监控页面：" target="_blank" rel="noopener">http://localhost:8888/user/findAll，进行访问后，打开SQL监控页面：</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/8.png" alt=""></p><p>我们可以从这里监控到每一次的SQL读取。</p><p>Druid除了拥有更好的性能之外，还能对SQL语句的进行进行更好的监控和管理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排错指南 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Swagger </tag>
            
            <tag> Druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署MySQL</title>
      <link href="/2020/02/03/docker1/"/>
      <url>/2020/02/03/docker1/</url>
      
        <content type="html"><![CDATA[<h2 id="Dokcer"><a href="#Dokcer" class="headerlink" title="Dokcer"></a>Dokcer</h2><p>每次我们要使用一个又一个的工具的时候，总是需要非常麻烦的下载和安装，特别不方便。</p><p>但是，”人总是越来越懒的“——鲁迅。（我没有说过）</p><p>为了不怎么麻烦，节约一点时间，便诞生了Docker这个，非常方便的，一键安装所有工具的  “工具”。</p><h3 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Docker是一个开源的应用容器引擎；是一个轻量级容器技术；<br>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使<br>用这个镜像；<br>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/1.png" alt=""></p><p>Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（namespaces），来创建独立的容器（containers）。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施，</p><p>依据行业分析公司“451研究”：“Dockers是有能力打包应用程序及其虚拟容器，可以在任何Linux服务器上运行的依赖性工具，这有助于实现灵活性和便携性，应用程序在任何地方都可以运行，无论是公用云、私有云、单机等。”</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/2.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/3.jpg" alt=""></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/4.jpg" alt=""></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止</p><h4 id="在Liunx上安装docker"><a href="#在Liunx上安装docker" class="headerlink" title="在Liunx上安装docker"></a>在Liunx上安装docker</h4><p>可以选择安装虚拟机或者是买一台云服务器，以下使用虚拟机进行试验：</p><p>1）、VMWare、VirtualBox（安装）；<br>2）、导入虚拟机文件centos7-atguigu.ova；<br>3）、双击启动linux虚拟机;使用 root/ 123456登陆<br>4）、使用客户端连接linux服务器进行命令操作；<br>5）、设置虚拟机网络；<br>桥接网络=选好网卡==接入网线；<br>6）、设置好网络以后使用命令重启虚拟机的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>7）、查看linux的ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>​    8）、使用客户端连接linux；</p><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、检查内核版本，必须是3.10及以上</span><br><span class="line">uname -r</span><br><span class="line">2、安装docker</span><br><span class="line">yum install docker</span><br><span class="line">3、输入y确认安装</span><br><span class="line">4、启动docker</span><br><span class="line">[root@localhost ~]# systemctl start docker</span><br><span class="line">[root@localhost ~]# docker -v</span><br><span class="line">Docker version 1.12.6, build 3e8e77d/1.12.6</span><br><span class="line">5、开机启动docker</span><br><span class="line">[root@localhost ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">6、停止docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h3><h4 id="1）、镜像操作"><a href="#1）、镜像操作" class="headerlink" title="1）、镜像操作"></a>1）、镜像操作</h4><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h4 id="2）、容器操作"><a href="#2）、容器操作" class="headerlink" title="2）、容器操作"></a>2）、容器操作</h4><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、搜索镜像</span><br><span class="line">[root@localhost ~]# docker search tomcat</span><br><span class="line">2、拉取镜像</span><br><span class="line">[root@localhost ~]# docker pull tomcat</span><br><span class="line">3、根据镜像启动容器</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">4、docker ps  </span><br><span class="line">查看运行中的容器</span><br><span class="line">5、 停止运行中的容器</span><br><span class="line">docker stop  容器的id</span><br><span class="line">6、查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line">7、启动容器</span><br><span class="line">docker start 容器id</span><br><span class="line">8、删除一个容器</span><br><span class="line"> docker rm 容器id</span><br><span class="line">9、启动一个做了端口映射的tomcat</span><br><span class="line">[root@localhost ~]# docker run -d -p 8888:8080 tomcat</span><br><span class="line">-d：后台运行</span><br><span class="line">-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口</span><br><span class="line"></span><br><span class="line">10、为了演示简单关闭了linux的防火墙</span><br><span class="line">service firewalld status ；查看防火墙状态</span><br><span class="line">service firewalld stop：关闭防火墙</span><br><span class="line">11、查看容器的日志</span><br><span class="line">docker logs container-name/container-id</span><br><span class="line"></span><br><span class="line">更多命令参看</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/docker/</span><br><span class="line">可以参考每一个镜像的文档</span><br></pre></td></tr></table></figure><h4 id="3）、安装MySQL示例"><a href="#3）、安装MySQL示例" class="headerlink" title="3）、安装MySQL示例"></a>3）、安装MySQL示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>错误的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -d mysql</span><br><span class="line">42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846</span><br><span class="line"></span><br><span class="line">mysql退出了</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES</span><br><span class="line">42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01</span><br><span class="line">538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_</span><br><span class="line">goldstine</span><br><span class="line">c4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi</span><br><span class="line">81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//错误日志</span><br><span class="line">[root@localhost ~]# docker logs 42f09819908b</span><br><span class="line">error: database is uninitialized and password option is not specified </span><br><span class="line">  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</span><br></pre></td></tr></table></figure><p>正确的启动，主要是使用这个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</span><br></pre></td></tr></table></figure><p>做了端口映射，不过默认是3306 ，一般不设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</span><br></pre></td></tr></table></figure><p>几个其他的高级操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="meta">#</span><span class="bash">把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面</span></span><br><span class="line"><span class="meta">#</span><span class="bash">改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）</span></span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line"><span class="meta">#</span><span class="bash">指定mysql的一些配置参数</span></span><br></pre></td></tr></table></figure><h3 id="使用Navicat连接docker的mysql"><a href="#使用Navicat连接docker的mysql" class="headerlink" title="使用Navicat连接docker的mysql"></a>使用Navicat连接docker的mysql</h3><h4 id="下载安装Navicat"><a href="#下载安装Navicat" class="headerlink" title="下载安装Navicat"></a>下载安装Navicat</h4><p>适应navicat去连接虚拟机的mysql，可以使得我们的数据库有一个可以操作的界面，这样就有更好的操作空间，这里暂时不过多赘述，自行下载安装便是了。</p><h4 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h4><p>这里才是主要说的一点，现在大多数人学习的时候，采用的都是mysql80以上的版本，但是这样通常会出现一个问题：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/7.jpg" alt=""></p><p>原因：mysql 8.0 默认使用 caching_sha2_password 身份验证机制；客户端不支持新的加密方式。</p><p>解决：</p><p>修改用户（root）的加密方式</p><p>步骤：<br>1、进入mysql容器内部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it mysql01 bash   ## mysql01是容器的别名，这里也可以用容器的id代替</span><br></pre></td></tr></table></figure><p>2、登录mysql：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@e285125c99d6:/# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 11</span><br><span class="line">Server version: 8.0.13 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br></pre></td></tr></table></figure><p>3、设置用户配置项<br>1）、查看用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select host,user,plugin,authentication_string from mysql.user; </span></span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| %         | root             | caching_sha2_password | $A$005$HF7;krfwhkKHp5fPenQm4J2dm/RJtbbyjtCUVdDCcboXQw3ALxsif/sS1 |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>备注：host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码</p><p>2）、修改加密方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';  </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 123456 mysql的登录密码</span></span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>然后再查看用户信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select host,user,plugin,authentication_string from mysql.user;</span></span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| %         | root             | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>4、测试：连接成功</p><p>或者是2003错误，可以使用：</p><p>关闭并禁止firewall开机启动</p><p>停止：systemctl stop firewalld.service</p><p>禁止开机自启：systemctl disable firewalld.service</p><h3 id="部署SpringBoot项目"><a href="#部署SpringBoot项目" class="headerlink" title="部署SpringBoot项目"></a>部署SpringBoot项目</h3><p>cd到相应的目录下，使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxxx.jar</span><br></pre></td></tr></table></figure><p>但是这样只要关闭了终端，项目还是会结束。</p><p>所以需要加一个：nohub 让其能够在后台运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxxx.jar</span><br></pre></td></tr></table></figure><p>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;</p><h4 id="命令详解："><a href="#命令详解：" class="headerlink" title="命令详解："></a>命令详解：</h4><p><strong>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log  2&gt;&amp;1 &amp;</strong></p><p>nohup：不挂断地运行命令，退出帐户之后继续运行相应的进程。</p><p>“&gt;”：日志文件名.log：是nohup把command的输出重定向到当前目录的指定的“日志文件名.log”文件中，即输出内容不打印到屏幕上，而是输出到”日志文件名.log”文件中。不指定文件名会在当前目录创建nohup.out，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p><p>”2&gt;&amp;1“：2就是标准错误，1是标准输出，该命令相当于把标准错误重定向到标准输出么。这里&amp;相当于标准错误等效于标准输出，即把标准错误和标准输出同时输出到指定的“日志文件名.log”文件中。</p><p>java -jar 自己的springboot项目.jar：执行springboot的项目，如果单单只执行该命令，linux只会短暂的运行该项目，当退出控制台后会自动关闭该项目。</p><p>最后的&amp;：让改作业在后台运行。</p><p>所以一般仅仅是测试项目，建议使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxxx.jar</span><br><span class="line">或者是：</span><br><span class="line">nohup java -jar xxxx.jar &amp;</span><br></pre></td></tr></table></figure><h4 id="结束项目"><a href="#结束项目" class="headerlink" title="结束项目"></a>结束项目</h4><p>这个和liunx结束项目的方法是一致的。</p><p>查看当前所有进程：</p><p><strong>ps -aux</strong></p><p>查看筛选的进程：</p><p><strong>ps -aux|grep “xxxxxx”</strong></p><p>查看二次筛选的进程：</p><p><strong>ps -aux|grep “xxxxxx”|grep -v “aaa”</strong></p><p>结束进程：<br><strong>kill -9 8888</strong></p><p>注：</p><ol><li>grep -v “grep”是指过滤掉含有”grep”的进程</li><li>“|”是指用前面的输出作为输入</li><li>kill后面跟的是进程号</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 排错指南 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排错：mybatis报错：Invalid bound statement (not found)</title>
      <link href="/2020/02/01/error1/"/>
      <url>/2020/02/01/error1/</url>
      
        <content type="html"><![CDATA[<h3 id="Invalid-bound-statement-not-found"><a href="#Invalid-bound-statement-not-found" class="headerlink" title="Invalid bound statement (not found)"></a>Invalid bound statement (not found)</h3><p>在使用mybatis时，有时候会出现一些逻辑上解释不通的错误，这个时候就需要一本排错指南，记住这些常见的错误。</p><p>出现错误并不代表他复杂且难以理解，在有时候，某些错误就和电脑重开机就能解决90%的问题一样，充满玄学。</p><h4 id="第一种：语法错误"><a href="#第一种：语法错误" class="headerlink" title="第一种：语法错误"></a><strong>第一种：语法错误</strong></h4><p>Java DAO层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@Param(<span class="string">"id"</span>)</span>String id)</span>;</span><br></pre></td></tr></table></figure><p>Java 对应的mapper.xml文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"xxx.xxx.xxx.Mapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 删除数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">        DELETE FROM xxx WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>检查：1. 接口中方法名（delete）与xml文件中 id=”delete”是否一致</p><p>　　　2. xml文件中的 namespace=”xxx.xxx.xxx.Mapper” 中的路径是否与接口文件路径一致</p><p>　　　3.parameterType类型 与 resultType类型是否准确；resultMap与resultType是不一样的。</p><h4 id="第二种：编译错误"><a href="#第二种：编译错误" class="headerlink" title="第二种：编译错误"></a><strong>第二种：编译错误</strong></h4><p>　定位到项目路径下：target\classes\ 中报错路径下，寻找对应的xml文件是否存在。</p><p>（1）若不存在对应的xml文件，则需要在pom.xml中加入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　删除classes文件夹中文件，重新编译，出现了对应的xml文件即可。</p><p>（2）若存在xml文件，则打开xml文件，检查其中报错部分是否与源文件一致，不一致，则</p><p>　　先清除classes文件夹中文件，执行命令：mvn clean 清理内容，重新编译后即可。</p><h4 id="第三种：配置错误"><a href="#第三种：配置错误" class="headerlink" title="第三种：配置错误"></a><strong>第三种：配置错误</strong></h4><p>在配置文件中指定扫描包时，配置路径有问题。例如：spring配置文件中”basePackage” 属性包名的指定一定要具体到接口所在包，而不要写父级甚至更高级别的包 ，否则可能出现问题；cn.dao 与cn.*也可能导致错误；注解扫描时，可能没有扫描到包等。</p><h4 id="第四种-细节错误"><a href="#第四种-细节错误" class="headerlink" title="第四种 细节错误"></a>第四种 细节错误</h4><p>比如：</p><p>忘记在配置文件上加别名</p><p>忘记开启驼峰命名法</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.thymeleaf.pojo</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="第五种-弱智型错误"><a href="#第五种-弱智型错误" class="headerlink" title="第五种 弱智型错误"></a>第五种 弱智型错误</h4><p>再比如：</p><p>文件头没加@MapperSacn</p><p>或者是xml的文件头没加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 排错指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB存储引擎</title>
      <link href="/2020/01/29/mysql3/"/>
      <url>/2020/01/29/mysql3/</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p><h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>Master Thread是一个非常核心的后台线程,主要负责将缓冲池的数据异步刷新到磁盘,保证数据的一致性,包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</p><h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>在InnoDB存储引擎使用大量的AIO（Async IO） 来处理IO请求，这样可以极大提高数据库的性能。<br>在Linux平台下 IO Thread的数量不能进行调整，在windows平台1.0.x版本开始 分别使用 innodb_read_io_threads 和 innodb_write_io_theads参数进行设置,如:</p><p>mysql&gt;SHOW VARIABLES LIKE ‘innodb_version’\G;</p><p>mysql&gt; SHOW VARIABLES LIKE ‘innodb_%io_threads’\G;</p><p>通过SHOW ENGINE INNODB STATUS\G; 观察 InnoDB 中的IO Thread。</p><h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>事务被提交后,其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。<br>在InnoDB 1.1 版本中 innodb_purge_rgreads设为大于1,存储启动将其设为1,并报错。</p><p>在InnoDB1.2版本开始 InnoDB 支持多个Purge Thread。</p><h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>Page Cleaner Thread在InnoDB 1.2.x版本中引入的。其作用是将之前版本中的脏页的刷新操作放入到单独的线程中完成。</p><h3 id="InnoDB内存"><a href="#InnoDB内存" class="headerlink" title="InnoDB内存"></a>InnoDB内存</h3><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>InnoDB存储引擎是基于磁盘存储的,并将其中的记录按照页的方式进行管理。<br>缓存池简单来说就是一块内存区域。</p><p>通过参数innodb_buffer_pool_size配置缓存池: show variables like ‘innodb_buffer_pool_size’\G</p><p>内存结构：</p><p><img src="https://box.kancloud.cn/4cd2284ff4362e47710ebe90aa9fc9d4_794x299.png" alt=""></p><p>具体来看缓冲池中缓存的数据页类型有:<br>索引页: 缓存数据表索引<br>数据页: 缓存数据页，占缓冲池的绝大部分<br>undo页: undo页是保存事务，为回滚做准备的。<br>插入缓冲(Insert buffer): 上面提到的插入数据时要先插入到缓存池中。<br>自适应哈希索引(adaptive hash index): 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。<br>InnoDB存储的锁信息(lock info):<br>数据字典(data dictionary):<br>内存中除了缓冲池外外还有:<br>重做日志缓冲redo log: 为了避免数据丢失的问题，当前数据库系统普遍采用了write ahead log策略，既当事务提交时先写重做日志，再修改写页。当由于发生宕机而导致数据丢失时，可以通过重做日志进行恢复。InnoDB先将重做日志放到这个缓冲区，然后按照一定的频率更新到重做日志文件中。重做日志一般在下列情况下会刷新内容到文件:</p><p>1.Master Thread每一秒将重做日志缓冲刷新到重做日志文件<br>2.每个事务提交时会将重做日志缓冲刷新到重做日志文件<br>3.当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件<br>额外内存池: InnoDB存储引擎中，对内存的管理师通过一种称为内存堆的方式进行的，在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。<br>缓冲池是一个很大的内存区域，InnoDB是如何对这些内存进行管理的呢。答案就使用LRU list。<br>LRU(Latest Recent Used, 最近最少使用)算法默认的是最近使用的放到表头，最早使用的放到表尾，依次排列。当有LRU填满时有新的进来就把最早的淘汰掉。InnoDB则是在这个基础上进行了修改:</p><p>最近使用的不放到表头，而是根据配置放到一定比例处，这个地方叫做midpoint, midpoint之前的成为new列表，之后的成为old列表。淘汰的同样是表尾的页。<br>为了保证new列表的不经常使用时能够淘汰，设置了一个超时时间:innodb_old_blocks_time，当数据在midpoint(我理解应该是在old列表中，不然这个点的页就一个，变化也比较频繁)的时间超过找个时间时就会被提升到表头，new列表的表尾页则被置换到old列表中。<br>这么做的原因主要是因为常见的索引或数据的扫描操作会连续读取大量的页，甚至是全表扫描。如果采用原来的LRU算法就会更新全部的缓冲池，其他查询需要的热点数据就会被冲走，导致更多的磁盘读取操作，降低数据库的性能。<br>LRU是用来管理已经读取的页，当数据库启动时LRU是空列表,既只有表头，没有内容。这时页都放在Free List中。当需要有数据读写时要进行需要获取分页，这时要从Free List中删除分页，然后添加到LRU list中。到一定时间Free List中的分页就会被分配完毕，这时候就正常使用上面的LRU策略。<br>LRU列表中的页被修改后，称该页为脏页(dirty page),既缓冲池中的数据和磁盘上的数据产生了不一致，这时脏页会被加入到一个Flush 列表中(注意，同时存在两个列表中)。然后根据刷新的机制定时的刷新到磁盘中。</p><p>InnoDB 1.0.x开始允许多个缓存实例。</p><p>参数innodb_buffer_pool_instances来进行配置 默认唯一。</p><p><img src="https://box.kancloud.cn/3908739be0890daefa25489ed6c4d488_700x94.png" alt=""></p><p>参数innodb_buffer_pool_instances可以设置大于1的值就可以得到多个缓冲池实例。</p><p>再通过命令SHOW ENGINE INNODB STATUS\G; 观察内容</p><p>mysql5.6开始:<br>SELECT POOL_ID POOL_SIZE, FREE_BUFFERS,DATABASE_PAGES FROM INNODB_BUFFER_POOL_STATS\G<br>查看缓冲状态。</p><h4 id="LRU-List、Free-List-和-Flush-List"><a href="#LRU-List、Free-List-和-Flush-List" class="headerlink" title="LRU List、Free List 和 Flush List"></a>LRU List、Free List 和 Flush List</h4><p>缓存池默认页大小16kB，同样使用LRU算法进行缓冲池进行管理。</p><p><img src="https://box.kancloud.cn/8b5de1bc2ab5e5df499a92cdd1e15757_802x363.png" alt=""></p><p>通过information_schema架构下的表观察unzip_LRU列表中的页:SELECT TABLE_NAME,SPACE,PAGE_NUMBER,COMPRESSED_SIZE FROM INNODB_BUFFER_PAGE_LRU WHERE C OMPRSSED_SIZE &lt;&gt; 0;</p><p>Flush List为脏页列表;</p><p><img src="https://box.kancloud.cn/0a771448997c98db048fddca47971938_792x154.png" alt=""></p><h4 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h4><p><img src="https://box.kancloud.cn/f75f7e4ec65857de30137f676e37cc77_841x328.png" alt=""></p><h4 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h4><p>在对一些数据结构本身的内存进行分配时,需要从额外的内存池中进行申请,当该区域的内存不够的时候,会从缓冲池进行申请。</p><h3 id="InnoDB存储引擎三大特性"><a href="#InnoDB存储引擎三大特性" class="headerlink" title="InnoDB存储引擎三大特性"></a>InnoDB存储引擎三大特性</h3><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><p>innodb使用insert buffer”欺骗”数据库:对于为非唯一索引，辅助索引的修改操作并非实时更新索引的叶子页,而是把若干对同一页面的更新缓存起来做合并为一次性更新操作,转化随机IO 为顺序IO,这样可以避免随机IO带来性能损耗，提高数据库的写性能。</p><p><img src="https://box.kancloud.cn/d68efa9ed3220fc7016e36450b2a534e_826x388.png" alt=""></p><p>IBUF_POOL_SIZE_PER_MAX_SIZE参数修改默认为2 即为最大缓存为1/2 如果将其改为3 这最大能够使用1/3的缓存池内存。</p><h5 id="聚簇索引与非聚簇索引的区别"><a href="#聚簇索引与非聚簇索引的区别" class="headerlink" title="聚簇索引与非聚簇索引的区别"></a>聚簇索引与非聚簇索引的区别</h5><p>聚集索引的叶子节点存储的是数据，而且是按照物理顺序存储的;非聚集索引叶子节点是地址(也就是聚集索引键地址)，是按照逻辑顺序存储的(以上言论是从网上了解到的，但是，聚集索引也不是按照物理地址连续的，而是逻辑上连续的)。</p><h5 id="高并发后的insert会发生什么？"><a href="#高并发后的insert会发生什么？" class="headerlink" title="高并发后的insert会发生什么？"></a>高并发后的insert会发生什么？</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t ( id int auto_increment, </span><br><span class="line">name varchar(30),primary key (id),key(name));  </span><br><span class="line">Query OK, 0 rows affected (0.21 sec)</span><br></pre></td></tr></table></figure><p>我们知道，主键是行唯一的标识符，在应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要磁盘的随机读取，速度会很快，但是我们看到上一个表还有一个叫做name的索引字段，这样的情况下产生了一个非聚集的并且不是唯一的索引。在进行插入操作时，数据页的存放还是按主键id的执行顺序存放，但是对于非聚集索引，叶子节点的插入不再是顺序的了。这时就需要离散地访问非聚集索引页，插入性能在这里变低了。然而这并不是这个name字段上索引的错误，是因为B+树的特性决定了非聚集索引插入的离散性</p><h5 id="插入缓冲的实现"><a href="#插入缓冲的实现" class="headerlink" title="插入缓冲的实现"></a>插入缓冲的实现</h5><p><img src="http://www.plantuml.com/plantuml/svg/LKvB2e906DxFAMPfLz1TkuuHD98G5iwqQ5U14j6Bx06zo22em5wOA5YdyH_r5WtOfc_vlIah6mp9V3m5yyXx2xxs-EAk84t5KhRTfPrLjhOIxm3HF7DUi3abaGtMap_sSU0MCAiI7KijGWi82yY9Y8-EUPk2I8qIBEdrdyXd7q77GJiEBYMT4eFXObDLYG6tC7queb39ZN1TyQN_RvaEqey9_NF-1SO-k9Eqtqsw8Knw4FhS7iRlZTZKAvgAAAitlW00" alt=""></p><p>在innodb的1.0x版本开始，引入了change buffer，可以把它看成insert buffer的升级版，innodb可以对DML操作-INSERT/DELETE/UPDATE都进行缓冲。<br>1.将一个辅助索引插入到页(space,offset)<br>2.检查这个页是否在缓冲池中<br>在:直接插入<br>不在:继续<br>3.缓存进入insert buffer<br>4.构造一个search key<br>5.查询insert buffer树<br>6.生成逻辑记录并插入树中</p><h5 id="insert-buffer内部实现原理"><a href="#insert-buffer内部实现原理" class="headerlink" title="insert buffer内部实现原理"></a>insert buffer内部实现原理</h5><p>在mysql4.1版本之后，insert buffer是通过一全局唯一的一个B+树进行管理所有表的辅助索引。而这颗树存放在共享表空间中，格式为ibdata1，所以如果试图通过独立表空间idb文件恢复表中数据的时候，往往会导致CHECK TABLE失败，这是因为表的辅助索引中的数据可能还在INSERT BUFFER中，也就是共享表空间中，所以通过ibd文件进行恢复后，还需要进行REPAIR TABLE 操作来重建表上所有的辅助索引。</p><p>insert buffer的b+树的非叶子节点存放的是查询的search key（键值），其构造如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/8.png" alt=""></p><ul><li>space为表空间id</li><li>marker用来兼容老版本</li><li>offset表示页所在偏移量</li></ul><p>叶子节点会比非叶子节点多俩数据，一个是metadata，一个是secondary index record。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/7.png" alt=""></p><ul><li>metadata 记录的每一列的类型,长度</li><li>secondary index record 记录的具体值</li></ul><p>为了保证每个辅助索引页Merge Insert Buffer的B+树必须成功，还需要有一个特殊的页用来标记每个辅助索引页（space，page_no）的可用空间。这个页的类型为Insert Buffer Bitmap。它会标记16385个辅助索引页，每个辅助索引页会在其中占用4bit的位置来记录信息，具体信息如下：</p><p>Merge Insert Buffer的操作可能发生在以下几种情况下：</p><ul><li>辅助索引页被读取到缓冲池时；</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；</li><li>Master Thread。</li></ul><p>第一种情况为当辅助索引页被读取到缓冲池中时，例如这在执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中。若有，则将Insert Buffer B+树中该页的记录插入到该辅助索引页中。可以看到对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。<br>Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间。若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。这就是上述所说的第二种情况。<br>还有一种情况，之前在分析Master Thread时曾讲到，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。</p><h5 id="缓冲的限制条件"><a href="#缓冲的限制条件" class="headerlink" title="缓冲的限制条件"></a>缓冲的限制条件</h5><p>插入缓冲的启用需要满足一下两个条件：<br>1）索引是辅助索引（secondary index）<br>2）索引不适合唯一的<br>原因是因为插入缓冲本身就是为了解决二级索引离散插入的问题，所以建立一个缓冲区将部分离散的索引数据合并，使用一次大的IO操作统一刷到磁盘，如果索引是唯一的，那这么做将失去意义，而且每次还需要去询问数据页是否已经存在，还会增加额外的IO操作。</p><h5 id="插入缓冲性能影响"><a href="#插入缓冲性能影响" class="headerlink" title="插入缓冲性能影响"></a>插入缓冲性能影响</h5><p>任何一项技术在带来好处的同时，必然也带来坏处。插入缓冲主要带来如下两个坏处：<br>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\g;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">2</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="number">0.00</span> <span class="keyword">hash</span> searches/s, <span class="number">0.00</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure><p>从上面可以看到其中有一部分叫做INSERT BUFFER AND ADAPTIVE HASH INDEX，其中的seg size指的就是当前insert buffer的大小，具体计算方式为seg_size*16KB =32KB，free list len表示空闲列表的长度，size表示已经合并记录页的数量。</p><h4 id="二次写（double-write）"><a href="#二次写（double-write）" class="headerlink" title="二次写（double write）"></a>二次写（double write）</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>doublewrite由两部分组成,一部分是内存的doublewrite buffer,大小为2MB,另一部分是物理磁盘上共享表空间中联系的128个页,即2个区(extent),大小同样为2MB。<br>脏读刷新先复制到内存中的doublewrite buffer，之后doublewrite buffer再分两次，每次1MB写入共享表空间的物理磁盘，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/12.png" alt=""></p><p>通过命令SHOW GLOBAL STATUS LIKE ‘innodb dblwr%’\G观察doublewrite运行的情况。</p><h5 id="页断裂（partial-write）"><a href="#页断裂（partial-write）" class="headerlink" title="页断裂（partial write）"></a>页断裂（partial write）</h5><p>所谓页断裂是数据库宕机时(OS重启，或主机掉电重启)，数据库页面只有部分写入磁盘，导致页面出现不一致的情况。那么为什么会不一样呢？因为数据库，OS和磁盘读写的基本单位是块，也可以称之为(page size)block size。我们知道数据库的块一般为8K，16K；而OS的块则一般为4K；IO块则更小，linux内核要求IO block size&lt;=OS block size。磁盘IO除了IO block size，还有一个概念是扇区(IO sector)，扇区是磁盘物理操作的基本单位，而IO 块是磁盘操作的逻辑单位，一个IO块对应一个或多个扇区，扇区大小一般为512个字节。所以各个块大小的关系可以梳理如下：<br>DB block &gt; OS block &gt;= IO block &gt; 磁盘 sector，而且他们之间保持了整数倍的关系。所以说当数据库突然宕机，就会造成部分DB block的数据实际上并未写入到磁盘的sector中，出现了页断裂的情况，进而导致数据不一致的现象。</p><h5 id="数据库日志的三种格式"><a href="#数据库日志的三种格式" class="headerlink" title="数据库日志的三种格式"></a>数据库日志的三种格式</h5><p>数据库系统实现日志主要有三种格式，逻辑日志(logical logging)，物理日志(physical logging)，物理逻辑日志(physiological logging)，逻辑日志，记录一个个逻辑操作，不涉及物理存储位置信息，比如mysql的binlog；物理日志，则是记录一个个具体物理位置的操作，比如在2号表空间，1号文件，48页的233这个offset地方写入了8个字节的数据，通过(group_id,file_id,page_no,offset)4元组，就能唯一确定数据存储在磁盘的物理位置；物理逻辑日志是物理日志和逻辑日志的混合，如果一个数据库操作(DDL，DML，DCL)产生的日志跨越了多个页面，那么会产生多个物理页面的日志，但对于每个物理页面日志，里面记录则是逻辑信息。这里我举一个简单的INSERT操作来说明几种日志形式。<br>比如innodb表T(c1,c2, key key_c1(c1)),插入记录row1(1,’abc’)<br>逻辑日志：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert OP, T, 1,’abc’&gt;</span><br></pre></td></tr></table></figure><p>逻辑物理日志：因为表T含有索引key_c1, 一次插入操作至少涉及两次B树操作，二次B树必然涉及至少两个物理页面,因此至少有两条日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert OP, page_no_1, log_body&gt;</span><br><span class="line">&lt;insert OP, page_no_2, log_body&gt;</span><br></pre></td></tr></table></figure><p>物理理日志：由于一次INSERT操作，物理上来说要修改页头信息(如,页内的记录数要加1)，要修改相邻记录里的链表指针，要修改Slot属性等，因此对应逻辑物理日志的每一条日志，都会有N条物理日志产生。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; group_id,file_id,page_no,offset1, value1&gt;</span><br><span class="line">&lt; group_id,file_id,page_no,offset2, value2&gt;</span><br><span class="line">……</span><br><span class="line">&lt; group_id,file_id,page_no,offsetN, valueN&gt;</span><br></pre></td></tr></table></figure><p>因此对于上述一个INSERT操作，会产生一条逻辑日志，二条逻辑物理日志，2*N条物理日志。从上面简单的分析可以看出，逻辑日志的日志量最小，而物理日志的日志量最大；物理日志是纯物理的；而逻辑物理日志则页间物理，页内逻辑，所谓physical-to-a-page, logical-within-a-page。</p><h5 id="页断裂和数据一致性"><a href="#页断裂和数据一致性" class="headerlink" title="页断裂和数据一致性"></a>页断裂和数据一致性</h5><p>前面我们分析了异常重启导致页断裂的原因，而页断裂就意味着数据库页面不完整，那么数据库页面不完整就意味着数据库不一致。我们知道，数据库异常重启时，自身有异常恢复机制，主流数据库基本原理类似：第一阶段重做redo日志，恢复数据页和undo页到异常crash时的状态；第二阶段，根据undo页的内容，回滚没有提交事务的修改。通过两个阶段保证了数据库的一致性。对于mysql而言，在第一阶段，若出现页断裂问题，则无法通过重做redo日志恢复，进而导致恢复中断，数据库不一致。这里大家可能会有疑问，数据库的redo不是记录了所有的变更，并且是物理的吗？理论上来说，无论页面是否断裂，从上一个检查点对应的redo位置开始，一直重做redo，页面自然能恢复到正常状态。对吗？</p><h5 id="redo格式与数据一致性"><a href="#redo格式与数据一致性" class="headerlink" title="redo格式与数据一致性"></a>redo格式与数据一致性</h5><p>回到“发生页断裂后，是否会影响数据库一致性”的问题，发生页断裂后，对于利用纯物理日志实现redo的数据库不受影响，因为每一条redo日志完全不依赖物理页的状态，并且是幂等的(执行一次与N次，结果是一样的)，而逻辑物理日志则不行，比如修改页头信息，页内记录数加1，slot信息修改等都依赖于页面处于一个一致状态，否则就无法正确重做redo。而mysql正是采用这种日志类型，另外要说明一点，redo日志的页大小一般设计为512个字节，因此redo日志页本身不会发生页断裂。所以发生页面断裂时，异常恢复就会出现问题，需要借助于double write技术来辅助处理。</p><h5 id="doubleWrite的实现"><a href="#doubleWrite的实现" class="headerlink" title="doubleWrite的实现"></a>doubleWrite的实现</h5><p>在InnoDB将BP中的Dirty Page刷（flush）到磁盘上时，首先会将（memcpy函数）Page刷到InnoDB tablespace的一个区域中，我们称该区域为Double write Buffer（大小为2MB，每次写入1MB，128个页，每个页16k,其中120个页为后台线程的批量刷Dirty Page，还有8个也是为了前台起的sigle Page Flash线程，用户可以主动请求，并且能迅速的提供空余的空间）。在向Double write Buffer写入成功后，第二步、再将数据分别刷到一个共享空间和真正应该存在的位置。具体的流程如下图所示：<br><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/9.png" alt=""></p><h5 id="doubleWrite的保护机制"><a href="#doubleWrite的保护机制" class="headerlink" title="doubleWrite的保护机制"></a>doubleWrite的保护机制</h5><p>下面来看下在不同的写入阶段，操作系统crash后，double write带来的保护机制：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/10.png" alt=""></p><p>阶段一：copy过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可阶段二：write到共享表空间过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可阶段三：write到独立表空间过程中，操作系统crash，重启之后，发现：（1）数据文件内的页损坏：头尾checksum值不匹配（即出现了partial page write的问题）。从共享表空间中的doublewrite segment内恢复该页的一个副本到数据文件，再应用redo log；（2）若页自身的checksum匹配，但与doublewrite segment中对应页的checksum不匹配，则统一可以通过apply redo log来恢复。）阶段X：recover过程中，操作系统crash，重启之后，innodb面对的情况同阶段三一样（数据文件损坏，但共享表空间内有副本），再次应用redo log即可。</p><h5 id="doubleWrite对性能的影响"><a href="#doubleWrite对性能的影响" class="headerlink" title="doubleWrite对性能的影响"></a>doubleWrite对性能的影响</h5><p>系统需要将数据写两份，一般认为，Double Write是会降低系统性能的。peter猜测可能会有5-10%的性能损失，但是因为实现了数据的一致，是值得的。Mark Callaghan认为这应该是存储层面应该解决的问题，放在数据库层面无疑是牺牲了很多性能的。事实上，Double Write对性能影响并没有你想象（写两遍性能应该降低了50%吧？）的那么大。在BP中一次性往往会有很多的Dirty Page同时被flush，Double Write则把这些写操作，由随机写转化为了顺序写。而在Double Write的第二个阶段，因为Double Write Buffer中积累了很多Dirty Page，所以向真正的数据文件中写数据的时候，可能有很多写操作可以合并，这样有可能会降低Fsync的调用次数。基于上面的原因，Double Write并没有想象的那么糟。最后发现打开和关闭Double Write对效率的影响并不大。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>哈希索引只有Memory, NDB两种引擎支持，Memory引擎默认支持哈希索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储。但是，Memory引擎表只对能够适合机器的内存切实有限的数据集。要使InnoDB或MyISAM支持哈希索引，可以通过伪哈希索引来实现，但是innodb还实现了一种叫做自适应哈希索引来达到目的。<br>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><h5 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">……</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br></pre></td></tr></table></figure><p>1、34673：字节为单位，占用内存空间总量</p><p>2、通过hash searches、non-hash searches计算自适应hash索引带来的收益以及付出，确定是否开启自适应hash索引</p><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>　　1、只能用于等值比较，例如=， &lt;=&gt;，in<br>　　2、无法用于排序<br>　　3、有冲突可能<br>　　4、MySQL自动管理，人为无法干预。</p><h5 id="自适应哈希索引的控制"><a href="#自适应哈希索引的控制" class="headerlink" title="自适应哈希索引的控制"></a>自适应哈希索引的控制</h5><p>由于innodb不支持hash索引，但是在某些情况下hash索引的效率很高，于是出现了adaptive hash index功能，但是通过上面的状态监控，可以计算其收益以及付出，控制该功能开启与否。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/11.png" alt=""></p><h4 id="其他关键特性"><a href="#其他关键特性" class="headerlink" title="其他关键特性"></a>其他关键特性</h4><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO,AIO）的方式来处理磁盘操作。<br>与AIO对应的是 Sync IO，Sync IO每次进行IO操作 需要等到改操作结束才能继续接下来的操作。但是如果用户是一条索引扫描的查询，那么需要扫描索引页，也就是需要进行多次的IO操作。如果是这样的话就没有必要了。</p><p>用户发送一个IO请求就可以发送另一个IO请求，当全部发送完毕，等待所有的IO操作的完成，这就是AIO。<br>AIO的另一个优势 可以进行IO Merge操作，也就是将多个IO何必为一个IO。<br>若通过Linux操作系统下的iostat 命令 可以观察 rrqm/s和wrqm/s。<br>InnoDB 1.1.x 开始（InnoDB Plugin 不支持）提供了内核级别AIO的支持，称为 NatIve AIO。因此编译或者运行该版本MySQL时需要libaio的支持。若没有则会出现如下的提示：</p><p><img src="https://box.kancloud.cn/caa0fef240a025c16fbe4d9d842f0009_846x84.png" alt=""></p><p>Native AIO只有windows 和linux系统支持。Mac OSX不支持。参数innodb_use_native_aio 控制师傅启动 liunx默认不启动。</p><p>SHOW VARIABLES LIKE ‘innodb_use_native_aio’\G</p><p><img src="https://box.kancloud.cn/18a374770ed2be0874341ccf079c9cf2_677x117.png" alt=""></p><p>官方显示，启用NatIve AIO，恢复速度可以提高75%。<br>read ahead方式读取都是通过AIO完成，脏页的刷新和磁盘写入操作则全部由AIO完成。</p><h5 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h5><p>InnoDB存储引擎还提供了Flush Neighbor Page(刷新邻接页)的特性。工作原理：当刷新脏页时，InnoDB存储引擎会检测所在区的所有页，如果是脏页，那么一起进行刷新。<br>参数innodb_flush_neighbors 控制是否启用改特性.如果是机械硬盘建议启用，如果是固态硬盘就不建议使用 IOPS性能的磁盘 则建议设置为0，关闭此特性。</p><h5 id="启动、关闭和恢复"><a href="#启动、关闭和恢复" class="headerlink" title="启动、关闭和恢复"></a>启动、关闭和恢复</h5><p>关闭时参数innodb_fast_shutdown影响着表存储引擎InnoDB的行为。该参数可取值为0、1、2，默认为1</p><p><img src="https://box.kancloud.cn/fc3c79f738da0285b045df30098e7257_824x319.png" alt=""></p><p>当正常关闭MySQL数据库时，下次的启动应该会非常“正常”。但是没有正常关闭 如用kill命令关闭数据库，在MySQL 数据库运行中重启服务器，或者关闭数据库时，将参数innodb_fast_shuidown设为了2时,下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数innodb_force_recovery影响了正规InnoDB存储引擎恢复的状况。默认为0，代表当发生需要恢复时，进行所有恢复的操作，当不能进行有效恢复时，如数据页发送了corruption，MySQL数据库可能发送宕机（crash），并把错误写入错误日志中去。</p><p>如果用户知道怎么进行恢复 比如进行alter table操作是发生意外了，数据库重启会对InnoDB进行回滚操作，对于大表涞水需要很长时间，所以可以把表删除，从备份中导入数据到表。速度就会比回滚操作快。</p><p><img src="https://box.kancloud.cn/9b3c7309d263250656fdfb9387f8fbf9_804x237.png" alt=""></p><p>如果innodb_force_recovery 设置为3 则不需要回滚,因此数据库很快就启动完成了。 但是需要仔细确认是否需要回滚事务操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务的特性和隔离级别</title>
      <link href="/2020/01/28/mysql2/"/>
      <url>/2020/01/28/mysql2/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="comment">-- 第一步：将id=1的A账户余额减去100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 第二步：将id=2的B账户余额加上100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<strong>事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><h3 id="事务管理-ACID"><a href="#事务管理-ACID" class="headerlink" title="事务管理(ACID)"></a>事务管理(ACID)</h3><p>讲到事务，一般就有一些评判标准，就像volatile有一致性和可见性而没有原子性一样，对于事务，也有四种特性：</p><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>这个原子性和并发中的原子性类似，但不完全一样。并发中的原子性表示操作不可分割，要么执行完，要么不执行。这个放在数据库也是一样的：</p><p>举个例子，A向B转账，会出现两个步骤：</p><ul><li>A扣除100块</li><li>B获得100块</li></ul><p>这两个步骤要么不执行，要么一起执行，这就是原子性。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>就以上面的例子而言，一致性就是必须符合运算逻辑：</p><ul><li>A必须扣除的数值是100，而不是90或者是其他数值。</li><li>B收到的数值必须是A扣除的数值，假如A因特殊原因只扣到50，B也只能收到50。</li></ul><h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a><strong>持久性（Durability）</strong></h4><p>表示事务结束后的数据不随着外界原因导致数据丢失</p><p>操作前A：800，B：200<br>操作后A：600，B：400<br>如果在操作前（事务还没有提交）服务器宕机或者断电，那么重启数据库以后，数据状态应该为<br>A：800，B：200<br>如果在操作后（事务已经提交）服务器宕机或者断电，那么重启数据库以后，数据状态应该为<br>A：600，B：400</p><h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a><strong>隔离性（Isolation）</strong></h4><p>针对多个用户同时操作，主要是排除其他事务对本次事务的影响。就比如多个事务同时进行，存在ABCD互相转账，要根据实际情况来进行数据的隔离。</p><h3 id="隔离的级别"><a href="#隔离的级别" class="headerlink" title="隔离的级别"></a>隔离的级别</h3><h4 id="未提交读（Read-uncommitted）"><a href="#未提交读（Read-uncommitted）" class="headerlink" title="未提交读（Read uncommitted）"></a>未提交读（Read uncommitted）</h4><p>未提交读是最低的隔离级别，但这种隔离级别有着最高的效率，在这种情况允许一个未提交的事务去读取另一个未提交的事务，可以让一个事务被数据库处理之前，已经把两个事务应该处理的数据处理完毕。</p><p>但是如此高效率的处理方式，容易引起一个糟糕的现象，叫做脏读：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/1.png" alt=""></p><p>在T3时刻，事务2去读取了事务1的数据，并进行了处理，然后提交。但是这个时候，如果发生了因为第一类丢失更新而导致的回滚，（第一类丢失更新是指在高并发情况下产生的数据丢不一致，但现已经被克服，所以会产生回滚），但是因为数据是在事务2被处理完成的，如果将事务1进行回滚，将不会回滚为2，而是直接为0。这样会导致最后的订单数少于总库存量。</p><p>还有一种情况下：</p><ul><li><p>T1 事务读取账户余额 100 块，取钱，将余额修改为 50 块，但并没有提交。</p></li><li><p>T2 事务读取了 <strong>尚未提交</strong> 的数据，认为余额是 50 块。</p></li><li><p>T1 事务回滚。</p></li><li><p>T2 事务存钱 100 块，将余额计算为 50 + 100 = 150 块，此为脏数据，实际余额应该为 200 块。</p></li></ul><p>在高并发情况下，很容易会发生第一类丢失更新，这个时候，事务1执行过程中修改了数据X，在未提交前，事务2读取了X，而事务1却回滚了，这样事务2就形成了脏读。也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。</p><h4 id="读写提交（Read-committed）"><a href="#读写提交（Read-committed）" class="headerlink" title="读写提交（Read committed）"></a>读写提交（Read committed）</h4><p>是指一个事务只能读取到另外一个事务已经提交的数据。</p><p>就以上述例子而言，因为总是读取到尚未提交的数据，才导致的数据不一致，那么，就只读取已经提交的数据便可以的，如此克服脏读：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/2.png" alt=""></p><p>但是读写提交也会导致下面的问题：那就是当我们事务2读取到了库存之后，事务1马上提交事务，导致事务2读取到的库存是脏的、错误的库存。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/3.png" alt=""></p><p>T3时刻读取到库存为1，由于事务尚未提交，所以就导致了事务2误以为还能够进行减库存，但随之事务1便进行了提交，最后发现减库存失败的现象，这种现象会导致订单的数量多于商品的库存量。</p><h4 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h4><p><strong>这正是 MySQL InnoDB 的默认事务隔离级别</strong><br>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。同时也克服了不可重读的场景：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/4.png" alt=""></p><p>此级别可能出现的问题——幻读（Phantom Read）：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/5.png" alt=""></p><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于 update 和 delete，而幻读的重点在于 insert。</p><p>InnoDB 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题</p><h4 id="可串行化（Serializable）"><a href="#可串行化（Serializable）" class="headerlink" title="可串行化（Serializable）"></a>可串行化（Serializable）</h4><ul><li>这是最高的隔离级别</li><li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。</li><li>在这个级别，可能导致大量的超时现象和锁竞争</li></ul><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/6.png" alt=""></p><p>InnoDB 实现方式：这种事务的隔离级别下，所有 select 语句都会被隐式的转化为 select … in share mode。</p><p><strong>首先这些读数据读错了，但是不管脏读，不可重复读，还是幻读，都是读操作似乎不会对数据库的数据造成影响，但是我们代码里面有后续的操作，一般都要用读出来的值进行对数据加工处理，然后就会对数据造成影响。</strong></p><p>在SpingBoot中，可以通过application.yml来统一设置事务的隔离级别，也可以在方法上使用@Translational（isolation=isolation.Serializable），指定事务的隔离级别。</p><h3 id="InnoDB下幻读是如何在RR级别下被解决的？"><a href="#InnoDB下幻读是如何在RR级别下被解决的？" class="headerlink" title="InnoDB下幻读是如何在RR级别下被解决的？"></a>InnoDB下幻读是如何在RR级别下被解决的？</h3><p><strong>RR(Repeatable Read)</strong> </p><p>一个事务A在事务执行过程中第一次读取的值和第二次读取的值一致（解决了不可重复读），但是其他事务B 的insert 或者 delete的操作，会影响到俩次查询的条数（现象：幻读）</p><h4 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h4><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</p><p><strong>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong><br> 下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p><ul><li><p>SELECT</p><p>InnoDB会根据以下两个条件检查每行记录：</p><ol><li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li></ol><p>只有符合上述两个条件的记录，才能返回作为查询结果</p></li><li><p>INSERT</p><p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li><li><p>DELETE</p><p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li><li><p>UPDATE</p><p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。<br> 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</p></li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mvcctest( </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p><strong>transaction 1:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'mi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'kong'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>假设系统初始事务ID为1:</p><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>undefined</td></tr></tbody></table><p><strong>transaction 2:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest;  //(1)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest;  //(2)</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务3：</p><p><strong>transaction 3:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'qu'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>qu</td><td>3</td><td>undefined</td></tr></tbody></table><p>事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过乐观锁的方式避免了幻读的产生</p><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：</p><p><strong>transaction session 4:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> mvcctest <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'fan'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间</p><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>4</td></tr><tr><td>2</td><td>fan</td><td>4</td><td>undefined</td></tr></tbody></table><p>事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在两次读取时读取到的数据的状态是一致的</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：</p><p><strong>transaction session 5:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mvcctest <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>5</td></tr></tbody></table><p>事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的</p><h4 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h4><p>  数据库使用锁是为了支持更好的并发，提供数据的完整性和一致性。InnoDB是一个支持行锁的存储引擎，锁的类型有：共享锁（S）、排他锁（X）、意向共享（IS）、意向排他（IX）。为了提供更好的并发，<strong>InnoDB提供了非锁定读：不需要等待访问行上的锁释放，读取行的一个快照。</strong></p><p><strong>InnoDB有三种行锁的算法：</strong></p><h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><p>单个行记录上的锁。record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p><h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><p>间隙锁定是对索引记录之间的间隙的锁定，或者是对第一个或最后一个索引记录之前的间隙的锁定。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>防止其他事务将value <code>15</code>插入column中<code>t.c1</code>，无论该列 中是否已有这样的值，因为该范围中所有现有值之间的间隙都是锁定的。</p><p>间隙可能跨越单个索引值，多个索引值，甚至为空。</p><p>间隙锁是性能和并发性之间权衡的一部分，并且在某些事务隔离级别而非其他级别中使用。</p><p>对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。）例如，如果该<code>id</code>列具有唯一索引，则以下语句仅使用一个具有<code>id</code>值100 的行的索引记录锁定，其他会话是否在前面的间隙中插入行并不重要：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>如果id未建立索引或索引不唯一，则该语句会锁定前面的间隙。</p><p>在这里还值得注意的是，可以通过不同的事务将冲突的锁保持在间隙上。例如，事务A可以在间隙上保留一个共享的间隙锁（间隙S锁），而事务B可以在同一间隙上保留排他的间隙锁（间隙X锁）。允许冲突的间隙锁的原因是，如果从索引中清除记录，则必须合并由不同事务保留在记录上的间隙锁。</p><p>间隙锁定InnoDB是“ 纯粹抑制性的 ”，这意味着它们的唯一目的是防止其他事务插入间隙。间隙锁可以共存。一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。共享和专用间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p><p>间隙锁定可以显式禁用。如果将事务隔离级别更改为，则会发生这种情况 READ COMMITTED。在这种情况下，将禁用间隙锁定来进行搜索和索引扫描，并且间隙锁定仅用于外键约束检查和重复键检查。</p><p>使用READ COMMITTED隔离级别还有其他影响 。MySQL评估WHERE条件后，将释放不匹配行的记录锁。对于 UPDATE语句，请InnoDB 执行“ 半一致 ”读取，以便将最新的提交版本返回给MySQL，以便MySQL可以确定行是否与的WHERE 条件匹配UPDATE。</p><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><p>Next-Key Lock是索引记录上的记录锁定和索引记录之前的间隙上的间隙锁定的组合。</p><p>InnoDB执行行级锁定，以使其在搜索或扫描表索引时对遇到的索引记录设置共享或排他锁。因此，行级锁实际上是索引记录锁。索引记录上的Next-Key Lock也会影响该索引记录之前的“ 间隙 ”。即，Next-Key Lock是索引记录锁定加上索引记录之前的间隙上的间隙锁定。如果一个会话R在索引中的记录上具有共享或排他锁 ，则另一会话不能R在索引顺序之前的间隙中插入新的索引记录 。</p><p>假定索引包含值10、11、13和20。此索引的可能的Next-Key Lock涵盖以下间隔，其中，圆括号表示排除区间端点，方括号表示包括端点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>对于最后一个间隔，Next-Key Lock将间隙锁定在索引中的最大值之上，并且“ supreumum ” 伪记录的值高于索引中实际的任何值。最高不是真正的索引记录，因此，实际上，此Next-Key Lock仅锁定最大索引值之后的间隙。</p><p>默认情况下，InnoDB以 REPEATABLE READ事务隔离级别运行。在这种情况下，请InnoDB使用next-key锁进行搜索和索引扫描。</p><p>用于Next-Key Lock事务数据出现类似于在下面SHOW ENGINE INNODB STATUS和 InnoDB的监视器 输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">1</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">1</span>; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     'O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL体系结构</title>
      <link href="/2020/01/27/mysql1/"/>
      <url>/2020/01/27/mysql1/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p>现在来讲一讲数据库，数据库是虚拟世界与现实世界的第一层抽象。数据库在任何领域，都有着非常重要的作用，我们的身体、每一个器官、每一个细胞，都可以是一个数据库。数据库可以是世界上所有信息的载体，而并非仅仅只体现在计算机学科身上。</p><h3 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h3><h4 id="技术初衷"><a href="#技术初衷" class="headerlink" title="技术初衷"></a>技术初衷</h4><p>在操作系统出现之后，随着计算机应用范围的扩大、需要处理的数据迅速膨胀。最初，数据与程序一样，以简单的文件作为主要存储形式。以这种方式组织的数据在逻辑上更简单，但可扩展性差，访问这种数据的程序需要了解数据的具体组织格式。当系统数据量大或者用户访问量大时，应用程序还需要解决数据的完整性、一致性以及安全性等一系列的问题。因此，必须开发出一种系统软件，它应该能够像操作系统屏蔽了硬件访问复杂性那样，屏蔽数据访问的复杂性。由此产生了数据管理系统，即数据库。</p><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><p>数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。数据库管理系统可以依据它所支持的数据库模型来作分类，例如关系式、XML；或依据所支持的电脑类型来作分类，例如服务器聚类、移动电话；或依据所用查询语言来作分类，例如SQL、XQuery；或依据性能冲量重点来作分类，例如最大规模、最高运行速度；亦或其他的分类方式。不论使用哪种分类方式，一些DBMS能够跨类别，例如，同时支持多种查询语言。</p><h4 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h4><p>随着数据库技术与其他分支学科技术的结合，出现了多种新型数据库，例如：与分布处理技术结合产生的分布式数据库、与并行处理技术结合产生的并行数据库、与人工智能结合产生的演绎数据库、与多媒体技术结合产生的多媒体数据库。另外，数据库技术应用于特定的领域，出现了工程数据库、 地理数据库、统计数据库、空间数据库等特定领域数据库。</p><h5 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h5><ul><li>MySQL<ul><li><a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">MariaDB</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=Percona_Server&action=edit&redlink=1" target="_blank" rel="noopener">Percona Server</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/PostgreSQL" target="_blank" rel="noopener">PostgreSQL</a></li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_Access" target="_blank" rel="noopener">Microsoft Access</a></li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_SQL_Server" target="_blank" rel="noopener">Microsoft SQL Server</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=Google_Fusion_Tables&action=edit&redlink=1" target="_blank" rel="noopener">Google Fusion Tables</a></li><li><a href="https://zh.wikipedia.org/wiki/FileMaker" target="_blank" rel="noopener">FileMaker</a></li><li><a href="https://zh.wikipedia.org/wiki/Oracle数据库" target="_blank" rel="noopener">Oracle数据库</a></li><li><a href="https://zh.wikipedia.org/wiki/Sybase" target="_blank" rel="noopener">Sybase</a></li><li><a href="https://zh.wikipedia.org/wiki/DBASE" target="_blank" rel="noopener">dBASE</a></li><li><a href="https://zh.wikipedia.org/wiki/Clipper" target="_blank" rel="noopener">Clipper</a></li><li><a href="https://zh.wikipedia.org/wiki/FoxPro" target="_blank" rel="noopener">FoxPro</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=Foshub&action=edit&redlink=1" target="_blank" rel="noopener">foshub</a></li></ul><p>几乎所有的数据库管理系统都配备了一个<a href="https://zh.wikipedia.org/wiki/開放式資料庫連接" target="_blank" rel="noopener">开放式数据库连接</a>（ODBC）驱动程序，令各个数据库之间得以互相集成。</p><h5 id="非关系数据库-NoSQL"><a href="#非关系数据库-NoSQL" class="headerlink" title="非关系数据库(NoSQL)"></a>非关系数据库(NoSQL)</h5><ul><li><p><a href="https://zh.wikipedia.org/wiki/BigTable" target="_blank" rel="noopener">BigTable</a>（Google）</p></li><li><p><a href="https://zh.wikipedia.org/wiki/Cassandra" target="_blank" rel="noopener">Cassandra</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/MongoDB" target="_blank" rel="noopener">MongoDB</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/CouchDB" target="_blank" rel="noopener">CouchDB</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/Redis" target="_blank" rel="noopener">Redis</a></p><p><strong>键值数据库</strong></p></li><li><p><a href="https://zh.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="noopener">Apache Cassandra</a></p></li><li><p><a href="https://zh.wikipedia.org/w/index.php?title=Dynamo&action=edit&redlink=1" target="_blank" rel="noopener">Dynamo</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/LevelDB" target="_blank" rel="noopener">LevelDB</a>（Google）</p></li></ul><h4 id="数据库技术的发展"><a href="#数据库技术的发展" class="headerlink" title="数据库技术的发展"></a>数据库技术的发展</h4><p>随着互联网的普及，数据库使用环境也随之发生变化，这种变化主要体现为XML和Java技术的大量使用、要求支持各种互联网环境下的应用服务器、极容易出现大量用户同时访问数据库、要求支持7x24小时不间断运行和高安全性等。</p><p>为解决由于这些变化所带来的新问题，数据库管理系统也逐渐产生变化，包括：</p><p>(一)网络化的大型通用数据库管理系统的出现</p><p>由于互联网应用的用户数量无法预测，这就要求数据库相比以前拥有能处理更大量的数据以及为更多的用户提供服务的能力，即更好的可伸缩性及高可用性，因此，能够支持Internet的数据库应用已经成为数据库系统的重要方面，学术界及各主流数据库公司都将大型通用数据管理系统作为主要发展方向。例如Oracle公司从 8 版起全面支持互联网应用，微软公司更是将 SQL Server 作为 其整个 .NET计划中的一个重要的成分。</p><p>(二)数据库安全系统及技术的提升</p><p>由于数据库系统在现代计算机系统中的地位越来越趋于核心的地位，数据库系统的安全问题自然受到越来越多的关注。在当前各国所引用或制定的 一系列安全标准中，最重要的两个是由美国国防部制定的《可信计算机系统的评估标准》(简称TCSEC)和《可信计算机系统的评估标准关于可信数据库系统的解释》(简称 TDI)。当前，所有数据库的开发必须遵从相应的安全标准。</p><p>(三)XML及Web数据管理技术的普及</p><p>随着越来越多的Web应用，如电子商务、数字图书馆、信息服务等采用XML作为数据表现形式、越来越多网站采用XML作为信息发布的语言，以XML格式数据为主的半结构化数据逐步成为网上数据交换和数据表示的标准。而XML具有如下的一些特征：面向显示、半结构化和无结构、不同形式的数据源，动态变化以及数据海量等。因此，支持这种结构松散、形式多样、动态变化的海量数据的存储、共享、管理、检索，成了数据库技术的大势所趋。</p><p>Web数据管理是一个很松散的概念，大体上它是指在Web环境下对各种复杂信息的有效组织与集成，进行方便而准确的信息查询和发布。当前Web数据管理的研究开发方向主要包括：半结构化数据管理、Web数据查询、Web信息集成、XML数据管理等。到当前为止，XML 与 Web 数据管理的研究工作中主要集中在如下的一些方面。</p><ol><li>半结构化数据</li></ol><p>2.Web 数据查询</p><p>3.XML 相关标准</p><p>4.XML 数据管理</p><p>(四)嵌入式移动数据库技术</p><p>随着移动通信技术的迅速发展和投入使用，加上移动智能电话、移动计算机的大量普及，国内外许多研究机构都展开了对移动数据库的研究，并获取了许多有价值的成果。移动数据库技术涉及数据库技术、分布式计算技术以及移动通信技术等多个学科领域，具有较高的学术起点。</p><h4 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h4><ul><li><p><a href="https://zh.wikipedia.org/w/index.php?title=物件模型&action=edit&redlink=1" target="_blank" rel="noopener">对象模型</a></p></li><li><p>层次模型（轻量级数据访问协议）</p></li><li><p>网状模型（大型数据储存）</p></li><li><p>关系模型</p></li><li><p>面向对象模型</p></li><li><p>半结构化模型</p></li><li><p><a href="https://zh.wikipedia.org/w/index.php?title=平面模型&action=edit&redlink=1" target="_blank" rel="noopener">平面模型</a>（表格模型，一般在形式上是一个二维<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>。如表格模型数据<a href="https://zh.wikipedia.org/wiki/Excel" target="_blank" rel="noopener">Excel</a>)</p></li></ul><p><strong>架构</strong></p><p>数据库的架构可以大致区分为三个概括层次：内层、概念层和外层。</p><ul><li>内层：最接近实际存储体，亦即有关数据的实际存储方式。</li><li>外层：最接近用户，即有关个别用户观看数据的方式。</li><li>概念层：介于两者之间的间接层。</li></ul><p><strong>数据库索引</strong></p><p>数据索引的观念由来已久，像是一本书前面几页都有目录，目录也算是索引的一种，只是它的分类较广，例如车牌、身份证字号、条码等，都是一个索引的号码，当我们看到号码时，可以从号码中看出其中的端倪，若是要找的人、车或物品，也只要提供相关的号码，即可迅速查到正确的人事物。</p><p>另外，索引跟字段有着相应的关系，索引即是由字段而来，其中字段有所谓的关键字段（Key Field），该字段具有唯一性，即其值不可重复，且不可为”<a href="https://zh.wikipedia.org/wiki/空值" target="_blank" rel="noopener">空值</a>（null）”。例如：在合并数据时，索引便是扮演欲附加字段数据之指向性用途的角色。故此索引为不可重复性且不可为空。</p><p><strong>数据库事务</strong></p><p>事务（transaction）包含一组数据库操作的逻辑工作单元，在事务中包含的数据库操作是不可分割的整体，这些操作要么一起做，要么一起回滚（Roll Back）到执行前的状态。 事务的<a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a>特性：</p><ul><li>基元性（atomicity）</li><li>一致性（consistency）</li><li>隔离性（isolation）</li><li>持续性（durability）</li></ul><p>事务的并发性是指多个事务的并行操作轮流交叉运行，事务的并发可能会访问和存储不正确的数据，破坏交易的隔离性和数据库的一致性。</p><p><strong>网状数据模型的数据结构</strong></p><p>满足下面两个条件的基本层次联系的集合为网状模型。</p><ol><li>允许一个以上的结点无双亲；</li><li>一个结点可以有多于一个的双亲。</li></ol><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL数据库是一个应用最为广泛，且免费的数据库。这个数据库无论在性能，还是在可操作性上，都非常的出众。现在众多的企业，都在使用着MySQL。</p><h4 id="定义数据库和实例"><a href="#定义数据库和实例" class="headerlink" title="定义数据库和实例"></a>定义数据库和实例</h4><p><strong>数据库</strong>：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。可以看做为，数据库仅仅是一个静态的TXT文件，单独的存放在硬盘中。</p><p><strong>实例</strong>：MySQL数据库由后台线程以及共享内存区组成。MySQL数据库实例在系统上的表现就是一个进程。也正是由实例，来操作数据库。</p><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>Read Uncommitted（读取未提交内容）</p><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><p>Read Committed（读取提交内容）</p><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><p>Repeatable Read（可重读）(默认)</p><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><p>Serializable（可串行化）</p><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p><p><img src="https://box.kancloud.cn/c67eb13942f3ba82f96499bcd14bd47a_686x140.png" alt=""></p><h4 id="MySQL构成"><a href="#MySQL构成" class="headerlink" title="MySQL构成"></a>MySQL构成</h4><p>数据库和实例，是两个不同的事物，但是也可以结合到一起，就好似，数据库是一个巨大的压缩包，你要用解压缩软件（实例），去操作这个压缩包。数据库文件一般都是二进制文件，因为二进制是最基础的类型，能够存储任何的信息。我们需要实例，去对二进制文件进行增删改查操作，</p><p>MySQL由以下几部分组成：</p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1580119995136&di=ccfb19525fab0e9fac77845a2d5d0443&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3988714236%2C2708734242%26fm%3D214%26gp%3D0.jpg" alt=""></p><p>由图可以发现，MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式服务。它提供了一系列标准的管理和服务支持，如SQL分析器和优化器，而存储引擎是底层物理结构的实现，<strong>存储引擎是基于表的，而不是数据库</strong>。</p><h4 id="存储引擎类型"><a href="#存储引擎类型" class="headerlink" title="存储引擎类型"></a>存储引擎类型</h4><h5 id="innoDB存储引擎"><a href="#innoDB存储引擎" class="headerlink" title="innoDB存储引擎"></a>innoDB存储引擎</h5><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。 该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。</p><p>但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><p>其特点十行锁设计、支持危机，并支持类型与Oracle的非锁定读，即默认读取操作不会产生锁。</p><p>InnoDB通过使用多版本并发控制（MVCC） 来获取高并发性，并且实现了SQL标准的4种隔离，默认为REPEATABLE级别。同时使用一种被称为next-keylocking的策略来避免幻读（phantom）现象的产生。 除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写（double write）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等高性能和高可用的功能。<br>对于表中数据的存储， InnoDB存储引擎采用了聚集（slustered）的方式，因此每张表的存储都是按主键的顺序存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此为主键。</p><h5 id="MylSAM存储引擎"><a href="#MylSAM存储引擎" class="headerlink" title="MylSAM存储引擎"></a>MylSAM存储引擎</h5><p>在MySQL 5.1 及之前的版本，是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyISAM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyISAM也是很好的选择。</p><p>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。 MyISAM存储引擎另一个与众不同的地方是它的缓冲池只缓存（cache）索引文件，而不缓冲数据文件。</p><p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。 可以通过myisampack工具来进一步压缩数据文件</p><p>（采用赫夫曼【Huffman】）编码静态算法来压缩数据，因此压缩之后的数据表示只读的， 也可以通过该工具解压数据文件。 从5.0版本之前 默认支持表大小为4GB，5.0开始默认支持256TB的单表数据。）</p><p><strong>简单介绍区别</strong>：</p><ul><li>1、MyISAM是非事务安全的，而InnoDB是事务安全的</li><li>2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁</li><li>3、MyISAM支持全文类型索引，而InnoDB不支持全文索引</li><li>4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</li><li>5、MyISAM表保存成文件形式，跨平台使用更加方便</li></ul><p><strong>应用场景</strong>：</p><ul><li>1、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM</li><li>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li></ul><h5 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h5><p>NDB存储引擎是一个集群存储引擎，类似于Oracle 的RAC集群，不过与其架构不同的是，其结构是share nothing 的集群架构，因此能提供更高的可用性。NDB的特点是数据全部放在内存中（mysql 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。</p><p>注意：NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的 ，而不是在存储引擎层完成的。 这意味着，复杂的挎包和操作需要巨大的网络开销，因此查询速度很慢。</p><h5 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h5><p>Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据重启或者发生崩溃，表中的数据将不在 所以适合用于存储临时数据的临时表，以及数据仓库的纬度表。 Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树状索引。<br>Memory存储引擎速度非常快，但是也有一定的限制。比如:只支持表锁,并发性能差。并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（已经给出了patch解决方案）。</p><p>MySQL数据库使用Memory存储引擎作为临时表存放查询中间的结果集。 如果中间结果集大于Memory存储引擎表的容量设置，或者含有TEXT或BLOB列类型字段，则MySQL数据库会转换成MyISAM存储引擎表而存放到磁盘。因为MyISAM不缓存数据文件，所以这是产生的临时表的性能对于查询会有损失。</p><h5 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h5><p>Archive存储引擎只支持INSERT 和 SELECT 操作, MySQL5.1版本支持索引。 Archive存储引擎使用zlib算法将数据行进行压缩 压缩比一般可达1:10。可以用来做日志信息。 Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身不是书屋安全的存储引擎，其设计目标主要是提供高数的插入和压缩功能。</p><h5 id="Federated-存储引擎"><a href="#Federated-存储引擎" class="headerlink" title="Federated 存储引擎"></a>Federated 存储引擎</h5><p>Federated 存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server 的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。</p><h5 id="Maria存储引擎"><a href="#Maria存储引擎" class="headerlink" title="Maria存储引擎"></a>Maria存储引擎</h5><p>Maria存储引擎 是新开发订单引擎，设计目标主要是取代MyISAM存储引擎，从而成为MySQL的默认存储引擎。<br>特点：注册缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。</p><h5 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h5><p>如：Merge、CSV、Sphinx和Infobright等。</p><p>不同之处：存储容量的限制、事务支持、锁的粒度、MVCC支持、支持的索引、备份和复制等。</p><p><img src="https://box.kancloud.cn/67c9fd3b0f58f5d7b83140026b5c9c21_836x582.png" alt=""></p><h4 id="数据库的链接方式"><a href="#数据库的链接方式" class="headerlink" title="数据库的链接方式"></a>数据库的链接方式</h4><h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h5><p>TCP/IP套接字方式MySQL数据库 在任何的平台下都提供的链接方式，也是网络中使用最多的链接方式。<br>链接例如：mysql -h【ip】 -u 【用户名】 -p【密码】 &gt; mysql -h127.0.0.1 -u root -proot<br>判断客户端是否允许链接Mysql实例<br>链接完数据库<br>选择数据库 use mysql;<br>在查询表select host,user,password from user;<br>就可以得到相对应的链接ip</p><h5 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h5><p><img src="https://box.kancloud.cn/7961c80f6443a8a63416658f2bbc856d_858x228.png" alt=""></p><h5 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h5><p>linux和UNIX环境下 可以使用. UNIX域套接字不是网络协议 所以只能在同一台服务器上使用。<br>用户可以在配置文件中知道套接字文件的路径 如果–socket=/tmp/mysql.sock。<br>通过命令查找UNIX域套接字文件SHOW VARIABLES LIKE ‘socket’\G</p><p><img src="https://box.kancloud.cn/aa479d02d235c06a2799f21198eef7be_484x115.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Security框架</title>
      <link href="/2020/01/24/spring7/"/>
      <url>/2020/01/24/spring7/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>“万一我随便输入一个账号，再随便输入一堆密码，就登录到了马云的淘宝号呢？”:yum:</p><p>“那阿里又要向社会输入工作十年的人才了。”:happy:</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>我们之前在众多的实验中，无论虽然对业务逻辑的处理和持久层的操作，都封装在后端，无法被轻易访问。但是，要调用的时候，还是需要通过前端的控制层，以及thymeleaf页面来完成，这个时候很多操作都可以从url头直接进行，而不加以限制，这样是不完善的。</p><p>粗俗一点讲，就是我们需要登录了才能访问页面，其他的请求将通通加以限制。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架（简单说是对访问权限进行控制嘛）。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><p>可以简单地认为 Spring Security 是放在用户和 Spring 应用之间的一个安全屏障, 每一个 web 请求都先要经过 Spring Security 进行 Authenticate 和 Authoration 验证。</p><p>我们现在来使用Security框架，来制作需要登录验证的网站模型。</p><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>security的理解的使用比较繁杂，我们先把基础配置和重点分开来讲：</p><h4 id="依赖与设置"><a href="#依赖与设置" class="headerlink" title="依赖与设置"></a>依赖与设置</h4><h5 id="引入pom依赖："><a href="#引入pom依赖：" class="headerlink" title="引入pom依赖："></a>引入pom依赖：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml:"></a>配置yml:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.example.security.pojo</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>这里还是使用mybatis来操作持久层</p><h5 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.security.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from t_user_roles where username =#&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapper的设置，直接获取全部属性。</p><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/1.png" alt=""></p><p>这是数据库的设置，注意roles形式是固定，必须有ROLE_ 前缀</p><h4 id="必要的组件"><a href="#必要的组件" class="headerlink" title="必要的组件"></a>必要的组件</h4><p>这里将所有必要的组件类列出来，这里不是重点，但是很有必要。</p><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String roles;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(String username)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">     UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUser(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/mypage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">my</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mypage"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logoutpage</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Authentication 是一个接口，用来表示用户认证信息</span></span><br><span class="line">        Authentication auth= SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (auth!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> SecurityContextLogoutHandler().logout(request,response,auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向到 login</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/login?logout"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里列出了控制层要接收的所有映射，现在暂时不说明他们各自的作用，待会会结合Security的各个配置一并讲解出来。</p><h3 id="Security——登录和注销"><a href="#Security——登录和注销" class="headerlink" title="Security——登录和注销"></a>Security——登录和注销</h3><p>这里开始讲述，Security是如何将它们整合起来的。大家可能会发现，上面的Controller层代码并没有Service层的注入，那么控制层是如何从数据库获取验证的呢？这里由下而上，从Service的注入开始。</p><h4 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h4><p>Service层的注入在了一个接入了UserDetailsService接口的类里面。而这个类通过重写UserDetailsService的方法，来获取到数据库的用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过用户名加载用户"</span>);</span><br><span class="line">        com.example.security.pojo.User user = userService.getUserName(s);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(user.getUsername() ,user.getPassword(),</span><br><span class="line">                createAuthority(user.getRoles()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是将数据库的角色分割，构造GrantedAuthority</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title">createAuthority</span><span class="params">(String roles)</span> </span>&#123;</span><br><span class="line">        String[] roleArray = roles.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String role : roleArray) &#123;</span><br><span class="line">            authorityList.add(<span class="keyword">new</span> SimpleGrantedAuthority(role));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorityList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重写了loadUserByUsername方法，这个方法会返回一个User类，我们会使用服务层的API，从数据库读取数据，让我们的user获得各项信息，在结合自己定义的方法，把我们的Roles划分为一个ArrayList列表。再使用Security的User类去重新构造它，并且返回。</p><p>注意，返回的这个User类是属于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br></pre></td></tr></table></figure><p>这里在下犯了一个错误，就是不应该直接把实体类的名称直接定义为User，这样导致两个User类产生了冲突，所以在loadUserByUsername方法开头的user实例，使用地址的方式去声明。</p><p>那么这个类的方法又会被谁调用呢？</p><h4 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h4><p>这个方法会被继承了WebSecurityConfigurerAdapter的类所调用。我们首先要继承WebSecurityConfigurerAdapter，并重写两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailService myUserDetailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>, <span class="string">"/index"</span>).permitAll()<span class="comment">//允许/、/index的访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/mypage/**"</span>).hasAnyRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/mypage下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasAnyRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line">                .anyRequest().authenticated()<span class="comment">//其它所有访问都拦截</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()<span class="comment">//添加登陆</span></span><br><span class="line">                .loginPage(<span class="string">"/login"</span>).permitAll()<span class="comment">//登陆页面“/login"允许访问</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/mypage"</span>)<span class="comment">//成功默认跳转 url</span></span><br><span class="line">                .usernameParameter(<span class="string">"user"</span>)</span><br><span class="line">                .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .permitAll()</span><br><span class="line">                <span class="comment">//设置注销操作</span></span><br><span class="line">                <span class="comment">//所有用户都可以访问（可以使用注销）</span></span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling().accessDeniedPage(<span class="string">"/error"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        auth</span><br><span class="line">                .userDetailsService(myUserDetailService)</span><br><span class="line">                .passwordEncoder(<span class="keyword">new</span> MyPassWordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重写了configure(AuthenticationManagerBuilder auth)方法后，调用auth的注册，我们就能把用户的信息注册到整个Servelet的上下文中，使其全局存在，注意这里的MyPassWordEncoder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPassWordEncoder</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> charSequence.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence charSequence, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是需要重写PasswordEncoder去实现的，这是为了完成Security的密码加密功能，这里暂时不做延伸。</p><p>然后重写的configure(HttpSecurity http)方法，这个方法就是用来拦截请求和注册的，非常的关键。</p><p>一开始，便使用了authorizeRequests，来配置和定义请求，使用antMatchers来定义页面和权限的信息。</p><p>.and()的作用是连接表示还有事务需要配置</p><p>使用.formLogin()去定义登录页面，对于需要权限的请求，都需要跳转到某个url进行登录操作，使用loginPage(“/login”)，表示url，permitAll()表示全部需要权限的页面</p><p>最后的logout()表示注销的页面，这里默认为logout，但注销操作实际上要根据业务的需要去定义，一般不会直接定位到某个页面。</p><p>.exceptionHandling().accessDeniedPage(“/error”);表示出现权限不足时，需要跳转的页面。</p><p>这里就需要重新提起Controller层的操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们定义了跳转页面，但是我们仍然需要对/login请求进行重新规划，在defaultSuccessUrl中，定义了登录成功后会跳转的URL，这就表示了，如果登录成功，则跳转到相应的URL页面，否则，仍然返回login页面。</p><h4 id="注销的实现"><a href="#注销的实现" class="headerlink" title="注销的实现"></a>注销的实现</h4><p>重新看回Controller层的/logout页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logoutpage</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Authentication 是一个接口，用来表示用户认证信息</span></span><br><span class="line">    Authentication auth= SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="keyword">if</span> (auth!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">new</span> SecurityContextLogoutHandler().logout(request,response,auth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向到 login</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/login?logout"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们接受到了一个请求，使用（HttpServletRequest request, HttpServletResponse response），去处理这请求。</p><p>首先看到SecurityContextHolder.getContext().getAuthentication(); 它获取了我们存在于服务器中的上下文，同时又获取到了该用户的名字，如果该用户存在，则new一个新的用户去相应logout页面，最后再重定向回来。重定向在thymeleaf中也有所提及，是重新访问url页面并执行方法的意思。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>开始测试，首先需要HTML页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登陆页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;param.error&#125;"</span>&gt;</span></span><br><span class="line">    密码错误</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;param.logout&#125;"</span>&gt;</span></span><br><span class="line">    您已注销</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/login&#125;"</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"user"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span>&gt;</span>记住我<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/2.png" alt=""></p><p>这个就是登录界面.。</p><h5 id="权限页面"><a href="#权限页面" class="headerlink" title="权限页面"></a>权限页面</h5><p>当我们登录了张三这个用户的身份后，将自动跳转到mypage页面</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/4.png" alt=""></p><p>再尝试去访问admin页面。</p><p> <img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/3.png" alt=""></p><p>于是点击退出</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/5.png" alt=""></p><p>然后再次用管理员的账号去登录管理员界面</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/6.png" alt=""></p><p>完成！余下HTML页面会在文章最后的源码连接中放出。</p><h3 id="Security——记住我"><a href="#Security——记住我" class="headerlink" title="Security——记住我"></a>Security——记住我</h3><p>在WebSecurityConfigurerAdapter，选择记住我，但是这个.rememberMe()，也是有着许许多多的层级关系的。</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>我们直接配置中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.rememberMe();</span><br></pre></td></tr></table></figure><p>开启的rememberMe()功能，但是它是存储于一个全局的Cookies中的，它会存在一段时间，在这段时间中，即使你切到其他页面，再切回来，也不用登录，但是一旦清除了Cookies，那就必须重新登录了。</p><p>同时，除了通过自己去编辑注销之外，还可以使用Security中自带的注销方法，它还可以自定义注销成功跳转的目录。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.logout().logoutSuccessUrl(<span class="string">"/"</span>);</span><br></pre></td></tr></table></figure><p>同时，在控制层中注释掉logout的映射关系，并在html页面上改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/logout&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注销"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它就会提交一个logout请求，而Security就会自动识别到这个请求，来完成我们的注销功能</p><p>可以在浏览器中按F12，打开application 的cookies页面，查看jsession信息。</p><h4 id="自定义Cookies"><a href="#自定义Cookies" class="headerlink" title="自定义Cookies"></a>自定义Cookies</h4><p>我们还可以使用自定义Cookies去存储用户信息，使我们在关闭浏览器后，还缓存固定的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()                </span><br><span class="line">    .and()</span><br><span class="line">                .rememberMe()</span><br><span class="line">                .key(<span class="string">"uniqueAndSecret"</span>)</span><br><span class="line">                .rememberMeCookieName(<span class="string">"remember-me"</span>)</span><br><span class="line">                .tokenValiditySeconds(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>重新添加这段代码后，我们就将用户信息缓存在了Cookies中。</p><p>使用.key(“uniqueAndSecret”)，指定缓存的键名，.rememberMeCookieName(“remember-me”)指定Cookies名。</p><p>.tokenValiditySeconds(60);则是指定Cookies时间，这里使用60秒来进行测试，我们可以在测试后发现，它确实在关闭浏览器后，仍然仍然存在。</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>但是使用Cookies还是有着弊端，那就是我们再使用什么清理垃圾软件清理缓存的时候，将全部被清除掉，或者对于不支持缓存的浏览器而言，也是极其致命的，于是，我们可以将数据放到数据库中。这样就没有问题了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/8.jpg" alt=""></p><h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .tokenRepository(persistentTokenRepository())</span><br><span class="line">        .tokenValiditySeconds(<span class="number">60</span>)</span><br><span class="line">        .userDetailsService(myUserDetailService);</span><br></pre></td></tr></table></figure><p>增加这项配置，注意 .tokenRepository 将会注册一个处理方法：</p><h5 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">    <span class="comment">// 配置数据源</span></span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// 第一次启动的时候自动建表</span></span><br><span class="line">     <span class="comment">//jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置了PersistentTokenRepository，也就是Token的处理方法。当我们开启了这个后，可以访问页面，这个时候便可以再去观察数据库，你会发现：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/7.png" alt=""></p><p>这个便是我们的登录的信息，它会被存储在数据库里，它也会再时间过期后，将用户登录信息给无效化。</p><h3 id="Security——定制跳转"><a href="#Security——定制跳转" class="headerlink" title="Security——定制跳转"></a>Security——定制跳转</h3><p>我们也可以在登录成功后，定制跳转页面，使得我们拥有admin权限的用户直接跳转到后台管理页面，而user权限的则跳转默认的主页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AppSecurityConfigurer()调用-------"</span>);</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            <span class="comment">//spring-scurity 5.0之后需要过滤静态资源</span></span><br><span class="line"></span><br><span class="line">            .antMatchers(<span class="string">"/login"</span>,<span class="string">"/css/**"</span>,<span class="string">"/js/**"</span>,<span class="string">"/img/**"</span>).permitAll()</span><br><span class="line">            <span class="comment">//指定用户可以访问的多个url模式。</span></span><br><span class="line">            <span class="comment">// 特别的，任何用户可以访问以"/resources"开头的url资源，或者等于"/signup"或about</span></span><br><span class="line"></span><br><span class="line">            .antMatchers(<span class="string">"/"</span>,<span class="string">"/home"</span>).hasRole(<span class="string">"USER"</span>)</span><br><span class="line">            <span class="comment">//任何以"/home"开头的请求限制用户具有 "ROLE_USER"角色。</span></span><br><span class="line">            <span class="comment">// 你可能已经注意的，尽管我们调用的hasRole方法，但是不用传入"ROLE_"前缀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            .antMatchers(<span class="string">"/admin/**"</span>).hasAnyRole(<span class="string">"ADMIN"</span>,<span class="string">"DBA"</span>)</span><br><span class="line">            <span class="comment">//这个是拥有其中一个权限都能使用</span></span><br><span class="line"></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            <span class="comment">//任何没有匹配上的其他的url请求，需要用户被验证。</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">//拼接</span></span><br><span class="line"></span><br><span class="line">            .formLogin().loginPage(<span class="string">"/login"</span>)</span><br><span class="line">            <span class="comment">//开始设置登录操作</span></span><br><span class="line">            <span class="comment">//设置登录页面的访问地址</span></span><br><span class="line"></span><br><span class="line">            .successHandler(authenticationSuccessHandler)</span><br><span class="line">            <span class="comment">//设置了一个认证处理，登录成功后不同用户需要跳转到不同的页面</span></span><br><span class="line">            <span class="comment">//以此认证，视为通行证</span></span><br><span class="line"></span><br><span class="line">            .usernameParameter(<span class="string">"loginName"</span>).passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">            <span class="comment">//登录时接受传递的参数 loginName 和password</span></span><br><span class="line">            <span class="comment">//注意大小写</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .logout().permitAll()</span><br><span class="line">            <span class="comment">//设置注销操作</span></span><br><span class="line">            <span class="comment">//所有用户都可以访问（可以使用注销）</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .exceptionHandling().accessDeniedPage(<span class="string">"/accessDenied"</span>);</span><br><span class="line">    <span class="comment">//指定异常处理页面</span></span><br><span class="line">    <span class="comment">//特别是在没有权限的时候使用发生的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是我们重新写的http处理。注释写完整了各个位置的含义。</p><p>以下是AuthenticationSuccessHandler 处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title">SimpleUrlAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring security 通过RedirectStrategy 对象负责所有重定向事务</span></span><br><span class="line">    <span class="keyword">private</span> RedirectStrategy redirectStrategy=<span class="keyword">new</span> DefaultRedirectStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    重写 handle 方法，方法中通过 RedirectStrategy 对象重定向到指定的url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//通过determineTargetURL方法返回需要跳转的URL</span></span><br><span class="line">        String targetUrl=determineTargetUrl(authentication);</span><br><span class="line">        <span class="comment">//重定向请求指定的URL</span></span><br><span class="line">        redirectStrategy.sendRedirect(request,response,targetUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从Authentication 对象中提取当前登录用户的角色，并根据其角色返回适当的URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineTargetUrl</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        String url=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前登录用户的角色权限到集合 authentication</span></span><br><span class="line">        Collection&lt;? extends GrantedAuthority&gt; authorities=authentication.getAuthorities();</span><br><span class="line">        <span class="comment">//Collection是最基本的集合接口，</span></span><br><span class="line">        <span class="comment">// 一个Collection代表一组Object，即Collection的元素（Elements）。</span></span><br><span class="line">        <span class="comment">// 一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。</span></span><br><span class="line">        <span class="comment">// Java SDK不提供直接继承自Collection的类，</span></span><br><span class="line">        <span class="comment">// Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; roles=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将角色名称添加到List集合</span></span><br><span class="line">        <span class="keyword">for</span> (GrantedAuthority a:authorities)</span><br><span class="line">        &#123;</span><br><span class="line">            roles.add(a.getAuthority());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断不同角色跳转到不同的URL</span></span><br><span class="line">        <span class="keyword">if</span>(isAdmin(roles))</span><br><span class="line">        &#123;</span><br><span class="line">            url=<span class="string">"/admin"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isUser(roles))&#123;</span><br><span class="line">            url=<span class="string">"/home"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;url=<span class="string">"/accessDenied"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"url="</span>+url);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUser</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roles.contains(<span class="string">"ROLE_USER"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAdmin</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roles.contains(<span class="string">"ROLE_ADMIN"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set 和  get</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedirectStrategy <span class="title">getRedirectStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redirectStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedirectStrategy</span><span class="params">(RedirectStrategy redirectStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redirectStrategy = redirectStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址：</p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/security">https://github.com/Antarctica000/SpringBoot/tree/master/security</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Thymeleaf</title>
      <link href="/2020/01/21/spring6/"/>
      <url>/2020/01/21/spring6/</url>
      
        <content type="html"><![CDATA[<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>在下在此奉劝大家，不要再学JSP了。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Thymeleaf的概念："><a href="#Thymeleaf的概念：" class="headerlink" title="Thymeleaf的概念："></a>Thymeleaf的概念：</h4><p><strong>Thymeleaf</strong>是适用于Web和独立环境的现代服务器端Java模板引擎。</p><p>Thymeleaf的主要目标是为您的开发工作流程带来优雅的<em>自然模板</em> -HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。</p><p>可以在Web（基于servlet ）和非Web环境中工作。 它更适合在基于MVC的Web应用程序的视图层提供XHTML / HTML5，但它甚至可以在脱机环境中处理任何XML文件。 它提供完整的Spring Framework。</p><p>在Web应用程序中，Thymeleaf旨在成为JavaServer Pages （JSP）的完全替代品，并实现自然模板的概念：模板文件可以直接在浏览器中打开，并且仍然可以正确显示为网页。</p><p>对了，Thymeleaf取代了JSP。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><p>用于<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a> ， <a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="noopener">XHTML</a>和<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5的</a> Java 模板引擎 。</p></li><li><p>适用于Web和非Web（离线）环境。 没有硬依赖<a href="https://zh.wikipedia.org/wiki/Java_Servlet" target="_blank" rel="noopener">Servlet</a> API。</p></li><li><p>基于称为</p><p>方言的</p><p>模块化特征集。</p><ul><li>方言特征（例如：评估，迭代等）通过将它们链接到模板的标签和/或属性来应用。</li><li>开箱即用的两种方言：Standard和SpringStandard（适用于<a href="https://zh.wikipedia.org/wiki/Spring_Framework" target="_blank" rel="noopener">Spring MVC</a>应用程序，与标准语法相同）。</li><li>开发人员可以扩展和创建自定义方言。</li></ul></li><li><p>几种模板模式：</p><ul><li><strong><a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a></strong> ：验证<a href="https://zh.wikipedia.org/wiki/文档类型定义" target="_blank" rel="noopener">DTD</a>与否。</li><li><strong><a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="noopener">XHTML</a> 1.0和1.1</strong> ：是否针对标准<a href="https://zh.wikipedia.org/wiki/文档类型定义" target="_blank" rel="noopener">DTD进行</a>验证。</li><li><strong><a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a></strong> ：XML格式的代码和基于遗留的HTML5。 传统的非XML代码将自动清理并转换为<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>格式。</li></ul></li><li><p>完整（和可扩展）的<strong>国际化</strong>支持。</p></li><li><p>可配置的高性能<strong>解析模板缓存</strong> ，可将输入/输出降至最低。</p></li><li><p>自动DOCTYPE转换 - 从模板<a href="https://zh.wikipedia.org/wiki/文档类型定义" target="_blank" rel="noopener">DTD</a>到结果DTD-用于（可选）验证模板和结果代码。</p></li><li><p>极易扩展：如果需要，可以用作模板引擎框架。</p></li><li><p>完整的文档，包括几个示例应用。</p></li></ul><h4 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h4><p>Thymeleaf现在经常和Spring组件一起，成为一个完整的SSM框架。</p><p><strong>SSM</strong>：</p><p><strong>Spring</strong><br>　　Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。<br>　　Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。<br><strong>SpringMVC</strong><br>　　SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。<br><strong>mybatis</strong><br>　　mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p><p>到现在，新一代的SSM定义应该为SpringBoot+SpringMVC+MyBatis。</p><p>于是，现在开始学习关于SpringMVC的知识。</p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><p>Thymeleaf有很多的语法，虽然一个一个列出来并不复杂，但是为了更好的去理解它们的使用，而不是仅仅的列出公式。我希望能够将常用的抽离出来，并且将它们整合为一个项目。然后再单独的讲一下不常用的。</p><h4 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了更好的完成视图的开发，一般会多引入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是开发工具，能够实时的在网页上查看更改的效果，实现边改边看。</p><p><strong>配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>关闭缓存，实现实现边改边看。</p><h4 id="各个类的准备"><a href="#各个类的准备" class="headerlink" title="各个类的准备"></a>各个类的准备</h4><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3288311147760635602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3288311147760635602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//展示全部</span></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">ShowAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除产品</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加产品</span></span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Product product)</span></span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">ShowAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productDao.showProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productDao.deleteProduct(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productDao.addProduct(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.thymeleaf.dao.ProductDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 展示产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"showProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from t_product</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--增加产品--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addProduct"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag"><span class="attr">parameterType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">insert into t_product(product_name, stock,price,version,note)</span><br><span class="line">values(#&#123;productName&#125;,#&#123;stock&#125;,#&#123;price&#125;,#&#123;version&#125;,#&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 减少产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_product where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">         model.addAttribute(<span class="string">"products"</span>, productService.ShowAll());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h4><p>首先要准备一个index页面，并且在顶部添上一句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样HTML页面便能够识别我们的Thymeleaf语法。</p><h5 id="th-each"><a href="#th-each" class="headerlink" title="th:each"></a>th:each</h5><p>th:each 是一个经常被使用的语法，它能够不断地去读取从后端发出的队列，并且显示出来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"product:$&#123;products&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.stock&#125;"</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.price&#125;"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.version&#125;"</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.note&#125;"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;deletelist/&#123;id&#125;(id=$&#123;product.getId()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getId()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">onclick</span>=<span class="string">"return del()"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它会将我们从数据库中读取到的数据量的多少，来显示我们的页面。</p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/1.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/1.png" alt="img"></a></p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/2.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/2.png" alt="img"></a></p><h5 id="使用form表单提交信息"><a href="#使用form表单提交信息" class="headerlink" title="使用form表单提交信息"></a>使用form表单提交信息</h5><p>我们在添加信息的时候，首先会在index页面添加一个：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"add"</span>&gt;</span>增加产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它能够发起一个add请求到后端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    model.addAttribute(<span class="string">"product"</span>,product);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端接收到了这个请求后，就会使用return到另一个页面，值得注意的是，我们这里又new了一个新的product，之所以这样做是为了能够add页面，使用product这个类。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/addproduct&#125;"</span> <span class="attr">th:object</span>=<span class="string">"$&#123;product&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;id&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;productName&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;stock&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;price&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;version&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;note&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个就是我们的提交表单的行为，这里的<strong>th:action</strong>表示这个表单将会提交到：/addproduct 这个链接的方法中。</p><p>这里使用<strong>th:object</strong>去定义要使用的实例，我们就能够再text框中输入实例的属性，以此决定我们实例的数据。</p><p>使用<strong>th:field</strong>去表示这是我们实例的哪个属性。</p><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/addproduct"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addpro</span><span class="params">(@ModelAttribute Product product)</span></span>&#123;</span><br><span class="line">    productService.add(product);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/add"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个请求就是表单提交的链接的方法，会使用服务的方法区增加信息。最后哪个redirect:/add ，表示需要重定向到链接add，重新执行add链接下的方法。</p><h5 id="删除信息"><a href="#删除信息" class="headerlink" title="删除信息"></a>删除信息</h5><p>写一个删除信息的页面，再添加：</p><p><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/deleteproduct&#125;"</span> <span class="attr">th:object</span>=<span class="string">"$&#123;product&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;id&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会根据id去删除数据库的信息，这个也是一个表单，和add类似，使用表单的好处是以后更方便的用于修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    model.addAttribute(<span class="string">"product"</span>,product);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"delete"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/deleteproduct"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deletepro</span><span class="params">(@ModelAttribute Product product)</span></span>&#123;</span><br><span class="line">    productService.delete(product.getId());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置为重定向到index。</p><h5 id="使用按钮删除信息"><a href="#使用按钮删除信息" class="headerlink" title="使用按钮删除信息"></a>使用按钮删除信息</h5><p>实际在后端管理中，为了更方便的去增删改查。很多时候都是使用链接去完成的。回看index页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"product:$&#123;products&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.stock&#125;"</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.price&#125;"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.version&#125;"</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.note&#125;"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;deletelist/&#123;id&#125;(id=$&#123;product.getId()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getId()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">onclick</span>=<span class="string">"return del()"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用在最后的时候使用了一个 a 标签，表示这是一个链接。<strong>th:href</strong> 里面表示的是链接值，链接值的id，使用了REST风格的形式。</p><p><strong>onclick</strong>则是表达点击下去会发生什么。这里运用了js的知识，返回了一个函数del()，看一下这个del函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (confirm(<span class="string">"您确定要删除吗？"</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它会显示：你是否确定点击这个链接，是则返回true，否则返回false。</p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/3.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/3.png" alt="img"></a></p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/4.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/4.png" alt="img"></a></p><h5 id="展示单个产品"><a href="#展示单个产品" class="headerlink" title="展示单个产品"></a>展示单个产品</h5><p>先添加xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from t_product where product_name=#&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后添加dao层和服务层相应的操作，并再往控制层加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/showpro/&#123;p&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showpro</span><span class="params">(@PathVariable(<span class="string">"p"</span>)</span> String product,Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"product"</span>,productService.get(product));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会接收到从index页面传入的产品名称，并且访问数据库，读取出相应的数据</p><p>再更改html类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;showpro/&#123;p&#125;(p=$&#123;product.getProductName()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getProductName()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后的改动都以此类推，多试几次，逻辑是很简单的。</p><h5 id="产品分页"><a href="#产品分页" class="headerlink" title="产品分页"></a>产品分页</h5><p>如果我们的产品有很多，想必就不能一口气全部展示出来，这个时候，就要实现分页功能。</p><p>首先要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要引入的依赖最好为这样由springboot自动注入的形式，而不是直接就引入pagehelpe的jar包。</p><p>然后在Controller层增加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页功能</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">page</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @RequestParam(defaultValue = <span class="string">"1"</span>)</span> Integer pageNum,</span></span><br><span class="line"><span class="function">                   @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"2"</span>)</span> Integer pageSize)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//引入分页查询，使用PageHelper分页功能在查询之前传入当前页，然后多少记录</span></span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">    <span class="comment">//startPage后紧跟的这个查询就是分页查询</span></span><br><span class="line">    List&lt;Product&gt; products=productService.ShowAll();</span><br><span class="line">    <span class="comment">//使用PageInfo包装查询结果，只需要将pageInfo交给页面就可以</span></span><br><span class="line">    PageInfo pageInfo = <span class="keyword">new</span> PageInfo&lt;Product&gt;(products, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"pageInfo"</span>, pageInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前页</span></span><br><span class="line">    model.addAttribute(<span class="string">"pageNum"</span>, pageInfo.getPageNum());</span><br><span class="line">    <span class="comment">//获得一页显示的条数</span></span><br><span class="line">    model.addAttribute(<span class="string">"pageSize"</span>, pageInfo.getPageSize());</span><br><span class="line">    <span class="comment">//是否是第一页</span></span><br><span class="line">    model.addAttribute(<span class="string">"isFirstPage"</span>, pageInfo.isIsFirstPage());</span><br><span class="line">    <span class="comment">//获得总页数</span></span><br><span class="line">    model.addAttribute(<span class="string">"totalPages"</span>, pageInfo.getPages());</span><br><span class="line">    <span class="comment">//是否是最后一页</span></span><br><span class="line">    model.addAttribute(<span class="string">"isLastPage"</span>, pageInfo.isIsLastPage());</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"products"</span>, pageInfo.getList());</span><br><span class="line">    System.out.println(pageInfo.getList()+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法比较浅显而且易读，首先由@RequestParam(defaultValue = “1”)去定义默认值，在默认的情况下先打开第一页，并且第一页有着两条信息。PageHelper.startPage则是指定，分页功能，使其在全局生效。而那些model的作用，是用来交接HTML页面的。</p><p>修改index.html页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (confirm(<span class="string">"您确定要删除吗？"</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"product:$&#123;pageInfo.list&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;showpro/&#123;p&#125;(p=$&#123;product.getProductName()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getProductName()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.stock&#125;"</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.price&#125;"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.version&#125;"</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.note&#125;"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;deletelist/&#123;id&#125;(id=$&#123;product.getId()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getId()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">onclick</span>=<span class="string">"return del()"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"add"</span>&gt;</span>增加产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"delete"</span>&gt;</span>删除产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not isFirstPage&#125;"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;'/page'&#125;(pageNum=$&#123;pageNum-1&#125;,pageSize=$&#123;pageSize&#125;)&#125;"</span> <span class="attr">aria-label</span>=<span class="string">"Previous"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;isFirstPage&#125;"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">aria-label</span>=<span class="string">"Previous"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"pageNo : $&#123;#numbers.sequence(1, totalPages)&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;pageNum eq pageNo&#125;"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;pageNo&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not (pageNum eq pageNo)&#125;"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;'/page'&#125;(pageNum=$&#123;pageNo&#125;,pageSize=$&#123;pageSize&#125;)&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;pageNo&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not isLastPage&#125;"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;'/page'&#125;(pageNum=$&#123;pageNum+1&#125;,pageSize=$&#123;pageSize&#125;)&#125;"</span> <span class="attr">aria-label</span>=<span class="string">"Next"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;isLastPage&#125;"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">aria-label</span>=<span class="string">"Next"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在index页面添加了有关于分页的信息，这里是使用了thymeleaf语法来完成和实现的。</p><p>th:if=”${not isFirstPage} 表示着如果存在isFirstPage，或者说不存在isFirstPage的值为真，那么将不会显示上一页，否则则显示。可能有点绕，简而言之，就是如果不为真为真，则XXX…….</p><p>然后就是如果为真，则显示href=”javascript:void(0);”，这表示着仍然是本页，不进行任何更改。</p><p>而中间的这段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"pageNo : $&#123;#numbers.sequence(1, totalPages)&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则是表示中间还有多少页的意思。并且定位到相应的页面。</p><p>而之后的next，和previous差不多。它们所获取到的值，其实都是model里面的key-value值。</p><p><strong>测试：</strong></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/5.png" alt=""></p><h5 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h5><p>前面的实验都是没有引入css和js的，如果要引入这些资源的话，css和js必须放在static目录下。</p><p>如果还是无法获得静态资源，那么就在application.yml中加入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span></span><br></pre></td></tr></table></figure><p>强行扫描所有静态资源</p><h4 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h4><h5 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h5><p>我们使用${xxxxx}，就是一个变量表达式，它能够获取从控制层中传入的Model。</p><h5 id="选择表达式"><a href="#选择表达式" class="headerlink" title="选择表达式"></a>选择表达式</h5><p>*{xxxxxx}，使用预先选择的对象来表达，可理解为是能够获取实例中的属性。</p><h5 id="文字国际化表达式"><a href="#文字国际化表达式" class="headerlink" title="文字国际化表达式"></a>文字国际化表达式</h5><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用 Key 索引 Value，还可以提供一组参数(可选)：</p><p>#{main.title}<br>#{message.entrycreated(${entryId})}</p><p>这个主要的做法是用于整个网站的字体或者语言文字转化。</p><h5 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h5><p>@{XXXXX}，能够把一个有用的上下文或者是回话信息添加到URL</p><h5 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h5><p>字面（Literals）</p><ul><li>文本文字（Text literals）: ‘one text’, ‘Another one!’,…</li><li>数字文本（Number literals）: 0, 34, 3.0, 12.3,…</li><li>布尔文本（Boolean literals）:true, false</li><li>空（Null literal）:null</li><li>文字标记（Literal tokens）:one, sometext, main,…</li></ul><p>文本操作（Text operations）</p><ul><li>字符串连接(String concatenation):+</li><li>文本替换（Literal substitutions）:|The name is ${name}|</li></ul><p>算术运算（Arithmetic operations）</p><ul><li>二元运算符（Binary operators）:+, -, *, /, %</li><li>减号（单目运算符）Minus sign (unary operator):-</li></ul><p>布尔操作（Boolean operations）</p><ul><li>二元运算符（Binary operators）:and, or</li><li>布尔否定（一元运算符）Boolean negation (unary operator):!, not</li></ul><p>比较和等价(Comparisons and equality)</p><ul><li>比较（Comparators）:&gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)</li><li>等值运算符（Equality operators）:==, != (eq, ne)</li></ul><p>条件运算符（Conditional operators）</p><ul><li>If-then:(if) ? (then)</li><li>If-then-else:(if) ? (then) : (else)</li><li>Default: (value) ?:(defaultvalue)</li></ul><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/q.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/q.jpg" alt=""></p><p>源码地址：</p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/thymeleaf">https://github.com/Antarctica000/SpringBoot/tree/master/thymeleaf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 前端 </tag>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识整合：抢购商品</title>
      <link href="/2020/01/20/spring5/"/>
      <url>/2020/01/20/spring5/</url>
      
        <content type="html"><![CDATA[<h2 id="高并发下抢购商品"><a href="#高并发下抢购商品" class="headerlink" title="高并发下抢购商品"></a>高并发下抢购商品</h2><p>这次做一个知识的总结，把之前所学习的mybatis、redis，rest、和并发编程相关的内容整合起来，模拟一个小型的场景。</p><p>这次场景叫做：抢购商品。我们在淘宝或者京东买东西的时候，偶尔某些商品会有一些打折期。这时候就有很多人去抢购商品，同时也是最考验我们数据库性能和后端设计的时候了。</p><h3 id="设计与开发"><a href="#设计与开发" class="headerlink" title="设计与开发"></a>设计与开发</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>先建立两个表，分别为产品表和订单表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`springtest`</span>.<span class="string">`t_product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品名称'</span>,</span><br><span class="line">  <span class="string">`stock`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'库存'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'单价'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  <span class="string">`note`</span> <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><p>订单表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`springtest`</span>.<span class="string">`t_purchase_record`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`product_id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品编号'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'价格'</span>,</span><br><span class="line">  <span class="string">`quantity`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'数量'</span>,</span><br><span class="line">  <span class="string">`sum`</span> <span class="built_in">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'总价'</span>,</span><br><span class="line">  <span class="string">`purchase_date`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>() <span class="keyword">COMMENT</span> <span class="string">'购买日期'</span>,</span><br><span class="line">  <span class="string">`note`</span> <span class="built_in">VARCHAR</span>(<span class="number">512</span>) <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h4 id="持久层开发"><a href="#持久层开发" class="headerlink" title="持久层开发"></a>持久层开发</h4><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductPo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3288311147760635602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> String note;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"purchaseRecord"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRecordPo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">360816189433370174L</span>;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Long userId;</span><br><span class="line"><span class="keyword">private</span> Long productId;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">private</span> Timestamp purchaseTime;</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接入了 Serializable，之所以要这么做，是为了<strong>序列化</strong>。</p><p>什么情况下需要序列化？</p><ul><li>a）当你想把的内存中的对象写入到硬盘的时候；</li><li>b）当你想用套接字在网络上传送对象的时候；</li><li>c）当你想通过RMI传输对象的时候</li></ul><p>总的就是说安全性问题，具体原因见解释：假如没有一个接口（即没有Serializable来标记是否可以序列化），让所有对象都可以序列化。那么所有对象通过序列化存储到硬盘上后，都可以在序列化得到的文件中看到属性对应的值（后面将会通过代码展示）。所以最后为了安全性（即不让一些对象中私有属性的值被外露），不能让所有对象都可以序列化。要让用户自己来选择是否可以序列化，因此需要一个接口来标记该类是否可序列化。。</p><p>最重要的两个原因是：<br>　　1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；<br>　　2、按值将对象从一个应用程序域发送至另一个应用程序域。<br>通俗的说：在分布式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。</p><h5 id="xml设计"><a href="#xml设计" class="headerlink" title="xml设计"></a>xml设计</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.designshop.dao.ProductDao"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 获取产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select id, product_name as productName,</span><br><span class="line">stock, price, version, note from t_product</span><br><span class="line">where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 减库存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decreaseProduct"</span>&gt;</span></span><br><span class="line">update t_product set stock = stock - #&#123;quantity&#125;,</span><br><span class="line">version = version +1</span><br><span class="line">where id = #&#123;id&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.designshop.dao.PurchaseRecordDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertPurchaseRecord"</span> <span class="attr">parameterType</span>=<span class="string">"purchaseRecord"</span>&gt;</span></span><br><span class="line">insert into t_purchase_record(</span><br><span class="line">user_id, product_id, price, quantity, sum, purchase_date, note)</span><br><span class="line">values(#&#123;userId&#125;, #&#123;productId&#125;, #&#123;price&#125;, #&#123;quantity&#125;,</span><br><span class="line">#&#123;sum&#125;, now(), #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductPo <span class="title">getProduct</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//减库存，而@Param标明MyBatis参数传递给后台</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decreaseProduct</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id, @<span class="title">Param</span><span class="params">(<span class="string">"quantity"</span>)</span> <span class="keyword">int</span> quantity)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PurchaseRecordDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertPurchaseRecord</span><span class="params">(PurchaseRecordPo pr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.example.designshop.pojo</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line">      # 隔离级别为读写提交</span><br><span class="line">      default-transaction-isolation: 2</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>隔离级别涉及到数据库事务相关，譬如脏读可重复读等待，以后会讲。</p><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PurchaseService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理购买业务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId 用户编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productId 产品编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> quantity 购买数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功or失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseServiceImpl</span> <span class="keyword">implements</span> <span class="title">PurchaseService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductDao productDao = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PurchaseRecordDao purchaseRecordDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="comment">// 启动Spring数据库事务机制</span></span><br><span class="line"> <span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 获取产品</span></span><br><span class="line"> ProductPo product = productDao.getProduct(productId);</span><br><span class="line"> <span class="comment">// 比较库存和购买数量</span></span><br><span class="line"> <span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line"> <span class="comment">// 库存不足</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 扣减库存</span></span><br><span class="line"> productDao.decreaseProduct(productId, quantity);</span><br><span class="line"> <span class="comment">// 初始化购买记录</span></span><br><span class="line"> PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line"> <span class="comment">// 插入购买记录</span></span><br><span class="line"> purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 初始化购买信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PurchaseRecordPo <span class="title">initPurchaseRecord</span><span class="params">(Long userId, ProductPo product, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">PurchaseRecordPo pr = <span class="keyword">new</span> PurchaseRecordPo();</span><br><span class="line">pr.setNote(<span class="string">"购买日志，时间："</span> + System.currentTimeMillis());</span><br><span class="line">pr.setPrice(product.getPrice());</span><br><span class="line">pr.setProductId(product.getId());</span><br><span class="line">pr.setQuantity(quantity);</span><br><span class="line"><span class="keyword">double</span> sum = product.getPrice() * quantity;</span><br><span class="line">pr.setSum(sum);</span><br><span class="line">pr.setUserId(userId);</span><br><span class="line"><span class="keyword">return</span> pr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显的可以看到，我们从Dao层读取数据，看看是否还有库存，如果库存不足，则直接返回false，否则进行扣减库存，并且更新订单表。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REST风格控制器</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PurchaseService purchaseService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/purchase"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">purchase</span><span class="params">(Long userId, Long productId, Integer quantity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> success = purchaseService.purchase(userId, productId, quantity);</span><br><span class="line">String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">Result result = <span class="keyword">new</span> Result(success, message);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 响应结果</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> String message = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">boolean</span> success, String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.success = success;</span><br><span class="line"><span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层从从服务层调用方法，并且将数据装进响应结果里面。可以从控制层看到的是，我们是通过result传达信息到前端的。</p><h5 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--后面需要改写这段JavaScript脚本进行测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">         <span class="keyword">var</span> params = &#123;</span></span><br><span class="line">             userId : 1,</span><br><span class="line">             productId : 1,</span><br><span class="line">             quantity : 3</span><br><span class="line">         &#125;;</span><br><span class="line"><span class="actionscript">         <span class="comment">// 通过POST请求后端</span></span></span><br><span class="line"><span class="javascript">         $.post(<span class="string">"./purchase"</span>, params, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">             alert(result.message);</span><br><span class="line">         &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端会使用post方法，去请求后端，执行方法。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这是数据库库存：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/1.png" alt=""></p><p>在网页输入 <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a></p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/3.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/2.png" alt=""></p><p>抢购成功！</p><p>回看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/4.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/5.png" alt=""></p><h3 id="高并发情况下"><a href="#高并发情况下" class="headerlink" title="高并发情况下"></a>高并发情况下</h3><h4 id="500次抢购"><a href="#500次抢购" class="headerlink" title="500次抢购"></a>500次抢购</h4><p>上面的例子仅仅是在一个单例进行的测试，那么，在高并发情况下，有着很多很多的请求呢？</p><p>我们假设有300的库存：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/6.png" alt=""></p><p>在html页面设置 500次抢购：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i<span class="tag">&lt;<span class="name">=500;</span> <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">var</span> <span class="attr">params</span> = <span class="string">&#123;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">userId</span> <span class="attr">:</span> <span class="attr">1</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">productId</span> <span class="attr">:</span> <span class="attr">1</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">quantity</span> <span class="attr">:</span> <span class="attr">1</span></span></span><br><span class="line"><span class="tag">    &#125;;</span></span><br><span class="line"><span class="tag">    // 通过<span class="attr">POST</span>请求后端,这里的<span class="attr">JavaScript</span>会采用异步请求</span></span><br><span class="line"><span class="tag">    $<span class="attr">.post</span>("<span class="attr">.</span>/<span class="attr">purchase</span>", <span class="attr">params</span>, <span class="attr">function</span>(<span class="attr">result</span>) &#123;</span></span><br><span class="line"><span class="tag">    &#125;);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>再次输入  <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a> 进行测试：</p><p>结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/7.png" alt=""></p><p>？？？？   -5？</p><p>为什么会有这样数据，我们再看看订单表：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/8.png" alt=""></p><p>确实有着305条订单，显然，数据库事务的读写级别虽然达到了一致性，却没有达到原子性。面对这种情况，根据我们所学的知识，在并发编程里，可以使用<strong>锁</strong>去完成。</p><h4 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h4><p>在这样的高并发情况下，最简单粗暴的解决方法就是加锁，下面我们为数据库加一条锁，在xml 加入 for update 。就使用了悲观锁，当前的SQL被执行时，不允许其他线程执行该SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select id, product_name as productName,</span><br><span class="line">stock, price, version, note from t_product</span><br><span class="line">where id=#&#123;id&#125; for update </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再打开 <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a>  进行测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/9.png" alt=""></p><p>我们发现，成功保持了只有300条的订单。但是，在使用这样悲观锁的前提下，数据库的性能会变成很差，效率也就变的缓慢。所以，我们开始引入乐观锁。</p><h4 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h4><p>乐观锁是一种不使用数据库锁和不阻塞线程并发的方案。就是一个线程一开始先读取商品库存数据，保存起来，我们把这些旧数据称之为旧值，然后执行一定的业务逻辑，等到需要对共享数据做修改时，会事先将保存的旧值库存与当前数据库的库存进行比较，如果旧值与当前库存一致，它就认为数据没有被修改过，否则就认为数据已经被修改过，当前计算将不被信任，所以就不再修改任何数据。</p><p>这就是多线程的概念 :CAS</p><p>然而，这一种方案却会引发一种ABA问题。关于ABA问题，之前在讲AtomicInteger 的时候谈论过，这里再放一个例子：</p><p>AbA问题的产生：要了解什么是ABA问题，首先我们来通俗的看一下这个例子，一家火锅店为了生意推出了一个特别活动，凡是在五一期间的老用户凡是卡里余额小于20的，赠送10元，但是这种活动没人只可享受一次。然后火锅店的后台程序员小王开始工作了，很简单就用cas技术，先去用户卡里的余额，然后包装成AtomicInteger，写一个判断，开启10个线程，然后判断小于20的，一律加20，然后就很开心的交差了。可是过了一段时间，发现账面亏损的厉害，老板起先的预支是2000块，因为店里的会员总共也就100多个，就算每人都符合条件，最多也就2000啊，怎么预支了这么多。小王一下就懵逼了，赶紧debug，tail -f一下日志，这不看不知道，一看吓一跳，有个客户被充值了10次!</p><p>阐述：</p><p>假设有个线程A去判断账户里的钱此时是15，满足条件，直接+20，这时候卡里余额是35.但是此时不巧，正好在连锁店里，这个客人正在消费，又消费了20，此时卡里余额又为15，线程B去执行扫描账户的时候，发现它又小于20，又用过cas给它加了20，这样的话就相当于加了两次，这样循环往复肯定把老板的钱就坑没了！</p><p>本质：</p><p>ABA问题的根本在于cas在修改变量的时候，无法记录变量的状态，比如修改的次数，否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成casd多次执行的问题。</p><p>为了解决这样的问题，我们在这个例子中引入了版本号。</p><h5 id="增加版本号判断"><a href="#增加版本号判断" class="headerlink" title="增加版本号判断"></a>增加版本号判断</h5><p>在xml中修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 减库存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decreaseProduct"</span>&gt;</span></span><br><span class="line">update t_product set stock = stock - #&#123;quantity&#125;,</span><br><span class="line">version = version +1</span><br><span class="line">where id = #&#123;id&#125; and version =  #&#123;version&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在DAO层中修改定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decreaseProduct</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id,</span></span><br><span class="line"><span class="function">    @<span class="title">Param</span><span class="params">(<span class="string">"quantity"</span>)</span> <span class="keyword">int</span> quantity, @<span class="title">Param</span><span class="params">(<span class="string">"version"</span>)</span> <span class="keyword">int</span> version)</span>;</span><br></pre></td></tr></table></figure><p>修改服务层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 启动Spring数据库事务机制</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取产品（线程旧值）</span></span><br><span class="line">ProductPo product = productDao.getProduct(productId);</span><br><span class="line"><span class="comment">// 比较库存和购买数量</span></span><br><span class="line"><span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line"><span class="comment">// 库存不足</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前版本号</span></span><br><span class="line"><span class="keyword">int</span> version = product.getVersion();</span><br><span class="line"><span class="comment">// 扣减库存,同时将当前版本号发送给后台去比较</span></span><br><span class="line"><span class="keyword">int</span> result = productDao.decreaseProduct(productId, quantity, version);</span><br><span class="line"><span class="comment">// 如果更新数据失败，说明数据在多线程中被其他线程修改，导致失败返回</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化购买记录</span></span><br><span class="line">PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line"><span class="comment">// 插入购买记录</span></span><br><span class="line">purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，我们每次执行都会去数据库读取版本号，如果一致则版本号+1，并且修改，否则则返回false。</p><p>再次测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/10.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/11.png" alt=""></p><p>居然还有库存？？？</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/12.png" alt=""></p><p>显然，大量的请求得到了大量的失败，这就导致了我们500次的读取却只有84次是成功的。</p><p>为了解决这个问题，乐观锁还可以引入重入机制，就是一旦更新失败，就重新做一次，而不是结束请求。</p><h5 id="按时间戳重入"><a href="#按时间戳重入" class="headerlink" title="按时间戳重入"></a>按时间戳重入</h5><p>但是这样又引入了其他问题，比如，SQL被执行的次数总数恐怕达到了上千次。为了克服这个问题，我们引入时间戳的方法来试试重入机制。</p><p>修改服务层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动Spring数据库事务机制</span></span><br><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 循环尝试直至成功</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 循环时间</span></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 如果循环时间大于100毫秒返回终止循环</span></span><br><span class="line"><span class="keyword">if</span> (end - start &gt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取产品</span></span><br><span class="line">ProductPo product = productDao.getProduct(productId);</span><br><span class="line"><span class="comment">// 获取当前版本号</span></span><br><span class="line"><span class="keyword">int</span> version = product.getVersion();</span><br><span class="line"><span class="comment">// 比较库存和购买数量</span></span><br><span class="line"><span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line"><span class="comment">// 库存不足</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扣减库存,同时将当前版本号发送给后台去比较</span></span><br><span class="line"><span class="keyword">int</span> result = productDao.decreaseProduct(productId, quantity, version);</span><br><span class="line"><span class="comment">// 如果更新数据失败，说明数据在多线程中被其他线程修改，</span></span><br><span class="line"><span class="comment">// 导致失败，则通过循环重入尝试购买商品</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化购买记录</span></span><br><span class="line">PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line"><span class="comment">// 插入购买记录</span></span><br><span class="line">purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将一个请求限制为100ms的生存期，如果在100ms内发生版本号冲突而不能更新的，则重新尝试，否则请求失败。</p><p>开始测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/13.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/14.png" alt=""></p><p>可以看到，测试成功了。</p><p>但是按照时间戳重入也有一个弊端，那就是系统会随着自身的忙碌而大大减少重入次数，因此有时候也会采用按次数重入的机制。</p><h5 id="按次数重入"><a href="#按次数重入" class="headerlink" title="按次数重入"></a>按次数重入</h5><p>服务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 启动Spring数据库事务机制，并将隔离级别设置为读写提交</span></span><br><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 循环尝试直至成功</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 如果循环时间大于100毫秒返回终止循环</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取产品</span></span><br><span class="line">        ProductPo product = productDao.getProduct(productId);</span><br><span class="line">        <span class="comment">// 比较库存和购买数量</span></span><br><span class="line">        <span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前版本号</span></span><br><span class="line">        <span class="keyword">int</span> version = product.getVersion();</span><br><span class="line">        <span class="comment">// 扣减库存,同时将当前版本号发送给后台去比较</span></span><br><span class="line">        <span class="keyword">int</span> result = productDao.decreaseProduct(productId, quantity,version);</span><br><span class="line">        <span class="comment">// 如果更新数据失败，说明数据在多线程中被其他线程修改，</span></span><br><span class="line">        <span class="comment">// 导致失败，则通过循环重入尝试购买商品</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化购买记录</span></span><br><span class="line">        PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line">        <span class="comment">// 插入购买记录</span></span><br><span class="line">        purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里使用for的三重循环进行尝试。三次去尝试获取锁，如果都不能够成功获得，则请求失败。但是使用乐观锁，还是一个相对来说比较复杂的方式，因为在不同场景下势必要在后端中多次更改代码。现在，可以使用Redis缓存，去解决这个问题。</p><h4 id="使用Redis处理高并发"><a href="#使用Redis处理高并发" class="headerlink" title="使用Redis处理高并发"></a>使用Redis处理高并发</h4><p>在高并发的环境下，仅仅使用数据库去完成业务，是不够的。在前人的摸索中，开发出了一个叫Redis的缓存，去搭配数据库完成业务。</p><p>数据库是一个读写磁盘的过程，这个速度显然没有直接写入内存的Redis快。Redis的机制也能够帮助我们克服超发现象。但是，因为其命令方式的运算能力比较薄弱，所以往往采用Redis Luau去代替它原有的命令方式。</p><p>Redis Lua在Redis的执行中是具备原子性的，当它被执行时不会被其他客户端发送的命令所打断，通过这样一种机制可以在高并发环境下考虑使用Redis去代替数据库作为响应用户的数据载体。</p><p>设计主要分两部分：</p><ul><li>先使用Redis响应高并发用户的请求。</li><li>启动定时任务将Redis保存到数据库。</li></ul><h5 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">  jedis:</span><br><span class="line">    pool:</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 10</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 2000</span><br><span class="line">  port: 6379</span><br><span class="line">  host: localhost</span><br><span class="line">  timeout: 1000</span><br></pre></td></tr></table></figure><h5 id="服务层-1"><a href="#服务层-1" class="headerlink" title="服务层"></a>服务层</h5><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">purchaseRedis</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dealRedisPurchase</span><span class="params">(List&lt;PurchaseRecordPo&gt; prpList)</span></span>;</span><br></pre></td></tr></table></figure><p>定制属于Redis的查找和删除</p><p>服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line">String purchaseScript =</span><br><span class="line"><span class="comment">// 先将产品编号保存到集合中</span></span><br><span class="line"><span class="string">" redis.call('sadd', KEYS[1], ARGV[2]) \n"</span></span><br><span class="line"><span class="comment">// 购买列表</span></span><br><span class="line">+ <span class="string">"local productPurchaseList = KEYS[2]..ARGV[2] \n"</span></span><br><span class="line"><span class="comment">// 用户编号</span></span><br><span class="line">+ <span class="string">"local userId = ARGV[1] \n"</span></span><br><span class="line"><span class="comment">// 产品key</span></span><br><span class="line">+ <span class="string">"local product = 'product_'..ARGV[2] \n"</span></span><br><span class="line"><span class="comment">// 购买数量</span></span><br><span class="line">+ <span class="string">"local quantity = tonumber(ARGV[3]) \n"</span></span><br><span class="line"><span class="comment">// 当前库存</span></span><br><span class="line">+ <span class="string">"local stock = tonumber(redis.call('hget', product, 'stock')) \n"</span></span><br><span class="line"><span class="comment">// 价格</span></span><br><span class="line">+ <span class="string">"local price = tonumber(redis.call('hget', product, 'price')) \n"</span></span><br><span class="line"><span class="comment">// 购买时间</span></span><br><span class="line">+ <span class="string">"local purchase_date = ARGV[4] \n"</span></span><br><span class="line"><span class="comment">// 库存不足，返回0</span></span><br><span class="line">+ <span class="string">"if stock &lt; quantity then return 0 end \n"</span></span><br><span class="line"><span class="comment">// 减库存</span></span><br><span class="line">+ <span class="string">"stock = stock - quantity \n"</span></span><br><span class="line">+ <span class="string">"redis.call('hset', product, 'stock', tostring(stock)) \n"</span></span><br><span class="line"><span class="comment">// 计算价格</span></span><br><span class="line">+ <span class="string">"local sum = price * quantity \n"</span></span><br><span class="line"><span class="comment">// 合并购买记录数据</span></span><br><span class="line">+ <span class="string">"local purchaseRecord = userId..','..quantity..','"</span></span><br><span class="line">+ <span class="string">"..sum..','..price..','..purchase_date \n"</span></span><br><span class="line"><span class="comment">// 保存到将购买记录保存到list里</span></span><br><span class="line">+ <span class="string">"redis.call('rpush', productPurchaseList, purchaseRecord) \n"</span></span><br><span class="line"><span class="comment">// 返回成功</span></span><br><span class="line">+ <span class="string">"return 1 \n"</span>;</span><br><span class="line"><span class="comment">// Redis购买记录集合前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PURCHASE_PRODUCT_LIST = <span class="string">"purchase_list_"</span>;</span><br><span class="line"><span class="comment">// 抢购商品集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_SCHEDULE_SET = <span class="string">"product_schedule_set"</span>;</span><br><span class="line"><span class="comment">// 32位SHA1编码，第一次执行的时候先让Redis进行缓存脚本返回</span></span><br><span class="line"><span class="keyword">private</span> String sha1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchaseRedis</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 购买时间</span></span><br><span class="line">Long purchaseDate = System.currentTimeMillis();</span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取原始连接</span></span><br><span class="line">jedis = (Jedis) stringRedisTemplate</span><br><span class="line">.getConnectionFactory().getConnection().getNativeConnection();</span><br><span class="line"><span class="comment">// 如果没有加载过，则先将脚本加载到Redis服务器，让其返回sha1</span></span><br><span class="line"><span class="keyword">if</span> (sha1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">sha1 = jedis.scriptLoad(purchaseScript);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行脚本，返回结果</span></span><br><span class="line">Object res = jedis.evalsha(sha1, <span class="number">2</span>, PRODUCT_SCHEDULE_SET,</span><br><span class="line">PURCHASE_PRODUCT_LIST, userId + <span class="string">""</span>, productId + <span class="string">""</span>,</span><br><span class="line">quantity + <span class="string">""</span>, purchaseDate + <span class="string">""</span>);</span><br><span class="line">Long result = (Long) res;</span><br><span class="line"><span class="keyword">return</span> result == <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭jedis连接</span></span><br><span class="line"><span class="keyword">if</span> (jedis != <span class="keyword">null</span> &amp;&amp; jedis.isConnected()) &#123;</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码中的StringRedisTemplate 是由SpringBoot机制自动生成的。</p><p>购买记录中使用了Lua语言，会在第一次执行时，把脚本缓存到Redis服务器中，然后Redis会返回一个 32位的SHA1编码，并缓存到变量sha1中，再通过它将程序需要的键和参数传递到后台去执行Lua脚本。Lua脚本会在减少库存后，将信息缓存起来。</p><p>注意这一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行脚本，返回结果</span></span><br><span class="line">Object res = jedis.evalsha(sha1, <span class="number">2</span>, PRODUCT_SCHEDULE_SET,</span><br><span class="line">PURCHASE_PRODUCT_LIST, userId + <span class="string">""</span>, productId + <span class="string">""</span>,</span><br><span class="line">quantity + <span class="string">""</span>, purchaseDate + <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>局部变量sha1代表一个32位的SHA1编码，用来执行缓存在Redis的脚本中，所以PRODUCT_SCHEDULE_SET和PURCHASE_PRODUCT_LIST都只是键。它们在Lua脚本中以Key[index]表示。而index则是它的索引，以1开始。从第二个参数之后，则都是脚本的参数，在Lua脚本中会以ARGV[index]表示。</p><p>最后，保存记录的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 当运行方法启用新的独立事务运行</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dealRedisPurchase</span><span class="params">(List&lt;PurchaseRecordPo&gt; prpList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (PurchaseRecordPo prp : prpList) &#123;</span><br><span class="line">        purchaseRecordDao.insertPurchaseRecord(prp);</span><br><span class="line">        productDao.decreaseProduct(prp.getProductId(), prp.getQuantity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将会把购买记录保存到数据库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br></pre></td></tr></table></figure><p>这个事务传播行为配置为 Propagation.REQUIRES_NEW 这意味这它会将当前事务挂起，开启新的事务，回滚时只会回滚这个方法的内部事务，而不会影响全局事务。</p><h5 id="开启定时任务"><a href="#开启定时任务" class="headerlink" title="开启定时任务"></a>开启定时任务</h5><p>启动器上添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br></pre></td></tr></table></figure><h5 id="增加定时任务接口"><a href="#增加定时任务接口" class="headerlink" title="增加定时任务接口"></a>增加定时任务接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定时任务服务"><a href="#定时任务服务" class="headerlink" title="定时任务服务"></a>定时任务服务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PurchaseService purchaseService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_SCHEDULE_SET = <span class="string">"product_schedule_set"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PURCHASE_PRODUCT_LIST = <span class="string">"purchase_list_"</span>;</span><br><span class="line">    <span class="comment">// 每次取出1000条，避免一次取出消耗太多内存，导致JVM内存溢出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_TIME_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 每天半夜1点钟开始执行任务</span></span><br><span class="line"><span class="comment">//    @Scheduled(cron = "0 0 1 * * ?")</span></span><br><span class="line">    <span class="comment">// 下面是用于测试的配置，每分钟执行一次任务</span></span><br><span class="line">     <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"定时任务开始......"</span>);</span><br><span class="line">        Set&lt;String&gt; productIdList</span><br><span class="line">    = stringRedisTemplate.opsForSet().members(PRODUCT_SCHEDULE_SET);</span><br><span class="line">        List&lt;PurchaseRecordPo&gt; prpList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String productIdStr : productIdList) &#123;</span><br><span class="line">            Long productId = Long.parseLong(productIdStr);</span><br><span class="line">            String purchaseKey = PURCHASE_PRODUCT_LIST + productId;</span><br><span class="line">            BoundListOperations&lt;String, String&gt; ops</span><br><span class="line">        = stringRedisTemplate.boundListOps(purchaseKey);</span><br><span class="line">            <span class="comment">// 计算记录数</span></span><br><span class="line">            <span class="keyword">long</span> size = stringRedisTemplate.opsForList().size(purchaseKey);</span><br><span class="line">            Long times = size % ONE_TIME_SIZE == <span class="number">0</span> ? </span><br><span class="line">        size / ONE_TIME_SIZE : size / ONE_TIME_SIZE + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取至多TIME_SIZE个抢红包信息</span></span><br><span class="line">                List&lt;String&gt; prList = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    prList  = ops.range(i * ONE_TIME_SIZE, </span><br><span class="line">    (i + <span class="number">1</span>) * ONE_TIME_SIZE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prList = ops.range(i * ONE_TIME_SIZE + <span class="number">1</span>, </span><br><span class="line">    (i + <span class="number">1</span>) * ONE_TIME_SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String prStr : prList) &#123;</span><br><span class="line">                    PurchaseRecordPo prp </span><br><span class="line">    = <span class="keyword">this</span>.createPurchaseRecord(productId, prStr);</span><br><span class="line">                    prpList.add(prp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 采用该方法采用新建事务的方式，这样不会导致全局事务回滚</span></span><br><span class="line">                    purchaseService.dealRedisPurchase(prpList);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清除列表为空，等待重新写入数据</span></span><br><span class="line">                prpList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除购买列表</span></span><br><span class="line">            stringRedisTemplate.delete(purchaseKey);</span><br><span class="line">            <span class="comment">// 从商品集合中删除商品</span></span><br><span class="line">            stringRedisTemplate.opsForSet()</span><br><span class="line">    .remove(PRODUCT_SCHEDULE_SET, productIdStr);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"定时任务结束......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> PurchaseRecordPo <span class="title">createPurchaseRecord</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Long productId, String prStr)</span> </span>&#123;</span><br><span class="line">        String[] arr = prStr.split(<span class="string">","</span>);</span><br><span class="line">        Long userId = Long.parseLong(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> quantity = Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">double</span> sum = Double.valueOf(arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">double</span> price = Double.valueOf(arr[<span class="number">3</span>]);</span><br><span class="line">        Long time = Long.parseLong(arr[<span class="number">4</span>]);</span><br><span class="line">        Timestamp purchaseTime = <span class="keyword">new</span> Timestamp(time);</span><br><span class="line">        PurchaseRecordPo pr = <span class="keyword">new</span> PurchaseRecordPo();</span><br><span class="line">        pr.setProductId(productId);</span><br><span class="line">        pr.setPurchaseTime(purchaseTime);</span><br><span class="line">        pr.setPrice(price);</span><br><span class="line">        pr.setQuantity(quantity);</span><br><span class="line">        pr.setSum(sum);</span><br><span class="line">        pr.setUserId(userId);</span><br><span class="line">        pr.setNote(<span class="string">"购买日志，时间："</span> + purchaseTime.getTime());</span><br><span class="line">        <span class="keyword">return</span> pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Scheduled定义时间：上一篇文章有写具体该怎么写。</p><p>它会从产品列表中读取产品编号，然后根据产品编号找到购买列表。在读出数据后，会转换为POJO对象，通过PurchaseService的createPurchaseRecord方法进行保存。</p><h5 id="修改控制层"><a href="#修改控制层" class="headerlink" title="修改控制层"></a>修改控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/purchase"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">purchase</span><span class="params">(Long userId, Long productId, Integer quantity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> success = purchaseService.purchaseRedis(userId, productId, quantity);</span><br><span class="line">String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">Result result = <span class="keyword">new</span> Result(success, message);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后注意记得删除mapper中的version判定。</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>在Redis输入：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/15.png" alt=""></p><p>打开 <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a> 测试：</p><p>查看Redis:</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/16.png" alt=""></p><p>发现多了这些键，这正是我们在业务层定义的键，查看键里包含的值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/17.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/19.png" alt=""></p><p>发现Redis存储了这次数据库执行的结果，但是还没有写入数据库。在实际应用中，我们可以让Redis在一个夜深人静的夜晚，再缓慢的写回数据库。时间使用@Scheduled定义。</p><p>等时间到了，IDEA会出现这段文字：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/18.png" alt=""></p><p>再去查看数据库，发现成功写回了：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/13.png" alt=""></p><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/designshop">https://github.com/Antarctica000/SpringBoot/tree/master/designshop</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> 项目 </tag>
            
            <tag> MyBtis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合RabbitMQ</title>
      <link href="/2020/01/19/spring4/"/>
      <url>/2020/01/19/spring4/</url>
      
        <content type="html"><![CDATA[<h2 id="中间件技术：RabbitMQ"><a href="#中间件技术：RabbitMQ" class="headerlink" title="中间件技术：RabbitMQ"></a>中间件技术：RabbitMQ</h2><p>有了中间件，就相当于以后上学不用走路，而是骑单车。:call_me_hand:</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>中间件（英语：Middleware），又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。</p><p>就好似下图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r1.png" alt=""></p><p>而RabbitMQ则是一个中间件。</p><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而聚类和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p><p>简而言之，RabbitMQ是一套开源（MPL）的消息队列服务软件，我们使用这个消息队列，去传输信息。</p><h3 id="RabbitMQ的特性"><a href="#RabbitMQ的特性" class="headerlink" title="RabbitMQ的特性"></a>RabbitMQ的特性</h3><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ul><li>可靠性（Reliability）</li></ul><p>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p><ul><li>灵活的路由（Flexible Routing）</li></ul><p>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p><ul><li>消息集群（Clustering）</li></ul><p>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p><ul><li>高可用（Highly Available Queues）</li></ul><p>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p><ul><li>多种协议（Multi-protocol）</li></ul><p>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p><ul><li>多语言客户端（Many Clients）</li></ul><p>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p><ul><li>管理界面（Management UI）</li></ul><p>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</p><ul><li>跟踪机制（Tracing）</li></ul><p>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p><ul><li>插件机制（Plugin System）</li></ul><p>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p><h3 id="RabbitMQ的基本组成"><a href="#RabbitMQ的基本组成" class="headerlink" title="RabbitMQ的基本组成"></a>RabbitMQ的基本组成</h3><ul><li>Message</li></ul><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><ul><li>Publisher</li></ul><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><ul><li>Exchange</li></ul><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><ul><li>Routing Key</li></ul><p>路由关键字,exchange根据这个关键字进行消息投递。</p><ul><li>Binding</li></ul><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><ul><li>Queue</li></ul><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ul><li>Connection</li></ul><p>网络连接，比如一个TCP连接。</p><ul><li>Channel</li></ul><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><ul><li>Consumer</li></ul><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ul><li>Virtual Host</li></ul><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ul><li>Broker</li></ul><p>表示消息队列服务器实体。它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输。</p><h3 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h3><p>RabbitMQ需要提前在电脑中安装，这里不多赘述，先发个网址给大家安装：</p><p><a href="https://blog.csdn.net/weixin_39735923/article/details/79288578" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39735923/article/details/79288578</a></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看清楚，RabbitMQ的依赖叫做<strong>AMQP</strong>。</p><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure><p>因为我们不进行web的测试，这里仅仅只需要配置rabbitmq就行了。下面就正式开始测试，并且介绍一下RabbitMQ的三个模式。</p><h4 id="Direct-Exchange（直接交换）"><a href="#Direct-Exchange（直接交换）" class="headerlink" title="Direct Exchange（直接交换）"></a>Direct Exchange（直接交换）</h4><p>直接交换：- 直接交换是一种基于消息路由密钥将消息路由到队列的交换。路由密钥是生产者添加的消息头中的消息属性。生产者在消息头中添加路由密钥，并将其发送到直接交换。收到消息后，交换  尝试匹配的路由键  与所有绑定到队列的结合键  它。如果找到匹配项，它将消息路由到绑定键  已匹配的队列，如果未找到匹配项，它将忽略该消息。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r2.png" alt=""></p><p>下面进行测试：</p><h5 id="一对一发送"><a href="#一对一发送" class="headerlink" title="一对一发送"></a>一对一发送</h5><p><strong>config包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里导入的队列是：</span></span><br><span class="line">    <span class="comment">//org.springframework.amqp.core.Queue;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rabbitmq包</strong></p><p>发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context = <span class="string">"hello----"</span>+<span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"send:"</span>+context);</span><br><span class="line">        <span class="comment">//往名称为 hello 的queue中发送消息</span></span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息处理器</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver:"</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><p>我们这次就直接使用IDEA下的测试类，开始对队列进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Sender Sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send:hello----Sun Jan 19 19:12:00 CST 2020</span><br><span class="line">Receiver:hello----Sun Jan 19 19:12:00 CST 2020</span><br></pre></td></tr></table></figure><p>可以看到，这是一个单对单的发送。</p><h5 id="一对多发送"><a href="#一对多发送" class="headerlink" title="一对多发送"></a>一对多发送</h5><p>在Sender继续添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给hello2发送消息,并接受一个计数参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    String context = i+<span class="string">""</span>;</span><br><span class="line">    System.out.println(context+<span class="string">"--send:"</span>);</span><br><span class="line">    <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello2"</span>,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver1:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver2:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始下一轮测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manyReceiver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Sender.send2(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0--send:</span><br><span class="line">1--send:</span><br><span class="line">2--send:</span><br><span class="line">3--send:</span><br><span class="line">4--send:</span><br><span class="line">5--send:</span><br><span class="line">6--send:</span><br><span class="line">7--send:</span><br><span class="line">8--send:</span><br><span class="line">9--send:</span><br><span class="line">Receiver1:0</span><br><span class="line">Receiver2:1</span><br><span class="line">Receiver1:2</span><br><span class="line">Receiver2:3</span><br><span class="line">Receiver2:5</span><br><span class="line">Receiver1:4</span><br><span class="line">Receiver2:7</span><br><span class="line">Receiver1:6</span><br><span class="line">Receiver2:9</span><br><span class="line">Receiver1:8</span><br></pre></td></tr></table></figure><p>可以从结果看到，我们发送了10个消息，这些消息有两个接收者。而这两个接收者均匀的接收了这10个消息。</p><h5 id="多对多发送"><a href="#多对多发送" class="headerlink" title="多对多发送"></a>多对多发送</h5><p>有了前面两个案例，我们再来试试多对多发送是如何的：</p><p>再建立一个新的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        String context = i+<span class="string">""</span>;</span><br><span class="line">        System.out.println(context+<span class="string">"--send:"</span>);</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello2"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得同时也需要注入AutoWired，再添加测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">many2many</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Sender.send2(i);</span><br><span class="line">        Sender2.send2(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">0--send:</span><br><span class="line">0--send:</span><br><span class="line">1--send:</span><br><span class="line">1--send:</span><br><span class="line">2--send:</span><br><span class="line">2--send:</span><br><span class="line">3--send:</span><br><span class="line">3--send:</span><br><span class="line">4--send:</span><br><span class="line">4--send:</span><br><span class="line">5--send:</span><br><span class="line">5--send:</span><br><span class="line">6--send:</span><br><span class="line">6--send:</span><br><span class="line">7--send:</span><br><span class="line">7--send:</span><br><span class="line">8--send:</span><br><span class="line">8--send:</span><br><span class="line">9--send:</span><br><span class="line">9--send:</span><br><span class="line">Receiver2:0</span><br><span class="line">Receiver1:0</span><br><span class="line">Receiver2:1</span><br><span class="line">Receiver1:1</span><br><span class="line">Receiver2:2</span><br><span class="line">Receiver1:2</span><br><span class="line">Receiver2:3</span><br><span class="line">Receiver1:3</span><br><span class="line">Receiver2:4</span><br><span class="line">Receiver2:5</span><br><span class="line">Receiver1:4</span><br><span class="line">Receiver2:6</span><br><span class="line">Receiver1:5</span><br><span class="line">Receiver2:7</span><br><span class="line">Receiver1:6</span><br><span class="line">Receiver2:8</span><br><span class="line">Receiver1:7</span><br><span class="line">Receiver2:9</span><br><span class="line">Receiver1:8</span><br><span class="line">Receiver1:9</span><br></pre></td></tr></table></figure><p>可见他们均匀的收到了消息，且不重复。</p><h5 id="发送对象"><a href="#发送对象" class="headerlink" title="发送对象"></a>发送对象</h5><p>先构建一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">queue3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"object_queue"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发送者和接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Send object:"</span>+user.toString());</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"object_queue"</span>,user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"object_queue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objectReceiver</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver object:"</span>+user.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">object</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"张三"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    objectSender.sendUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Send object:User(username&#x3D;张三, password&#x3D;123456)</span><br><span class="line">Receiver object:User(username&#x3D;张三, password&#x3D;123456)</span><br></pre></td></tr></table></figure><h4 id="Topic-Exchange（主题交换）"><a href="#Topic-Exchange（主题交换）" class="headerlink" title="Topic Exchange（主题交换）"></a>Topic Exchange（主题交换）</h4><p>主题交换： 主题交换是基于队列绑定期间指定的路由键和路由模式之间的通配符匹配，将消息路由到队列的交换。 生产者在消息头中添加路由密钥，并将其发送到主题交换。收到消息后，交换  尝试将路由密钥与与其绑定的所有队列的绑定路由模式进行匹配。如果找到匹配项，它将把消息路由到路由模式匹配的队列，如果找不到匹配项，它将忽略该消息。</p><p>路由关键字：-这是单词列表，以句点（。）分隔，例如“ asia.china.beijing”</p><p>路由模式：- 这是在绑定队列期间指定的模式，它是单词和通配符的列表，例如“ * ”和“ ＃ ”，以句点（。）分隔。通配符的使用如下：</p><ul><li>“ * ”：-用于匹配路由键中特定位置的单词，例如路由模式“ asia.china。*”将与第一个单词为“ asia”且第二个单词为第二个的路由键匹配单词是“ china”，如“ asia.china.beijing”和“ asia.china.nanjing”。</li><li>“ ＃ ”：-用于匹配零个或多个单词，例如“ asia.china。＃”的路由模式将与以“ asia.china”开头的路由键（例如“ asia.china”和“ asia.china.beijing”。</li></ul><p>可以说：topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r3.png" alt=""></p><p>先配置新的configuration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String message = <span class="string">"topic.message"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String messages = <span class="string">"topic.messages"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个 Queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 TopicExchange,指定名称为 topicExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"topicExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给队列绑定 exchange 和 routing_key</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queueMessage, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessage).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bingingExchangeMessages</span><span class="params">(Queue queueMessages, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessages).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>topic发送者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context = <span class="string">"hi, i am message 1"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"topicExchange"</span>,<span class="string">"topic.message"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hi, i am messages 2"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"topicExchange"</span>, <span class="string">"topic.messages"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver topic.messages: "</span>+ message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.message"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver topic.message :"</span>+ message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    topicSender.send1();</span><br><span class="line">    topicSender.send2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, i am message 1</span><br><span class="line">Sender : hi, i am messages 2</span><br><span class="line">Receiver topic.message :hi, i am message 1</span><br><span class="line">Receiver topic.messages: hi, i am message 1</span><br><span class="line">Receiver topic.messages: hi, i am messages 2</span><br></pre></td></tr></table></figure><p>可以看到，绑定的队列头不一样的队列，收到的信息也是不一样的，但是这是一个包含关系。</p><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配的只有Receiver2，Receiver2收到了第二条监听到消息</p><h4 id="Fanout-Exchange（扇出交换）"><a href="#Fanout-Exchange（扇出交换）" class="headerlink" title="Fanout Exchange（扇出交换）"></a>Fanout Exchange（扇出交换）</h4><p>扇出交换：扇出交换是一种将接收到的消息路由到与其绑定的所有队列的交换。 当生产者将消息发送到扇出交换时，它将复制消息并将其路由到与其绑定的所有队列。它只是忽略路由键或生产者提供的任何模式匹配。当需要将同一消息存储在一个或多个队列中时，这种类型的交换非常有用。</p><p>简而言之，Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r4.png" alt=""></p><p>配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanOutRabbitMq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个队列</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">AMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">BMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">CMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建exchange,指定交换策略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别给三个队列指定exchange,这里使用了1、2、3三个队列绑定到Fanout交换机上面，发送端的routing_key写任何字符都会被忽略：</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeA</span><span class="params">(Queue AMessage, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeB</span><span class="params">(Queue BMessage,FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeC</span><span class="params">(Queue CMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutSender</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String context = <span class="string">"hi, fanout msg "</span>;</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="comment">//这里使用了1、2、3三个队列绑定到Fanout交换机上面，发送端的routing_key写任何字符都会被忽略：</span></span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"fanoutExchange"</span>,<span class="string">""</span>, context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver form fanout.A: "</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver form fanout_2: "</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.3"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver form fanout_3: "</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fanoutSender.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">Receiver form fanout_3: hi, fanout msg </span><br><span class="line">Receiver form fanout_1: hi, fanout msg </span><br><span class="line">Receiver form fanout_2: hi, fanout msg</span><br></pre></td></tr></table></figure><p>放个更形象的比喻：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r5.png" alt=""></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>本来是想单开一篇，但实在是觉得太简单，所以也连着一块说了吧。</p><p>异步这个词之前在学习多线程的时候有遇见过，但是可能很多人不太理解该如何结合到Spring当中运用，这次就来粗略的展示一下：</p><p>首先需要一个服务层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span><span class="comment">//告诉spring这是一个异步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数据处理中----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在方法上面标明这是一个异步方法，这样后台就会为这个方法单开一个线程执行。</p><p>最后别忘了在启动器加上注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableAsync&#x2F;&#x2F;开启异步注解功能</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据处理中----Sun Jan 19 22:30:13 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:14 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:15 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:15 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:16 CST 2020</span><br></pre></td></tr></table></figure><p>可以从时间上看到，时间之差似乎只有1秒，仿佛没有把3秒的线程睡眠给编译进去。但是你可以把这个注解取消，就会发现它每个动作都得延迟3秒进行，这就是异步控制。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>在实际运用中，有时候需要定一个时间去发消息，比如各个月末的报表，某些定时推送的新闻，年终的奖金等等，就需要一个定时器去完成。这个在Spring当中，当然也有内置的方法，由于比较简单，所以也一块说了。</p><p>这个定时器也需要在启动器中加入：@EnableScheduling   进行开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）.</span></span><br><span class="line"><span class="comment">     * 0 * * * * MON-FRI</span></span><br><span class="line"><span class="comment">     *  【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次</span></span><br><span class="line"><span class="comment">     *  【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/1 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"scheduled----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就代表了，每一秒都发一条信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scheduled----------</span><br><span class="line">scheduled----------</span><br><span class="line">scheduled----------</span><br></pre></td></tr></table></figure><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/rabbitmq">https://github.com/Antarctica000/SpringBoot/tree/master/rabbitmq</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 中间件 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 异步 </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REST风格</title>
      <link href="/2020/01/18/spring3/"/>
      <url>/2020/01/18/spring3/</url>
      
        <content type="html"><![CDATA[<h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h2><h3 id="初识REST"><a href="#初识REST" class="headerlink" title="初识REST"></a>初识REST</h3><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>比如说，我们以前在进行开发的时候，通常一个请求是：<a href="http://localhost:8888/user/getUser?id=1" target="_blank" rel="noopener">http://localhost:8888/user/getUser?id=1</a></p><p>在这个请求中，getUser是方法名，一个动词，我们要根据这个动词去进行相应的操作，换句话说，这个为名id的用户，它的资料存在这个一个getUser方法中。从现实中来看，这是不科学的，一个用户怎么会存在一个动词当中，一个用户应该使用： <a href="http://localhost:8888/user/1" target="_blank" rel="noopener">http://localhost:8888/user/1</a> 来表达才比较对，user代表了这个群体是一个用户，1表示了这个用户的id。</p><p>基于这种思想，就诞生了一个名为：REST的风格。这种规范自2000年以来，开始流传于世间。</p><h3 id="构建REST风格网站"><a href="#构建REST风格网站" class="headerlink" title="构建REST风格网站"></a>构建REST风格网站</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在构建过程中，除了前面必要的依赖，如mysql、mybatis之外，还需要引入一个人依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这个依赖，才能实现对页面的处理，首先看一个例子：</p><h4 id="页面之间的跳转"><a href="#页面之间的跳转" class="headerlink" title="页面之间的跳转"></a>页面之间的跳转</h4><p>我们在controller中先写入这一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码表示，接收一个index请求，并且会返回一个为名index的字符串。看起来是这样的，但实际上，它在引入了thymeleaf依赖之后，会自动在String后面拼串，返回的是一个名为 index.html的页面。</p><p>同时，也需要在 resource的templates包中，放入index的页面，它就能够识别，且自动跳转。</p><p>同时，你还要学习关于计算机网络和HTTP相关的知识，至少要知道一下几点：</p><p><strong>POST:一般是用于提交数据的</strong></p><p><strong>GET:一般是用于获取数据的</strong></p><p><strong>PUT:一般是用于更新一条数据的</strong></p><p><strong>DELETE:一般是用于删除数据的</strong></p><p><strong>PATCH:一般是用于更新一批数据的</strong></p><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>为了使得出入的数据都能被完全的转移至数据库，通常需要以下几个实体类：</p><p>用于传入数据库的user：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> SexEnum sex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端传进来的user：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sexCode;</span><br><span class="line"><span class="keyword">private</span> String sexName;</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller层中，需要添加的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换Vo变为PO</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> User <span class="title">changeToPo</span><span class="params">(UserVo userVo)</span> </span>&#123;</span><br><span class="line">     User user = <span class="keyword">new</span> User();</span><br><span class="line">     user.setId(userVo.getId());</span><br><span class="line">     user.setUserName(userVo.getUserName());</span><br><span class="line">     user.setSex(SexEnum.getSexEnum(userVo.getSexCode()));</span><br><span class="line">     user.setNote(userVo.getNote());</span><br><span class="line">     <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 转换PO变为VO</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> UserVo <span class="title">changeToVo</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">     UserVo userVo = <span class="keyword">new</span> UserVo();</span><br><span class="line">     userVo.setId(user.getId());</span><br><span class="line">     userVo.setUserName(user.getUserName());</span><br><span class="line">     userVo.setSexCode(user.getSex().getCode());</span><br><span class="line">     userVo.setSexName(user.getSex().getName());</span><br><span class="line">     userVo.setNote(user.getNote());</span><br><span class="line">     <span class="keyword">return</span> userVo;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将PO列表转换为VO列表</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;UserVo&gt; <span class="title">changeToVoes</span><span class="params">(List&lt;User&gt; poList)</span> </span>&#123;</span><br><span class="line">     List&lt;UserVo&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (User user : poList) &#123;</span><br><span class="line">         UserVo userVo = changeToVo(user);</span><br><span class="line">         voList.add(userVo);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> voList;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 结果VO</span></span><br><span class="line"> <span class="meta">@Data</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ResultVo</span><span class="params">(Boolean success, String message)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.success = success;</span><br><span class="line">         <span class="keyword">this</span>.message = message;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Boolean success = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">private</span> String message = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span><br><span class="line">  type-aliases-package: com.example.rest.pojo</span><br><span class="line">  type-handlers-package: com.example.rest.typeHandler</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br></pre></td></tr></table></figure><h4 id="MyBatis的xml配置"><a href="#MyBatis的xml配置" class="headerlink" title="MyBatis的xml配置"></a>MyBatis的xml配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.rest.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">insert into t_user(user_name, note)</span><br><span class="line">values(#&#123;userName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span>user_name =#&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span>note =#&#123;note&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select id, user_name as userName, note from t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">                and user_name = #&#123;userName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span></span><br><span class="line">                and note = #&#123;note&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>为了不多赘述，以下省略mybatis、mysql、typeHandler和enum的配置。</strong></p><h4 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h4><h5 id="添加json数据至数据库"><a href="#添加json数据至数据库" class="headerlink" title="添加json数据至数据库"></a>添加json数据至数据库</h5><p>先贴controller层的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户服务接口</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(@RequestBody UserVo userVo)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">this</span>.changeToPo(userVo);</span><br><span class="line">        <span class="keyword">return</span> userService.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是PostMaping，表示我们所接受到的是Post请求，这里在UserVO使用@RequestBody，目的是表示这里接受的必须是json型数据，也之后json型数据才会被绑定到UserVo当中。</p><p>然后在使用转换，在传入数据库当中，这里打开PostMan开始测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/1.png" alt=""></p><p>传入的是json型数据，可以发现，这里在URL并没有使用任何的动词，而是直接传入json数据到后端。</p><p>看看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/2.png" alt=""></p><p>这显然成功了。</p><h5 id="获得数据库信息"><a href="#获得数据库信息" class="headerlink" title="获得数据库信息"></a>获得数据库信息</h5><p>我们继续在controller中添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVo <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="keyword">return</span> changeToVo(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到，使用的是@PathVariable，这是什么意思呢？这表示我们的id字段将会从url中获取，于是id变获得了，{id}，可能你会提问，我使用：？id=1，不是也可以吗？当然可以，但是当你传入多个参数的时候，就会变的很麻烦，别着急，往下看。</p><p>在看看是否从数据库获取成功：</p><p>输入： <a href="http://localhost:8888/user/1" target="_blank" rel="noopener">http://localhost:8888/user/1</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/3.png" alt=""></p><p>我们发现，这次没使用所谓的getUser，也获得了数据。但是你看，这里userName居然是空的？</p><p>我回去看看数据库，原来数据库设置用户名是user_name，而我们设计的类是userName，这不一样，但是没关系，我们可以在yml配置文件中的mybatis配置中加一句：configuration:  map-underscore-to-camel-case: true</p><p>这样它就会开启驼峰命名法，会自动将大写转化为 _ 加 小写 ，这样在映射数据库中，就成功把userName转化为user_name了。</p><h5 id="查询符合要求的用户"><a href="#查询符合要求的用户" class="headerlink" title="查询符合要求的用户"></a>查询符合要求的用户</h5><p>在查询符合要求的用户时，为了节省查询量，肯定需要传入多个关键词，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users/&#123;userName&#125;/&#123;note&#125;/&#123;start&#125;/&#123;limit&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVo&gt; <span class="title">findUsers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable(<span class="string">"userName"</span>)</span> String userName,</span></span><br><span class="line"><span class="function">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"note"</span>)</span> String note,</span></span><br><span class="line"><span class="function">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start,</span></span><br><span class="line"><span class="function">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"limit"</span>)</span> <span class="keyword">int</span> limit) </span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = userService.findUsers(userName, note, start, limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.changeToVoes(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是，我们传入了多个关键词就只用/分割开就行了，不需要传入id=1&amp;username=“xxx”,这么麻烦了，这就是 @PathVariable的作用。</p><h5 id="修改用户数据"><a href="#修改用户数据" class="headerlink" title="修改用户数据"></a>修改用户数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id, @RequestBody UserVo userVo) </span>&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.changeToPo(userVo);</span><br><span class="line">    user.setId(id);</span><br><span class="line">    userService.updateUser(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里将两个注解结合到了一起，使用在这个url中，修改所需要的修改的用户：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/4.png" alt=""></p><p>看，这样就好了，即在url中选择了用户id，又在json中传达了需要的数据，并且又避免了动词的存在，一举三得。再看看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/5.png" alt=""></p><h5 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h5><p>其他数据测试也是几乎一样的，这里仅提供代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@PatchMapping</span>(<span class="string">"/user/&#123;id&#125;/&#123;userName&#125;"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResultVo <span class="title">changeUserName</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id,</span></span><br><span class="line"><span class="function">                                  @<span class="title">PathVariable</span><span class="params">(<span class="string">"userName"</span>)</span> String userName) </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = userService.updateUserName(id, userName);</span><br><span class="line">       ResultVo resultVo = <span class="keyword">new</span> ResultVo(result&gt;<span class="number">0</span>,result &gt; <span class="number">0</span> ? <span class="string">"更新成功"</span> : <span class="string">"更新用户【"</span> + id + <span class="string">"】失败。"</span>);</span><br><span class="line">       <span class="keyword">return</span> resultVo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVo <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userService.deleteUser(id);</span><br><span class="line">    ResultVo resultVo = <span class="keyword">new</span> ResultVo(result&gt;<span class="number">0</span>, </span><br><span class="line">        result &gt; <span class="number">0</span> ? <span class="string">"更新成功"</span> : <span class="string">"更新用户【"</span> + id + <span class="string">"】失败。"</span>);</span><br><span class="line">    <span class="keyword">return</span> resultVo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PatchMapping</span>(<span class="string">"/user/name"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVo <span class="title">changeUserName2</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userService.updateUserName(id, userName);</span><br><span class="line">    ResultVo resultVo = <span class="keyword">new</span> ResultVo(result&gt;<span class="number">0</span>, </span><br><span class="line">        result &gt; <span class="number">0</span> ? <span class="string">"更新成功"</span> : <span class="string">"更新用户名【"</span> + id + <span class="string">"】失败。"</span>);</span><br><span class="line">    <span class="keyword">return</span> resultVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码补充"><a href="#代码补充" class="headerlink" title="代码补充"></a>代码补充</h4><p>性别的枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum &#123;<span class="comment">/**/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MALE(0, "男"),</span></span><br><span class="line"><span class="comment">FEMALE(1, "女");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">private int code;</span></span><br><span class="line"><span class="comment">private String name;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SexEnum(int code, String name) &#123;</span></span><br><span class="line"><span class="comment">this.code = code;</span></span><br><span class="line"><span class="comment">this.name = name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static SexEnum getSexEnum(int code) &#123;</span></span><br><span class="line"><span class="comment">for (SexEnum sex : SexEnum.values()) &#123;</span></span><br><span class="line"><span class="comment">if (sex.getCode() == code) &#123;</span></span><br><span class="line"><span class="comment">return sex;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return null;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int getCode() &#123;</span></span><br><span class="line"><span class="comment">return code;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void setCode(int code) &#123;</span></span><br><span class="line"><span class="comment">this.code = code;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public String getName() &#123;</span></span><br><span class="line"><span class="comment">return name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void setName(String name) &#123;</span></span><br><span class="line"><span class="comment">this.name = name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>其实并不长，之所以看起来长，是因为枚举类型不能使用@Data。</p><p>SexTypeHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedTypes</span>(SexEnum<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">MappedJdbcTypes</span>(<span class="title">JdbcType</span>.<span class="title">INTEGER</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SexTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">SexEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SexEnum <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> code = rs.getInt(columnName);</span><br><span class="line"><span class="keyword">return</span> SexEnum.getSexEnum(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SexEnum <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> code = rs.getInt(index);</span><br><span class="line"><span class="keyword">return</span> SexEnum.getSexEnum(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SexEnum <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> code = cs.getInt(index);</span><br><span class="line"><span class="keyword">return</span> SexEnum.getSexEnum(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> index, SexEnum sex, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">ps.setInt(index, sex.getCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学点前端"><a href="#学点前端" class="headerlink" title="学点前端"></a>学点前端</h3><p>闭门造车，不是明智之选，看点前端知识：</p><p>为了在前端也能够识别且使用thymleaf语法，需要在页面顶部添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了能使用JQuery库，需要添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript和JQuery的区别就像，C++和STL类库的区别，int和Integer的区别，面粉和蛋糕的区别。</p><p>学一下JS：</p><p>在前面的使用post请求时，也可以在页面这么使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">     <span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">var</span> params = &#123;</span></span><br><span class="line"><span class="actionscript"> <span class="string">'userName'</span>: <span class="string">'user_name_new'</span>, </span></span><br><span class="line"><span class="actionscript"> <span class="string">'sexCode'</span> : <span class="number">1</span>,</span></span><br><span class="line"><span class="actionscript"> <span class="string">'note'</span> : <span class="string">"note_new"</span></span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="javascript"> $.post(&#123;</span></span><br><span class="line"><span class="actionscript"> url : <span class="string">"./user"</span>,</span></span><br><span class="line"><span class="actionscript"> <span class="comment">// 此处需要告知传递参数类型为JSON，不能缺少</span></span></span><br><span class="line"><span class="actionscript"> contentType : <span class="string">"application/json"</span>,</span></span><br><span class="line"><span class="actionscript"> <span class="comment">// 将JSON转化为字符串传递</span></span></span><br><span class="line"><span class="javascript"> data : <span class="built_in">JSON</span>.stringify(params),</span></span><br><span class="line"><span class="actionscript"> <span class="comment">// 成功后的方法</span></span></span><br><span class="line"><span class="actionscript"> success : <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">if</span> (result == <span class="literal">null</span> || result.id == <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="actionscript"> alert(<span class="string">"插入失败"</span>);</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">return</span>;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="actionscript"> alert(<span class="string">"插入成功"</span>);</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> post();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便可以在前端执行JS代码。运行这个页面的时候，会触发post函数，post函数开头便定义了一个值，这个值是json类型，并且会执行$.post方法，它可以这么写是因为JQ的原因，从传达的url中获取要接收的json参数，成功则执行函数，并返回成功的消息框，否则会在页面返回插入失败的消息框。OK。</p><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/rest">https://github.com/Antarctica000/SpringBoot/tree/master/rest</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Redis缓存</title>
      <link href="/2020/01/16/spirng2/"/>
      <url>/2020/01/16/spirng2/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合Redis缓存"><a href="#SpringBoot整合Redis缓存" class="headerlink" title="SpringBoot整合Redis缓存"></a>SpringBoot整合Redis缓存</h2><p>如果我们每次需要数据都要从数据库访问数据的话，会给数据库带来极大的压力，这时候，就需要一个地点暂时居住起来，这样就不会因为大量的IO导致效率低下。:happy:</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>简而言之就是一个高速的缓存器，我使用这个缓存器使在数据库中传入的数据，放入到一个缓存库中。这样，就不用每次需要数据，都连接一次数据库了。</p><h4 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h4><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>redis默认使用lettuce去连接，使用exclusions去排除，再加入jedis连接。当然，只加redis依赖也可以，只不过jedis比较受欢迎而已。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span><br><span class="line">  type-aliases-package: com.example.redis.pojo</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line"></span><br><span class="line">  cache:</span><br><span class="line">    type: redis</span><br><span class="line">  redis:</span><br><span class="line">    database: 0</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">      # 有密码填密码，没有密码不填</span><br><span class="line">    password:</span><br><span class="line">      # 连接超时时间（ms)</span><br><span class="line">    timeout: 1000ms</span><br><span class="line">      # 高版本springboot中使用jedis或者lettuce</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">          # 连接池最大连接数（负值表示无限制）</span><br><span class="line">        max-active: 8</span><br><span class="line">          # 连接池最大阻塞等待时间（负值无限制)</span><br><span class="line">        max-wait: 5000ms</span><br><span class="line">          # 最大空闲链接数</span><br><span class="line">        max-idle: 8</span><br><span class="line">          # 最小空闲链接数</span><br><span class="line">        min-idle: 0</span><br></pre></td></tr></table></figure><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7760614561073458247L</span>;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(@Param(<span class="string">"userName"</span>)</span> String userName,@<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.redis.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">select id, user_name as userName, note from t_user</span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">insert into t_user(user_name, note)</span><br><span class="line">values(#&#123;userName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span>user_name =#&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span>note =#&#123;note&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select id, user_name as userName, note from t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">                and user_name = #&#123;userName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span></span><br><span class="line">                and note = #&#123;note&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>熟练的定义一个接口，同时也记得要在启动器中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCaching</span><br><span class="line">@MapperScan(&quot;com.example.redis.dao&quot;)</span><br></pre></td></tr></table></figure><p>@EnableCaching 记得一定要加，表示开启缓存。</p><h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单个用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户</span></span><br><span class="line">    <span class="function">User <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户，指定MyBatis的参数名称</span></span><br><span class="line">    <span class="function">User <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户，指定MyBatis的参数名称</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户，最后MyBatis会回填id，取结果id缓存用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_'+#result.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取id，取参数id缓存用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_'+#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service"</span>);</span><br><span class="line">        <span class="keyword">return</span> userDao.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新数据后，充值缓存，使用condition配置项使得结果返回为null，不缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"redisCache"</span>, condition = <span class="string">"#result != 'null'"</span>, key = <span class="string">"'redis_user_'+#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处调用getUser方法，该方法缓存注解失效，</span></span><br><span class="line">        <span class="comment">// 所以这里还会执行SQL，将查询到数据库最新数据</span></span><br><span class="line">        User user = <span class="keyword">this</span>.getUser(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        userDao.updateUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命中率低，所以不采用缓存机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUsers(userName, note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_'+#id"</span>, beforeInvocation = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Transactional表示是一个关于数据库的事务，能够控制数据库隔离级别和事务类型，这里先不详谈。</p><p>@CachePut表示将方法的结果放入缓存，比如你插入了一条数据后，就会返回一个布尔值，表示成功或是失败，如果成功，则放这条数据放入redis中。</p><p>value表示缓存库的名字是什么，要放入到哪个缓存区域去，key表示缓存的值，类似hashmap的形式，# 表示传入的参数。</p><p>@Cacheable能从缓存中通过定义的键进行查询，如果查询到数据，则返回，否则执行该方法，返回数据，并且将返回结果保持到缓存中，是使用最多的方法。</p><p>@CacheEvic 言简意赅，移除缓存。</p><h4 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"controller"</span>);</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insertUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        user.setNote(note);</span><br><span class="line">        userService.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findUsers"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUsers(userName, note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/updateUserName"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">        User user = userService.updateUserName(id, userName);</span><br><span class="line">        <span class="keyword">boolean</span> flag = user != <span class="keyword">null</span>;</span><br><span class="line">        String message = flag? <span class="string">"更新成功"</span> : <span class="string">"更新失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> resultMap(flag, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/deleteUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">deleteUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">boolean</span> flag = result == <span class="number">1</span>;</span><br><span class="line">        String message = flag? <span class="string">"删除成功"</span> : <span class="string">"删除失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> resultMap(flag, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">resultMap</span><span class="params">(<span class="keyword">boolean</span> success, String message)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        result.put(<span class="string">"success"</span>, success);</span><br><span class="line">        result.put(<span class="string">"message"</span>, message);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，来测试一下吧。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>输入地址：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1.png" alt=""></p><p>回去查看idea：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2.png" alt=""></p><p>我们可以看到的是，在Controller层进行了访问，然后在Service层进行了访问，这表示是第一次读取这个值，需要访问数据库，并且在放入缓存中。</p><p>那么再多访问几次看看吧。</p><p>连续的页面刷新后，再去idea</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/3.png" alt=""></p><p>我们发现，这只执行到Controller层，而不进行Service层，这表示了我们读取到的是缓存，而不是数据库，因为只执行Controller层便结束了。</p><h3 id="Redis拓展"><a href="#Redis拓展" class="headerlink" title="Redis拓展"></a>Redis拓展</h3><p>我们放入Redis的缓存，在不设置之前，是永久存在的。，如果缓存只会被放入，而不设置过期时间的话，就算有办法取消掉一些缓存，但随着时间的推移，总会有些缓存会被遗忘，一直作为内存的存在Redis当中。这时，就需要深入的配置Redis，让其能够主动的销毁。</p><h4 id="设置缓存过期时间"><a href="#设置缓存过期时间" class="headerlink" title="设置缓存过期时间"></a>设置缓存过期时间</h4><p>加入configuration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义Redis缓存管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">redisCacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Redis加锁的写入器</span></span><br><span class="line">        RedisCacheWriter writer=RedisCacheWriter.lockingRedisCacheWriter(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//这里注入了Redis连接工厂</span></span><br><span class="line">        <span class="comment">//启动Redis缓存默认设置</span></span><br><span class="line">        RedisCacheConfiguration config=RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">//设置JDK序列化器</span></span><br><span class="line">        <span class="comment">//设置10秒超时</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer()));</span><br><span class="line">        <span class="comment">//禁用前缀</span></span><br><span class="line">        config=config.disableKeyPrefix();</span><br><span class="line">        <span class="comment">//设置10秒超时</span></span><br><span class="line">        config=config.entryTtl(Duration.ofSeconds(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//创建缓存管理器</span></span><br><span class="line">        RedisCacheManager redisCacheManager=<span class="keyword">new</span> RedisCacheManager( writer,config);</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configuration会全局识别为SpringBoot的配置文件，使用@Bean注解，去把这个容器注入到SpringBoot中。</p><p>再去测试一下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/5.png" alt=""></p><p>我这里是每15秒进行一次访问，可以发现，缓存都在10后会自动过期，都需要重新从数据库读取。</p><p>我们可以使用RedisDesktop去查看Redis到底存放了些什么：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/4.png" alt=""></p><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/redis">https://github.com/Antarctica000/SpringBoot/tree/master/redis</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合MyBatis框架</title>
      <link href="/2020/01/14/spring1/"/>
      <url>/2020/01/14/spring1/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合MyBatis框架"><a href="#SpringBoot整合MyBatis框架" class="headerlink" title="SpringBoot整合MyBatis框架"></a>SpringBoot整合MyBatis框架</h2><p>我们很多应用，访问数据库的方式都是JDBC等等，这些非常麻烦而又繁琐的操作，为了使得这个方式得到更好的优化，人们便开始对上帝有所诉求，上帝感到了程序猿的不幸，为了平衡各个物种的差别，同时也得给达尔文一个面子，于是诞生了MyBatis（瞎说）。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>讲到MyBatis，就先讲明这是什么吧。它是一个主流的ORM框架。那ORM又是什么呢？</p><p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/orm.jpg" alt=""></p><p><strong>简而言之，可以通过ORM框架去更方便的操控数据库。</strong></p><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/mybatis.jpg" alt=""></p><p>Hibernate是全自动ORM框架，而Mybatis是半自动的。 hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。 而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><p>无论是Mybatis、Hibernate都是ORM的一种实现框架，都是对JDBC的一种封装。</p><h4 id="最原始的MyBatis"><a href="#最原始的MyBatis" class="headerlink" title="最原始的MyBatis"></a>最原始的MyBatis</h4><h5 id="先加入pom依赖"><a href="#先加入pom依赖" class="headerlink" title="先加入pom依赖"></a>先加入pom依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/springdatajpa?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">qwe123456</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>定义好要连接的数据库属性，这里涉及到Spring的AOP，这些都是基础配置了。</p><h5 id="实体类："><a href="#实体类：" class="headerlink" title="实体类："></a>实体类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">private</span> String loginName ;</span><br><span class="line"><span class="keyword">private</span> String username ;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLoginName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loginName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginName</span><span class="params">(String loginName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loginName = loginName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用插件，省略掉写这些get和set哦，后面会讲。</p><h5 id="SQL的实现"><a href="#SQL的实现" class="headerlink" title="SQL的实现"></a>SQL的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into tb_user(login_name ,username ,password) "</span></span><br><span class="line">+ <span class="string">"values (#&#123;loginName&#125;,#&#123;username&#125;,#&#123;password&#125;)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入数据获取主键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into tb_user(login_name ,username ,password) "</span></span><br><span class="line">+ <span class="string">"values (#&#123;loginName&#125;,#&#123;username&#125;,#&#123;password&#125;)"</span>)</span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys=<span class="keyword">true</span>,keyProperty=<span class="string">"id"</span>,keyColumn=<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertGetKey</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from tb_user where username = #&#123;username&#125;"</span>)</span><br><span class="line"><span class="comment">// 引用id="userResult"的@Results</span></span><br><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"userResult"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByUsername</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from tb_user"</span>)</span><br><span class="line"><span class="comment">// @Results用于映射对象属性和数据库列，常用于对象属性和数据库列不同名情况</span></span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"userResult"</span>,value=&#123;</span><br><span class="line"><span class="meta">@Result</span>(id=<span class="keyword">true</span>,column=<span class="string">"id"</span>,property=<span class="string">"id"</span>),</span><br><span class="line"><span class="meta">@Result</span>(column=<span class="string">"login_name"</span>,property=<span class="string">"loginName"</span>),</span><br><span class="line"><span class="meta">@Result</span>(column=<span class="string">"password"</span>,property=<span class="string">"password"</span>),</span><br><span class="line"><span class="meta">@Result</span>(column=<span class="string">"username"</span>,property=<span class="string">"username"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete</span>(<span class="string">"delete from tb_user where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from tb_user where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="comment">// 引用id="userResult"的@Results</span></span><br><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"userResult"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update</span>(<span class="string">"update tb_user set username=#&#123;username&#125;, login_name=#&#123;loginName&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个接口，所有的SQL实现通过注解写在函数前面，就拥有了这些功能。</p><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入UserRepository</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByUsername</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.selectByUsername(username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertGetKey</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 数据插入成功以后，Mybatis框架会将插入成功的数据主键存入到user对象中去</span></span><br><span class="line">userRepository.insertGetKey(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">userRepository.update(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">userRepository.delete(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层并不需要做些什么，仅仅是注入持久层便可。持久层会使用它的方法，再结合注解去完成查找或查询操作。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入UserService</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/insertUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"插入数据["</span>+userService.insertUser(user)+<span class="string">"]条"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/insertGetKey"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">insertGetKey</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">userService.insertGetKey(user);</span><br><span class="line"><span class="keyword">return</span> user ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/selectByUsername"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByUsername</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.selectByUsername(username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.findAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">userService.update(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">userService.delete(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用的@Resource可以寻找服务层的类去注入，从结构来看，一般都是从控制层往下直到持久层。</p><h5 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.my.data07mybatis.repository"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data07mybatisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Data07mybatisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了在启动器前面加入@MapperScan，它会扫描在这个包下的所有类，并将其识别为MyBatis的Mapper类，这也是MyBatis独有的注解。</p><h4 id="XML型MyBatis"><a href="#XML型MyBatis" class="headerlink" title="XML型MyBatis"></a>XML型MyBatis</h4><p>使用xml文件去完成mybatis的各种SQL，有利于集中的SQL编写和控制，使我们能够更好的完成业务，大部分公司都在用这个写法。</p><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String user_name;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入了Lombok之后，写一个类只需要在上面加一个@Data注解便可以了，会自动生成get和set方法。</p><h5 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要做个接口就可以了，写好要做的事件的函数头便可，其他都不用。</p><p>不过同样的，也需要在启动器中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.mybatis2.mapper"</span>)</span><br></pre></td></tr></table></figure><p>和之前的比起来，少了个SQL语句的编写，那么SQL不用写怎么知道要干什么呢？当然不是不用，而是使用XML文件去代替：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.mybatis2.mapper.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"find"</span>  <span class="attr">resultType</span>=<span class="string">"user"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select * from t_user where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这便是一个SQL语句，由namespace定位mapper类，由id确定方法头，由parametertype确定传入参数类型，而resulttype则是返回值类型啦。</p><p>记得要放在resource文件的mapper文件下哦，不然扫描不到的，具体可以根据自己的需求，在application.yml里面改。</p><h5 id="业务层和控制层"><a href="#业务层和控制层" class="headerlink" title="业务层和控制层"></a>业务层和控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userMapper user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userService user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/find"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面差不多，这里省略了其他方法。</p><p>同样的，也需要在启动器中加入MapperScan（），去扫描dao层(持久层)的数据哦。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>在浏览器输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;user&#x2F;find?id&#x3D;1</span><br></pre></td></tr></table></figure><p>便看到结果了:</p><p><img src="https://s2.ax1x.com/2020/01/15/lXYEse.png" alt=""></p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>但，这样还是太麻烦了，咱们还是用更偷懒的办法吧。</p><h3 id="高级偷懒法：MyBatis-Puls"><a href="#高级偷懒法：MyBatis-Puls" class="headerlink" title="高级偷懒法：MyBatis-Puls"></a>高级偷懒法：MyBatis-Puls</h3><p>MyBatis-Puls，可以让你不写SQL哦。。。</p><p>请看：</p><h5 id="在pom文件中加入MyBatis-Puls依赖：："><a href="#在pom文件中加入MyBatis-Puls依赖：：" class="headerlink" title="在pom文件中加入MyBatis-Puls依赖：："></a>在pom文件中加入MyBatis-Puls依赖：：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>MyBatis-Plus</strong>（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>建议在编程的时候有个好习惯，多加点插件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lombok是个好东西，谁用谁知道。</p><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml:"></a>application.yml:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><h5 id="config的配置："><a href="#config的配置：" class="headerlink" title="config的配置："></a>config的配置：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.mybatis.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="UserMapper"><a href="#UserMapper" class="headerlink" title="UserMapper"></a>UserMapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实不加入这个也可以，没有影响。</p><h5 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl_user&#96;</span><br><span class="line">(</span><br><span class="line">   user_id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,&#96;</span><br><span class="line">   user_name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,&#96;</span><br><span class="line">   user_age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,&#96;</span><br><span class="line">   PRIMARY KEY (user_id)&#96;</span><br><span class="line">) charset &#x3D; utf8;&#96;</span><br></pre></td></tr></table></figure><h4 id="业务编写"><a href="#业务编写" class="headerlink" title="业务编写"></a>业务编写</h4><h5 id="实体类-1"><a href="#实体类-1" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"tbl_user"</span>)</span><br><span class="line"><span class="comment">//@Alias("name")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"user_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Data能够自动构造get和set方法。</p><p>@TableName进行绑定操作</p><p>同时也可以使用@Alias去指定别名</p><h5 id="Mapper类"><a href="#Mapper类" class="headerlink" title="Mapper类"></a>Mapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接口什么都不需要不用写。</p><h5 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">( User user )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">( User user )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">( User user )</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">findUserByName</span><span class="params">( String userName )</span></span>;</span><br><span class="line">    <span class="function">IPage <span class="title">getUserPage</span><span class="params">(Page page, User user )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务层接口定义好要进行的操作。</p><h5 id="实现Service层"><a href="#实现Service层" class="headerlink" title="实现Service层"></a>实现Service层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insert( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.updateById( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.deleteById( user.getUserId() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName</span><span class="params">( String userName )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage <span class="title">getUserPage</span><span class="params">(Page page, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这里的增删改查，通通都不用写SQL，简直人类福音啊。因为大部分繁琐的SQL语句，都被封装在baseMapper里面了。</p><h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><p>最后的就是控制层了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContorller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    <span class="meta">@PostMapping</span>( value = <span class="string">"/insert"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">insert</span><span class="params">( @RequestBody User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.insertUser( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    <span class="meta">@PostMapping</span>( value = <span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">update</span><span class="params">( @RequestBody User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.updateUser( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="meta">@PostMapping</span>( value = <span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">delete</span><span class="params">( @RequestBody User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.deleteUser( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    <span class="meta">@GetMapping</span>( value = <span class="string">"/getUserByName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUserByName</span><span class="params">( @RequestParam String userName )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUserByName( userName );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就好了，开始尝试一下把。</p><p>先打开postman，在输入：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/1.png" alt=""></p><p>多输入几条，最后再去数据库查看一下。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/2.png" alt=""></p><p>果然都输入进去了，那么再试试更改：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/3.png" alt=""></p><p>看看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/4.png" alt=""></p><p>发现也成功了，删除就不演示了。这样的方式，省略了大量的SQL语句，同样将数据传入了数据库。</p><p>是不是一点SQL都不用写，只用写实体类，再调用方法就行了。很棒吧。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>还是太麻烦了，我懒，我实体类都不想写，我想让实体类都自己生成。</p><p>。</p><p>。</p><p>行吧，我告诉你一个更好的办法，自动生成代码！</p><h3 id="究极偷懒法：Mybatis-Generator"><a href="#究极偷懒法：Mybatis-Generator" class="headerlink" title="究极偷懒法：Mybatis-Generator"></a>究极偷懒法：Mybatis-Generator</h3><p>这个能够让你自动生成代码，连实体类都不用写哦。</p><p>方法如下：</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>MyBatis Generator 也需要一个 xml格式的配置文件，该文件的位置配在了上文 引入 MyBatis Generator Maven 插件的 xml配置里，即 src/main/resources/mybatis-generator.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MySql"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.mybatis4.entity"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span>  <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.mybatis4.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>&gt;</span><span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tbl_user"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"modelOnly"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面 xml中几个关键的配置简介如下：</p><ul><li>jdbcConnection：数据库连接配置</li><li>javaModelGenerator：指定自动生成的 POJO置于哪个包下 </li><li>sqlMapGenerator：指定自动生成的 mapper.xml置于哪个包下</li><li>javaClientGenerator：指定自动生成的 DAO接口置于哪个包下</li><li>table tableName：指定数据表名，可以使用_和%通配符</li></ul><p>记得一定要配置好，具体可以对照着配置。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>双击右边的MyBatis Generator：</p><p><img src="https://s2.ax1x.com/2020/01/15/lXtUne.png" alt=""></p><p>看看效果吧：</p><p><img src="https://s2.ax1x.com/2020/01/15/lXtW7j.png" alt=""></p><p>这样，就连实体类都自动生成了。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>我还想。。。让数据库自己跑到后端，自己动，可以吗？</p><p>。</p><p>。</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=0c4373343ad12f2ece05ae687fc3d5ff/44130ae93901213fcfa15c3f58e736d12e2e9542.jpg" alt=""></p><p>项目地址：</p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis</a></p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis2">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis2</a></p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis3">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis3</a></p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis4">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis4</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（七）虚拟机性能监控、故障处理工具</title>
      <link href="/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA7/"/>
      <url>/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA7/</url>
      
        <content type="html"><![CDATA[<h3 id="基础故障工具"><a href="#基础故障工具" class="headerlink" title="基础故障工具"></a>基础故障工具</h3><p>在JDK中，有很多工具可以进行对虚拟机的性能监控，或者是故障处理。</p><h4 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h4><p>之前在讲多线程的时候也有用到了，在检查死锁问题的时候，使用jps查看是哪个线程。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jps.png" alt="jps"></p><h4 id="jstat：虚拟机统计信息工具"><a href="#jstat：虚拟机统计信息工具" class="headerlink" title="jstat：虚拟机统计信息工具"></a>jstat：虚拟机统计信息工具</h4><p>jstat可以用于对线程的监控和统计，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/1.png" alt=""></p><p>对 15192线程查询GC的情况，一共查询20次，每250ms一次。</p><h4 id="jinfo：Java配置工具"><a href="#jinfo：Java配置工具" class="headerlink" title="jinfo：Java配置工具"></a>jinfo：Java配置工具</h4><p>jinfo可以用于查询和配置Java虚拟机的配置信息，但在Windows平台限制较大，只能使用-flag指令。</p><h4 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h4><p>能进行对内存的信息进行快照存储，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/2.png" alt=""></p><p>让虚拟机生成堆转储快照文件，一个生成的文件名为eclipse.bin ，去进程15192获取。</p><h4 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h4><p>jhat命令可以和jmap搭配使用。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/3.png" alt=""></p><p>能够分析出这个eclipse文件，看到分析结果。</p><h4 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h4><p>能够追踪到Java堆栈的运行状况，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/4.png" alt=""></p><p>拿出之前发生过死锁的程序来进行判断，寻找死锁的原因。</p><h3 id="可视化故障工具"><a href="#可视化故障工具" class="headerlink" title="可视化故障工具"></a>可视化故障工具</h3><p>JDK除了大量的命令行工具之外，也有一些好用的可视化工具去对故障进行处理。</p><h4 id="JHSDB：基于服务性代理的调试工具"><a href="#JHSDB：基于服务性代理的调试工具" class="headerlink" title="JHSDB：基于服务性代理的调试工具"></a>JHSDB：基于服务性代理的调试工具</h4><p>JHSDB是一款基于服务性代理实现的进程外调试工具。它可以在一个独立的JAVA虚拟机进程里分析其他的HotSpot虚拟机的内部数据。我们这次就是JHSDB分析一下以下代码，看看staticObj、instanceObj、localObj存放在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//-Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">"done"</span>);    <span class="comment">// 这里设一个断点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过jps查询进程，再通过Jhsdb打开图形化模式。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/5.png" alt=""></p><p>打开后如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/6.png" alt=""></p><p>运行到断点处，一共会创建三个ObjectHolder对象的实例。只要是对象实例，就必然会在Java堆中分配。</p><p>先点击菜单的Tools-&gt; Heap Parameters</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/7.png" alt=""></p><p>接着在Windows的</p><p>scanoops 0x0000020717600000 0x0000020717950000 test$ObjectHolder</p><p>注意要使用相应的内存地址，在寻找的时候你也可以看到cmd同时也进行的寻址：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/8.png" alt=""></p><p>最后我们运行完，可以看到这三行内容：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/9.png" alt=""></p><p>找出了这三个实例的地址。然后继续使用tools的Inspector，去查找：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/10.png" alt=""></p><p>发现查找到的正是我们所在的类的内存，接下来要根据堆中对象实例地址找出引用它们的指针。使用如下命令：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/11.png" alt=""></p><p>那么在根据得到的指针去寻找是否就是对应的对象。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/12.png" alt=""></p><p>可以看到，正是指向了我们所引用的对象实例，可见这是正确的行为。接下来试试第二个：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/13.png" alt=""></p><p>再查找：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/14.png" alt=""></p><p>第三个：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/15.png" alt=""></p><p>发现第三个居然不行了，直接显示为null，表示查找不到这个指针。看来revptrs命令并不支持查找栈上的指针，但这并不妨碍我们。我们还可以用Java Thread窗口的main线程，点击Stack Memory，手动去寻找栈内存。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/16.png" alt=""></p><p>如此一来，三个对象都找到了，还追溯到了引用它们的地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（六）内存分配与回收策略</title>
      <link href="/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA6/"/>
      <url>/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA6/</url>
      
        <content type="html"><![CDATA[<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>这次，我们就是用最基本的收集器 Serial来查看内存是怎么分配和回收的吧。首先看Java堆的分区：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm14.jpg" alt=""></p><p><strong>1.Eden区</strong></p><p>  Eden区位于Java堆的年轻代，是<strong>新对象</strong>分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。</p><p><strong>2.Survival from to</strong></p><p>  Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。</p><p><strong>3.年老代</strong></p><p>  年老代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC），回收年老代和年轻代中不再被使用的对象资源。</p><p>注:本节使用JDK均为JDK6。</p><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Jdk6</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC [DefNew: 6825K-&gt;172K(9216K), 0.0045184 secs] 6825K-&gt;6316K(19456K), 0.0045424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 4598K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  54% used [0x33050000, 0x334a27a0, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,  16% used [0x33950000, 0x3397b060, 0x33a50000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33850000, 0x33850000, 0x33950000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 6144K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  60% used [0x33a50000, 0x34050030, 0x34050200, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 424K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344ba2f8, 0x344ba400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure><p>-XX:SurvivorRatio=8</p><p>这个程序分配了三个2MB大小和一个4MB大小的对象，执行分配allocation4时会发生一次MinorGC，这次回收的结果是新生代6825K-&gt;172K，总内存占用量几乎没有减少。产生垃圾回收的原因是allocation4不足以在新生代中存放了，而三个2MB的对象又无法放入Survivor空间（1MB），所以只能通过分配担保机制提前转移到老年代去。</p><p>所以收集结束后，allocation4被分配到了Eden中，Survivor空闲，老年代被占用6MB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def new generation   total 9216K, used 4598K</span><br><span class="line"> tenured generation   total 10240K, used 6144K</span><br></pre></td></tr></table></figure><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>使得大对象直接进入老年代，就可以避免在Eden区和两个Survivor区之间来回复制，产生大量的内存复制操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> * -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">//直接分配在老年代中C</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 845K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  10% used [0x33050000, 0x331234d0, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,   0% used [0x33850000, 0x33850000, 0x33950000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33950000, 0x33950000, 0x33a50000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 4096K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  40% used [0x33a50000, 0x33e50010, 0x33e50200, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 424K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344ba260, 0x344ba400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure><p>可以从 <strong>total 10240K, used 4096K</strong> ，这一条得出，大对象直接进入到了老年代，不过不是默认进行的，需要使用：-XX:+PrintTenuringDistribution。进行设置。</p><h4 id="长期存活的对象直接进入老年代"><a href="#长期存活的对象直接进入老年代" class="headerlink" title="长期存活的对象直接进入老年代"></a>长期存活的对象直接进入老年代</h4><p>在进行内存回收时，为了能够判断哪些存活对象是放在新生代还是老年代。有一个默认的评判机制，当<strong>在新生代经过了N次MinorGC后</strong>，仍然存活，便将其放入老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment"> * -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];  <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将XX:MaxTenuringThreshold=1设置后，仅仅经过一次MinorGC，便放入老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:     <span class="number">438384</span> bytes,     <span class="number">438384</span> total</span><br><span class="line">: <span class="number">5033</span>K-&gt;<span class="number">428</span>K(<span class="number">9216</span>K), <span class="number">0.0044237</span> secs] <span class="number">5033</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0044527</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">224</span> bytes,        <span class="number">224</span> total</span><br><span class="line">: <span class="number">4772</span>K-&gt;<span class="number">0</span>K(<span class="number">9216</span>K), <span class="number">0.0009550</span> secs] <span class="number">8868</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0009794</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4234</span>K [<span class="number">0x33050000</span>, <span class="number">0x33a50000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x33050000</span>, <span class="number">0x334728b0</span>, <span class="number">0x33850000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x33850000</span>, <span class="number">0x338500e0</span>, <span class="number">0x33950000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x33950000</span>, <span class="number">0x33950000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">4523</span>K [<span class="number">0x33a50000</span>, <span class="number">0x34450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x33a50000</span>, <span class="number">0x33ebafb0</span>, <span class="number">0x33ebb000</span>, <span class="number">0x34450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">428</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb298</span>, <span class="number">0x344bb400</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure><p>那么如果设置为默认值15呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:     <span class="number">438384</span> bytes,     <span class="number">438384</span> total</span><br><span class="line">: <span class="number">5033</span>K-&gt;<span class="number">428</span>K(<span class="number">9216</span>K), <span class="number">0.0040562</span> secs] <span class="number">5033</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0040857</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">224</span> bytes,        <span class="number">224</span> total</span><br><span class="line">- age   <span class="number">2</span>:     <span class="number">438176</span> bytes,     <span class="number">438400</span> total</span><br><span class="line">: <span class="number">4772</span>K-&gt;<span class="number">428</span>K(<span class="number">9216</span>K), <span class="number">0.0008210</span> secs] <span class="number">8868</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0008423</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4662</span>K [<span class="number">0x33050000</span>, <span class="number">0x33a50000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x33050000</span>, <span class="number">0x334728b0</span>, <span class="number">0x33850000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,  <span class="number">41</span>% used [<span class="number">0x33850000</span>, <span class="number">0x338bb080</span>, <span class="number">0x33950000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x33950000</span>, <span class="number">0x33950000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">4096</span>K [<span class="number">0x33a50000</span>, <span class="number">0x34450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">40</span>% used [<span class="number">0x33a50000</span>, <span class="number">0x33e50010</span>, <span class="number">0x33e50200</span>, <span class="number">0x34450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">426</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb108</span>, <span class="number">0x344bb200</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure><h4 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h4><p>HotSpot虚拟机并不是永远要求对象的年龄必须达到指定值才能够晋升老年代，如果在Survivor空间中，相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象，也可以直接进入老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment"> * -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];   <span class="comment">// allocation1+allocation2大于survivo空间一半</span></span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC [DefNew</span></span><br><span class="line"><span class="comment">Desired survivor size 524288 bytes, new threshold 1 (max 15)</span></span><br><span class="line"><span class="comment">- age   1:     700544 bytes,     700544 total</span></span><br><span class="line"><span class="comment">: 5289K-&gt;684K(9216K), 0.0044213 secs] 5289K-&gt;4780K(19456K), 0.0044653 secs] [Times: user=0.02 sys=0.02, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC [DefNew</span></span><br><span class="line"><span class="comment">Desired survivor size 524288 bytes, new threshold 15 (max 15)</span></span><br><span class="line"><span class="comment">- age   1:        224 bytes,        224 total</span></span><br><span class="line"><span class="comment">: 5028K-&gt;0K(9216K), 0.0013033 secs] 9124K-&gt;4780K(19456K), 0.0013299 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 4234K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  51% used [0x33050000, 0x33472858, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,   0% used [0x33850000, 0x338500e0, 0x33950000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33950000, 0x33950000, 0x33a50000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 4779K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  46% used [0x33a50000, 0x33efafc0, 0x33efb000, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 428K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344bb2c8, 0x344bb400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>前面说到，当大量对象在经过MinorGC之后，仍然存活，但Survivor已经放不下这么多的对象了，那么便直接将对象送入到老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation1 = <span class="keyword">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">null</span>;</span><br><span class="line">        allocation5 = <span class="keyword">null</span>;</span><br><span class="line">        allocation6 = <span class="keyword">null</span>;</span><br><span class="line">        allocation7 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC [DefNew: 6825K-&gt;172K(9216K), 0.0040796 secs] 6825K-&gt;4268K(19456K), 0.0041041 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC [DefNew: 6651K-&gt;172K(9216K), 0.0009841 secs] 10747K-&gt;4268K(19456K), 0.0010203 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 2357K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  26% used [0x33050000, 0x33272560, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,  16% used [0x33850000, 0x3387b070, 0x33950000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33950000, 0x33950000, 0x33a50000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 4096K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  40% used [0x33a50000, 0x33e50020, 0x33e50200, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 428K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344bb358, 0x344bb400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（五）经典的垃圾收集器</title>
      <link href="/2020/01/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA5/"/>
      <url>/2020/01/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA5/</url>
      
        <content type="html"><![CDATA[<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集算法，都是一个原理，这些算法的实现的最终结果，就是垃圾收集器。每个垃圾收集器虽然算法上类似，但是各个都有着自己的优势。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm7.jpg" alt="jvm7"></p><p>这七个就是是如今比较流行的垃圾收集器。它们都是在分代收集算法的策略下运行的。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>这是一个最古老的垃圾收集器，现在几乎不被使用了。它的原理非常简单，就是在进行垃圾收集的时候暂停所有的线程。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm8.jpg" alt=""></p><p>正如图所示，这是一个单核的垃圾收集器，会在新生代使用复制算法，在老年代执行整理算法。一般在收集几十兆的新生代，所暂停的时间也仅仅在十几毫秒以内，对于运行在客户端模式下的虚拟机而言，也是可以接受的。</p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old收集器是Serial收集器的老年版本。它经常被用来与其他收集器搭配使用。一般的搭档是 Parallel Scavenge收集器，还有一个就是作为CMS收集器发生失败时的后备预案。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器是Serial收集器的多线程版本。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm9.jpg" alt=""></p><p>遗憾的是ParNew收集器仅仅只有复制算法实现了多线程，在标记整理当中，还是需要Serial Old收集器，暂停所有的线程来进行回收内存。但垃圾收集器并不是只能使用一种类型，ParNew收集器还能和CMS收集器结合在一起，实现完全的多线程垃圾收集。</p><h4 id="Parallel-Scabenge和Parallel-Old收集器"><a href="#Parallel-Scabenge和Parallel-Old收集器" class="headerlink" title="Parallel Scabenge和Parallel Old收集器"></a>Parallel Scabenge和Parallel Old收集器</h4><p>Parallel Scabenge和Parallel Old并不是同一时期的产物，是先有了Parallel Scabenge收集器，然后在JDK6的时候才提供了Parallel Old收集器，之后我们可以统称为Parallel收集器。运行效果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm11.jpg" alt=""></p><p>Parallel收集器的特点和其他的收集都有着很大的不同，这个收集器不把目光局限于缩短线程停顿的时间，而是引入了一个新的名词：<strong>吞吐量</strong>。</p><p>吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉了一分钟，那么吞吐量就是99%。</p><p>可以通过 -XX：MaxGCPauseMills 参数设置内存回收花费最大时间， -XX:GCTimeRatio 设置垃圾收集时间占总时间的比率。-XX:+UseAdaptiveSizePolicy开启自动吞吐量控制。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><p><strong>JDK8用的正是这种模式的收集器</strong>。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是一个基于标记清除算法的，能并发收集，低停顿的收集器。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm12.jpg" alt=""></p><p>这个收集器的运行过程更为复杂，整个过程分为四个阶段：</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p>可惜的是这个收集器无法处理“浮动垃圾”，并且也可能会产生内存碎片过多的问题，目前并未广泛的投入使用。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器是在垃圾收集器技术发展史上的一个里程碑式的成果。G1的进行回收的标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最大，回收收益最大，这就是G1的Mixed GC模式。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm13.jpg" alt=""></p><p>这个收集器开创了面向局部收集的设计思路和基于Region的内存布局形式，同样有着四个阶段：</p><ol><li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象。</li><li>并发标记：开始进行可达性分析。</li><li>最终标记：处理并发阶段遗留的SATB记录。</li><li>筛选回收：对各个Region的价值和回收成本进行排序，然后回收。</li></ol><p><strong>就目前从JDK9到最新的JDK13而言，使用的正是G1收集器。</strong>这也是收集器未来的发展趋势。</p><h4 id="shenandoah收集器"><a href="#shenandoah收集器" class="headerlink" title="shenandoah收集器"></a>shenandoah收集器</h4><p>拥有九个阶段的、及其复杂的收集器，是基于G1的思想研发出来，目前处于试验状态。</p><h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><p>引入的染色指针的概念，也是基于G1的思想，而且对并发整理算法有着特别的改进，是一个新的低延迟收集器，目前也处于试验状态。</p><h4 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h4><p>拥有自动内存管理子系统的收集器。不以垃圾回收为关注点，而是集中在内存管理方面，是一个在只需要运行数分钟就关闭的应用上，有着极其低延迟的收集器。</p><h3 id="如何查看GC日志"><a href="#如何查看GC日志" class="headerlink" title="如何查看GC日志"></a>如何查看GC日志</h3><p>我们在进行调优的时候，往往需要根据GC情况来进行，但是我们该怎么得知GC信息呢？</p><h4 id="查看GC详细信息"><a href="#查看GC详细信息" class="headerlink" title="查看GC详细信息"></a>查看GC详细信息</h4><p>在JDK9之前使用-XX:+PrintGCDetails查看GC日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC (System.gc()) [PSYoungGen: 6425K-&gt;760K(33280K)] 6425K-&gt;768K(110080K), 0.0019406 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[Full GC (System.gc()) [PSYoungGen: 760K-&gt;0K(33280K)] [ParOldGen: 8K-&gt;581K(76800K)] 768K-&gt;581K(110080K), [Metaspace: 3099K-&gt;3099K(1056768K)], 0.0054005 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> PSYoungGen      total 33280K, used 860K [0x00000000daf80000, 0x00000000dd480000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  eden space 28672K, 3% used [0x00000000daf80000,0x00000000db057230,0x00000000dcb80000)</span></span><br><span class="line"><span class="comment">  from space 4608K, 0% used [0x00000000dcb80000,0x00000000dcb80000,0x00000000dd000000)</span></span><br><span class="line"><span class="comment">  to   space 4608K, 0% used [0x00000000dd000000,0x00000000dd000000,0x00000000dd480000)</span></span><br><span class="line"><span class="comment"> ParOldGen       total 76800K, used 581K [0x0000000090e00000, 0x0000000095900000, 0x00000000daf80000)</span></span><br><span class="line"><span class="comment">  object space 76800K, 0% used [0x0000000090e00000,0x0000000090e917e0,0x0000000095900000)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3121K, capacity 4496K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K</span></span><br></pre></td></tr></table></figure><p>在JDK9以及之后使用-Xlog:gc*查看GC日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xlog:gc*</span></span><br><span class="line"><span class="comment">//JDK13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0.014s][info][gc,heap] Heap region size: 1M</span></span><br><span class="line"><span class="comment">[0.017s][info][gc     ] Using G1</span></span><br><span class="line"><span class="comment">[0.017s][info][gc,heap,coops] Heap address: 0x0000000090e00000, size: 1778 MB, Compressed Oops mode: 32-bit</span></span><br><span class="line"><span class="comment">[0.039s][info][gc           ] Periodic GC disabled</span></span><br><span class="line"><span class="comment">[0.088s][info][gc,task      ] GC(0) Using 2 workers of 8 for full compaction</span></span><br><span class="line"><span class="comment">[0.088s][info][gc,start     ] GC(0) Pause Full (System.gc())</span></span><br><span class="line"><span class="comment">[0.089s][info][gc,phases,start] GC(0) Phase 1: Mark live objects</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases      ] GC(0) Phase 1: Mark live objects 1.420ms</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases,start] GC(0) Phase 2: Prepare for compaction</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases      ] GC(0) Phase 2: Prepare for compaction 0.351ms</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases,start] GC(0) Phase 3: Adjust pointers</span></span><br><span class="line"><span class="comment">[0.091s][info][gc,phases      ] GC(0) Phase 3: Adjust pointers 0.674ms</span></span><br><span class="line"><span class="comment">[0.091s][info][gc,phases,start] GC(0) Phase 4: Compact heap</span></span><br><span class="line"><span class="comment">[0.092s][info][gc,phases      ] GC(0) Phase 4: Compact heap 0.484ms</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Eden regions: 2-&gt;0(2)</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Survivor regions: 0-&gt;0(0)</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Old regions: 0-&gt;2</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Archive regions: 0-&gt;0</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Humongous regions: 6-&gt;0</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,metaspace   ] GC(0) Metaspace: 339K-&gt;339K(1056768K)</span></span><br><span class="line"><span class="comment">[0.093s][info][gc             ] GC(0) Pause Full (System.gc()) 7M-&gt;0M(8M) 4.329ms</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,cpu         ] GC(0) User=0.00s Sys=0.00s Real=0.01s</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ] Heap</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]  garbage-first heap   total 8192K, used 751K [0x0000000090e00000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]   region size 1024K, 1 young (1024K), 0 survivors (0K)</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]  Metaspace       used 343K, capacity 4494K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]   class space    used 22K, capacity 386K, committed 512K, reserved 1048576K</span></span><br></pre></td></tr></table></figure><h4 id="查看GC前后堆"><a href="#查看GC前后堆" class="headerlink" title="查看GC前后堆"></a>查看GC前后堆</h4><p>JDK9之前使用-XX:+PrintHeapAtGC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">6425</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">22</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000db5c6570</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">0</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Heap</span> <span class="title">after</span> <span class="title">GC</span> <span class="title">invocations</span></span>=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">824</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">0</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">17</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcc4e030</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">8</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e02000</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span>&#123;Heap before GC invocations=<span class="number">2</span> (full <span class="number">1</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">824</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">0</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">17</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcc4e030</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">8</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e02000</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Heap</span> <span class="title">after</span> <span class="title">GC</span> <span class="title">invocations</span></span>=<span class="number">2</span> (full <span class="number">1</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">0</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">0</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">614</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e99838</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>在JDK9之后使用 -Xlog:gc+heap=debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.017</span>s][info][gc,heap] Heap region size: <span class="number">1</span>M</span><br><span class="line">[<span class="number">0.017</span>s][debug][gc,heap] Minimum heap <span class="number">8388608</span>  Initial heap <span class="number">117440512</span>  Maximum heap <span class="number">1864368128</span></span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>) Heap before GC invocations=<span class="number">0</span> (full <span class="number">0</span>): garbage-first heap   total <span class="number">114688</span>K, used <span class="number">7168</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>)   region size <span class="number">1024</span>K, <span class="number">2</span> young (<span class="number">2048</span>K), <span class="number">0</span> survivors (<span class="number">0</span>K)</span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>)  Metaspace       used <span class="number">334</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>)   <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 21<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">[0.095s][info ][gc,heap] GC(0) Eden regions: 2-&gt;0(2)</span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Survivor regions: <span class="number">0</span>-&gt;<span class="number">0</span>(<span class="number">0</span>)</span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Old regions: <span class="number">0</span>-&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Archive regions: <span class="number">0</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Humongous regions: <span class="number">6</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>) Heap after GC invocations=<span class="number">1</span> (full <span class="number">1</span>): garbage-first heap   total <span class="number">8192</span>K, used <span class="number">745</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>)   region size <span class="number">1024</span>K, <span class="number">0</span> young (<span class="number">0</span>K), <span class="number">0</span> survivors (<span class="number">0</span>K)</span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>)  Metaspace       used <span class="number">334</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>)   <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 21<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><h4 id="查看并发时间以及停顿时间"><a href="#查看并发时间以及停顿时间" class="headerlink" title="查看并发时间以及停顿时间"></a>查看并发时间以及停顿时间</h4><p>JDK9之前使用 -XX:+PrintGCApplicationConcurrentTime 或-XX:+PrintGCApplicationStoppedTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application time: <span class="number">0.0037062</span> seconds</span><br><span class="line">Application time: <span class="number">0.0004107</span> seconds</span><br></pre></td></tr></table></figure><p>JDK9以及之后使用 -Xlog:safepoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.069</span>s][info][safepoint] Safepoint <span class="string">"EnableBiasedLocking"</span>, Time since last: <span class="number">42245400</span> ns, Reaching safepoint: <span class="number">71800</span> ns, At safepoint: <span class="number">47700</span> ns, Total: <span class="number">119500</span> ns</span><br><span class="line">[<span class="number">0.076</span>s][info][safepoint] Safepoint <span class="string">"RevokeBias"</span>, Time since last: <span class="number">6808300</span> ns, Reaching safepoint: <span class="number">71400</span> ns, At safepoint: <span class="number">85600</span> ns, Total: <span class="number">157000</span> ns</span><br><span class="line">[<span class="number">0.084</span>s][info][safepoint] Safepoint <span class="string">"Deoptimize"</span>, Time since last: <span class="number">7844900</span> ns, Reaching safepoint: <span class="number">57900</span> ns, At safepoint: <span class="number">28000</span> ns, Total: <span class="number">85900</span> ns</span><br><span class="line">[<span class="number">0.096</span>s][info][safepoint] Safepoint <span class="string">"G1CollectFull"</span>, Time since last: <span class="number">7976700</span> ns, Reaching safepoint: <span class="number">48500</span> ns, At safepoint: <span class="number">4234200</span> ns, Total: <span class="number">4282700</span> ns</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap原理</title>
      <link href="/2020/01/11/ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/11/ConcurrentHashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h3><p>ConcurrentHashMap指的是一个线程安全的HashMap，并且ConcurrentHashMap比起HashTable，拥有这着更高的效率。ConcurrentHashMap更多的时候，是用来代替HahsMap在多线程下进行生产活动。</p><h4 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h4><p>要先说为什么HashMap线程不安全，主要有两个原因。</p><p>1、put的时候导致的多线程数据不一致。<br> 这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap11.png" alt="put"></p><p>2、另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%），具体分析如下：</p><p>下面的代码是resize的核心内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个方法的功能是将原来的记录重新计算在新桶的位置，然后迁移过去。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap12.jpg" alt="hashmapresize"></p><p>我们假设有两个线程同时需要执行resize操作，我们原来的桶数量为2，记录数为3，需要resize桶到4，原来的记录分别为：[3,A],[7,B],[5,C]，在原来的map里面，我们发现这三个entry都落到了第二个桶里面。</p><p> 假设线程thread1执行到了resize方法的：next = e.next; 这一句，然后时间片用完了，此时的e = [3,A], next = [7,B]。线程thread2被调度执行并且顺利完成了resize操作，需要注意的是，此时的[7,B]的next为[3,A]。</p><p>此时线程thread1重新被调度运行，此时的thread1持有的引用是已经被thread2 resize之后的结果。线程thread1首先将[3,A]迁移到新的数组上，然后再处理[7,B]，而[7,B]被链接到了[3,A]的后面，处理完[7,B]之后，就需要处理[7,B]的next了啊，而通过thread2的resize之后，[7,B]的next变为了[3,A]，此时，[3,A]和[7,B]形成了环形链表，在get的时候，如果get的key的桶索引和[3,A]和[7,B]一样，那么就会陷入死循环。</p><p>如果在取链表的时候从头开始取（现在是从尾部开始取）的话，则可以保证节点之间的顺序，那样就不存在这样的问题了。</p><p>综合上面两点，可以说明HashMap是线程不安全的。</p><h4 id="ConcurrentHashMap做出的改变"><a href="#ConcurrentHashMap做出的改变" class="headerlink" title="ConcurrentHashMap做出的改变"></a>ConcurrentHashMap做出的改变</h4><p>前面也说过，ConcurrentHashMap可以看作为是一个线程安全的HahsMap，在这个前提下，ConcurrentHashMap本身的数据结构和HashMap并没有什么太大的不同，只是在每个数组(或叫做entry、bucket)，采用CAS和synchronized来保证并发安全。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap14.jpg" alt=""></p><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h5><p>put方法做出了少许改变，毕竟导致hashmap线程不安全的原因之一就是put方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static final int spread(int h) &#123;</span></span><br><span class="line"><span class="comment">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">//添加到空节点时无锁</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span></span><br><span class="line"><span class="comment">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span></span><br><span class="line"><span class="comment">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">       <span class="comment">// ...省略部分代码，放到后面讲</span></span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以根据之前hashmap的解析当中看到，这个put方法在计算hash值的方法是传入到了putval当中进行的，并且在进行添添加节点的时候，进行了CAS操作，来保障hashmap的线程安全。CAS操作之前也讲过，就是在进行交换值的时候，如果已经存在了交换关系，则进行自旋再次尝试。当然，如果 CAS 成功，说明 Node 节点已经插入，随后 addCount(1L, binCount) 方法会检查当前容量是否需要进行扩容。</p><p>这里有一个f值，这个putval方法就是根据这个节点的信息去判断接下来该如何行动的。</p><p>如果 f 为 null，说明 table 中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject 方法插入 Node 节点。</p><p>如果f的 hash 值为 -1，说明当前 f 是 ForwardingNode 节点，意味有其它线程正在扩容，则一起进行扩容操作。</p><p>其余情况把新的 Node 节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key ||</span><br><span class="line">                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                    oldVal = e.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        e.val = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                              value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                    p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在节点 f 上进行同步，节点插入之前，再次利用<code>tabAt(tab, i) == f</code>判断，防止被其它线程修改。</p><p>如果 f.hash &gt;= 0，说明 f 是链表结构的头结点，遍历链表，如果找到对应的 node 节点，则修改 value，否则在链表尾部加入节点。 如果 f 是 TreeBin 类型节点，说明 f 是红黑树根节点，则在树结构上遍历元素，更新或增加节点。 如果链表中节点数 binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。</p><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>ConcurrentHashMap的扩容方法叫做addCount()，当数组不够的时候，便会触发扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略。。。</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在扩容数组的过程中，通过 Unsafe.compareAndSwapInt 修改 sizeCtl 值，保证只有一个线程能够初始化 nextTable，节点从 table 移动到 nextTable，大体思想是遍历、复制的过程。</p><p>首先根据运算得到需要遍历的次数i，然后利用 tabAt 方法获得 i 位置的元素 f，初始化一个 forwardNode 实例 fwd。</p><p>如果 f == null，则在 table 中的 i 位置放入 fwd，这个过程是采用 Unsafe.compareAndSwapObjectf 方法实现的，很巧妙的实现了节点的并发移动。</p><p>如果 f 是链表的头节点，就构造一个反序链表，把他们分别放在 nextTable 的 i 和 i+n 的位置上，移动完成，采用 Unsafe.putObjectVolatile 方法给 table 原位置赋值 fwd。 如果 f 是 TreeBin 节点，也做一个反序处理，并判断是否需要 untreeify，把处理的结果分别放在 nextTable 的 i 和 i+n 的位置上，移动完成，同样采用 Unsafe.putObjectVolatile 方法给 table 原位置赋值 fwd。 遍历过所有的节点以后就完成了复制工作，把 table 指向 nextTable，并更新 sizeCtl 为新数组大小的 0.75 倍 ，扩容完成。</p><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><p>get方法是读取map里面的值，并没有做出结果性的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h5><p>在JDK8的ConcurrentHashMap中，size方法有了很大的改观。它不再是像HashMap一样是一个类的静态字段了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现实际上使用的是sumCount方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 提供了 baseCount、counterCells 两个辅助变量和一个 CounterCell 辅助内部类。通过迭代 counterCells 来统计 sum 的过程。而这个counterCells的计算，实际上在putVal方法中，也有说明，是使用CAS去完成的。JDK8的size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。</p><h4 id="JDK7和JDK8的ConcurrentHashMap"><a href="#JDK7和JDK8的ConcurrentHashMap" class="headerlink" title="JDK7和JDK8的ConcurrentHashMap"></a>JDK7和JDK8的ConcurrentHashMap</h4><p>或许很多人在看之前的对ConcurrentHashMap介绍中，都提到了segment这个词，但实际上在JDK8版本中，便取消了这个做法。因为在使用segment的时候，虽然也能包保持线程的安全，但随着ConcurrentHashMapd容量的增大，ssegment的并发性并没有什么提高，而改用CAS和synchronized的方式去保持线程安全，在ConcurrentHashMap容量增大的同时，也提高了锁的细化，让ConcurrentHashMap更接近于HahsMap了。</p><p>其次是synchronized的升级，让它能够拥有更好的性能，去代替segment的ReentrantLock。</p><p>最后是红黑树的引入，这里先不对此做过多解释。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap原理</title>
      <link href="/2020/01/10/HashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/10/HashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><h4 id="HashMap怎么使用"><a href="#HashMap怎么使用" class="headerlink" title="HashMap怎么使用"></a>HashMap怎么使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,String&gt; (<span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="string">"map加入值"</span>);</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"q"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"w"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">"e"</span>);</span><br><span class="line">        System.out.println(<span class="string">"判断该键是否存在:"</span>+map.containsKey(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"获取该键的值:"</span>+map.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"map的大小："</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"判断是否相等："</span>+<span class="string">"q"</span>.equals(map.get(<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">for</span> (String a: map.values()) &#123;</span><br><span class="line">            System.out.print(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map加入值</span></span><br><span class="line"><span class="comment">判断该键是否存在:false</span></span><br><span class="line"><span class="comment">获取该键的值:q</span></span><br><span class="line"><span class="comment">map的大小：3</span></span><br><span class="line"><span class="comment">判断是否相等：true</span></span><br><span class="line"><span class="comment">qwe</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>HashMap的使用比较直观，可以粗略的把HashMap看做为一个数组去使用。</p><h4 id="HashMap的定义"><a href="#HashMap的定义" class="headerlink" title="HashMap的定义"></a>HashMap的定义</h4><p>从类的定义来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashMap继承了抽象map类，实现了cloneable和Serializable接口。</p><p>HashMap的数据都存在一个entry数组里面，在HashMap有一个静态类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"><span class="comment">//JDK8</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><p>可以看到无论是JDK7还是JDK8，都定义了两种值，key和value，我们存入的数据，都是存入在这数组之中，而且还定义了一个next，next就像是链表一样，用于指向下一个值。所以table中存储的是Entry的单向链表。默认参数的HashMap结构如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmapyl2.jpg" alt="hashmap2"></p><p>所以，可以把它看作为是一个数组，然后每个数组都由链表组成。</p><h4 id="HashMap的构造方法"><a href="#HashMap的构造方法" class="headerlink" title="HashMap的构造方法"></a>HashMap的构造方法</h4><p>HashMap一共有四个构造方法，这里只看一下默认的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里调用了this</span></span><br><span class="line"><span class="comment">//DEFAULT_LOAD_FACTOR是一个负载因子，默认为0.75</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//传入的大小小于0，抛出异常 </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//传入的值大于最大值，将其变为等于最大值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//加载负载因子</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor是用来纠正传入的大小的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>哈希桶数组会在首次使用时初始化，默认大小是 16，并根据需要调整大小，且长度总是 2 的次幂。如果构造函数设置的初始容量不是 2 的次幂，那么使用tableSizeFor方法，来设置一个大于且靠近它的 2 的次幂的值。</p><p>影响 HashMap 性能的主要参数是：<strong>初始容量</strong>和<strong>负载因子</strong>。当散列表元素数超过负载因子和当前容量的乘积时（（initialCapacity * loadFactor）。），就会扩容，扩大到原来容量的<strong>两倍</strong>，并对键重新散列。</p><p>HashMap 内部的其他字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 记录结构修改次数，用于迭代时的快速失败</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 负载因子，默认 0.75f</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 扩容的下一个容量值，也就是键值对个数的最大值，它等于(capacity * loadFactor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><h4 id="HashMap的put-方法"><a href="#HashMap的put-方法" class="headerlink" title="HashMap的put()方法"></a>HashMap的put()方法</h4><p>put方式是我们在使用HashMap中经常使用的方法，所以要好好研究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在使用put方法的时候，实际是使用一个putVal方法。而在这个putVal方法中，会将key值先进行hash运算，得到hash码。</p><h5 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash()方法"></a>hash()方法</h5><p>这个hash方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果key值为null的时候，就返回hash码为0。但如果不为null呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure><p>这个会是什么意思呢？这段代码叫“<strong>扰动函数</strong>”。<strong>key.hashCode()</strong>函数调用的是key键值类型自带的哈希函数，返回int型散列值。这个求出hashcode的方法非常的复杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure><p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从<strong>-2147483648</strong>到<strong>2147483648</strong>。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p><p>但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>而这个对数组的长度取模运算的操作，正好解释了<strong>为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1 ）正好相当于一个“低位掩码”。</strong></p><p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p><p>这时候“<strong>扰动函数</strong>”的价值就体现出来了：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap4.jpg" alt="raodong"></p><p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><p>此时的key值先求出hash值，再经过扰动函数之后，得出来的hash值的重复率就大大的降低了。而对数组的长度取模运算的操作，发生在putVal()方法当中。</p><h5 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal()方法"></a>putVal()方法</h5><p>我们可以从源码上得之，使用put方法，实际上是在使用putVal方法，那我们来解析一下吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将 key 的 hashCode 散列</span></span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//1.如果table 为 null，初始化哈希桶数组</span></span><br><span class="line">    <span class="comment">//此时的n就被初始化，赋值为hashmap的大小,即n=length</span></span><br><span class="line">    <span class="comment">//resize()方法后面会提</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//2.计算数组的下标(n - 1) &amp; hash</span></span><br><span class="line">      <span class="comment">//这其实就是mod取余的一种替换方式，相当于hash%(n-1)</span></span><br><span class="line">      <span class="comment">//&amp;是位运算，效率要高于%。至于为什么是跟n-1进行&amp;的位运算，是因为n为2的幂次方，即一定是偶数，偶数减1，即是奇数，这样保证了（n-1）在二进制中最低位是1，而&amp;运算结果的最低位是1还是0完全取决于hash值二进制的最低位。如果n为奇数，则n-1则为偶数，则n-1二进制的最低位横为0，则&amp;位运算的结果最低位横为0，即横为偶数。这样table数组就只可能在偶数下标的位置存储了数据，浪费了所有奇数下标的位置，这样也更容易产生hash冲突。这也是HashMap的容量为什么总是2的平方数的原因。</span></span><br><span class="line"></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 3. 这个槽还没有插入过数据，直接插入</span></span><br><span class="line">     <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 4. else表示节点 key 存在，使用链表去连接前一个值，此后这个key返回的value值变成新值</span></span><br><span class="line">           </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 在树中插入</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">       <span class="comment">// 5. 该链的链长如果大于8，则转成了红黑树进行存储</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 6. esle表示该链是链表 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 遍历找到尾节点插入</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">            <span class="comment">// 链表长度大于 8 转为红黑树</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">          <span class="comment">// 遍历的过程中，遇到相同 key 则覆盖 value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//现有键映射</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 判断是否允许覆盖，并且value是否为空</span></span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;  <span class="comment">// 更改操作次数</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">      <span class="comment">// 大于临界值</span></span><br><span class="line"> <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">        <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">    resize();</span><br><span class="line">     <span class="comment">// 7. 超过最大容量，扩容</span></span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK8 在插入链表时采用的是尾插入法，也就是顺序插入，而 JDK7 使用的是头插法，逆序插入。</span></span><br></pre></td></tr></table></figure><p>PutVal方法中，会对Hash码和hashmap的长度-1做与运算，这样的运算方式比取余更为快速。从而得到的最后结果就是元素存放的地点。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap5.jpg" alt="putval"></p><h4 id="HashMap的扩容：resize"><a href="#HashMap的扩容：resize" class="headerlink" title="HashMap的扩容：resize()"></a>HashMap的扩容：resize()</h4><h5 id="JDK8的优化扩容机制"><a href="#JDK8的优化扩容机制" class="headerlink" title="JDK8的优化扩容机制"></a>JDK8的优化扩容机制</h5><p>每次在空的数组中存放元素成功，就会执行++size操作，当元素存储的大小大于threshold，即大于整个数组的0.75倍时，就会触发扩容操作，把整个数组扩容成原来大小的<strong>两倍</strong>。因为使用的是<strong>2的次幂扩展</strong>，那么元素的位置要么保持不变，要么在原位置上偏移2的次幂。</p><p>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hahsmap8.png" alt="扩容"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap9.png" alt="扩容2"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap10.png" alt="扩容3"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><p>我们接下来看看JDK8的resize()的源码实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 超过最大值，不在扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;<span class="comment">// 否则扩大为原来的 2 倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">           oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 双倍的阈值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始容量置于阈值</span></span><br><span class="line">    <span class="comment">// 初始化时，threshold 暂时保存 initialCapacity 参数的值</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// 零初始阈值表示使用默认值</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="comment">// 将旧的键值对移动到新的哈希桶数组中</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 无链条</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">// 拆红黑树，先拆成两个子链表，再分别按需转成红黑树</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          <span class="comment">// 拆链表，拆成两个子链表并保持原有顺序，在重新计算链表中元素位置时，只可能得到两个子链表：索引不变的元素链表和有相同偏移量的元素链表。</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">// 原位置不变的子链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原位置偏移 oldCap 的子链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 放到新的哈希桶中</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="comment">//红黑树之所以能够按照链表的逻辑拆分，是因为链表在转红黑树时，保留了原链表的链条引用，这样也方便了遍历操作。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h5><p>链表转红黑树主要做了以下几件事：</p><ol><li>判断桶容量是否达到树化的最低要求，否则进行扩容</li><li>将原链表转为由 TreeNode 组成的双向链表</li><li>将新链表转为红黑树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">// 如果哈希桶容量小于树化的最小容量，优先进行扩容</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 将普通节点转为树形节点</span></span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">      <span class="comment">// 把原来的单链表转成了双向链表</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab); <span class="comment">// 将链表转为红黑树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在设计时应该没有考虑后期会引入红黑树，所以没有提供 key 的比较器或要求 key 实现 Comparable 接口。为了比较两个 key 的大小，HashMap 按以下步骤处理：</p><ol><li>如果两个 key 的 hash 值不等，则比较 hash 值大小</li><li>如果相等，若 key 实现了 Comparable 接口，使用 compareTo 方法比较</li><li>如果结果还是相等，使用自定义的 tieBreakOrder 方法比较，逻辑如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> || <span class="comment">// 比较 className 的大小</span></span><br><span class="line">    (d = a.getClass().getName().compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 比较由本地方法生成的 hash 值大小，仍然有可能冲突，几率太小，此时认为是小于的结果</span></span><br><span class="line">    d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h5><p>JDK8 中的 HashMap 代码还是比较复杂的，优化方面主要有以下三点：</p><ul><li>优化 hash 算法只进行一次位移操作</li><li>引入红黑树，在冲突比较严重的情况下，将 get 操作的时间复杂从 O(n) 降为了 O(logn)</li><li>扩容时，利用 2 的次幂数值的二进制特点，既省去重新计算 hash 的时间，又把之前冲突的节点散列到了其他位置</li></ul><p>此外，HashMap 是<strong>非线程安全</strong>的，线程间的<strong>竞争条件</strong>主要是发生冲突或扩容时，链表的断链和续链操作。扩容也就意味着内存拷贝，这是一个很耗费性能的操作，所以预分配一个足够大的初始容量，减少扩容的次数，能够让 HashMap 有更好的表现。</p><h4 id="HashMap的get-方法"><a href="#HashMap的get-方法" class="headerlink" title="HashMap的get()方法"></a>HashMap的get()方法</h4><p>get()方法也是在HashMap一种较为常用的方法，我们来看看它是怎么回事吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//计算存放在数组table中的位置.具体计算方法上面也已经介绍了</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先查找是不是就是数组中的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//该位置为红黑树根节点或者链表头结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果first为红黑树结点，就在红黑树中遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//不是树结点，就在链表中遍历查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据key算出hash值定位到哈希桶的索引，当可以就是当前索引的值则直接返回其对于的value，反之用key去遍历equal该索引下的key，直到找到位置。如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap6.jpg" alt="get"></p><h4 id="HashMap的remove-方法"><a href="#HashMap的remove-方法" class="headerlink" title="HashMap的remove()方法"></a>HashMap的remove()方法</h4><p>最后还有一个基本的方法，那就是remove方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个remove方法实际上调用的是removeNode方法，而它的参数和putVal方法中非常的类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index; <span class="comment">// 声明节点数组、当前节点、数组长度、索引值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p（该节点为 树的根节点 或 链表的首节点）不为空</span></span><br><span class="line"><span class="comment">     * 需要从该节点p向下遍历，找到那个和key匹配的节点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v; <span class="comment">// 定义要返回的节点对象，声明一个临时节点变量、键变量、值变量</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果当前节点的键和key相等，那么当前节点就是要删除的节点，赋值给node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 到这一步说明首节点没有匹配上，那么检查下是否有next节点</span></span><br><span class="line"><span class="comment">         * 如果没有next节点，就说明该节点所在位置上没有发生hash碰撞, 就一个节点并且还没匹配上，也就没得删了，最终也就返回null了</span></span><br><span class="line"><span class="comment">         * 如果存在next节点，就说明该数组位置上发生了hash碰撞，此时可能存在一个链表，也可能是一颗红黑树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是TreeNode类型，说明已经是一个红黑树，那么调用getTreeNode方法从树结构中查找满足条件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果不是树节点，那么就是一个链表，只需要从头到尾逐个节点比对即可    </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量，调出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// 走到这里，说明e也没有匹配上</span></span><br><span class="line">                    p = e; <span class="comment">// 把当前节点p指向e，这一步是让p存储的永远下一次循环里e的父节点，如果下一次e匹配上了，那么p就是node的父节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 如果e存在下一个节点，那么继续去匹配下一个节点。直到匹配到某个节点跳出 或者 遍历完链表所有节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果node不为空，说明根据key匹配到了要删除的节点</span></span><br><span class="line"><span class="comment">         * 如果不需要对比value值  或者  需要对比value值但是value值也相等</span></span><br><span class="line"><span class="comment">         * 那么就可以删除该node节点了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果该节点是个TreeNode对象，说明此节点存在于红黑树结构中，调用removeTreeNode方法（该方法单独解析）移除该节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 如果该节点不是TreeNode对象，node == p 的意思是该node节点就是首节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">// 由于删除的是首节点，那么直接将节点数组对应位置指向到第二个节点即可</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果node节点不是首节点，此时p是node的父节点，由于要删除node，所有只需要把p的下一个节点指向到node的下一个节点即可把node从链表中删除了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// HashMap的修改次数递增</span></span><br><span class="line">            --size; <span class="comment">// HashMap的元素个数递减</span></span><br><span class="line">            afterNodeRemoval(node); <span class="comment">// 调用afterNodeRemoval方法，该方法HashMap没有任何实现逻辑，目的是为了让子类根据需要自行覆写</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作就是一个查找+删除的过程，它的步骤也很简单，就先根据hashcode值，找到bucket的位置，找到位置之后，在节点中根据key的值，找到对应的value。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next</li><li>HashMap存储数据是无序的</li><li>hash冲突是通过拉链法解决的</li><li>HashMap的容量永远为2的幂次方，有利于哈希表的散列</li><li>HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖</li><li>put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n)</li><li>get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n)</li></ol><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><p> void    clear()<br>          从此映射中移除所有映射关系。<br> Object    clone()<br>          返回此 HashMap 实例的浅表副本：并不复制键和值本身。<br> boolean    containsKey(Object key)<br>          如果此映射包含对于指定键的映射关系，则返回 true。<br> boolean    containsValue(Object value)<br>          如果此映射将一个或多个键映射到指定值，则返回 true。<br> Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()<br>          返回此映射所包含的映射关系的 Set 视图。<br> V    get(Object key)<br>          返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回 null。<br> boolean    isEmpty()<br>          如果此映射不包含键-值映射关系，则返回 true。<br> Set<K>    keySet()<br>          返回此映射中所包含的键的 Set 视图。<br> V    put(K key, V value)<br>          在此映射中关联指定值与指定键。<br> void    putAll(Map&lt;? extends K,? extends V&gt; m)<br>          将指定映射的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。<br> V    remove(Object key)<br>          从此映射中移除指定键的映射关系（如果存在）。<br> int    size()<br>          返回此映射中的键-值映射关系数。<br> Collection<V>    values()<br>          返回此映射所包含的值的 Collection 视图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS队列同步器</title>
      <link href="/2020/01/09/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
      <url>/2020/01/09/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="队列同步器-AbstractQueuedSynchronizer"><a href="#队列同步器-AbstractQueuedSynchronizer" class="headerlink" title="队列同步器(AbstractQueuedSynchronizer)"></a>队列同步器(AbstractQueuedSynchronizer)</h3><p>队列同步器，是一个用来构建锁或者其他同步组件的基础框架,像之前提到的重入锁，读写锁，都是使用这个框架搭建起来的。它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><h4 id="队列同步器接口的方法"><a href="#队列同步器接口的方法" class="headerlink" title="队列同步器接口的方法"></a>队列同步器接口的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>以独占的方式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS操作设置同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>共享释放同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占，返回的是一个布尔值</p><h4 id="同步器的工作方式"><a href="#同步器的工作方式" class="headerlink" title="同步器的工作方式"></a>同步器的工作方式</h4><p>先举一个例子，制作一个同步锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="comment">//当状态为0的时候获得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (getState()==<span class="number">0</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();&#125;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                setState(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//释放锁，将状态设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//是否处于独占状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回一个Condition，每个Condition都包含一个Condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要的操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync=<span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//表示获得了锁，即上锁的意思</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类在继承了Lock接口后，继承各种锁的操作方法，然后在类的内部有一个静态类，静态类继承了AbstractQueuedSynchronizer类，通过重写类的方法，去设置锁的类型。该Mutex类在状态为0的时候可以申请获得锁，之后若处于被锁住的状态，就不能够被其他对象所获得，只有等待该对象解锁后，才能够被其他对象获得。</p><p>值得注意的是，锁的设置一般不直接去设置内部的同步器，而是通过一个类去调用方法的方式去使用内部同步器的API来实现相关的功能。这就是一般同步器的工作方式。</p><h4 id="队列同步器的实现原理"><a href="#队列同步器的实现原理" class="headerlink" title="队列同步器的实现原理"></a>队列同步器的实现原理</h4><p>队列同步器是如何完成线程同步的呢？</p><h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p>之前有提到，同步器的内部有同步队列FIFO，FIFO是一个双向队列，这个队列的数据模型和一般的双向队列相似。每当有一个线程尝试去进行同步，但同步失败的时候，该线程就会被阻塞，且该线程当时的状态和信息就会构造成一个节点，并将其加入同步队列，只有当同步状态释放的时候，才会把首节点中线程唤醒，再次去尝试获取同步状态。同步队列使得线程之间的数据同步变的更加的有序。队列节点元素有4种类型， 每种类型表示线程被阻塞的原因，这四种类型分别是：</p><ul><li>CANCELLED : 表示该线程是因为超时或者中断原因而被放到队列中</li><li>CONDITION : 表示该线程是因为某个条件不满足而被放到队列中，需要等待一个条件，直到条件成立后才会出队</li><li>SIGNAL : 表示该线程需要被唤醒</li><li>PROPAGATE： 表示在共享模式下，当前节点执行释放release操作后，当前结点需要传播通知给后面所有节点</li></ul><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs2.jpg" alt="aqs2"></p><h5 id="独占式同步状态的获取与释放"><a href="#独占式同步状态的获取与释放" class="headerlink" title="独占式同步状态的获取与释放"></a>独占式同步状态的获取与释放</h5><p>在同步器内部，可以通过调用同步器的acquire方法获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同步器中，又会调用自定义的tryAcquire去判断当前是否获取了同步状态，若获取同步状态失败，则构造同步节点并通过addWaiter方法将该节点加入到同步队列尾部，在掉用acquireQueued使其死循环，不断地去尝试获得同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把当前线程包装为node,设为独占模式</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="comment">//如果tail不为空,把node插入末尾</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//此时可能有其他线程插入,所以重新判断tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//若队列为空或者cas设置失败后，调用enq自旋再次设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">//此时可能有其他线程插入,所以重新判断tail是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果tail节点为空,执行enq(node);重新尝试,最终把node插入.在把node插入队列末尾后,它并不立即挂起该节点中线程,因为在插入它的过程中,前面的线程可能已经执行完成,所以它会先进行自旋操作acquireQueued(node, arg),尝试让该线程重新获取锁!当条件满足获取到了锁则可以从自旋过程中退出，否则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//如果它的前继节点为头结点,尝试获取锁,获取成功则返回           </span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AQS的模板方法acquire通过调用子类自定义实现的tryAcquire获取同步状态失败后-&gt;将线程构造成Node节点(addWaiter)-&gt;将Node节点添加到同步队列对尾(addWaiter)-&gt;节点以自旋的方法获取同步状态(acquirQueued)。在节点自旋获取同步状态时，只有其前驱节点是头节点的时候才会尝试获取同步状态，如果该节点的前驱不是头节点或者该节点的前驱节点是头节点但获取同步状态失败，则判断当前线程需要阻塞，如果需要阻塞则需要被唤醒过后才返回。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs.jpg" alt="aqs"></p><p>那么接下来看看看独占式同步器是怎么释放的吧，在执行完相应的逻辑后，就需要释放同步状态，这时候就需要调用release方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若释放同步状态成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 获取同步队列头节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 唤醒头节点的后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前节点等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 若状态为SIGNAL、CONDITION或PROPAGATE，CAS将其状态置为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 若后继节点为null或其状态为CANCELLED(等待超市或者被中断)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾结点遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒节点所关联的线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在自定义方法准备好了之后，去把头结点向后移动一位，表示下一个节点也准备好了。从源码中可以发现唤醒的节点<strong>从尾遍历</strong>而不是从头遍历，原因是当前节点的后继可能为null、等待超时或被中断，所以从尾部向前进行遍。</p><h5 id="共享式同步状态的获取与释放"><a href="#共享式同步状态的获取与释放" class="headerlink" title="共享式同步状态的获取与释放"></a>共享式同步状态的获取与释放</h5><p>前面在介绍锁的时候，除了重入锁这种独占锁之外，还有像读写锁一样的共享锁，同步器身为最高位，当然也有相应的共享式同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将共享节点加入同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断标记</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前驱节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 若获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断线程是否需要阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个共享式的方法，在一开始调用了tryAcquireShared(arg)方法尝试去获取同步状态，这个方法自然也是自定义的方法，且这个方法的返回值如果是大于或等于0，自然就能够获取同步状态。如果并非如此，就进行doAcquireShared方法，它会不断地自旋去尝试获取同步状态。对应的获得了同步状态后，也有相应的共享释放方法释放状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。</p><h5 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h5><p>在JDK5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行终端操作，此时线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待获取锁。而早JDK5之中，同步器提供了一个acquireInterruptibly方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">         doAcquireInterruptibly(arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 setHead(node);</span><br><span class="line">                 p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                 failed = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>tryAcquireNanos()方法超时获取同步状态是响应中断获取同步状态的”增强版”，在doAcquireInterruptibly基础上增加了超时控制：主要是需要计算出睡眠的时间间隔nanosTimeout，在这个时间段内，如果获取到了同步状态则返回true，否则返回false，并进行异常处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 超时时间    </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 将独占节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前驱节点为头节点且获取同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若获取失败，判断是否超时</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 判断线程是否中断    </span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nanosTimeout的计算公式为：nanosTimeout-=now(当前唤醒时间)-lastTime(上次唤醒时间)。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs3.png" alt="aqs3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（四）垃圾回收的机制和算法</title>
      <link href="/2020/01/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA4/"/>
      <url>/2020/01/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA4/</url>
      
        <content type="html"><![CDATA[<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>Java虚拟机除了支持了Java的跨平台性之外，最重要的就是虚拟机能够自动进行内存的回收，它不像C++那样，需要析构函数之类的去分配和管理内存，同样的也没有指针这个神奇的玩意，在处理不会再被使用的对象时，Java虚拟机会自动帮我们完成内存的回收。而所谓的内存回收，就叫做GC，也可以叫做垃圾收集，了解如何去完成Java的内存回收，对于我们使用Java，是一件非常重要的事情。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>我想从最简单的开始去描述这一个事物，假如，你需要去判断一个对象是否要被回收，判断的依据是什么呢？一般来说，那就是以后都不会再去使用它了，所以它需要被回收，那么对于这种方式，是使用着什么的计算方法去测试呢？我们可以从synchronized的重入上找思路，是不是可以做出一个计数器，当对象存在引用的时候，就计数器加一，直到对象不被引用，计数器就减一，当对象的计数器归零了，是不是就可以被回收了呢？我们可以做出一个例子看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">//JDK6</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[GC [DefNew: <span class="number">2546</span>K-&gt;<span class="number">173</span>K(<span class="number">4928</span>K), <span class="number">0.0029877</span> secs] <span class="number">2546</span>K-&gt;<span class="number">2221</span>K(<span class="number">15872</span>K), <span class="number">0.0030177</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System)</span> [Tenured: 2048K-&gt;173<span class="title">K</span><span class="params">(<span class="number">10944</span>K)</span>, 0.0106634 secs] 4403K-&gt;173<span class="title">K</span><span class="params">(<span class="number">15872</span>K)</span>, [Perm : 424K-&gt;424<span class="title">K</span><span class="params">(<span class="number">12288</span>K)</span>], 0.0107119 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">4992</span>K, used <span class="number">91</span>K [<span class="number">0x24450000</span>, <span class="number">0x249b0000</span>, <span class="number">0x299a0000</span>)</span><br><span class="line">  eden space <span class="number">4480</span>K,   <span class="number">2</span>% used [<span class="number">0x24450000</span>, <span class="number">0x24466d20</span>, <span class="number">0x248b0000</span>)</span><br><span class="line">  from space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x248b0000</span>, <span class="number">0x248b0000</span>, <span class="number">0x24930000</span>)</span><br><span class="line">  to   space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x24930000</span>, <span class="number">0x24930000</span>, <span class="number">0x249b0000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10944</span>K, used <span class="number">173</span>K [<span class="number">0x299a0000</span>, <span class="number">0x2a450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10944</span>K,   <span class="number">1</span>% used [<span class="number">0x299a0000</span>, <span class="number">0x299cb588</span>, <span class="number">0x299cb600</span>, <span class="number">0x2a450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">428</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb1a0</span>, <span class="number">0x344bb200</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure><p>这段代码使得两个对象互相引用对方，这样的话就似乎永久不会被销毁了<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm5.jpg" alt="jvm5"></p><p>但接下来的GC日志告诉我们，事情并不是这样的，在进行自主选择的full GC(充分GC)当中，出现了4403K-&gt;173K(15872K)，可见的，就算互相引用，最终也会被销毁的，所以GC所使用的的算法，并不是这样。但也许你会说，它们都是变量，变量之间互相引用本来就是可以随意变换的，可能GC在对引用一个常量的时候，才会做出存活判断，而对变量都进行销毁。</p><h4 id="可达分析算法"><a href="#可达分析算法" class="headerlink" title="可达分析算法"></a>可达分析算法</h4><p>那么我们就使用一种是否引用常量的可达分析算法去判断他们吧</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm6.jpg" alt="jvm6"></p><p>这种方法，可以把一个GC roots作为不可被回收的引用池，所有连接在GC roots的都会是一直存活的对象，直到他们不引用任何GC Roots时，才去判断回收。可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="引用的状态"><a href="#引用的状态" class="headerlink" title="引用的状态"></a>引用的状态</h4><p>这样的算法很纯粹，但是太过狭隘，一个对象可否存活，直接用处引用还是未引用的状态去判断。虽然很科学，但是未必会贴合实际，我们更希望当内存空间还足够时，保留它们，而内存空间在进行一次垃圾回收后，仍然未够的话，就放弃它们。而之后，Java对这个对象的引用状态，又增加了很多概念：</p><ul><li>强引用：类似于 Object obj = new Object();`创建的，只要强引用在就不回收</li><li>软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li><li>弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</li><li>虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="对象的自救"><a href="#对象的自救" class="headerlink" title="对象的自救"></a>对象的自救</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，就好像判了刑并不会立即处死一样，还有缓刑这个概念，这个倒是挺人性化的。在虚拟机中，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。那么我们来看看，对象如何自救：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">// * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> test SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize mehtod executed!"</span>);</span><br><span class="line">        test.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finalize mehtod executed!</span><br><span class="line">yes, i am still alive </span><br><span class="line">no, i am dead</span><br></pre></td></tr></table></figure><p>可以看到，被测试的对象，在覆盖了Finalizer方法之后，就有了一次暂时不死的机会，让其自救，而在使用了这个方法之后，对象仍然不知死活，那就真的要死了。但是Finalizer方法用系统的开销极大，后面也被废弃了，这里仅仅是谈谈而已。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区之前被称之为永久代，这是一个误解，但事实也和所谓的永久代差不多。一般方法区是很少出现回收这个事件，如果出现回收，那么不外乎有两种情况：废弃的常量和无用的类。废弃的常量判断比较简单，那就是这个常量，比如“qwe”，它在堆中不会在有任何实例去引用它，那么它就暂时失去价值了，所以会被销毁。而无用的类的判断方法更为复杂一点，一般要满足一下三点：</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>可达分析算法准确来说是一个判断垃圾是否需要被回收的一种机制，而我们的Jvm，对垃圾的收集，也有着不同的算法。这些算法建立在两个假说身上：</p><ol><li>弱分代假说：绝大多数对象都是朝生熄灭的。</li><li>强分代假说：熬过多次垃圾收集过程的对象就越难以消亡。</li></ol><p>这两种假说奠定了垃圾收集器一致性的原则。从而也有了“minor GC”，“MajorGC“，”Full GC“这样不同的回收类型。不同的回收类型对应的不同的分代，在内存块中，也会给对象标明是新生代还是老年代，以此做出区分，这样在每次进行内存回收的时候，能够大大的提高效率。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>现在的虚拟机多是使用这样的机制，把Java堆分成为新生代和老年代，根据各个代的特点，使用不同的算法，比如新生代每次GC，都会有70%~90%的对象被回收，所以使用的是复制算法，而在经历15次回收后，该对象就会进入到老年代。老年代使用的是标记清理或者标记整理算法来进行回收。</p><h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>最早诞生的垃圾收集算法叫做标记清楚算法。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf1.jpg" alt="bjqc"></p><p>这种算法就是把需要被回收的空间标记出来，然后在进行回收，整体而言比较好理解，但是这样的算法有两个不足，一是效率不高，如果内存空间极大，就要进行大量的标记动作，二是空间上会产生大量的碎片。</p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>接着就是复制算法，它是为了解决标记清除算法面对大量可回收对象的时候，效率低下的问题。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf2.jpg" alt="fzsf"></p><p>这种算法是把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。解决前一种方法的不足，但是会造成空间利用率低下。</p><p>因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。</p><p>当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>这种算法的标记过程和标记清除算法一样，只不过后面的步骤不是直接进行清除，而是让所有存活的对象都向内存空间的一段移动。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf3.jpg" alt="bjzlsf"></p><p>这种算法也是把需要回收的内存打标记，之后再进行整理，把所有存活的对象内存移动至一端，然后直接清理掉边界以外的内存。</p><h4 id="HotSpot算法的细节实现"><a href="#HotSpot算法的细节实现" class="headerlink" title="HotSpot算法的细节实现"></a>HotSpot算法的细节实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>前面说到使用的是可达分析算法去判断是否存在引用，而在判断的过程中，需要进行枚举根节点操作，去根节点寻找引用链。但是在应用越来越大的时候，可能仅仅方法区就有将近几百兆，要逐个检查他们的是否存在引用。另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为每次要进行枚举根节点的时候，为了线程之间不出错，也为了能够准确的找出所有的引用，会把所有的线程停顿下来，等待所有线程的停顿想必需要大量的时间。</p><p>在停顿下来的时候，其实并不需要一个不漏的检查完所有执行上下文和全局的引用位置。在寻找引用的时候，HotSpot还会用到一种名为OopMap的数据结构，一旦类加载动作完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译中，也会在特定的位置记录下栈里和寄存器里是哪里的引用。这样，收集器在扫描的时候，就可以直接得知这些信息，并不需要一个不漏地从方法区等GC Roots开始查找。</p><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>因为OopMap的内容变化指令非常多，如果为每一条指令都生成对应的OopMap，将会需要大量的额外空间。但实际上，HotSpot也没有为每一条指令都生成OopMap，而是在程序执行到达Safepoint(安全点)的时候，才暂停下来，准备GC。那如何去判断程序是否到达安全点呢？HotSpot使用主动式中断的思想，当GC需要中断线程的时候，会设置一个标志，各个线程会主动去轮询这个标志，当满足安全中断的条件后，才会停下来进行GC</p><h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>Safe Region(安全区域)，可以看作为是扩展了的安全点，当线程执行到安全区域时，会自行标识自己，在这段时候内，如果JVM需要GC，就会自行的进行暂停线程开始GC。</p><h5 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h5><p>在进行分代收集的时候，新生代和老年代都不是一个独立的个体，它们之间或多或少存在着一些互相引用的问题。如果要对老年代全部进行一次GC Roots，但是老年代却很少有内存是能够回收的，想必开销是非常大的。所以，为了避免这种情况，就在新生代中多了一个名为记忆集的数据结构。</p><p>记忆集是一种用于记录从非收集区域指向收集其余的指针集合的抽象数据结构，它也可以选择很多不同记忆精度面对不同的情况。一般选择的是<strong>卡精度</strong>，也被称为卡表，卡表最简单的形式可以只是一个字节数组，这个数组的每个key都有对应的卡页，一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象的字段存在跨代指针，就将key值标记为1，并称这个元素变脏了。在GC的时候，只会选择变脏的元素的对应区域进行GCRoots。</p><h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>有其他分代区域中对象的引用了本区域对象时，其对应的元素就会变脏。但这个过程只靠什么去维持的呢？这里可以引入类似于Synchronized的思想，去锁住它，于是便有了写屏障。在更改记忆集的时候，为了原子性得到保障，会使用这个写屏障去维护记忆集，但写屏障不仅仅这有这些作用，它还做到了类似于try-fianlly的操作，只不过这些都被封装起来了，就像Spring里面的AOP一样。</p><h5 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h5><p>当堆越来越大的时候，试图去进行根节点遍历就会变的困难起来。所以面对这种情况，就引入了多线程里面的概念，我们不将所有的线程都暂停后才进行GC，而是直接随着线程的执行而进行根节点遍历。</p><p>但这也引入了新的问题，那就是在多线程情况下的不确定性，比如把新生代要回收的内存区域错误标记成了老年代，这个是可以容忍的，但如果错误的把老年代标记为要被销毁的新生代，那可能会使程序崩溃，为了解决这种事务端，也诞生了两种解决方案：<strong>增量更新和原始快照</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（三）虚拟机中的内存溢出</title>
      <link href="/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA3/"/>
      <url>/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA3/</url>
      
        <content type="html"><![CDATA[<h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><p>OutOfMemoryError异常（简称OOM）是Java虚拟机中一个比较常见的异常，它的情况有很多种，我们就以HotSpot的虚拟机为例，讲解一下常见的异常。</p><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>Java堆是在虚拟机中，所有线程共享的一个堆栈，我们如果在程序中不断地添加一个对象而不去销毁，只会让虚拟机的堆内存填满直到溢出，这是一种常见的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认的jvm设置</span><br><span class="line"></span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx750m</span><br><span class="line">-XX:ReservedCodeCacheSize=<span class="number">240</span>m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=<span class="number">50</span></span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=<span class="keyword">false</span></span><br><span class="line">-Djava.net.preferIPv4Stack=<span class="keyword">true</span></span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=<span class="string">""</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br></pre></td></tr></table></figure><p>这是IDEA中的默认的虚拟机配置，可以自行改动。</p><p>java堆前面说过，是所有线程共享的，java程序代码在某些时候出现的错误操作，会导致内存溢出，这个和C++类似，不过Java的虚拟机不仅仅支持了代码的跨平台性，还拥有着自动的内存回收功能，下面来看看Java虚拟机在操作不当时候会出现的错误吧。</p><p>注1：在idea使用虚拟机设置时，点击上方的run-edit configuration-vm option</p><p>注2：以下实验默认基于JDK8，否则会特别声明版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid15176.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">28147742</span> bytes in <span class="number">0.098</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:<span class="number">265</span>)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">239</span>)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">231</span>)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:<span class="number">462</span>)</span><br><span class="line">at test.main(test.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>像这样不断增加对象的方式，会使得Java堆溢出。在idea中，可以直接点击test.java.14直接找到是哪里出现了错误。</p><h3 id="虚拟机栈和本地方法溢出"><a href="#虚拟机栈和本地方法溢出" class="headerlink" title="虚拟机栈和本地方法溢出"></a>虚拟机栈和本地方法溢出</h3><h4 id="过多的循环"><a href="#过多的循环" class="headerlink" title="过多的循环"></a>过多的循环</h4><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，虽然在Java虚拟机规范当中，是允许Java虚拟机选择是否支持栈动态扩展的，但是在HotSpot中没有这个选项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用-Xms128k</span></span><br><span class="line"><span class="comment">//减小栈的深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test oom = <span class="keyword">new</span> test();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">stack length:<span class="number">997</span></span><br><span class="line">    at test.stackLeak(test.java:<span class="number">8</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">    。。。。。。。。</span><br></pre></td></tr></table></figure><p>这个表示着不断地加入循环，在不断地压栈过程中极大的增加了栈的深度，导致了内存溢出。对于不同的操作系统，栈容量最小值可能有所限制，比如Windows最小不能低于180k，而Linux最小不能低于228k。当然，也不是仅仅使用循环过深才导致的，也会有创建线程过多，导致内存溢出。</p><h4 id="过多的线程"><a href="#过多的线程" class="headerlink" title="过多的线程"></a>过多的线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不在虚拟机上，千万不要尝试，有死机风险</span></span><br><span class="line"><span class="comment">//实验机器为32位系统，可以使用VMbox去尝试</span></span><br><span class="line"><span class="comment">//VM Args：-Xss2M </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高并发环境下，产生过多线程在服务器中是比较正常的事情了。但像这种产生过多的线程，又不能减少线程数的情况下，去减少最大堆和减少栈容量是比较好的选择。</p><h4 id="栈容量无法申请足够的内存"><a href="#栈容量无法申请足够的内存" class="headerlink" title="栈容量无法申请足够的内存"></a>栈容量无法申请足够的内存</h4><p>第一个实验都是基于虚拟机栈不能允许动态扩展的前提下，但如果允许动态扩展，却无法申请到足够内存时，也会抛出StackOverflowError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line"></span><br><span class="line">        stackLength ++;</span><br><span class="line">        test2();</span><br><span class="line"></span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">                unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">                        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">                                unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">                                        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">                                                unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">                                                        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">                                                                unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test2();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack length:<span class="number">6004</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>实验表明，无论是栈帧太大，还是虚拟机栈容量大小，当新的栈帧内存无法分配时，都会抛出StackOverflowError异常。</p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><h4 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h4><p>方法区曾被称之为永久代，但在jdk7以及之后开始逐步去永久代了，并且在JDK8当中，使用了元空间去代替。方法区存放的是常量池在不断存放过多的常量后也会溢出。以下实验先使用JDK6进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at test.main(test.java from InputFileObject:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>这里的intern()是Native方法，作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则将此String对象包含的字符串添加到常量池中，并返回此string对象的引用。如此一来，添加过多的常量，却不进行GC则导致的常量池溢出异常。</p><p>那么接下来是JDK7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line"><span class="comment">//-Xmx6M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.HashMap.resize(HashMap.java:<span class="number">704</span>)</span><br><span class="line">at java.util.HashMap.putVal(HashMap.java:<span class="number">663</span>)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:<span class="number">612</span>)</span><br><span class="line">at java.util.HashSet.add(HashSet.java:<span class="number">220</span>)</span><br><span class="line">at test.main(test.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>如果在JDK7中，仍然使用 VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M去进行的话，将会永久的运行下去，因为在JDK7中，已经把字符串常量池移动到了Java堆中。所以可以使用-Xmx6M去限制最大的堆，就可以看到不同的结果，结果表明是Java堆溢出。</p><h4 id="JDK6和JDK7"><a href="#JDK6和JDK7" class="headerlink" title="JDK6和JDK7"></a>JDK6和JDK7</h4><p>还有一个比较重要的案例是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"科学"</span>).toString();</span><br><span class="line">            System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">            String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">            System.out.println(str2.intern() == str2);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个案例在jdk6中会出现<strong>两个false</strong>，但是在jdk7中会出现<strong>一个true和一个false</strong>，这是因为在jdk6中，intern()会返回首次遇到的字符串复制在永久代中，而StringBuilder则是在堆中，所以两次的引用都不一样。</p><p>而在jdk7中，intern()不会再去复制，而只是在常量池中记录首次出现的引用，因此str1返回的字符串，都是在堆上的，而str2的字符串，在常量池中已经有它的引用了，所以str2的intern()还是返回的常量池的引用。</p><h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><p>方法区内存溢出属于比较常见的溢出异常。一个类要被垃圾收集器回收，判定条件是比较苛刻的。像这样的情况，产生大量的class，就难以被回收，如此类似的还有很多JSP文件。</p><p>在JDK8以后，永久代便安全退出了历史舞台，元空间作为代替者登场。元空间是一个很大的改变，比如像前面的这一些测试，已经很难再使虚拟机产生方法区溢出异常了。我们看看元空间的一些防御措施：</p><p>—XX:MaxMetaspaceSize：设置元空间的最大值，默认为-1，即不受限制，或者说只受限于本地内存大小。</p><p>—XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：MaxMetaspaceFreeRatio。</p><h3 id="本机内存直接溢出"><a href="#本机内存直接溢出" class="headerlink" title="本机内存直接溢出"></a>本机内存直接溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError</span><br></pre></td></tr></table></figure><p>在这一段代码中，通过了反射去获取Unsafe的实例，而unsafe.allocateMemory(_1MB);在不断向系统申请内存分配，却又不进行销毁，导致的本地内存溢出异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（二）HotSpot虚拟机对象探秘</title>
      <link href="/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/"/>
      <url>/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/</url>
      
        <content type="html"><![CDATA[<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>在Java中，一个对象的创建，一般是使用new指令去完成。而c++则是直接定义对象就行了，Java虚拟机在对对象的创建和使用中有着自己的分配机制。我们的虚拟机遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。<strong>如果没有，执行相应的类加载</strong>。类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域。</p><p>内存的划分方式有两种第一个是<strong>：‘指针碰撞-内存规整’</strong>。就是在内存空间中，有已使用内存和未使用内存，它们是整齐排列，有分界线的，当我们需要新的内存空间的时候，指针就会移动一小位内存空间去分配。第二种是：<strong>‘空闲列表-内存交错’</strong>的分配方式，在内存空间中，所有的内存呈现散列分布，需要通过一个表去记录哪里可以使用，哪里不可以使用。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。new 指令后执行，执行完init 方法才算一份真正可用的对象创建完成。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>我们一般使用的Java虚拟机，叫做HotSpot虚拟机。在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p><p><strong>对象头(Header)</strong>：包含两部分，<strong>第一部分</strong>用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。<strong>第二部分</strong>是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><strong>实例数据(Instance Data)</strong>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p><strong>对齐填充(Padding)</strong>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。HotSpot虚拟机自动内存管理系统要求对象起始地址必须是8字节的整数倍，不够则进行填充。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。但是 reference 并没有规定使用什么方式去引用，所以是取决于虚拟机的实现而定的，目前主流的方法有两种：</p><h4 id="通过句柄访问"><a href="#通过句柄访问" class="headerlink" title="通过句柄访问"></a>通过句柄访问</h4><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm3.jpg" alt="jvm3"></p><p>这个句柄池，可以看做为是一个有完整分类的区域，需要的各个对象，会不断地通过这个分类区域，通过一步步分类寻找，找到所需对象，可见性比较好。</p><h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><p>reference 中直接存储对象地址。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm4.jpg" alt="jvm4"></p><p>这种方式是使用指针去直接找到地址，好处就是直接寻址的方式更有利于非常频繁的访问，不好的地方在于可见性不强。这个两种方法各自有各自的好处。通过句柄的方式，在进行GC的时候，由于有一个大致的分类，GC比较快速，但是在访问的时候，花费时间比较长，而通过地址的方式则反之，它在进行频繁访问的的时候有极高的效率，但是在GC的时候，效果不佳。<strong>就单论HotSpot而言，是使用第二种方式去实现的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（一）Java虚拟机概念</title>
      <link href="/2020/01/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/"/>
      <url>/2020/01/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/</url>
      
        <content type="html"><![CDATA[<h3 id="Java的起源"><a href="#Java的起源" class="headerlink" title="Java的起源"></a>Java的起源</h3><p>但是要说清楚Java虚拟机，我想从JDK开始说起。我们想要在一个计算机上使用Java，就必须在网上下载JDK和JRE，JDK是Java的开发工具，JRE是Java的运行环境，有了这个两个就能在计算机上使用Java。有人说可能还需要配置path路径，其实也未必，之所以要配置Java_home，不是因为它必须配置了才能用，只是因为配置了path路径后，就能够在全局中访问到它，如果你没有配置，其实在使用idea的时候，也没有多大影响。</p><p>JDK起源于sun公司，这是一个B2B企业，专门为其他企业提供软件服务，但是如今的Java已经不属于sun公司了，sun被Oracle收购了，Java已经属于Oracle了，并且，这家公司还把JDK和JRE结合到了一起，下载的时候直接下载JDK就行了，而在命名上，也有了变化，以后没有1.7和1.8这样的说法了，统称JDk7和JDk8这样的命名，如今的Jdk，貌似出到了JDk13了。</p><h3 id="什么是Java虚拟机"><a href="#什么是Java虚拟机" class="headerlink" title="什么是Java虚拟机"></a>什么是Java虚拟机</h3><p>先简述一下：Java虚拟机把java代码，根据所在平台的不同，会自动编译成相应的字节码，在任何平台上运行。这么讲似乎有点抽象，那我们做一个比喻，比如c语言，它只能在自己的平台上运行，比如Windows，你把c语言代码拿去Linux下运行，那是行不通的，必须安装相应的运行环境，而Java虚拟机的优势在于，你只要写了Java代码，有这个虚拟机，就能在任意平台上运行，这就是所谓的跨平台性。</p><p>但是Java虚拟机并不是一个个体，而是一个种类，自Java的发展史以来，Java虚拟机有很多，而现今在使用的Java虚拟机叫做HotSpot，具体可以在cmd（命令行）中，使用Java -version进行查看。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm2.jpg" alt="jvm2"></p><p>可以从第三行得知，这个是HotSpot虚拟机</p><h3 id="Java虚拟机运行时的数据区域"><a href="#Java虚拟机运行时的数据区域" class="headerlink" title="Java虚拟机运行时的数据区域"></a>Java虚拟机运行时的数据区域</h3><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm.jpg" alt="jvm"></p><p>如图所示，共分为这么几个区域：</p><p><strong>1.程序计数器</strong>：内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。</p><p>（1），区别于计算机硬件的pc寄存器，两者不略有不同。计算机用pc寄存器来存放“伪指令”或地址，而相对于虚拟机，pc寄存器它表现为一块内存(一个字长，虚拟机要求字长最小为32位)，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址。</p><p>（2）当虚拟机正在执行的方法是一个本地（native）方法的时候，jvm的pc寄存器存储的值是undefined。</p><p>（3）程序计数器是线程私有的，它的生命周期与线程相同，每个线程都有一个。</p><p>（4）此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><p><strong>2.Java 虚拟机栈</strong>：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。Java虚拟机栈。即是Java中的栈内存。</p><p>（1）线程私有的，它的生命周期与线程相同，每个线程都有一个。</p><p>（2）每个线程创建的同时会创建一个JVM栈，JVM栈中每个栈帧存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double；和reference （32 位以内的数据类型，具体根据JVM位数（64为还是32位）有关，因为一个solt(槽）占用32位的内存空间 ）、部分的返回结果，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址；</p><p>（3）每一个方法从被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>（4）栈运行原理：栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3也被压入栈…… 依次执行完毕后，先弹出后进……F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p><p><strong>3.本地方法栈</strong>：区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。而所谓的Native方法，就是指使用非Java语言的方法，比如C++等，整个Java虚拟机的内部实现都是由C++构成的。</p><p>（1）先解释什么是本地方法：jvm中的本地方法是指方法的修饰符是带有native的但是方法体不是用java代码写的一类方法，这类方法存在的意义当然是填补java代码不方便实现的缺陷而提出的。案例介绍将在 下面22知识点仔细介绍。</p><p>（2）作用同java虚拟机栈类似，区别是：虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p><p>（3）是线程私有的，它的生命周期与线程相同，每个线程都有一个。</p><p><strong>4..Java 堆</strong>：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区。可以位于物理上不连续的空间，但是逻辑上要连续。即是所谓的堆内存的存放地点，在Java中经常会用到。</p><p>（1）是Java虚拟机所管理的内存中最大的一块。</p><p>（2）不同于上面3个，堆是jvm所有线程共享的。</p><p>（3）在虚拟机启动的时候创建。</p><p>（4）唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。</p><p>（5）Java堆是垃圾收集器管理的主要区域。</p><p>（6）因此很多时候java堆也被称为“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代又可以分为：Eden 空间、From Survivor空间、To Survivor空间。（23知识点详细介绍）</p><p>（7）java堆是计算机物理存储上不连续的、逻辑上是连续的，也是大小可调节的（通过-Xms和-Xmx控制）。</p><p>（8）如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p><strong>5.方法区</strong>：方法区在GC中，曾经也被称之为永久代，在JDK8以及之后被称之为元空间。也可以从逻辑上推导，方法在虚拟机中一般不会被GC回收。属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>（1）在虚拟机启动的时候创建。</p><p>（2）所有jvm线程共享。</p><p>（3）除了和堆一样不需要不连续的内存空间和可以固定大小或者可扩展外，还可以选择不实现垃圾收集。</p><p>（4）用于存放已被虚拟机加载的类信息、常量、静态变量、以及编译后的方法实现的二进制形式的机器指令集等数据。</p><p>（5）被装载的class的信息存储在Methodarea的内存中。当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件内容并把它传输到虚拟机中。</p><p>（6）运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p><strong>6.运行时常量池</strong>：属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p><p><strong>7.直接内存</strong>：非虚拟机运行时数据区的部分。可以看作为本机内存，本机内存不受堆大小的限制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（二十一）AIO</title>
      <link href="/2020/01/02/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B21/"/>
      <url>/2020/01/02/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B21/</url>
      
        <content type="html"><![CDATA[<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>在网络编程的一步一步进化中，NIO取代了旧的IO方式。而如今，NIO这样的通过selector不断去监控channel的方式，已经开始不满足于现如今的优化需要，也因为NIO一直都是一个同步的IO队列，对于高并发情况下，产生的阻塞依然会让人苦恼，于是乎，像AIO这样的异步IO方式，便诞生了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/aio.jpg" alt="aio"></p><p>AIO非常的简单，甚至可以说是完全的从面向对象出发，对方发送什么，我就<strong>立即</strong>返回。请注意这里的立即，因为AIO是异步的，所以它注定不会在服务端缓慢的处理信息，这里就要引入之前学过的Future模式，AIO正是这样的模式，得益于Future，收到了信息，便立即返回，然后在返回的途中处理完全部的数据。这样，即完成了异步（因为是立即返回，所以并不产生阻塞），又使得程序更为简洁。</p><p>以下便是使用AIO去再次重制服务器。注意，AIO的编程方式，虽然最终是面向对象，但还是引入了一个新的方式，那就是函数式编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> port=<span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOEchoServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server=AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AIOEchoServer().start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端口为："</span>+port);</span><br><span class="line"></span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行的线程为："</span>+Thread.currentThread().getName());</span><br><span class="line">                Future&lt;Integer&gt; writeResult=<span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//使用future模式，接收到数据便立即返回，在返回中处理，便可异步的使用</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                    <span class="comment">//清除上次的缓存</span></span><br><span class="line">                    result.read(byteBuffer).get(<span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    writeResult=result.write(byteBuffer);</span><br><span class="line">                    <span class="comment">//将数据立即写回给客户端</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        server.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">                        writeResult.get();</span><br><span class="line">                        <span class="comment">//服务器将进行下一次客户端接收的准备，</span></span><br><span class="line">                        <span class="comment">// 使用future.get，通过等待，保证write操作写完，再关闭</span></span><br><span class="line">                        result.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"失败"</span>+exc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是echo服务器，它的实际代码量其实非常的少，只有buffer那一段才是最为重要的。这里的AsynchronousServerSocketChannel调用了accept和read和write，它们的共同点就是，都继承了一个叫做CompletionHandler的接口，而这个CompletionHandler的接口又能够再接收一个AsynchronousSocketChannel，这样，服务器开始了它的俄罗斯套娃之旅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                                CompletionHandler&lt;AsynchronousSocketChannel,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ByteBuffer src,</span></span></span><br><span class="line"><span class="function"><span class="params">                            A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                            CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(src, <span class="number">0L</span>, TimeUnit.MILLISECONDS, attachment, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ByteBuffer dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                           CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(dst, <span class="number">0L</span>, TimeUnit.MILLISECONDS, attachment, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这样的函数式编程思维，使得AIO更为简洁，每次只有服务器接收到了数据才会返回。函数式编程在《Java8实战》中有着重的讲述，也算是JDK8或以上才拥有的特点。而我们也可以应用到客户端上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsynchronousSocketChannel client= AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">//建立通道</span></span><br><span class="line">        client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8000</span>), <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> CompletionHandler&lt;Void, Object&gt;() &#123;</span><br><span class="line">            <span class="comment">//先连接，连接过程中传入一个CompletionHandler写入</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Object attachment)</span> </span>&#123;</span><br><span class="line">                        client.write(ByteBuffer.wrap(<span class="string">"hello!"</span>.getBytes()),<span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">new</span> CompletionHandler&lt;Integer,Object&gt;()&#123;</span><br><span class="line">                        <span class="comment">//开始写入，完了接着往回read</span></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                            client.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                                             <span class="comment">//开始读取，读取完了关闭</span></span><br><span class="line">                                                <span class="meta">@Override</span></span><br><span class="line">                                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">                                                    buffer.flip();</span><br><span class="line">                                                    System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                                        client.close();</span><br><span class="line">                                                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                                        e.printStackTrace();</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                                <span class="meta">@Override</span></span><br><span class="line">                                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;);</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">服务端口为：8000</span></span><br><span class="line"><span class="comment">执行的线程为：Thread-9</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">hello!</span></span><br></pre></td></tr></table></figure><p>这里使用了connect去连接服务器，连接的时候，传入了一个CompletionHandler接口，完成连接之后便开始写入，而在写入的参数中又有一个CompletionHandler接口，完成它的读回，读取的过程中又有一个CompletionHandler，继续完成它的关闭连接操作，这样，它们便连接起来的了。每当有数据发送至服务端时，便可以立即被返回，不在服务器逗留。AIO的方式，又极大的提高了效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（二十）网络NIO</title>
      <link href="/2020/01/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B20/"/>
      <url>/2020/01/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B20/</url>
      
        <content type="html"><![CDATA[<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h4><p>NIO，即new io，一个可以代替Java io的一个新的机制。这个机制极大的区别的传统的io，让程序在多线程上拥有更好的效率。我们先来看看它和传统的io有什么区别。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio2.png" alt="nioandio"></p><p>它在类型上和io不同，nio主要是一个面向缓冲区操作的，我们传统的io，都是使用着stream流的方式去读写信息，而nio则是先接收任何的值，进入到缓冲队列，再将其通过通道的方式，传递给服务器，如图。<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio.png" alt="nioofshape"></p><p>因为在buffer中，有一个叫做byteBuffer的类，能够容乃任意类型的值而不改变，能将一个buffer加入到通道中进行传输。回过头来看，传统的io对于处理客户传进来的一个信息，会分出一个线程去进行io操作。而nio不一样，这就要关系到选择器了，nio只使用一个线程去管理客户传进来的信息，每当客户有信息传入时，选择器会给这个信息先分一个类，分成需要进行io操作的一类，和不需要进行io操作的一类。这样会使需要io操作的一类才进行io函数去处理，这在宏观上，有什么区别呢？举一个例子，你在逛淘宝店铺，当你点击进去一个店铺的时候，就向服务器传达了一个信息，表示客户您在线，而传统的io则直接分给你一个线程，你的所有购买商品的操作，都会在这个线程中完成，而我们的nio呢，则不会直接分发线程给你，而是接收你的所有操作，并把需要io和不需要的io的操作分开来，这样，就不会长时间的去占用系统资源。而我们的通道（channel），则在这个时候起到了极大的作用：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio6.png" alt="channel"></p><p>因为每一次启动io连接，都需要cpu去处理和调度，但是反反复复的使用cpu去开启和关闭io连接，无疑是一个极大的浪费，所以便使用了通道这一个技术，将io的数据使用buffer缓冲保存起来，并且通过通道去发送缓冲，这样效率便有了提升。</p><p>说到nio，也一下socket，是操作系统提供给通信层的一组抽象API接口。因为socket的存在，才能让两个进程实现通信。<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio3.jpg" alt="socket"></p><p>socket在计算机网络中，起到至关重要的地步，正是因为socket的存在，才使得数据连接起来，我们来看看socket是如何在客户端和服务器之间通信的。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio4.jpg" alt="socket2"></p><p>服务端首先初始化socket()，然后与端口绑定bind()，再对端口进行监听<code>listen()</code>，接着调用accept()堵塞等待客户端连接。此时，若有一个客户端初始化了一个Socket，然后连接服务端connect()。若连接成功，此时客户端与服务端的连接就建立了。客户端发送请求write()，服务端接收请求并处理read()，然后将回应发送给客户端write()，客户端读取数据read()，最后关闭连接close()，一次交互结束。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio5.gif" alt="socket3"></p><p>在这之后，我们使用socket来制作一个简单的echo服务器吧。echo服务器很简单，它在客户单读取的所有数据，都会原封不动的传输给服务端。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio7.png" alt="echo"></p><p>参考资料：</p><p><a href="https://www.cnblogs.com/pony1223/p/8138233.html" target="_blank" rel="noopener">https://www.cnblogs.com/pony1223/p/8138233.html</a></p><p><a href="https://www.jianshu.com/p/01b9a454de5a" target="_blank" rel="noopener">https://www.jianshu.com/p/01b9a454de5a</a></p><p><a href="https://blog.csdn.net/weibo1230123/article/details/81951731" target="_blank" rel="noopener">https://blog.csdn.net/weibo1230123/article/details/81951731</a></p><h4 id="基于Socket的echo服务器"><a href="#基于Socket的echo服务器" class="headerlink" title="基于Socket的echo服务器"></a>基于Socket的echo服务器</h4><p>这个服务器逻辑较为简单，就是从客户端接收到什么，就再次向客户端发送什么，这次先使用普通的io流进行编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">echo</span>服务器 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket echo=<span class="keyword">null</span>;</span><br><span class="line">        Socket client=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            echo=<span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client=echo.accept();</span><br><span class="line">                <span class="comment">//接收服务器获得的信息</span></span><br><span class="line">                System.out.println(<span class="string">"客户端地址："</span>+client.getRemoteSocketAddress()+<span class="string">" 发起了连接"</span>);</span><br><span class="line">                es.execute(<span class="keyword">new</span> HandleMsg(client));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Socket clientSocket;</span><br><span class="line">        <span class="comment">//建立一个客户端的socket</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader is=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//缓冲区的读</span></span><br><span class="line">            PrintWriter os=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//打印流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">                os=<span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//先将两个值进行初始化，使其指向Socket对象，避免空指针异常</span></span><br><span class="line">                <span class="comment">//从客户端读取信息</span></span><br><span class="line">                String input=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> ((input=is.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    os.println(input);</span><br><span class="line">                    <span class="comment">//使其读取的数据输出回客户端</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"花费时间："</span>+(end-start)+<span class="string">"ms"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (is!=<span class="keyword">null</span>)is.close();</span><br><span class="line">                    <span class="keyword">if</span> (os!=<span class="keyword">null</span>)os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端地址：/127.0.0.1:50214 发起了连接</span></span><br><span class="line"><span class="comment">//花费时间：1ms</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 客户端<span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket client=<span class="keyword">null</span>;</span><br><span class="line">        PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义各个值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client=<span class="keyword">new</span> Socket();</span><br><span class="line">            client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>));</span><br><span class="line">            <span class="comment">//去连接这个服务器的地址</span></span><br><span class="line">            writer=<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//设置好输出流</span></span><br><span class="line">            writer.println(<span class="string">"hello!"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">            reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            <span class="comment">//此时的i流正在读取从服务器发送回来的消息，寻址主要靠client的port端口</span></span><br><span class="line">            System.out.println(<span class="string">"来自于服务器："</span>+reader.readLine());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer!=<span class="keyword">null</span>)writer.close();</span><br><span class="line">            <span class="keyword">if</span> (reader!=<span class="keyword">null</span>)reader.close();</span><br><span class="line">            <span class="keyword">if</span> (client!=<span class="keyword">null</span>)client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来自于服务器：hello!</span></span><br></pre></td></tr></table></figure><p>如此一来便完成了一个简单的服务器。但是，这样的io型服务器，在实际使用中，往往不尽人意，因为你可以从结构看到，它在对服务器有着硬性要求的条件下，对客户端的要求也不低，为什么这么说呢？因为每次的任务提交，都需要进行一段时间的阻塞，假如在我们的客户端网络状况及其不好，那么对服务端来说，也有着极大的影响。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 客户端<span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sleeptime=<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Socket client=<span class="keyword">null</span>;</span><br><span class="line">            PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client =<span class="keyword">new</span> Socket();</span><br><span class="line">                client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>));</span><br><span class="line">                <span class="comment">//设定连接服务器的地址</span></span><br><span class="line">                writer=<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                writer.print(<span class="string">"H"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"e"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"l"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"l"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"o"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"!"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                <span class="comment">//传达数据</span></span><br><span class="line">                writer.println();</span><br><span class="line">                writer.flush();</span><br><span class="line"></span><br><span class="line">                reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                System.out.println(<span class="string">"来自于服务器："</span>+reader.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (writer!=<span class="keyword">null</span>)writer.close();</span><br><span class="line">                  <span class="keyword">if</span> (reader!=<span class="keyword">null</span>)reader.close();</span><br><span class="line">                  <span class="keyword">if</span> (client!=<span class="keyword">null</span>)client.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoClient ec=<span class="keyword">new</span> EchoClient();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.execute(ec);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注：一下输出结果均来自于服务器</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50254 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50256 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50255 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50257 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50258 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50259 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50260 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50261 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50262 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50263 发起了连接</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6001ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6001ms</span></span><br><span class="line"><span class="comment">花费时间：6001ms</span></span><br><span class="line"><span class="comment">花费时间：6003ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6003ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们的客户端网络状态很差的时候，我们的服务器状态也变的很差，服务器在等待客户端传输完数据的这六秒之内，是不能够做任何事情的，换句话说，属于服务器的性能，都用于等待你网络传输完数据。这表示你的多核服务器，将会有极大的资源浪费在这里。因此，NIO顺应而生了，NIO就是为了解决这样的问题而来，通过缓冲和通道交换的形式，NIO的选择器能够将需要读写的线程标记出来，让服务器在等待的过程中，还能去计算其他的事务。</p><h4 id="使用NIO在构建echo服务器"><a href="#使用NIO在构建echo服务器" class="headerlink" title="使用NIO在构建echo服务器"></a>使用NIO在构建echo服务器</h4><p>在NIO中，之前也提到过channel（通道），这个channel可以看作为socket。而向channel中传达buffer，就等于向socket中传达流，buffer和流不同的地方在于，buffer不会被阻塞，因为它仅是一个数据队列。而每一个channel中都有一个叫做selectablechannel，它被selector（选择器）所管理者。而selector可以被一个线程管理，也可以被多个线程管理，每当channel准备好数据时，selector就会得到通知，去处理这一些数据。那么，我们就来重新实现一下echo服务器吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 使用<span class="title">NIO</span>来实现服务器 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">//构造一个选择器</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,Long&gt; time_start=<span class="keyword">new</span> HashMap&lt;Socket, Long&gt;(<span class="number">10240</span>);</span><br><span class="line">    <span class="comment">//用于统计服务器线程在一个客户端上花费的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector= SelectorProvider.provider().openSelector();</span><br><span class="line">        <span class="comment">//开始使用选择器,此处使用的是工厂方法，返回一个instance</span></span><br><span class="line">        ServerSocketChannel ssc=ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//开始构建通道，获得一个实例</span></span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将通道的类型设置为非阻塞型</span></span><br><span class="line">                <span class="comment">//InetSocketAddress isa=new InetSocketAddress(InetAddress.getLocalHost(),8000);</span></span><br><span class="line">                <span class="comment">//这里意思也是为 localhost 和8000，只不过使用了类去包装它，</span></span><br><span class="line">        InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">//进行端口的设定</span></span><br><span class="line">        ssc.socket().bind(isa);</span><br><span class="line">        <span class="comment">//将通道口绑定端口</span></span><br><span class="line">        SelectionKey key=ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//最为关键的一步，将通道注册到选择器中，并设置捕获时间为：1 &lt;&lt; 4（二进制）</span></span><br><span class="line">        <span class="comment">//这样，选择器就能够为通道服务了。</span></span><br><span class="line">        <span class="comment">// register是一个注册器，会返回一个selector和channel的键值对，而selectionkey能够存储这样的关系</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//阻塞方法，如果没有任何数据，则会对线程进行阻塞，节省资源</span></span><br><span class="line">            <span class="comment">//但当有数据传输时，便返回收到的selectionkey</span></span><br><span class="line">            Set readyKeys=selector.selectedKeys();</span><br><span class="line">            <span class="comment">//获取key，并将其存放到列表中</span></span><br><span class="line">            Iterator i=readyKeys.iterator();</span><br><span class="line">            <span class="comment">//迭代器</span></span><br><span class="line">            <span class="keyword">long</span> e=System.currentTimeMillis();;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())&#123;</span><br><span class="line">                SelectionKey sk=(SelectionKey) i.next();</span><br><span class="line">                i.remove();</span><br><span class="line">                <span class="comment">//从i中获取一个key值，务必将其移除，不然会next将永不为空</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                    doAccept(sk);</span><br><span class="line">                    <span class="comment">//判断当前channel是否在接收状态，是则进行接收</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isValid()&amp;&amp;sk.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!time_start.containsKey(((SocketChannel)sk.channel()).socket())) &#123;</span><br><span class="line">                        time_start.put(((SocketChannel)sk.channel()).socket(),</span><br><span class="line">                            System.currentTimeMillis());</span><br><span class="line">                        <span class="comment">//是否可读，是则进行读取，并截取一个时间戳</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    doRead(sk);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isValid()&amp;&amp;sk.isWritable())&#123;</span><br><span class="line">                    doWrite(sk);</span><br><span class="line">                    <span class="comment">//判断是否可读，是则进行读取</span></span><br><span class="line">                    <span class="keyword">long</span> b=time_start.remove(((SocketChannel)sk.channel()).socket());</span><br><span class="line">                    System.out.println(<span class="string">"花费时间："</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey sk)</span></span>&#123;</span><br><span class="line">        ServerSocketChannel server=(ServerSocketChannel)sk.channel();</span><br><span class="line">        <span class="comment">//每当有一个客户端接入时，便产生一个新的channel去连接</span></span><br><span class="line">        SocketChannel clientChannel;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientChannel=server.accept();</span><br><span class="line">            <span class="comment">//接收消息</span></span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//设置为非阻塞型</span></span><br><span class="line">            SelectionKey clientKey=clientChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//将新生成的channel注册到selector选择器，并且告诉选择器，可以进行读取操作了</span></span><br><span class="line">            EchoClient ehco=<span class="keyword">new</span> EchoClient();</span><br><span class="line">            clientKey.attach(ehco);</span><br><span class="line">            <span class="comment">//将这个客户端实例附加到连接的socket当中，共享这一个实例</span></span><br><span class="line">            InetAddress clientAddress=clientChannel.socket().getInetAddress();</span><br><span class="line">            System.out.println(<span class="string">"数据连接来自于："</span>+clientAddress.getHostAddress()+<span class="string">"."</span>);</span><br><span class="line">            <span class="comment">//将相关消息打印出来</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收新客户失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey sk)</span></span>&#123;</span><br><span class="line">        SocketChannel channel=(SocketChannel)sk.channel();</span><br><span class="line">        <span class="comment">//接收参数，获得当前客户端的channel</span></span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">        <span class="comment">//设置缓冲区为8kb</span></span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            length=channel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//channel.read(byteBuffer);表示将所有的数据读取到缓冲区中</span></span><br><span class="line">            <span class="comment">//使用length去表现是否有数据，没有则断掉连接</span></span><br><span class="line">            <span class="keyword">if</span> (length&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                disconnect(sk);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收新客户失败"</span>);</span><br><span class="line">            disconnect(sk);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//重置缓冲区，为数据处理做准备</span></span><br><span class="line">        es.execute(<span class="keyword">new</span> HandleMsg(sk,byteBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SelectionKey sk)</span></span>&#123;</span><br><span class="line">        SocketChannel channel =(SocketChannel) sk.channel();</span><br><span class="line">        <span class="comment">//接收参数，获得当前客户端的channel</span></span><br><span class="line">        EchoClient echo=(EchoClient) sk.attachment();</span><br><span class="line">        <span class="comment">//将数据类型转换为可以被处理的数据</span></span><br><span class="line">        LinkedList&lt;ByteBuffer&gt; data=echo.getData();</span><br><span class="line">        <span class="comment">//获取发送的内容列表</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer=data.getLast();</span><br><span class="line">        <span class="comment">//获得列表顶部元素</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length =channel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//将数据进行回写</span></span><br><span class="line">            <span class="keyword">if</span> (length==-<span class="number">1</span>)&#123;</span><br><span class="line">                disconnect(sk);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//错误则断开连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (byteBuffer.remaining()==<span class="number">0</span>)&#123;</span><br><span class="line">                data.removeFirst();</span><br><span class="line">                <span class="comment">//为null则移除顶部元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收新客户失败"</span>);</span><br><span class="line">            disconnect(sk);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//告诉选择器，现在只能够进行读操作了</span></span><br><span class="line">            <span class="comment">//因为不一定还有数据可以写，因此每次想要执行写操作时，都要在前进的doread中进行判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        SelectionKey sk;</span><br><span class="line">        ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(SelectionKey sk, ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sk = sk;</span><br><span class="line">            <span class="keyword">this</span>.byteBuffer = byteBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据将被转移到这里进行处理，如果有实际数据，将为其分配一个线程</span></span><br><span class="line">        <span class="comment">//而没有数据，自然不会分配线程</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            EchoClient ehco=(EchoClient) sk.attachment();</span><br><span class="line">            <span class="comment">//将数据类型转换为可以被处理的数据</span></span><br><span class="line">            ehco.enqueue(byteBuffer);</span><br><span class="line">            <span class="comment">//这里是入队压栈，如果需要处理数据的业务，都可以在这里进行处理</span></span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//处理完后，告诉选择器，现在既可以进行读操作，也可以进行写操作</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">            <span class="comment">//强迫选择器立即返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;ByteBuffer&gt; data;</span><br><span class="line">        <span class="comment">//建立一个队列，来存储数据</span></span><br><span class="line">        EchoClient()&#123;</span><br><span class="line">            data=<span class="keyword">new</span> LinkedList&lt;ByteBuffer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> LinkedList&lt;ByteBuffer&gt; <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(ByteBuffer byteBuffer)</span></span>&#123;</span><br><span class="line">            data.addFirst(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        使用NIO来实现服务器 echoServer = <span class="keyword">new</span> 使用NIO来实现服务器();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            echoServer.startServer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">//客户端B</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br></pre></td></tr></table></figure><p>需要表达的都写了注释，在此不过多赘述。我们可以比较直观的看到，即使客户端出现的网络的延迟，也不会给服务器带来太大的问题，服务器只会在接收完客户端数据后再开启线程进行处理，而不是直接就分发线程给客户端。这里最关键的角色，还是selector（选择器）。</p><h4 id="使用NIO来构建客户端"><a href="#使用NIO来构建客户端" class="headerlink" title="使用NIO来构建客户端"></a>使用NIO来构建客户端</h4><p>上面使用了NIO来构建echo服务器，但还是用socket来构建的客户端。因此，我们可以使用NIO去重新构建一下客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 客户端<span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel=SocketChannel.open();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.selector= SelectorProvider.provider().openSelector();</span><br><span class="line">        <span class="comment">//初始化选择器和通道</span></span><br><span class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(ip,port));</span><br><span class="line">        <span class="comment">//绑定到socket上</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">//注册到选择器中，并且表示可以连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!selector.isOpen())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//无数据则阻塞，有则接受，并返回一个selectionkey</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; i=<span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())&#123;</span><br><span class="line">                SelectionKey key=i.next();</span><br><span class="line">                i.remove();</span><br><span class="line">                <span class="comment">//传入并清空</span></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable())&#123;</span><br><span class="line">                    connect(key);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//如果能读，则读</span></span><br><span class="line">                    read(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel=(SocketChannel)key.channel();</span><br><span class="line">        <span class="keyword">if</span> (channel.isConnectionPending())&#123;</span><br><span class="line">            channel.finishConnect();</span><br><span class="line">            <span class="comment">//如果正在连接，则完成连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//不阻塞</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="keyword">new</span> String(<span class="string">"hello server!\r\n"</span>).getBytes()));</span><br><span class="line">        <span class="comment">//写入一个字符串</span></span><br><span class="line">        channel.register(<span class="keyword">this</span>.selector,SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//表示现在可以进行读取操作了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel=(SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//创建读取缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        channel.read(byteBuffer);</span><br><span class="line">        <span class="comment">//进行读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=byteBuffer.array();</span><br><span class="line">        <span class="comment">//将缓冲区的字符串转化为字节流数组</span></span><br><span class="line">        String msg=<span class="keyword">new</span> String(data).trim();</span><br><span class="line">        <span class="comment">//转换为字符串</span></span><br><span class="line">        System.out.println(<span class="string">"客户端收到的信息为："</span>+msg);</span><br><span class="line">        channel.close();</span><br><span class="line">        key.selector().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        客户端C t=<span class="keyword">new</span> 客户端C();</span><br><span class="line">        t.init(<span class="string">"localhost"</span>,<span class="number">8000</span>);</span><br><span class="line">        t.working();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端收到的信息为：hello server!</span></span><br><span class="line"><span class="comment">/*echo服务器：</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">花费时间：2ms</span></span><br></pre></td></tr></table></figure><p>如此一来，便使用NIO实现了这个客户端C。可以看到，在使用NIO重构的过程中，不仅使得服务器和客户端有了更多优化，而且对于代码的复杂程度，也有着显著的减少。</p><p>不过，NIO虽然提供了不同于IO的阻塞策略，使得服务器得到优化，但是，NIO本身的IO行为，仍然是同步的，也就是说，也是在IO都准备好了之后，再去通知线程。那有没有方法可以先让IO操作完成后，再去通知线程呢？当然有，那就是AIO（Asynchronized），一种异步的IO方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十九）并行算法</title>
      <link href="/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B19/"/>
      <url>/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B19/</url>
      
        <content type="html"><![CDATA[<h3 id="串行计算在并行的情况"><a href="#串行计算在并行的情况" class="headerlink" title="串行计算在并行的情况"></a>串行计算在并行的情况</h3><p>在串行条件下，许多计算方法，都比较的贴近自然语言，就好似a=b+c； 这样的计算方法，无疑那么的明显，就是a要等于b和c的和，和我们使用手写写出来的，并没与什么区别。但是，这样的计算方法，在并行条件下，却有那么点不同。或者说，串行计算在并行条件(多线程)下，也只会执行串行计算。举个例子：(B+C)*D-2；这样的计算式，我们可能将它们拆分开来计算，不可能先计算D-2再去计算 *(B+C)，这样有违于计算的基本常识。所以，想要得到最终的答案，就不得不一直去等待(B+C)的结果，这样的话，很多并行计算其实也没有那么多优势。但人们的眼光不仅仅拘于此，人们想到了使用流水线的方式，去发挥并行计算所能达到的最佳性能，你可将以上式子，在并行条件下拆分为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T1=A+B;T2=T1*D;T3=T2-<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p> 这样的形式,让每一个线程在运行时，不必去重新计算他们的值，使用分工合作，一个线程负责加操作，一个负责乘操作，一个负责减操作，如此一来，就将我们的串行计算，大大的优化了。我们也可以使用例子去验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行一个(B+C)*D/2的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">msg</span> </span>&#123;</span><br><span class="line">    <span class="comment">//信息交换的载体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> j;</span><br><span class="line">    <span class="keyword">public</span> String s=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">puls</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;msg&gt; bq=<span class="keyword">new</span> LinkedBlockingQueue&lt;msg&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg m=bq.take();</span><br><span class="line">                <span class="comment">//从队列获得值</span></span><br><span class="line">                m.j=m.i+m.j;</span><br><span class="line">                <span class="comment">//求两数之和</span></span><br><span class="line">                multiply.bq.add(m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">multiply</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;msg&gt; bq=<span class="keyword">new</span> LinkedBlockingQueue&lt;msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg m=bq.take();</span><br><span class="line">                m.i=m.i*m.j;</span><br><span class="line">                div.bq.add(m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">div</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;msg&gt; bq=<span class="keyword">new</span> LinkedBlockingQueue&lt;msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg m=bq.take();</span><br><span class="line">                m.i=m.i/m.j;</span><br><span class="line">                System.out.println(m.s+<span class="string">"="</span>+m.i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> puls()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> multiply()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> div()).start();</span><br><span class="line">        <span class="comment">//开启三个线程，但在并未传入参数之前，都会被take所阻塞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                msg m=<span class="keyword">new</span> msg();</span><br><span class="line">                m.i=i;</span><br><span class="line">                m.j=j;</span><br><span class="line">                m.s=<span class="string">"(("</span>+i+<span class="string">"+"</span>+j+<span class="string">")*"</span>+i+<span class="string">")/2"</span>;</span><br><span class="line">                puls.bq.add(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">1</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">2</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">3</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">4</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">5</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">6</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">7</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>这样的并行计算，就结束啦。</p><h3 id="并行下的搜索"><a href="#并行下的搜索" class="headerlink" title="并行下的搜索"></a>并行下的搜索</h3><p>在并行条件下 ，除了使用的计算方式会有所不同之外，使用的算法也有着相应的改变。就比如搜索这一个算法，搜索在串行条件下，无论是二分搜索或者是其他搜索，我们都只需要在一个数组中遍历就了，最基本的搜索方式，就是在无序数组中，使用逐步遍历的方式进行搜索。那么在并行条件下，使用搜索，怎么把多线程里面的能力利用起来呢？这就要涉及到了一个线程之间的通信，我们可以想办法把一个数组分成两块，一个线程搜一块，这不就提高效率了吗，而之前所提到的Future模式，便可以应用到这里，搜索到了并返回搜索结果，这也是runnable接口所不具有的呢。来试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="comment">//表示要搜索的原数组</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Thread_num=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//线程数量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger result=<span class="keyword">new</span> AtomicInteger(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//定义搜索结果，没有搜到则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = begin; i &lt;end ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.get()&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result.get();</span><br><span class="line">                <span class="comment">//表示找到了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]==value)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!result.compareAndSet(-<span class="number">1</span>,i))&#123;</span><br><span class="line">                    <span class="comment">//如果设置失败，表示其他线程先找到了</span></span><br><span class="line">                    <span class="keyword">return</span> result.get();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin,end,value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> r=search(value,begin,end);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">psearch</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//根据线程数量对数组进行划分</span></span><br><span class="line">        <span class="keyword">int</span> sub=arr.length/Thread_num+<span class="number">1</span>;</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; r=<span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i+=sub) &#123;</span><br><span class="line">            <span class="keyword">int</span> end=i+sub;</span><br><span class="line">            <span class="keyword">if</span> (end&gt;=arr.length)&#123;</span><br><span class="line">                end=arr.length;</span><br><span class="line">            &#125;</span><br><span class="line">            r.add(es.submit(<span class="keyword">new</span> task(value,i,end)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; f:</span><br><span class="line">             r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.get()&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=psearch(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，数组下标为："</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到了，数组下标为：1</span></span><br></pre></td></tr></table></figure><p>通过使用Callable，就把并行搜索给实现了</p><h3 id="并行下的排序"><a href="#并行下的排序" class="headerlink" title="并行下的排序"></a>并行下的排序</h3><p>讲到排序，想必大家一开始学到的排序大多数冒泡排序之类的吧，像冒泡排序这种排序手法，在此不多赘述，但冒泡排序的特点就是，如果右边的数值比左边大，那么就将这两个相邻的数字进行一次交换，这个排序手法在串行条件下是那么的明确和简单。<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/xier.gif" alt="冒泡"></p><p>但是在并行条件下，两个不同的线程要怎么把这种即比较手法结合到一起呢？这似乎是一个难题，因为这不等于搜索，可以拆分成两块去搜，排序的要求至少对整体而言，必须是可见的，毕竟部分有序不等于整体有序，为了解决这种难题，从冒泡排序中更改了一些逻辑，诞生了一个新的排序方法：奇偶排序</p><h4 id="交换型排序：奇偶排序"><a href="#交换型排序：奇偶排序" class="headerlink" title="交换型排序：奇偶排序"></a>交换型排序：奇偶排序</h4><p>奇偶排序并不是字面上意思，即奇数与奇数排序偶数与偶数排序，奇偶排序实际上是分两个线程，一边使得该数组中的奇数与其相邻的数字进行比较和交换，一边让该数组中偶数和相邻的数字进行比较和交换。这样不断重复下来即可，这样就可以将冒泡排序的排序手法，运用到多线程中了。使用实际例子试一试吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">16</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置是否进行交换的标志，以此控制奇偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        flag = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">sort</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> i, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>]=temp;</span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                setFlag(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">psort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag==<span class="number">1</span> || start==<span class="number">1</span>)&#123;</span><br><span class="line">            setFlag(<span class="number">0</span>);</span><br><span class="line">            CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(arr.length/<span class="number">2</span>-(arr.length%<span class="number">2</span>==<span class="number">0</span>?start:<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//偶数的数组长度，当start等于1时，只有len/2-1个线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;arr.length-<span class="number">1</span> ; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                es.submit(<span class="keyword">new</span> sort(i,latch));</span><br><span class="line">                <span class="comment">//此处是核心所在，每次i+2，可以跳过 奇/偶 的位置</span></span><br><span class="line">                <span class="comment">// 不断地去提交任务给线程执行，每次执行完都会set一个flag，</span></span><br><span class="line">                <span class="comment">// 开始下一次 奇/偶 排序</span></span><br><span class="line">            &#125;</span><br><span class="line">            latch.await();</span><br><span class="line">            <span class="comment">//等待所有线程结束</span></span><br><span class="line">            <span class="keyword">if</span> (start==<span class="number">0</span>)&#123;</span><br><span class="line">                start=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"交换前："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">             arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">        psort(arr);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"交换后："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">交换前：</span><br><span class="line"> <span class="number">16</span> <span class="number">12</span> <span class="number">14</span> <span class="number">11</span> <span class="number">15</span> <span class="number">13</span></span><br><span class="line">交换后：</span><br><span class="line"> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>这样一来，就排序成功了，内部运行的效果可看下图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/%E5%A5%87%E5%81%B6%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F.gif" alt="奇偶排序">))</p><h4 id="插入型排序：希尔排序"><a href="#插入型排序：希尔排序" class="headerlink" title="插入型排序：希尔排序"></a>插入型排序：希尔排序</h4><p>插入排序是一种常见的排序类型，这个和交换类型排序有着比较大的区别，直接选择排序就是一种插入型排序。把数组分成两部分，一部分是排序好的，一部分是还未排序好的，把未排序好的数组中的元素插入到排序好的数组中，就是插入排序。如果想要把这样排序应用到并行程序当中，未免也太过于困难，于是乎，便根据插入排序的基本原则，诞生了一种适合多线程下运行的排序：希尔排序。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/xier2.jpg" alt="希尔"></p><p>我们来看看希尔排序如何在多线程下实现吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">16</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shell</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> h, CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[i-h])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                <span class="keyword">int</span> j=i-h;</span><br><span class="line">                <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp)&#123;</span><br><span class="line">                    arr[j+h]=arr[j];</span><br><span class="line">                    j-=h;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+h]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pshell</span><span class="params">(<span class="keyword">int</span>[]arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">        CountDownLatch latch=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (h&lt;=arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">            h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//计算出最大的h值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">"gap="</span>+h);</span><br><span class="line">            <span class="keyword">if</span> (h&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                latch=<span class="keyword">new</span> CountDownLatch(arr.length-h);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"交换的步骤："</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt;arr.length ; i++) &#123;</span><br><span class="line">                <span class="comment">//控制线程的数量</span></span><br><span class="line">                <span class="keyword">if</span> (h&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                    es.execute(<span class="keyword">new</span> shell(i,h,latch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i]&lt;arr[i-h])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                        <span class="keyword">int</span> j=i-h;</span><br><span class="line">                        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;temp)&#123;</span><br><span class="line">                            arr[j+h]=arr[j];</span><br><span class="line">                            j-=h;</span><br><span class="line">                        &#125;</span><br><span class="line">                        arr[j+h]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.await();</span><br><span class="line">            <span class="comment">//等待排序完成</span></span><br><span class="line">            h=(h-<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"交换前："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">        pshell(arr);</span><br><span class="line">        System.out.println(<span class="string">"交换后："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">交换前：</span><br><span class="line"> <span class="number">16</span> <span class="number">12</span> <span class="number">14</span> <span class="number">11</span> <span class="number">15</span> <span class="number">13</span></span><br><span class="line">gap=<span class="number">4</span></span><br><span class="line">交换的步骤：</span><br><span class="line"></span><br><span class="line">gap=<span class="number">1</span></span><br><span class="line">交换的步骤：</span><br><span class="line">[<span class="number">12</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]</span><br><span class="line">交换后：</span><br><span class="line"> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>如此一来，就排序成功了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十八）Future模式</title>
      <link href="/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B18/"/>
      <url>/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B18/</url>
      
        <content type="html"><![CDATA[<h3 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h3><p>Future模式是在多线程程序中设计中的一个非常常见的设计模式，它和Runnable非常类似，总整体而言，可以看作为有了返回值的Runnable。但是Future模式是继承Callable接口，重写call()方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future模式的由来"><a href="#Future模式的由来" class="headerlink" title="Future模式的由来"></a>Future模式的由来</h4><p>Future模式的诞生也很贴近现实，我们的Runnable接口模式可以看做为很古老的 “一手交钱一手交货”，而Future模式则看作为，我们使用支票交易。这两者的区别在于哪里呢？Runnable要求你来交易的时候，必须去银行把钱全都取出来后，才可以交易，比如你运行的run方法，要工作完了，才可以交易，而Future模式则表示，我告诉你我能够给你钱，到时候你去银行取就可以了，我们先进行交易。这样的改进极大的提高了效率。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/future.png" alt="future"></p><p>就如上图所示main代表主系统，client表示客户要处理的信息，data表示客户最终要获得的信息，realdata表示实际的数据，而使用future可以先返回一个futuredata，给data，futuredata是realdata包装，futuredata先返回结果值到data中，然后realdata再慢慢返回全部的数据。这种模式可以应用到大规模的抽奖当中，抽奖的时候可以先返回你是否抽到奖，之后再慢慢返回抽到的奖品的具体信息。</p><h4 id="实现Future模式"><a href="#实现Future模式" class="headerlink" title="实现Future模式"></a>实现Future模式</h4><p>我们可以试着手写出这样的模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> RealData realData=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isReady)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.realData=realData;</span><br><span class="line">        isReady=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"真实数据到达，唤醒getResult"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="comment">//当真实的数据已经到达之后，唤醒全部的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isReady)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"等待真实数据处理完毕"</span>);</span><br><span class="line">                wait();</span><br><span class="line">                <span class="comment">//等到真实的处理处理完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> realData.result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            sb.append(result);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">//模拟线程真实数据的缓慢处理</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.result = sb.toString();</span><br><span class="line">        <span class="comment">//完成构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">request</span> <span class="params">(<span class="keyword">final</span> String q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FutureData future=<span class="keyword">new</span> FutureData();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//真实数据构建比较慢，所以在单独的线程中运行</span></span><br><span class="line">                System.out.println(<span class="string">"开始对真实数据进行搭建"</span>);</span><br><span class="line">                RealData realData=<span class="keyword">new</span> RealData(q);</span><br><span class="line">                future.setRealData(realData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"返回future"</span>);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client=<span class="keyword">new</span> Client();</span><br><span class="line">        <span class="comment">//这里将立即返回，因为得到的是future凭证，而不是真实数据</span></span><br><span class="line">        Data data=client.request(<span class="string">"qwe"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟其他业务的进行，不妨碍真实数据</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用真实的数据</span></span><br><span class="line">        System.out.println(<span class="string">"getResult:数据="</span>+data.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回future</span><br><span class="line">请求完毕</span><br><span class="line">开始对真实数据进行搭建</span><br><span class="line">真实数据到达，唤醒getResult</span><br><span class="line">getResult:数据=qweqweqweqweqweqweqweqweqweqwe</span><br></pre></td></tr></table></figure><p>可以看到，是先返回一个凭证，然后让程序接着运行下去，最后获得结果。</p><h4 id="JDK内置的Future模式"><a href="#JDK内置的Future模式" class="headerlink" title="JDK内置的Future模式"></a>JDK内置的Future模式</h4><p>这种Future模式在JDK当然内置也有，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/future2.jpg" alt="fu2"></p><p>我们使用内置的Future模式来试试吧，它主要是继承一个Callable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String para;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.para = para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(<span class="string">"开始搭建真实数据"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            sb.append(para);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"返回数据"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//构造FutureTask</span></span><br><span class="line">        FutureTask&lt;String&gt; f=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> RealData(<span class="string">"qwe"</span>));</span><br><span class="line">        <span class="comment">//这里会传入一个值表示使用真实的数据，而我们的真实数据会先返回Future凭证</span></span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        es.submit(f);</span><br><span class="line">        System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"做些其他的事情"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数据="</span>+f.get());</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">请求完毕</span><br><span class="line">做些其他的事情</span><br><span class="line">开始搭建真实数据</span><br><span class="line">返回数据</span><br><span class="line">数据=qweqweqweqweqweqweqweqweqweqwe</span><br></pre></td></tr></table></figure><p>注意:这里和run方法的区别是，如果你使用Runable接口去实现，那么在run方法执行完之后，数据就没了，或者直接输出，但是，这样是不会被自己给控制的。这里使用的future，想让它什么时候输出数据，就什么时候输出数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十七）常见的设计模式</title>
      <link href="/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B17/"/>
      <url>/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B17/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，也就是所谓的工厂模式，单例模式是在设计模式中非常常见的模式，也是应用最为普遍的模式之一。它的特点是：<strong>确保系统中的类只产生一个实例。</strong>运用这种模式带来的最直观的好处是，减小开销，提高效率。这种模式省略了大量的new操作，对于要大量的使用某些重量级对象的程序而言，有着极大的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，这就是一个单例工厂，设置构造函数为私有，让它不能够被随意的使用，设置它的对象为private，保证对象的私有，不会被外界肆意的修改，并且设置获取对象的函数也为私有，保证只会被本类所调用。</p><p>之所以这么做，是会让所有需要使用这个类的时候，实例只会在第一次被创建的时候使用new去创建它，之后的每一次使用，都只是return回一个实例而已，这个类没有set方法，也不是public型，可以很好的保证自身的安全。</p><p>但是，这样做也会有些不足，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> status=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singleton instance=<span class="keyword">new</span> singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(singleton.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建一个实例</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>test只是想要使用一个类里面的静态成员，并没有去创建这个类的实例，但它还是创建了，这个实例，虽然这样并不一定会出错，毕竟singleton也不可被修改，可这终归不可控。但是否可以被改造为可控？当然可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lazysingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> status=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lazysingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个延迟的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> lazysingleton instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> lazysingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> lazysingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(lazysingleton.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这样便不会造成问题了，但随之而来的是，加了一个synchronized去保证不会被多次创建的时候，也极大的降低了效率。于是，我们便可以结合两者的优点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staicsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> status=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">staicsingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个静态的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">singlrtonholder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> staicsingleton instance=<span class="keyword">new</span> staicsingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> staicsingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singlrtonholder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(staicsingleton.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这样结合了两者的特点，使用一个静态的类去调用构造方法，这个和《effective Java》中的用静态方法去代替构造方法，有着异曲同工之妙。</p><h3 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h3><p>不变模式是在设计模式中，最为安全的模式。简而言之，不变模式通过把所有的类和属性，都设置为final型，使得它们永远的不可以被改变，从而保证了自身的安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置final型确保不会被子类继承给改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String no;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">product</span><span class="params">(String no, String name, String price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者—消费者模式"><a href="#生产者—消费者模式" class="headerlink" title="生产者—消费者模式"></a>生产者—消费者模式</h3><p>这个模式可以说是现实生活中很多场景的抽象，之前提到的BlockQueue，就是被运用在这种状态下的。就好似很多程序在被设计之初，如果将接收和处理，这两种操作结合到一起的话，虽然在一定程度上减少了程序的复杂程度，但是这会让整个程序的耦合度变得很高，一旦有什么需求的改动，或者客户端出现了些变化，就会导致整个系统变的更加复杂，甚至生涩难懂。所以，在现在，很多程序的设计都会运用到接收和处理的分离，就好似前端和后端的分离一样，两者变得不再互相依赖，想要这样的条件，就必须引用一个内存缓冲区，来作为数据的传输通道，而它们的实现，正是使用了BlockQueue。</p><p><img src="https://i.loli.net/2019/12/30/jOCf1pU57cXvmbW.png" alt="内存缓冲区"></p><p>而这个BlockQueue作为内存缓冲区来调节数据的运作。下面用一个实例来展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intdata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">int</span> intdata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intdata = intdata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(String intdata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intdata = Integer.valueOf(intdata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntdata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intdata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PCData&#123;"</span> +</span><br><span class="line">                <span class="string">"intdata="</span> + intdata +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning =<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;PCData&gt; queue;</span><br><span class="line">        <span class="comment">//内存缓冲区</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sleeptime=<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//线程睡眠时间</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.queue=queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                PCData data=<span class="keyword">null</span>;</span><br><span class="line">                Random r=<span class="keyword">new</span> Random();</span><br><span class="line">                System.out.println(<span class="string">"生产者线程"</span> +</span><br><span class="line">                        Thread.currentThread().getId()+<span class="string">"开始运行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (isRunning)&#123;</span><br><span class="line">                                Thread.sleep(r.nextInt(sleeptime));</span><br><span class="line">                                data=<span class="keyword">new</span> PCData(count.incrementAndGet());</span><br><span class="line">                                System.out.println(<span class="string">"数据入队成功！"</span>);</span><br><span class="line">                                <span class="keyword">if</span> (!queue.offer(data,<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                                        <span class="comment">//提交数据到缓冲区</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">                isRunning=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.bind.v2.runtime.output.Pcdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue &lt;PCData&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sleeptime=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">consumer</span><span class="params">(BlockingQueue&lt;PCData&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者线程"</span> +</span><br><span class="line">                Thread.currentThread().getId()+<span class="string">"开始运行"</span>);</span><br><span class="line"></span><br><span class="line">        Random r=<span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                PCData data=queue.take();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span>!=data)&#123;</span><br><span class="line">                    <span class="keyword">int</span> re=data.getIntdata()*data.getIntdata();</span><br><span class="line">                    System.out.println(MessageFormat.format(<span class="string">"&#123;0&#125;*&#123;1&#125;=&#123;2&#125;"</span>,</span><br><span class="line">                            data.getIntdata(),</span><br><span class="line">                            data.getIntdata(),</span><br><span class="line">                            re));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedBlockingQueue queue = <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//建立缓冲区间</span></span><br><span class="line">        producer producer1=<span class="keyword">new</span> producer(queue);</span><br><span class="line">        producer producer2=<span class="keyword">new</span> producer(queue);</span><br><span class="line">        producer producer3=<span class="keyword">new</span> producer(queue);</span><br><span class="line">        consumer consumer1=<span class="keyword">new</span> consumer(queue);</span><br><span class="line">        consumer consumer2=<span class="keyword">new</span> consumer(queue);</span><br><span class="line">        consumer consumer3=<span class="keyword">new</span> consumer(queue);</span><br><span class="line"></span><br><span class="line">        ExecutorService es=Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//建立一个线程池</span></span><br><span class="line">        es.execute(producer1);</span><br><span class="line">        es.execute(producer2);</span><br><span class="line">        es.execute(producer3);</span><br><span class="line">        es.execute(consumer1);</span><br><span class="line">        es.execute(consumer2);</span><br><span class="line">        es.execute(consumer3);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        producer1.stop();</span><br><span class="line">        producer2.stop();</span><br><span class="line">        producer3.stop();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消费者线程<span class="number">15</span>开始运行</span><br><span class="line">生产者线程<span class="number">14</span>开始运行</span><br><span class="line">消费者线程<span class="number">16</span>开始运行</span><br><span class="line">生产者线程<span class="number">13</span>开始运行</span><br><span class="line">生产者线程<span class="number">12</span>开始运行</span><br><span class="line">消费者线程<span class="number">17</span>开始运行</span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">10</span>*<span class="number">10</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure><p>可见 LinkedBlockingQueue这个队列承担了内存的缓冲区，作为一个程序的中间件，使得生产者和消费者连接起来，即使生产者并不认识消费者，也不知道彼此的工作方式，也可以通过建立缓冲区的方式，将它们连接起来。</p><h3 id="Disruptor：高性能的生产者和消费者框架"><a href="#Disruptor：高性能的生产者和消费者框架" class="headerlink" title="Disruptor：高性能的生产者和消费者框架"></a>Disruptor：高性能的生产者和消费者框架</h3><p>既然大家都能想的到用队列去实现内存缓冲区，那么也会有人想到该怎么去优化它，使其变的更好用，于是，一家名为LMAX的公司，便开发了一个高效的无锁内存队列，那就是Disruptor。Disruptor框架中，使用了一个环形的队列，叫做ringbuffer，这是一个有头尾两个指针的队列，而且数组大小为2的次幂。因为ringbuffer使用的是位运算符，它的sequence（队列）通过和queueSize-1的值做&amp;（与运算），能够快速的定位到实际元素的位置。注意，它和普通的环形队列相比，它并没有使用出队这个操作，而是用新覆盖旧元素的方法，去减少空间的分配和回收所需要的开销。</p><h4 id="重新实现这个案例"><a href="#重新实现这个案例" class="headerlink" title="重新实现这个案例"></a>重新实现这个案例</h4><p>我们可以尝试着用ringbuffer去重新实现它：(注：这需要外接一个jar包，jdk并不自带)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCDFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">PCData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PCData <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PCData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;PCData&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">producer</span><span class="params">(RingBuffer&lt;PCData&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">(ByteBuffer bb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        <span class="comment">//获取下一个可以使用的队列盒子</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PCData event =ringBuffer.get(sequence);</span><br><span class="line">            <span class="comment">//获取当前队列盒子中的值</span></span><br><span class="line">            event.setValue(bb.getLong(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//加将目标值设置为期望值，意思就是新值覆盖旧值，节省出队的开销</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">            <span class="comment">//加入已经制作完成的队列盒子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.WorkHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">implements</span> <span class="title">WorkHandler</span>&lt;<span class="title">PCData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(PCData o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">"线程正在消费"</span> +</span><br><span class="line">                o.getValue()*o.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.BlockingWaitStrategy;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//制作线程池</span></span><br><span class="line">        PCDFactory f=<span class="keyword">new</span> PCDFactory();</span><br><span class="line">        <span class="comment">//从工厂中制作一个新的实例，此处使用了单例模式</span></span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//队列的大小必须为2的次幂</span></span><br><span class="line">        Disruptor&lt;PCData&gt; disruptor=<span class="keyword">new</span> Disruptor&lt;PCData&gt;(f,</span><br><span class="line">                size,</span><br><span class="line">                es,</span><br><span class="line">                ProducerType.MULTI,</span><br><span class="line">                <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line">        <span class="comment">//每个参数分别为，实例，大小，线程池，生产者类型和策略</span></span><br><span class="line">        disruptor.handleEventsWithWorkerPool(</span><br><span class="line">                <span class="keyword">new</span> consumer(),</span><br><span class="line">                <span class="keyword">new</span> consumer(),</span><br><span class="line">                <span class="keyword">new</span> consumer(),</span><br><span class="line">                <span class="keyword">new</span> consumer()</span><br><span class="line">        );</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        RingBuffer&lt;PCData&gt; ringBuffer=disruptor.getRingBuffer();</span><br><span class="line">        <span class="comment">//将框架内容整合到环形队列中，这里算制作完了整个队列</span></span><br><span class="line">        producer p=<span class="keyword">new</span> producer(ringBuffer);</span><br><span class="line">        <span class="comment">//生产者添加环形队列，并表示可以正式生产</span></span><br><span class="line">        ByteBuffer bb= ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; <span class="keyword">true</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            bb.putLong(<span class="number">0</span>,i);</span><br><span class="line">            p.pushData(bb);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"增加数据:"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">0</span></span><br><span class="line">增加数据:<span class="number">0</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">1</span></span><br><span class="line">增加数据:<span class="number">1</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">4</span></span><br><span class="line">增加数据:<span class="number">2</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">9</span></span><br><span class="line">增加数据:<span class="number">3</span></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">16</span></span><br><span class="line">增加数据:<span class="number">4</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">25</span></span><br><span class="line">增加数据:<span class="number">5</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">36</span></span><br><span class="line">增加数据:<span class="number">6</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">49</span></span><br><span class="line">增加数据:<span class="number">7</span></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">64</span></span><br><span class="line">增加数据:<span class="number">8</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">81</span></span><br><span class="line">增加数据:<span class="number">9</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">100</span></span><br><span class="line">增加数据:<span class="number">10</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">121</span></span><br><span class="line">增加数据:<span class="number">11</span></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">144</span></span><br><span class="line">增加数据:<span class="number">12</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">169</span></span><br><span class="line">增加数据:<span class="number">13</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">196</span></span><br><span class="line">增加数据:<span class="number">14</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">225</span></span><br></pre></td></tr></table></figure><p>消费者在继承了WorkHandler的接口后，会要求重写消费该队列的方法，每次在生产者中使用了ringBuffer.publish(sequence);加入一个元素后，消费者会自动去调用重写的消费方法，去使用这个元素，比如求这个元素的平方。之所以使用bytebuffer去存储元素，是因为它能够存放任何的数据类型。每次存放一个数据后，都要使用next方法去继续获得下一个元素所存放的盒子。整个数据结构的图示如下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/ringbuffer.jpg" alt="ringbuffer"></p><h4 id="选择合适的策略"><a href="#选择合适的策略" class="headerlink" title="选择合适的策略"></a>选择合适的策略</h4><p>Disruptor在制作的时候，最后一个参数叫做BlockingWaitStrategy，这是disruptor的一个默认的策略，它和blockqueue非常类似，都是使用阻塞的方式，使用锁和条件(condition)进行阻塞，这种情况下非常节省cpu的使用，但使用着阻塞，便意味着在高并发的情况下，效果不会那么理想。接下来总结一个有哪些策略：</p><ol><li>sleepWaitStrategy：这个策略虽然不进行将线程挂起的操作，但是会使用自旋的方式让获取资源，这个策略不会占用太多的CPU资源，但是对数据处理效率也不高，甚至比阻塞的效率更低一点。好处就是，对生产者线程的影响非常小，比较适合异步日志。</li><li>BlockingWaitStrategy：使用锁和条件去阻塞队列，保证线程安全，但在高并发情况下效率低下。</li><li>YieldWaitStrategy：这个策略去CPU要求很高，消费者非常疯狂的去获得生产者所加入的元素，因为它的消费者会在内部执行一个Threa.yield的死循环。</li><li>BusySpinWaitStrategy：这个策略效率非常非常的高，但是它会使用掉几乎所有的CPU资源。</li></ol><h4 id="CPU的Cache优化"><a href="#CPU的Cache优化" class="headerlink" title="CPU的Cache优化"></a>CPU的Cache优化</h4><p>上述的一些策略，都是为了调节CPU资源等等的问题，可见CPU在程序中的重要性，我们除了要从框架上优化和调节CPU的使用之外，我们也要稍微了解一下CPU的机制，在讲述volatile的时候，使用了这一张图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/volatileyuanli.png" alt="volatile"></p><p>这张图也可以表示出，CPU都是从缓存中获取数据。但是要注意，每个数据被加入到cache中的时候，并不是单个单个存在的：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/cpu1.png" alt="CPU1"></p><p>像这样，每次在将一个新的x被更新后，就会使得所有和x层所在的元素，一同被声明为无效，对于这样的情况，我们的程序都可以想办法对cpu进行优化，这优化在《Java并发编程艺术》一书中也有所提及，就是想办法将其凑够一行，如图：<br><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/cpu2.png" alt="cpu2"></p><p>这样，每次被声明无效过后，只有x会被无效化，而y不会，这也是典型的以空间去换时间的做法，那我们可以在实际中试一试看看真的能不能提高效率。(注：使用JDK7)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 解决<span class="title">cpu</span>的<span class="title">cache</span>优化问题 <span class="keyword">implements</span> <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREADS=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ITERATIONS=<span class="number">500L</span>*<span class="number">1000L</span>*<span class="number">1000L</span>;</span><br><span class="line">    <span class="comment">//项目大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayindex;</span><br><span class="line">    <span class="comment">//数组的索引</span></span><br><span class="line">    <span class="keyword">public</span> 解决cpu的cache优化问题(<span class="keyword">int</span> arrayindex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayindex = arrayindex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> q1,q2,q3,q4,q5,q6,q7;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value=<span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> p1,p2,p3,p4,p5,p6,p7;</span><br><span class="line">        <span class="comment">//填充物，这关系到测试的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs=<span class="keyword">new</span> VolatileLong[NUM_THREADS];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;longs.length ; i++) &#123;</span><br><span class="line">            longs[i]=<span class="keyword">new</span> VolatileLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start =System.currentTimeMillis();</span><br><span class="line">        Runtest();</span><br><span class="line">        System.out.println(<span class="string">"持续时间="</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Runtest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] ts=<span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;ts.length ; i++) &#123;</span><br><span class="line">            ts[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> 解决cpu的cache优化问题(i));</span><br><span class="line">            <span class="comment">//建立测试线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t:</span><br><span class="line">             ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t:</span><br><span class="line">             ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i=ITERATIONS+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span>!=--i)&#123;</span><br><span class="line">            longs[arrayindex].value=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续时间=3514</span></span><br></pre></td></tr></table></figure><p>那我们把填充物给注释掉呢，看看结果会怎么样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持续时间=8312</span></span><br></pre></td></tr></table></figure><p>可以看到性能差距非常之大。为什么呢？因为CPU的每次缓存，都是缓存64的字节数，一个对象的引用一般占用4个字节，而在这里填充15个字节，使得缓存满64个字节，这样，便优化了效率。</p><p>但是注意，这里使用的是JDK7，因为jdk8会自动优化不使用的字段，这样我们的填充物就被所谓的 “优化”给优化没了，这可能就是所谓的负优化把……</p><p>而我们所使用的Disruptor就考虑到了这一层，所以，在总体实现上Disruptor的ringbuffer队列会比传统的LinkingBlockQueue快了很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十六）死锁状态</title>
      <link href="/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B16/"/>
      <url>/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B16/</url>
      
        <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在实际应用上，使用锁的环境远远要多于使用无锁。但是经常使用锁，一般都会面对一个问题，那就是死锁，现在用一个例子，简单的阐述死锁。</p><h4 id="哲学家的餐桌"><a href="#哲学家的餐桌" class="headerlink" title="哲学家的餐桌"></a>哲学家的餐桌</h4><p>哲学家就餐问题就是一个常见的死锁问题。有四个哲学家坐在一个正方形的桌子上面，每个桌角都放置有一个叉子，而哲学家必须使用两个叉子才能正常进餐，但是哲学家们并不一直用餐，它们有时候还会停止进餐，用一段时间去思考哲学问题，这样的话，餐桌上的叉子就一直都处于被竞争的状态，最多时，可以同时存在两个哲学家进餐，两个哲学家思考。但是，又因为哲学家们从不进行交谈，这就会产生一个问题，如果有一个哲学家只拿到了右边的叉子，需要等待左边的叉子的时候，左边的哲学家也在等待他左边的叉子，这样互相等待而不行动的状态，称之为死锁状态。这里就举一个最简单的例子，只有两个哲学家在吃饭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Object tool;</span><br><span class="line">    <span class="keyword">static</span> Object f1=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object f2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(Object tool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tool = tool;</span><br><span class="line">        <span class="keyword">if</span> (tool==f1)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"哲学家A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tool==f2)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"哲学家B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test 哲学家A=<span class="keyword">new</span> test(f1);</span><br><span class="line">        test 哲学家B=<span class="keyword">new</span> test(f2);</span><br><span class="line">        哲学家A.start();</span><br><span class="line">        哲学家B.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tool==f1)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (f2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"哲学家A开始进餐"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tool==f2)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (f1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"哲学家B开始进餐"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后发现进程并不会结束，将永久运行一下，因为它们在互相获取彼此的叉子的时候，又互相被锁住了。此时打开任务管理器，可以看到并不占用CPU ，因为产生了死锁，谁都没有行动。</p><p>也可以使用jps工具和jstack工具（只要能使用javac，就能使用这些工具）从cmd打印出到底出了什么问题哦!</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jps.png" alt="jps"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"哲学家B":</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000ae4f488 (object <span class="number">0</span>x00000000db0a48a0, a java.lang.Object),</span><br><span class="line">  which is held by "哲学家A"</span><br><span class="line">"哲学家A":</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000ae4c9e8 (object <span class="number">0</span>x00000000db0a48b0, a java.lang.Object),</span><br><span class="line">  which is held by "哲学家B"</span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"哲学家B":</span><br><span class="line">        <span class="built_in">at</span> test.run(test.java:<span class="number">46</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000db0a48a0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000db0a48b0&gt; (a java.lang.Object)</span><br><span class="line">"哲学家A":</span><br><span class="line">        <span class="built_in">at</span> test.run(test.java:<span class="number">34</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000db0a48b0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000db0a48a0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十五）线程互助的SynchronousQueue</title>
      <link href="/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B15/"/>
      <url>/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B15/</url>
      
        <content type="html"><![CDATA[<h4 id="让线程之间互相帮助：SynchronousQueue"><a href="#让线程之间互相帮助：SynchronousQueue" class="headerlink" title="让线程之间互相帮助：SynchronousQueue"></a>让线程之间互相帮助：SynchronousQueue</h4><p>在线程池的介绍当中，提到一个非常特殊的队列，叫做SynchronousQueue。它的容量为0，对任何一个写操作，都要等待一个读操作，可以把SynchronousQueue看做为一个数据的交换通道。讲到这样一个需要等待操作的方法，不得不提到之前的LinkedBLockQueue，它的put方法和take方法，正是需要等待队列的来唤醒，而我们这个SynchronousQueue，也正有着异曲同工之秒，它的put方法和take方法都涉及到了一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transferer.transfer(o, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>)<span class="comment">//put</span></span><br><span class="line">transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>)<span class="comment">//take</span></span><br></pre></td></tr></table></figure><p>而这个方法的参数有哪些呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，这个是一个抽象方法，等待SynchronousQueue去实现，而第一个值Object表示是否传入参数，第二个值表示是否传入存在时间，第三个值表示时长。为什么要这么做呢？因为如果传入的值一直都没有相应的take操作将其取出，就会导致堵塞，这样会使得SynchronousQueue不能正常工作，所以需要设定自我销毁时间。</p><p>transfer主要分三个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                SNode h = head;</span><br><span class="line">                <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                            casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                        SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                        <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                            clean(s);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                            casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                        <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>根据SynchronousQueue的特性，对任何一个写操作，都要等待一个读操作。一开始的SNode表示等待队列的节点，之后的if所判断的是如果队列为空，则直接返回空，或者队列中元素的模式和本次操作相同。比如都是读操作，则需要等待入队，从elseif开始，表示入队成功，之后节点就会处于自旋、等待的状态，直到有一个相应的线程使其唤醒。之后的操作则是帮助两个头部节点完成出队的操作，当然，这帮助不一定会有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                    <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                        casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                            SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                            <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                                casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                                s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                                <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            SNode mn = m.next;</span><br><span class="line">                            <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                                casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                                <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                            &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                                s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>如果等待队列和本次操作，是互补的，那么就插入一个完成状态的节点，让他匹配到一个等待节点上，之后弹出这两个节点，并且使得对应的两个线程继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                    SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                        casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                            casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                        <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                            h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>如果线程发现等待队列的节点就是完成节点，那么帮助这个节点完成任务，其流程和步骤2是一样的。</p><p>下面用一个实际例子去展示：例子来自于：<a href="https://blog.csdn.net/yanyan19880509/article/details/52562039" target="_blank" rel="noopener">https://blog.csdn.net/yanyan19880509/article/details/52562039</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 关于<span class="title">SynchronousQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Thread putThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"put 线程开始"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"put 线程结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread takeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"take 线程开始"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"take 来自于 put线程: "</span> + queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"take 线程结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        putThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        takeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，必须等待其他的线程使用take操作的时候，才能够让put的线程继续运行下去。这正是SynchronousQueue的特点，它不能够容乃任何事物，只能是一个任意门，一个通道，它是不能存放任何实体的。（注：SynchronousQueue内部没有容器指的是没有像数组那样的内存空间存多个元素，但是是有单地址内存空间，用于交换数据）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十四）无锁状态</title>
      <link href="/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B14/"/>
      <url>/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B14/</url>
      
        <content type="html"><![CDATA[<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>加锁是保证线程安全的常用手法，但是被加锁之后，往往会产生一些效率的问题，那不使用锁，也能保证线程安全吗？当然可以，并且，使用无锁的方法去实现的线程安全，不仅仅在效率上占优，而且，还不会产生死锁的问题哦。</p><h4 id="无锁的策略：CAS-Compare-And-Swap"><a href="#无锁的策略：CAS-Compare-And-Swap" class="headerlink" title="无锁的策略：CAS(Compare And Swap)"></a>无锁的策略：CAS(Compare And Swap)</h4><p>经常被使用的无锁方法，叫做CAS，就是比较和交换。它不是一个固定的类或者方法，而是一个常用的策略，是一个算法。CAS通常包括着三个参数（V,E,N）V代表着即将要被更新的变量，E代表着预期的值，N代表着新的值，只有当且仅当V=E的时候，才会把V更新为N。这表示着如果有多个线程企图使用CAS操作去更新一个值的时候，只有一个会更新成功，并且把更新成功后其他线程的E变换为更新过后的值，导致了其他线程的V！=E 从而使得其他线程的更新操作失败，不过，这并不会直接导致他们取消这次操作，而是让他们再次开始<strong>自旋</strong>去尝试进行CAS操作。</p><h4 id="AtomicInteger：无锁的线程安全整数"><a href="#AtomicInteger：无锁的线程安全整数" class="headerlink" title="AtomicInteger：无锁的线程安全整数"></a>AtomicInteger：无锁的线程安全整数</h4><p>AtomicInteger是一个使用CAS操作去实现的类，它是一个无锁的、线程安全的整体，它的任何类似于i++之类的操作，即使没有被加上锁，依然是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger a=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a.incrementAndGet();<span class="comment">//a++操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=<span class="number">200000</span></span><br><span class="line">a=<span class="number">1200000</span></span><br></pre></td></tr></table></figure><p>可以看到，无论是单独的使用线程，还是使用线程池，它们对于a的++操作，都是线程安全的。而AtomicInteger常用的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//i++</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span><span class="comment">//i--</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span><span class="comment">//i+delta</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span><span class="comment">//++i</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span><span class="comment">//--i</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span><span class="comment">//delta+i</span></span></span><br><span class="line"><span class="function">    <span class="comment">//注意顺序</span></span></span><br></pre></td></tr></table></figure><p>我们看看incrementAndGet()的源码吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk8，经过了层层封装，就以JDK7为例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();<span class="comment">//获取值</span></span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;<span class="comment">//创建新的对象使其+1，这种本身不变，通过创建新值的方式，来使自己增加，更具有安全性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))<span class="comment">//CAS操作</span></span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一开始看到这个for (;;) 它是一个无限的循环，正如开头所说的那样，就算失败也不会返回false，而是进行不断地尝试，直到正确为止。第二，这个CAS操作会在自己的线程中创建一个新的值，这样的线程局部变量仅仅对自身有效，而在执行CAS操作的时候，如果在这个时候，目标的值被改变，就不会返回，而是自旋，直到成功为止。</p><h4 id="Unsafe：Java中的指针"><a href="#Unsafe：Java中的指针" class="headerlink" title="Unsafe：Java中的指针"></a>Unsafe：Java中的指针</h4><p>看到无论是JDK7还是JDK8，都使用了一个叫做Unfase的类去调用CAS操作，在compareAndSet中，有着四个参数，this代表的是自身这个对象，valueOffset代表着目标的偏移量，expect是旧值，update是新值。而Java中其实并没有指针，所以他是不安全的，是Unsafe的，而这个valueOffset就是一个字段到目标头部的偏移量，通过这个偏移量快速定位字段，看不懂也没关系，这涉及到底层实现。</p><p>在AtomicInteger中，Unsafe有这样的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure><p>它实际获取的是Unsafe这个类中的getUnsafe方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (var0.getClassLoader() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个特别的地方，在那个if的判断语句当中，有着var0.getClassLoader() != null ，这个判断，它表示着如果这个类的类加载器不为空，则直接抛出异常，并且停止工作，这使我们无法直接去使用这个类，说明它是一个JDK内部的专属类，不可以被外部对象所使用。也就是说，我们不需要或不能去直接使用Unsafe，而是应该通过CAS去操纵它。</p><h4 id="AtomReference：无锁的对象引用"><a href="#AtomReference：无锁的对象引用" class="headerlink" title="AtomReference：无锁的对象引用"></a>AtomReference：无锁的对象引用</h4><p>除了AtomicInteger这样对整数进行无锁，却又能保证线程安全的类之外，设计者当然也考虑到了对象的线程安全使用问题。它的使用和AtomicInteger非常类似，在此不多赘述，只展示区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; a=<span class="keyword">new</span> AtomicReference&lt;String&gt;();<span class="comment">//被定义</span></span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            V x = get();</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(x, newValue))</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是需要补充的是，它们都涉及到了一个问题：对象的值被修改回原值，到底算不算修改。比如有三个线程ABC，A把i=1修改成i=2，B把i=2，再修改成i=1,那么对于C线程来说，i在进行CAS比较的时候，到底是被修改了还是没有被修改呢？但从代码上而言，对于C线程来说，i没有被修改，应该继续去执行CAS操作，而不是看做为被修改，从而再次循环。这或许在思维和逻辑上表示正确，但是现实生活中，却不应该是这样子，比如家里人给你1000块钱生活费，你一到账就用3秒时间全部还了花呗，你不能说在1分钟后，家里人问你到账没有，你说没有。实际上你确确实实花了那一部分钱，但这个在CAS操作中并没有被记录而已。接下来我们使用代码去还原当时的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicReference&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        money.set(<span class="number">900</span>);</span><br><span class="line">        <span class="comment">//你有900块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        Integer m=money.get();</span><br><span class="line">                        <span class="keyword">if</span>(m&lt;<span class="number">1000</span>)&#123;<span class="comment">//生活费不足</span></span><br><span class="line">                            <span class="keyword">if</span>(money.compareAndSet(m,m+<span class="number">1000</span>))&#123;</span><br><span class="line">                                System.out.println(<span class="string">"不足1000元，已打钱，余额："</span>+money.get());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//System.out.println("还不需要");</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        Integer m=money.get();</span><br><span class="line">                        <span class="keyword">if</span>(m&gt;<span class="number">500</span>)&#123;<span class="comment">//还花呗</span></span><br><span class="line">                            System.out.println(<span class="string">"大于500块"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (money.compareAndSet(m,m-<span class="number">500</span>))&#123;</span><br><span class="line">                                System.out.println(<span class="string">"成功还款500，余额："</span>+money.get());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有足够金额"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">1400</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">900</span></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">1400</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">900</span></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br></pre></td></tr></table></figure><p>这种几率非常非常的小，但是还是有可能发生的，为了解决这样的问题，就诞生了AtomicStampedReference。当然，也可以使用带版本号的方式去辨别。</p><h4 id="AtomicStampedReference：带有时间戳的对象引用"><a href="#AtomicStampedReference：带有时间戳的对象引用" class="headerlink" title="AtomicStampedReference：带有时间戳的对象引用"></a>AtomicStampedReference：带有时间戳的对象引用</h4><p>它会产生一个时间戳单位，并且在进行CAS的时候，会多传入两个参数，使其同时进行CAS操作，让它的时间戳+1，这样，修改了时间戳之后，代表了执行成功，就不会再次执行这样的操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//源码  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">900</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> time=money.getStamp();<span class="comment">//获取了时间戳</span></span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        Integer m=money.getReference();</span><br><span class="line">                        <span class="keyword">if</span>(m&lt;<span class="number">1000</span>)&#123;<span class="comment">//生活费不足</span></span><br><span class="line">                            <span class="keyword">if</span>(money.compareAndSet(m,m+<span class="number">1000</span>,time,time+<span class="number">1</span>))&#123;<span class="comment">//多传入了两个参数</span></span><br><span class="line">                                System.out.println(<span class="string">"不足1000元，已打钱，余额："</span>+money.getReference());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//System.out.println("还不需要");</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> time=money.getStamp();</span><br><span class="line">                        Integer m=money.getReference();</span><br><span class="line">                        <span class="keyword">if</span>(m&gt;<span class="number">500</span>)&#123;<span class="comment">//还花呗</span></span><br><span class="line">                            System.out.println(<span class="string">"大于500块"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (money.compareAndSet(m,m-<span class="number">500</span>,time,time+<span class="number">1</span>))&#123;</span><br><span class="line">                                System.out.println(<span class="string">"成功还款500，余额："</span>+money.getReference());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有足够金额"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">1400</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">400</span></span><br><span class="line">没有足够金额</span><br><span class="line">没有足够金额</span><br><span class="line">没有足够金额</span><br></pre></td></tr></table></figure><h4 id="AtomicIntegerArray：无锁的数组"><a href="#AtomicIntegerArray：无锁的数组" class="headerlink" title="AtomicIntegerArray：无锁的数组"></a>AtomicIntegerArray：无锁的数组</h4><p>同理，这里仅仅是简单展示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray a=<span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a.incrementAndGet(i%a.length());<span class="comment">//a++操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=[<span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>]</span><br></pre></td></tr></table></figure><h4 id="AtomicIntegerFieldUpdater：使int型也拥有原子性"><a href="#AtomicIntegerFieldUpdater：使int型也拥有原子性" class="headerlink" title="AtomicIntegerFieldUpdater：使int型也拥有原子性"></a>AtomicIntegerFieldUpdater：使int型也拥有原子性</h4><p>在实际开发过程中，由于初期考虑不周，没有对某些类设计为原子性，可能会在以后所应用的某些场景，出现线程安全的问题。就比如一些餐馆的菜单类在ID字段上设计为int型，很多时候我们并不需要去频繁的改动它，或者说，这菜品的ID也只是一个只读类型。但是在之后的过程中，这家餐馆被收购了，需要非常频繁的去改动菜品的ID，这就会涉及到数据不一致的问题，但是当初被设计的时候没有被考虑到，如果我们需要更改的话，可能会非常麻烦或者出现其他的错误，所以与其修改，不如去增加，这样更安全。所以我们使用AtomicIntegerFieldUpdater，去实现它。</p><p>举一个场景，某一地要进行一个选举，现在开始模拟投票场景，如果选民投了候选人一票，就记为1，否则为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">candidate</span></span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;candidate&gt; scoreUpdater</span><br><span class="line">            =AtomicIntegerFieldUpdater.newUpdater(candidate.class,"score");</span><br><span class="line">    <span class="comment">//传入一个泛型，在newUpdater中传入要绑定的类和类属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger all=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//总票数,用于检查updater工作是否正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> candidate stu=<span class="keyword">new</span> candidate();<span class="comment">//一个类的实例</span></span><br><span class="line">        Thread[] t=<span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            t[i]=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random()&gt;<span class="number">0.4</span>)&#123;<span class="comment">//假设有60%的人投了票</span></span><br><span class="line">                        scoreUpdater.incrementAndGet(stu);<span class="comment">//安全的增加这个类的属性的值，即使它不是AtomicInteger型</span></span><br><span class="line">                        all.incrementAndGet();<span class="comment">//起到验证作用</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"score="</span>+stu.score);</span><br><span class="line">        System.out.println(<span class="string">"all="</span>+all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//score=6013</span></span><br><span class="line"><span class="comment">//all=6013</span></span><br></pre></td></tr></table></figure><p>模拟这个选举，有60%的人投了这个候选人，那么使用这个候选人的属性，使得它绑定到scoreUpdater，使其成为原子的。因此做了个试验去验证。我们再来看看它是怎么实现的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass, String fieldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;(tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它传入的参数，一个是calss的值，一个是calss的属性，然后定位到这个类的属性，将其绑定成AtomicInteger，并且返回。最后使用AtomicIntegerFieldUpdater要注意几点：</p><ol><li>Updater只能修改可见变量，因为在源码中，使用了反射，所以score不能设置为private。</li><li>必须声明为volatile型</li><li>它的AtomicIntegerFieldUpdaterImpl中，也运用到了Unsafe，所以不支持静态变量，不能设置为static</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十三）ThreadLocal</title>
      <link href="/2019/12/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B13/"/>
      <url>/2019/12/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B13/</url>
      
        <content type="html"><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>锁可以保证一个变量被使用的时候，可以将其锁住，不让其他线程修改，那么引申到一个问题，可不可给每个线程都设置一个变量，让他们各自为营，以空间去换取时间呢？当然可以，于是乎就有了ThreadLocal这个新的方法，举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:m:ss"</span>);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date t=sdf.parse(<span class="string">"2019-12-28 15:19:"</span>+i/<span class="number">60</span>);</span><br><span class="line">            System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"pool-1-thread-6"</span> Exception in thread <span class="string">"pool-1-thread-4"</span> Exception in thread <span class="string">"pool-1-thread-7"</span> Exception in thread <span class="string">"pool-1-thread-1"</span> Exception in thread <span class="string">"pool-1-thread-2"</span> java.lang.NumberFormatException: multiple points</span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1890</span>)</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:<span class="number">538</span>)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2089</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1890</span>)</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:<span class="number">538</span>)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2089</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Exception in thread <span class="string">"pool-1-thread-5"</span> java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2162</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)<span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><p>很明显，不可以，因为sdf.parse并不是线程安全的，所以我们除了可以使用锁去锁住它之外，还可以使用ThreadLocal去处理，为每一个线程都产生一个ThreadLocal的局部对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(sdf.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                sdf.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:m:ss"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Date t=sdf.get().parse(<span class="string">"2019-12-28 15:19:"</span>+i/<span class="number">60</span>);</span><br><span class="line">            System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><p>可以看到，为每一个线程都分配了一个对象去工作，以空间换取时间，这使得我们每个线程都有了独立的局部变量，让其线程安全。但如果在应用上为每个对象都分配相同的对象实例，也是会导致线程不安全的。</p><h4 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h4><h5 id="set和get"><a href="#set和get" class="headerlink" title="set和get"></a>set和get</h5><p>ThreadLocal最主要的就是它的set和get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们传入的值，传入到了一个map中。把当前线程的值看做为一个key，把传入的参数看作为一个value，先获取当前线程的id，作为一个key，如果不存在则创造一个全局的map（其实就是ThreadLocal本身），将其key和value加入map中，若存在这个key，则重新修改这个值。在使用get方法取出的时候，利用了泛型，将value的值重新完整的取出。</p><h5 id="exit和remove"><a href="#exit和remove" class="headerlink" title="exit和remove"></a>exit和remove</h5><p>当我们的线程退出的时候，自动会执行exit方法，而exit方法也包括了对ThreadLocal的清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但平常我们并不经常单独的去使用一个线程，而是使用线程池去使用线程，这就牵扯到了一个问题，那就是线程池的线程有线程复用现象，那么这样的线程就不会被销毁，那么ThreadLocal也就一直存在，当它积累到一定程度的时候，就有内存泄漏的风险，于是乎，我们便可以手动的去销毁ThreadLocalmap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t.remove();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以主动的设置object=null，让jvm更快的回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>的<span class="title">GC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadLocal&lt;SimpleDateFormat&gt; t1=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString()+<span class="string">"is GC"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch cd=<span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">        cd.await();</span><br><span class="line">        System.out.println(<span class="string">"任务完成"</span>);</span><br><span class="line">        t1=<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"首次GC成功"</span>);</span><br><span class="line"></span><br><span class="line">        t1=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">        cd=<span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">        cd.await();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"第二次GC成功"</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(t1.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                            System.out.println(<span class="keyword">this</span>.toString()+<span class="string">"is GC2"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getId()+<span class="string">"create SimpleDateFormat"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Date t=t1.get().parse(<span class="string">"2019-12-28 15:19:"</span>+i/<span class="number">60</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                cd.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>create SimpleDateFormat</span><br><span class="line"><span class="number">21</span>create SimpleDateFormat</span><br><span class="line"><span class="number">19</span>create SimpleDateFormat</span><br><span class="line"><span class="number">16</span>create SimpleDateFormat</span><br><span class="line"><span class="number">14</span>create SimpleDateFormat</span><br><span class="line"><span class="number">17</span>create SimpleDateFormat</span><br><span class="line"><span class="number">18</span>create SimpleDateFormat</span><br><span class="line"><span class="number">20</span>create SimpleDateFormat</span><br><span class="line"><span class="number">15</span>create SimpleDateFormat</span><br><span class="line"><span class="number">12</span>create SimpleDateFormat</span><br><span class="line">任务完成</span><br><span class="line">首次GC成功</span><br><span class="line">ThreadLocal的GC$<span class="number">1</span>@<span class="number">74560f</span>d0is GC</span><br><span class="line"><span class="number">14</span>create SimpleDateFormat</span><br><span class="line"><span class="number">18</span>create SimpleDateFormat</span><br><span class="line"><span class="number">19</span>create SimpleDateFormat</span><br><span class="line"><span class="number">17</span>create SimpleDateFormat</span><br><span class="line"><span class="number">13</span>create SimpleDateFormat</span><br><span class="line"><span class="number">15</span>create SimpleDateFormat</span><br><span class="line"><span class="number">20</span>create SimpleDateFormat</span><br><span class="line"><span class="number">21</span>create SimpleDateFormat</span><br><span class="line"><span class="number">12</span>create SimpleDateFormat</span><br><span class="line"><span class="number">16</span>create SimpleDateFormat</span><br><span class="line">第二次GC成功</span><br></pre></td></tr></table></figure><p>这个例子首先设置了只有10个线程的线程池，然后使用线程池去使用线程，而CountDownLatch则是必须执行10000次，因为只有十个线程，所以也只制造了10个ThreadLocal实例，在它们执行完10000次后，将ThreadLocal的设置为null，这也就使得每个线程的ThreadLocal为空了，之后马上进行一次GC回收，再次创建的时候，判定t1.get()==null，可见ThreadLocal又重新被制作了。</p><p>前面对ThreadLocal的使用的涉及到了ThreadLocalMap的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看作为一种较为弱的HashMap。当这个ThreadLocal的t1被设置为null时，它的所有key值都将不复存在，但这并不代表线程已经被销毁了，而是指它和线程的ID 解绑了，于是ThreadLocal的entry也将被销毁，成为null，而再次去线程池里使用线程时，ThreadLocal的key值再次和线程ID绑定，只不过他的value已空，需要重新去设置。</p><h4 id="ThreadLocal对性能的提升"><a href="#ThreadLocal对性能的提升" class="headerlink" title="ThreadLocal对性能的提升"></a>ThreadLocal对性能的提升</h4><p>最后我们最后做一个测试去查看ThreadLocal对性能的提升如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GEN_COUNT=<span class="number">10000000</span>;<span class="comment">//每个线程要执行生成随机数的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT=<span class="number">4</span>;<span class="comment">//线程数</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random rnd=<span class="keyword">new</span> Random(<span class="number">123</span>);<span class="comment">//返回一个随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Random&gt; tRnd=<span class="keyword">new</span> ThreadLocal&lt;Random&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Random <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random(<span class="number">123</span>);<span class="comment">//返回一个随机数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RndTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//java5开始，提供了Callable接口，是Runable接口的增强版。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mode=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RndTask</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mode = mode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Random <span class="title">getRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mode==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> rnd;<span class="comment">//</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mode==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tRnd.get();<span class="comment">//ThreadLocal</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> b=System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;GEN_COUNT ; i++) &#123;</span><br><span class="line">                getRandom().nextInt();<span class="comment">//返回随机数，10000000次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> e=System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"花费"</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line">            <span class="keyword">return</span> e-b;<span class="comment">// java5提供了Future接口来代表Callable接口里的call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口，所以这样可以作为Thread的target。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;Long&gt;[] f=<span class="keyword">new</span> Future[THREAD_COUNT];<span class="comment">//制作四个线程组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            f[i]=es.submit(<span class="keyword">new</span> RndTask(<span class="number">0</span>));<span class="comment">//提交普通的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> totaltime=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            totaltime+=f[i].get();<span class="comment">//获取返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"多线程访问同一个Random实例"</span>+totaltime+<span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Threadlocal</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            f[i]=es.submit(<span class="keyword">new</span> RndTask(<span class="number">1</span>));<span class="comment">//提交ThreadLocal</span></span><br><span class="line">        &#125;</span><br><span class="line">        totaltime=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            totaltime+=f[i].get();<span class="comment">//获取返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"使用ThreadLocal包装Random实例"</span>+totaltime+<span class="string">"ms"</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>花费<span class="number">1596</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>花费<span class="number">1643</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>花费<span class="number">1688</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>花费<span class="number">1687</span>ms</span><br><span class="line">多线程访问同一个Random实例<span class="number">6614</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>花费<span class="number">110</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>花费<span class="number">121</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>花费<span class="number">127</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>花费<span class="number">132</span>ms</span><br><span class="line">使用ThreadLocal包装Random实例<span class="number">490</span>ms</span><br></pre></td></tr></table></figure><p>这个测试，一个使用全局的Random实例，被多个线程访问，每个线程都执行了100000次return new Random(123)的操作，总共产生了40000000次Random对象。而使用ThreadLocal去包装Random，总共就创建了4次Random对象，之后只是在不断地访问它而已，可见得，效率有着显著的提高。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十二）如何提高锁的性能</title>
      <link href="/2019/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B12/"/>
      <url>/2019/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B12/</url>
      
        <content type="html"><![CDATA[<h3 id="几种提高锁性能的方法"><a href="#几种提高锁性能的方法" class="headerlink" title="几种提高锁性能的方法"></a>几种提高锁性能的方法</h3><h4 id="减小锁持有的时间"><a href="#减小锁持有的时间" class="headerlink" title="减小锁持有的时间"></a>减小锁持有的时间</h4><p>synchronized虽然可以保持原子性，但是大量的使用synchronized会使系统的整体性能下降，于是，我们可以只在需要上锁的时候上锁，对某些不改变系统数据的方法不上锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        code1();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        code2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//可以改为</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        code1();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        code2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其实这个例子不能很好的说明，因为jvm对锁有优化，使得不需要上锁的区域会自动发生逃逸现象。</span></span><br></pre></td></tr></table></figure><p>比如code1和code2是不影响原子性的普通操作，而它们所占用的时间又很多，于是便可以将synchronized从一个整体函数拆分到一个个体中，更甚至可以使用lock和unlock继续细分，使得仅仅需要同步的方法上锁。</p><h4 id="减小锁的粒度：锁细化"><a href="#减小锁的粒度：锁细化" class="headerlink" title="减小锁的粒度：锁细化"></a>减小锁的粒度：锁细化</h4><p>除了可以通过减小锁持有的时间去提高性能外，还可以通过减小锁的粒度去提高性能，就比如HashMap，在使用put()的时候，它是线程不安全的，如果直接使用synchronized去上锁，那么可能会对整体性能造成很大的影响，因为HashMap经常需要被使用。所以，便可以通过减小锁的粒度的形式去改变它，就比如ConcurrentHashMap，它本身有16个空的容器可以容纳元素，它在使用put方法的时候，进行计算，如果各个线程所得出来的key值不相同，那就不进行加锁，也就是说，最多可以共同容纳16个线程不加锁去put元素，极大的提高了效率。以下提供ConcurrentHashMap源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，并不是所有的锁细化都可以提高性能，因为一旦进行锁细化操作后，如果一个全局的变量需要获得锁，那就必须等待所有被细化的锁释放之后才能进行。比如ConcurrentHashMap的size()；就必须获得整体的锁，所以在执行类似操作的时候，要注意当时的场景是否需要经常使用全局变量，比如一个需要实时统计数据的股票交易所，就不要使用锁细化。</p><h4 id="增大锁的粒度：锁粗化"><a href="#增大锁的粒度：锁粗化" class="headerlink" title="增大锁的粒度：锁粗化"></a>增大锁的粒度：锁粗化</h4><p>有的时候为了提高性能甚至还可以反其道而行之，提高锁的粒度。因为存在一个特殊的场景，需要经常获得锁，但是不需要获得锁的部分所执行的时间又极短，所以与其不停的去申请锁并释放锁，不如直接申请一个大锁，锁住全部内容，以为每次加锁和解锁都是需要时间的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2</span>);<span class="comment">//中间所执行时间极短</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不如就</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少锁的申请，减小开销</span></span><br></pre></td></tr></table></figure><h4 id="用读写锁去代替独占锁"><a href="#用读写锁去代替独占锁" class="headerlink" title="用读写锁去代替独占锁"></a>用读写锁去代替独占锁</h4><p>在生活中很多应用场合中，读取数据的次数总是要大于写入次数的，就比如购物平台，所以很多时候都可以用读写锁ReadWriteLock去代替独占锁，或者用重入锁去代替独占锁，很多特殊的锁在特定环境下总能够获得更大的性能，要看场合使用。</p><h4 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h4><p>从读写锁的角度出发，我们可以从中获得启发，那就是将锁分离，读写锁可以拆分为读锁和写锁，用作于很多不同的场景，而我们也可以试着将锁分离，或者增加更多的锁，从而用更多的方法去得到灵活性。就比如之前的LinkedBlockingQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>使用了两个锁，，分别去控制put方法和take方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();<span class="comment">//不能有两个线程同时进行put</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;<span class="comment">//如果达到了上限，便等待</span></span><br><span class="line">                notFull.await();<span class="comment">//等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);<span class="comment">//跳出了等待，便入队</span></span><br><span class="line">            c = count.getAndIncrement();<span class="comment">//入队成功，总数加一</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)<span class="comment">//如果仍未满，就通知其他线程的put继续入队</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();<span class="comment">//插入成功，通知take操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//以此类推......</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十一）并发容器</title>
      <link href="/2019/12/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11/"/>
      <url>/2019/12/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11/</url>
      
        <content type="html"><![CDATA[<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="一些常用的工具"><a href="#一些常用的工具" class="headerlink" title="一些常用的工具"></a>一些常用的工具</h4><ul><li>ConcurrentHashMap：线程安全的hashmap。</li><li>CopyOnWriteArrayList：线程安全的ArrayList，比较适合读多写少的场合，完胜vector。</li><li>ConcurrentLinkedQueue：线程安全的队列，它们两之间的差别在于数据结构不一样，一个是类似于数组，更适合直接查找，一个则是像链表一样，更适合添加和修改。</li><li>BlockingQueue：一个阻塞队列，也是一个接口，通常用于数据共享的通道。</li><li>ConcurrentSkipListMap：线程安全的跳表。</li></ul><table><thead><tr><th align="left">–</th><th align="left">ADD()操作</th><th align="left">DELETE()操作</th><th align="left">INSERT操作</th><th align="left">INDEX取值操作</th><th align="left">ITERATOR取值操作</th></tr></thead><tbody><tr><td align="left">ArrayList/Vector/Stack</td><td align="left">好</td><td align="left">差</td><td align="left">差</td><td align="left">极优</td><td align="left">极优</td></tr><tr><td align="left">LinkedList</td><td align="left">好</td><td align="left">好</td><td align="left">好</td><td align="left">差</td><td align="left">极优</td></tr></tbody></table><h4 id="初步实现线程安全"><a href="#初步实现线程安全" class="headerlink" title="初步实现线程安全"></a>初步实现线程安全</h4><p>想要保持HashMap的线程安全的话，出了手动使用synchronized包围之外，还能够调用一个类去实现它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map map= Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"><span class="comment">//将HashMap对象传入synchronized的map，正如字面意思所示</span></span><br><span class="line"><span class="comment">//看看里面的实现</span></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//list同理</span></span><br><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">            <span class="keyword">super</span>(list);</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> Objects.requireNonNull是判断有没有传入参数，mutex表示的是一个锁，表明要拥有这个锁的时候才能对map进行读取或写入，这样的话效率很低。</p><p>一个更好用的办法，就是用ConcurrentHashMap。</p><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue是在高并发环境下最好的队列了，队列经常被用于实际生活，比如消息队列，用餐的推送顺序，购票网站等，之前讲过的Java并发编程（六）的ArrayList线程不安全，我们用线程安全的代替试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentLinkedQueue list=<span class="keyword">new</span> ConcurrentLinkedQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.offer(i);</span><br><span class="line">            <span class="comment">//add也行，一样的</span></span><br><span class="line">            <span class="comment">//    public boolean add(E e) &#123;</span></span><br><span class="line">            <span class="comment">//        return offer(e);</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">200000</span></span><br></pre></td></tr></table></figure><p>我们看看ConcurrentLinkedQueue是如何实现的吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="comment">//无参数的构造方法，将类的头结点和子节点都设置为新的节点</span></span><br><span class="line"><span class="comment">//Node 是一个类，里面有两个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//E表示是泛型的容器，用传入的类型定义目标值，和用一个新的Node去定义next值，类似于链表一般，一个接着一个。</span></span><br><span class="line"><span class="comment">//而Node又有几个方法</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//casItem的意思是设置当前的值，使用cas操作(compareAndSwapObject)去保证其原子性</span></span><br></pre></td></tr></table></figure><p>队列里有head和tail两个值，分别代表的头结点和尾节点，头结点值永远不会为null，而我们正是使用头结点去遍历这个队列，每当有一个新的值入队的时候，都会从尾部入队，直接进入尾节点，从而只需移动尾节点便可以入队，极大的方便与插入和删除操作。而tail的更新情况并不一定是随时更新，而是可能会产生延迟，比如要进入了两个数值，尾节点才会移动到末尾。而我们入队的方法有两个，一个是add，一个是offer，但是实际上使用的都是offer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add也行，一样的</span></span><br><span class="line"><span class="comment">//    public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">//        return offer(e);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//检查是否为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">//然后便建立一个新的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<span class="comment">//p为头结点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;<span class="comment">//等于空表示是最后的节点</span></span><br><span class="line">            <span class="comment">//第一次加入元素时，p.next为空，于是便使用一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">//新节点与p的next交换(p为头节点)</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">//头结点不等于尾节点</span></span><br><span class="line">                    casTail(t, newNode);<span class="comment">//允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        <span class="comment">//取最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在if (q == null)这个判断中，如何q为空，可能队列为空，也可能加入新的节点，正常执行增加节点操作。但在队列为空时，p==t（即head=tail），因此不会执行castail()操作。</p><p>但在执行了第一个元素入队后，再执行第二个元素入队时，p的next不为空，于是就开始查找最后一个节点，执行 p = (p != t &amp;&amp; t != (t = tail)) ? t : q;     使得p取下一个节点或最后的节点，于是p就成了链表的第一个元素。这个时候再进行循环，p的null（即第一个元素的next）为空，而此时的p不等于尾节点，于是变更新尾节点，使得尾节点移动至链表最后。</p><p>而出现特殊情况 else if (p == q) 出现的时候，便使用新的tail作为链表的末尾。</p><p>特殊情况是怎么诞生的呢？比如两个线程去读取队列的一个值，一个读取完了之后，另一个执行了修改，那么第一个线程再次去读取的时候，就会发生两次数据不一致的问题。就会出现一个(t != (t = tail))的情况，这时候，如果尾节点没有被修改，则返回head，重新查找尾节点。</p><p>看看出队的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       restartFromHead:</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">               E item = p.item;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (p != h) </span><br><span class="line">                       updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   updateHead(h, p);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                   <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = q;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但在执行了第一个元素入队后，再执行第一个元素出队时，此刻的tail并没有更新，所以会直接执行最后一个操作，使得p=q；就是说把头结点的值变为第一个节点的值，然后再循环，执行到 item != null &amp;&amp; p.casItem(item, null) 此时的item元素不会为空，因为它现在是第一个节点，然后再将其cas交换，交换后，item值已经为空了，于是就不会等于h，然后执行   updateHead(h, ((q = p.next) != null) ? q : p); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再把head和tail变为同一个元素。</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList常被用作于商品类目的展示，黑名单等各种读多写少的场景。但是它只能保证数据的最终一致性，不能保证数据的实时一致性，也就是说，被修改的值不一定能够被马上读到。我们来看看它的源码把。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取的时候，返回一个get(getArray(), index)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) a[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这相当于每次都返回一个array[index]的内部数组，因为这个数组不会被修改，只能够被另一个array数组给替换，从而保证了原子性，所以就没有类似于synchronized和lock的加锁操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一开始便设置了一个重入锁，进行了加锁操作，然后没增加一个新元素，都会创建一个新的数组，然后使用setArray去改变这个数组的值，由于整体都加了锁，所以不会影响到原子性，其次array变量是一个volatile类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>所以被修改后，其他线程会被察觉到并将其修改，保证可见性和有序性。</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>之前在写线程池的时候，介绍过四个任务队列，它们都有一个共同的特点就是都具有阻塞功能，因为它们都来自于一个接口BlockingQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们就以ArrayBlockingQueue为例。虽然说ArrayBlockingQueue和concurrentlinkedqueue也有offer方法和poll方法，但是ArrayBlockingQueue由于继承的是BlockQueue，所以还有两个独有的方法，那就是put和take。</p><p>这有什么区别呢？可以猜的到这两个方法具有阻塞功能，就以offer方法和put方法来对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == items.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//直接返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                enqueue(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();<span class="comment">//阻塞</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        notFull.signal();<span class="comment">//唤醒notfull</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>它们之间最为明显的差别就是，offer在队列已经满的时候，直接返回一个false，而put方法则是使用了condition.await去阻塞这个线程继续运行，等待另一个dequeue方法，移除一个元素出队后，再去唤醒put方法，使其继续将未能加入线程的元素继续加入进去。</p><p>同理，take方法也是如此</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();<span class="comment">//直接返回</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();<span class="comment">//阻塞</span></span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用take想要获得队列首部信息的时候，如果没有值，便发生阻塞，直到有元素入队，使用notEmpty方法唤醒为止。</p><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>跳表(SkipList)，是除了哈希表(HashTable)以外，一个非常特别的表。哈希图是用哈希表去实现的，那么跳表也有对应的map结构，那就是跳图(ConcurrentSkipListMap)，这个ConcurrentSkipListMap非常的神奇，这是一个用空间去换时间的算法，它的数据结构如下：图片资源来自于：<a href="http://www.liuhaihua.cn/archives/40657.html" target="_blank" rel="noopener">http://www.liuhaihua.cn/archives/40657.html</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/skipmap1.jpg" alt="skipmap1"></p><p>顶层有着很少的数据和很大的区间，然后往下走，数据越密，区间越小。每个节点都有key值和value值，它的运行机制如下：当你要寻找一个key值的时候，从顶层开始找，如果需要找的key值小于当前节点，便继续前进一个节点，如果需要找的key值大于当前节点，便直接进入当前节点的下一层继续寻找，如果需要找的key值等于当前节点，便返回当前节点的value值。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/skipmap.jpg" alt="skipmap2"></p><p>如图所示，如果你要找的值为70，从顶层开始找，大于20往下，大于40再往下，小于40则往前，最后找到了目标值70。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; s=<span class="keyword">new</span> ConcurrentSkipListMap&lt;Integer,String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            s.put(i,<span class="string">"i am "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; e:s.entrySet()</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(e.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以发现它的输出是有序的，而HashMap的输出是无序的。</span></span><br></pre></td></tr></table></figure><p>我们看看它的源码构成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><p>每一个节点除了自己的key和value，还有下一个节点的next，类似于链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都使用CAS操作去保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br></pre></td></tr></table></figure><p>特别是这个index，定义了本身节点，右节点和下节点，这三个节点，这将其数据结构的实现联系到了一起，看看构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keySet = <span class="keyword">null</span>;</span><br><span class="line">        entrySet = <span class="keyword">null</span>;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        descendingMap = <span class="keyword">null</span>;</span><br><span class="line">        head = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(<span class="keyword">new</span> Node&lt;K,V&gt;(<span class="keyword">null</span>, BASE_HEADER, <span class="keyword">null</span>),</span><br><span class="line">                                  <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">        HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">            <span class="keyword">super</span>(node, down, right);</span><br><span class="line">            <span class="keyword">this</span>.level = level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个HeadIndex的三个参数分别是需要寻找的目标节点的移动，和当前节点的本身的值和右值和下值，最后一个参数表示了层数。这个构造函数是整个SkipMap的核心所在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十）线程池</title>
      <link href="/2019/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2019/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的基本使用"><a href="#线程池的基本使用" class="headerlink" title="线程池的基本使用"></a>线程池的基本使用</h4><h5 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h5><p>线程的每一次创建，最后的结果免不了都是销毁，那么在大型的系统的，就有着不断地创建和销毁，线程的创建和销毁开销是很大的，甚至在一些小的任务当中，创建和销毁的开销甚至超过了任务本身，那么，有方法可以去减少这种开销吗？设计者当然也想到了，于是乎有了线程池这个事物，使用线程池去创建线程，线程执行完任务后再回到线程池，等待下次任务的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t1=<span class="keyword">new</span> test();</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.submit(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">"线程ID："</span>+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">12</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">15</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">13</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">12</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">14</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">15</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">12</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">13</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">16</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">14</span></span><br></pre></td></tr></table></figure><p>可以看到，线程池只创建了5个线程，却要执行10个任务，使用线程池的方法可以使得线程被重复利用。从而减少线程的创建和销毁所占用的内存。</p><h5 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h5><p>线程池不仅仅只有一种创建方法，它还有其他的种类</p><ul><li>newFixedThreadPool(int nThreads)创建一个拥有固定数量的线程池</li><li>newSingleThreadExecutor()创建一个只有一个线程的线程池</li><li>newCachedThreadPool()创建一个拥有自动改变大小的线程池</li><li>newSingleThreadScheduledExecutor()创建一个有固定时间执行的单个线程池</li><li>newScheduledThreadPool(int corePoolSize)创建一个有固定时间执行的且指定数量的线程池</li></ul><h5 id="固定时间执行任务-：newScheduledThreadPool-int-corePoolSize"><a href="#固定时间执行任务-：newScheduledThreadPool-int-corePoolSize" class="headerlink" title="固定时间执行任务 ：newScheduledThreadPool(int corePoolSize)"></a>固定时间执行任务 ：newScheduledThreadPool(int corePoolSize)</h5><p>这个函数可以指定固定时间完成线程的执行，看看它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回的是一个ScheduledExecutorService 对象</span></span><br><span class="line"><span class="comment">//ScheduledExecutorService :</span></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure><p>它有三个方法，最主要的两个是scheduleAtFixedRate和scheduleWithFixedDelay，它们的区别在于传入的是period还是delay，实际运用的时候，AtFixedRate是等待initial+n*period的时间允许，而WithFixedDelay是在线程执行完后等待delay时间运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t=<span class="keyword">new</span> test();</span><br><span class="line">        ScheduledExecutorService es = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        es.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1577178569</span></span><br><span class="line"><span class="number">1577178571</span></span><br><span class="line"><span class="number">1577178573</span></span><br><span class="line"><span class="number">1577178575</span></span><br><span class="line"><span class="number">1577178577</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//每次丢失间隔两秒执行一次</span></span><br><span class="line"><span class="comment">//而我们把AtFixedRate换为WithFixedDelay呢？</span></span><br><span class="line"><span class="number">1577178975</span></span><br><span class="line"><span class="number">1577178978</span></span><br><span class="line"><span class="number">1577178981</span></span><br><span class="line"><span class="number">1577178984</span></span><br><span class="line"><span class="comment">//执行时间间隔变成了3秒</span></span><br></pre></td></tr></table></figure><p>但如果我们的周期时间要大于等待时间呢？比如说8秒，那我们的AtFixedRate就会执行完后继续执行而不是再继续等待，反之，WithFixedDelay是还要再等待2秒才会继续执行。</p><h4 id="线程池的内部实现"><a href="#线程池的内部实现" class="headerlink" title="线程池的内部实现"></a>线程池的内部实现</h4><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>倒回来去看看前三个线程池构造方法，可以点进去看他们的实现，发现他们的实现都是来源于一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们的不同也仅仅是传入的参数不同而已，并且都返回了一个叫做ThreadPoolExecutor的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize</li><li>maximumPoolSize</li><li>keepAliveTime超过指定线程数量的线程在被销毁前的存活时间</li><li>TimeUnit unit</li><li>BlockingQueue<Runnable> workQueue任务队列</li><li>Executors.defaultThreadFactory()</li><li>handler：拒绝策略</li></ul><p>这里有几个比较不好理解的词语：BlockingQueue和handler</p><h5 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h5><p>BlockingQueue是一个任务队列，它可以指定任务队列的样式，通常有那么几种：</p><ul><li>直接提交的队列：SynchronousQueue。它没有容量，它的每一个插入操作都要等待一个删除操作，这个队列锁提交的任务不会被真实的保存，而是将新任务交给线程执行，如果没有新的进程，便创建一个新的进程，它通常要设置很大的线程容量，否则很容易执行拒绝策略。</li><li>有界的任务队列：ArrayBlockingQueue。这个队列的特点就是，在等待队列已经满之时，又有新的任务加入，且指定线程数目还未超过最大线程数，就创建新的进程执行任务。</li><li>无界的任务队列：LinkedBlockQueue。这个队列在有新的任务加入队列时，但线程已经达到指定的容量，新的任务会进入队列一直等待，而不是创建新的进程。</li><li>优先任务队列：PriorityBlockQueue。顾名思义，带有优先级的队列，一般的队列都是依照着先进先出的规则执行，而这个队列的任务带有优先级标志，按照优先级去执行。</li></ul><p>前面提到过newCacheThreadPool，这个函数的指定线程为0，最大线程数为无穷大。一般情况下，这个线程池没有线程，但是当有新的任务分配到的时候，会加入SynchronousQueue，提交任务。执行完成后，空闲线程若无其他任务，就会在60秒内被回收。</p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><h5 id="jdk内置的拒绝策略"><a href="#jdk内置的拒绝策略" class="headerlink" title="jdk内置的拒绝策略"></a>jdk内置的拒绝策略</h5><ul><li>AbortPolicy策略：直接抛出异常</li><li>CallerRunsPolicy策略：直接在调用者线程中，运行被抛弃的任务</li><li>DiscardOledestPOlicy策略：丢弃最老的一个请求</li><li>DIscardPolicy策略：默默丢弃无法处理的任务</li></ul><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test t=<span class="keyword">new</span> test();</span><br><span class="line">        ExecutorService es= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">5</span>,<span class="number">0L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> RejectedExecutionHandler()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        System.out.println(r.toString()+<span class="string">"is discard"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;Integer.MAX_VALUE ; i++) &#123;</span><br><span class="line">            es.submit(t);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">" :Theard ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1577183355191</span> :Theard ID:<span class="number">12</span></span><br><span class="line"><span class="number">1577183355201</span> :Theard ID:<span class="number">13</span></span><br><span class="line"><span class="number">1577183355291</span> :Theard ID:<span class="number">12</span></span><br><span class="line"><span class="number">1577183355301</span> :Theard ID:<span class="number">13</span></span><br><span class="line"><span class="number">1577183355334</span> :Theard ID:<span class="number">14</span></span><br><span class="line"><span class="number">1577183355344</span> :Theard ID:<span class="number">15</span></span><br><span class="line"><span class="number">1577183355354</span> :Theard ID:<span class="number">16</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">135f</span>baa4is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">45</span>ee12a7is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">330</span>bedb4is discard</span><br><span class="line"><span class="number">1577183355391</span> :Theard ID:<span class="number">12</span></span><br><span class="line"><span class="number">1577183355401</span> :Theard ID:<span class="number">13</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">2503</span>dbd3is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">4</span>b67cf4dis discard</span><br><span class="line"><span class="number">1577183355434</span> :Theard ID:<span class="number">14</span></span><br><span class="line"><span class="number">1577183355444</span> :Theard ID:<span class="number">15</span></span><br><span class="line"><span class="number">1577183355454</span> :Theard ID:<span class="number">16</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">7</span>ea987acis discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">12</span>a3a380is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">29453f</span>44is discard</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如上所示，在创建了两个线程之后，发现所需线程不够，便达到了最大线程数，此刻在进行访问的时候，任务太多，处理不过来，便选择了抛弃任务，从而出现了拒绝策略，不去执行这个任务。</p><h5 id="自定义线程创建"><a href="#自定义线程创建" class="headerlink" title="自定义线程创建"></a>自定义线程创建</h5><p>线程池的目的是实现线程复用，但线程池并没有使用new语句去创建多个线程，它仅仅是进行了submit而已，那么这些线程是怎么来的呢？它们来自于ThreadFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//定制名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test t=<span class="keyword">new</span> test();</span><br><span class="line">        ExecutorService es=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        i++;<span class="comment">//</span></span><br><span class="line">                       Thread t=<span class="keyword">new</span> Thread(r,<span class="string">""</span>+i);<span class="comment">//定制名字</span></span><br><span class="line">                        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程</span></span><br><span class="line">                        System.out.println(<span class="string">"create"</span>+t);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            es.submit(t);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//es.shutdown();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createThread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><p>如上，在创建了线程池之后，重写线程池的ThreadFactory方法，修改了线程工厂的构造方法，这使得我们在submit这个t对象后，使用构造方法构造了许多线程，可以看到这个线程所输出的信息。由于将所有的线程都设置为了守护线程，这使得我们的主线程退出后，会自动销毁所有线程，而不需要再加一个es.shutdown();去手动的结束线程。</p><h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>我们在使用线程的时候，对于线程的创建和销毁状态是不可见的，只能在执行run方法的时候，才能够从中察觉，但能不能在创建或者销毁的时候去监控它呢?当然是可以的啦！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">mytask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">mytask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"正在执行"</span>+<span class="string">" 线程ID："</span>+Thread.currentThread().getId()+<span class="string">",task name="</span>+name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"准备执行"</span>+((mytask) r).name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行完成"</span>+((mytask) r).name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            mytask t=<span class="keyword">new</span> mytask(<span class="string">"task_geym_"</span>+i);</span><br><span class="line">            es.execute(t);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">准备执行task_geym_0</span><br><span class="line">正在执行 线程ID：<span class="number">12</span>,task name=task_geym_0</span><br><span class="line">准备执行task_geym_1</span><br><span class="line">正在执行 线程ID：<span class="number">13</span>,task name=task_geym_1</span><br><span class="line">准备执行task_geym_2</span><br><span class="line">正在执行 线程ID：<span class="number">14</span>,task name=task_geym_2</span><br><span class="line">准备执行task_geym_3</span><br><span class="line">正在执行 线程ID：<span class="number">15</span>,task name=task_geym_3</span><br><span class="line">准备执行task_geym_4</span><br><span class="line">正在执行 线程ID：<span class="number">16</span>,task name=task_geym_4</span><br><span class="line">执行完成task_geym_0</span><br><span class="line">执行完成task_geym_1</span><br><span class="line">执行完成task_geym_2</span><br><span class="line">执行完成task_geym_3</span><br><span class="line">执行完成task_geym_4</span><br><span class="line">线程池退出</span><br></pre></td></tr></table></figure><p>只要选择自行重写beforeExecute和afterExecute方法便可以实现啦。</p><h4 id="线程池中的堆栈"><a href="#线程池中的堆栈" class="headerlink" title="线程池中的堆栈"></a>线程池中的堆栈</h4><p>在上面的时候，我们发现线程池使用execute去执行程序而不是submit，这是有很多原因的，其中一点就是，execute可以打印出异常堆栈，这代表的，如果线程的创建出了一个无法被编译器识别的错误的，可以将其错误的地方打印出来，这使得我们的程序更为优秀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor es=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> test(<span class="number">100</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> re=a/b;</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"pool-1-thread-1"</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at test.run(test.java:<span class="number">24</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">25.0</span></span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="number">50.0</span></span><br></pre></td></tr></table></figure><p>比如这个，发生了除数为0，而导致线程的出错，但是如果你的方法是submit，则打印不出来异常堆栈。顺着提示的错误点，点进去，你就可以快速找到是哪里错了，但是这样仍然不能够找到提交的地点，那应该怎么做呢？</p><p>首先写一个新的类并继承ThreadPoolExecutor，并重写提交和执行这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 打印出异常堆栈的类 <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 打印出异常堆栈的类(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.execute(wrap(command,clientTrace(),Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task,clientTrace(),Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"客户端堆栈追踪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task,<span class="keyword">final</span> Exception clientStack,String clientThreadName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    clientStack.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而submit函数返回的是一个Runnable型的类，那么我们便可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个Runnable型函数去返回它，调用的时候还是使用task.run();继续调用，但区别在于传入了一个叫做Exception型的参数：clientStack.printStackTrace();使其找到提交的地点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor es=<span class="keyword">new</span> 打印出异常堆栈的类(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> test(<span class="number">100</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> re=a/b;</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.Exception: client stack trace</span><br><span class="line">at 打印出异常堆栈的类.clientTrace(打印出异常堆栈的类.java:<span class="number">21</span>)</span><br><span class="line">at 打印出异常堆栈的类.submit(打印出异常堆栈的类.java:<span class="number">18</span>)</span><br><span class="line">at test.main(test.java:<span class="number">17</span>)</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">25.0</span></span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="number">50.0</span></span><br></pre></td></tr></table></figure><p>瞬间定位提交地点。</p><h4 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h4><p>一般来说，线程都有各自的任务，但各个任务的难度都不相同，有的繁琐而艰巨，有的只是喝茶聊天，所以设计者为了平衡这样的状况，设计出了一个叫做Fork/Join的框架，它能够实现线程之间的互助，比如说t1线程早就执行完了自己的任务，他就会去帮助t2线程执行任务。而很多线程在执行任务的时候，都是由队列的顶部去抓取数据，而在Fork/Join框架线程互助的时候，t1会从t2的底部去抓取数据，从而避免了数据的竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Threshold =<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool fjp=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        test t=<span class="keyword">new</span> test(<span class="number">0</span>,<span class="number">200000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; result=fjp.submit(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> res=result.get();</span><br><span class="line">            System.out.println(<span class="string">"sum="</span>+res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> canCompute=(end-start)&lt;Threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;end ; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分成100个小任务</span></span><br><span class="line">            <span class="keyword">long</span> step=(start+end)/<span class="number">100</span>;</span><br><span class="line">            ArrayList&lt;test&gt; subtests=<span class="keyword">new</span> ArrayList&lt;test&gt;();</span><br><span class="line">            <span class="keyword">long</span> pos=start;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastone=pos+step;</span><br><span class="line">                <span class="keyword">if</span>(lastone&gt;end)&#123;</span><br><span class="line">                    lastone=end;</span><br><span class="line">                &#125;</span><br><span class="line">                test subtest=<span class="keyword">new</span> test(pos,lastone);</span><br><span class="line">                pos+=step+<span class="number">1</span>;</span><br><span class="line">                subtests.add(subtest);</span><br><span class="line">                subtest.fork();</span><br><span class="line">            &#125;<span class="comment">//分而治之</span></span><br><span class="line">            <span class="keyword">for</span> (test t:</span><br><span class="line">                 subtests) &#123;</span><br><span class="line">                sum+=t.join();</span><br><span class="line">            &#125;<span class="comment">//最后累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum=<span class="number">19989995149</span></span><br></pre></td></tr></table></figure><p>这是一道计算1到200000求和的计算题，利用了算法当中的分治法，但这个分治法是使用多线程是完成的。首先设置了阈值为10000，若大于这个阈值，则进行将其往下分解100个小任务，每个任务将每一段都构造新的test()进行加入队列，其次在使用fork方法执行每个test类的compute方法，分解的值都加入subtests队列。最后每个subtest使用join方法导出值，并且加入sum。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（九）同步控制</title>
      <link href="/2019/12/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2019/12/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程的团队协作"><a href="#多线程的团队协作" class="headerlink" title="多线程的团队协作"></a>多线程的团队协作</h3><h4 id="重入锁（ReentrantLock）"><a href="#重入锁（ReentrantLock）" class="headerlink" title="重入锁（ReentrantLock）"></a>重入锁（ReentrantLock）</h4><h5 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h5><p>重入锁和synchronized非常的相似，我们知道synchronized的锁区域是用大括号所包围起来的，而ReentrantLock则是可以自己决定加锁的位置和解锁的位置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L.lock();</span><br><span class="line">L.unloock();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock L=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10000</span> ; j++) &#123;</span><br><span class="line">            L.lock();</span><br><span class="line">            L.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                L.unlock();</span><br><span class="line">                L.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure><p>与synchronized比较大的区别还在于，ReentrantLock是可以重入的，如上述代码所示，使用了两个L.lock()，但是仍然能够运行，这表示着这是同一个线程在获得锁，每次获得锁就会在计数器上+1，在解锁的时候在计数器上-1，这样最后的计数器为零的时候完全释放锁。这种方法可以看做为，只要是同一个线程获取的锁，就可以被一直重入。</p><p>而lock（）的实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个叫做CAS操作，意思为比较和交换，这种操作方式能够获得原子性，以致于起到synchronized的作用。</p><h5 id="ReentrantLock的中断"><a href="#ReentrantLock的中断" class="headerlink" title="ReentrantLock的中断"></a>ReentrantLock的中断</h5><p>重入锁还有另一个非常人性化的一点，那就是会自然的中断，比如在遇到产生的死锁问题的时候ReentrantLock就会自然中断，防止死锁的发生，这是synchronized所不具有的。</p><p>还记得之前讲过的interrupt吗，它仅仅是起到一个标记作用而已，为什么不用flag去代替它呢？效果不是一样吗？其实，interrupt标记还能够作用于其他的类用于线程的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(<span class="number">1</span>));</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock==<span class="number">1</span>)&#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread())</span><br><span class="line">            &#123;lock1.unlock();&#125;</span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">            &#123;lock2.unlock();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"退出"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at test.run(test.java:<span class="number">38</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">12</span> 退出</span><br><span class="line"><span class="number">13</span> 退出</span><br></pre></td></tr></table></figure><p>一开始，设置了两个线程，线程t1先获得锁，t2阻塞，当在等待两秒后，设置了可以中断的标记，于是t2便不再尝试去获得锁，直接断开，从而开始输出错误信息。</p><h5 id="限时等待锁"><a href="#限时等待锁" class="headerlink" title="限时等待锁"></a>限时等待锁</h5><p>使用中断标记去打断锁的话，虽然可以解决死锁，但也可能会出现数据不一致的问题，于是乎可以使用等待时间这一方式去等待锁，如果时间到了还没有获得锁，便直接放弃它。使用的api叫做trylock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它有的构造方法有两个参数，一个是数值，一个是计时单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"get lock faild"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get lock faild</span><br></pre></td></tr></table></figure><p>一开始t1便运行run方法获得了锁，并等待6秒，然后t2进入了if判断语句中，开始等待5秒，等待时间过后，仍然没有获得锁，便返回一个false值，打印出get lock faild，最后lock再解锁。当然，你也会想，万一传入的参数是0怎么办呢，其实，你传入的参数是0的话，就和没有传参数的构造函数一样的，可以猜想的到，没有参数，那就不会等待，一旦感觉到阻塞，就立即退出。</p><h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><p>线程在相互竞争资源的顺序可以被自由决定吗？默认是不能的，其实设计者也能想的到，要由自己去控制资源的顺序，已达到安全的、稳定的目的，但是这样做会使的线程运行变得更慢，因为要给快速运行的线程加一个队列的话，开销是很大的，所以大多数的时候，是随意的、非公平的，但这并不代表不可以由自己自由的去决定。</p><p>我们先看一个ReentrantLock的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个单构造函数传入的是布尔值，这个布尔值是选择这个重入锁是公平的还是非公平的，默认是非公平的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(),<span class="string">"joker"</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(),<span class="string">"alex"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 获得锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">joker 获得锁</span><br><span class="line">alex 获得锁</span><br><span class="line">joker 获得锁</span><br><span class="line">alex 获得锁</span><br><span class="line">joker 获得锁</span><br><span class="line">alex 获得锁</span><br></pre></td></tr></table></figure><p>这就是重入锁设置公平和非公平的办法啦，看一来是不是有点眼熟呢，没错，我们之前的双线程累加到20000的例子，也可以用这个来实现。看看底层的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里在判断条件中，公平锁多了一个hasQueuedPredecessors()方法，既加入了同步队列中当前节点是否有前驱节点的判断，如果返回true，则表明有线程比当前线程更早的请求锁，因此需要等待前驱线程获取并释放锁之后才能继续获得锁。</p><p>总结：ReentrantLock的几个重要方法：</p><ul><li>lock();</li><li>lockinterruptibly();</li><li>trylock();</li><li>unlock();</li><li>new ReentrantLock(true);</li></ul><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><p>这里稍微讲一下底层的实现，我们可以从重入锁的类接口看到它是接入了一个Lock的接口，并重写它的方法，但值得注意的是，它们实际上使用的，是来自一个叫做AQS的同步器(AbstractQueuedSynchronizer)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><p>获得锁的调用的是tryAcquire方法，而这个方法来自于AQS队列同步器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用getState();去判断获取当前状态，如果为0，说明没有线程获得了该锁，代表可以进行CAS操作去获取锁</p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>总结了几点Synchronized和ReentrantLock的区别：</p><ol><li><p>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</p></li><li><p>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；</p></li><li><p>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</p></li><li><p>Synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；</p></li><li><p>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</p></li><li><p>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</p></li><li><p>Synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁，而ReentrantLock对于已经在等待的线程一定是先来的线程先获得锁；</p></li></ol><h4 id="Condition条件"><a href="#Condition条件" class="headerlink" title="Condition条件"></a>Condition条件</h4><p>与synchronized对应的是lock和unlock，那么与Tread类的wait和notify方法，ReentrantLock也有相应的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition condition=lock.newCondition();<span class="comment">//设置condition</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//继续加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        condition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"开始等待"</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"继续运行"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开始等待</span><br><span class="line">继续运行</span><br></pre></td></tr></table></figure><p>使用condition.await()和condition.signal()方法，分别让线程阻塞和唤醒。</p><h4 id="线程的交通信号灯：Semaphore"><a href="#线程的交通信号灯：Semaphore" class="headerlink" title="线程的交通信号灯：Semaphore"></a>线程的交通信号灯：Semaphore</h4><p>线程的公平锁和非公平锁是线程之间排队运行用的，但除此之外，我们还有别的控制线程的方法，就比如说，某个函数只是偶尔被调用，但需要调用的时候，却会变得非常频繁，这时候我们就要控制好线程的队列了，不能一口气涌入成千上万条线程，最终导致负载过大，停止运行。</p><p>于是便需要一个信号灯，也叫作信号量 ：Semaphore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newFixedThreadPool(<span class="number">20</span>);<span class="comment">//线程池，后面会提</span></span><br><span class="line">        <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            exec.submit(demo);<span class="comment">//运行run方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            semaphore.acquire();<span class="comment">//此处进入线程为5的时候，阻塞后面的线程，直到使用release为止</span></span><br><span class="line">            <span class="comment">//模拟耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"to doing"</span>);</span><br><span class="line">            semaphore.release();<span class="comment">//通知acquire继续放行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用acquire和release方法，控制着线程的运行数量。</p><ul><li>semaphore.acquire();//此处进入线程为5的时候，阻塞后面的线程，直到使用release为止</li><li>semaphore.release();;//通知acquire继续放行</li></ul><h4 id="倒计时器：CountDownLatch"><a href="#倒计时器：CountDownLatch" class="headerlink" title="倒计时器：CountDownLatch"></a>倒计时器：CountDownLatch</h4><p>如果说Semaphore如同交通信号灯一般，获取一定数量，每执行一次release释放一个线程，再允许进入一个线程，这样的流水线，那么CountDownLatch就是每次等到达一定数量，一口气放行。</p><p>CountDownLatch就像一个火箭的发射台，要等到全部准备就绪的时候，才能够发射，缺一个都不行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有就绪</span></span><br><span class="line">        end.await();<span class="comment">//主线程等待end的count值达到0之后继续执行下一步</span></span><br><span class="line">        <span class="comment">//开始</span></span><br><span class="line">        System.out.println(<span class="string">"开始"</span>);</span><br><span class="line">        executorService.shutdown();<span class="comment">//执行结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">"检查完成"</span>);</span><br><span class="line">            end.countDown();<span class="comment">//执行这个方法表示线程已经准备就绪了，count计数器-1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">开始</span><br></pre></td></tr></table></figure><p>里面涉及了几个方法，</p><ul><li>end.countDown();计数器</li><li>end.await();等待完成计数量</li><li>new CountDownLatch(10);传入一个参数表示数值</li></ul><h4 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h4><p>CyclicBarrier和CountDownLatch非常相似，最大的区别就是CyclicBarrier可以重复被利用，而CountDownLatch不行。</p><p>CyclicBarrier正如它的名字一样，循环栅栏，栅栏是一个阻挡别人进入的障碍物，CyclicBarrier和CountDownLatch一样有一个计数器，不过CountDownLatch的计数器被定义了之后就只能被一直减少，最后减少到0时，完全结束，而CyclicBarrier的计数器则是从0开始增加，直到指定数值时开始放行，然后计数器归零，并等待下一波线程的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier end=<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">100</span>);</span><br><span class="line">            end.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"集合完成"</span>);</span><br><span class="line">            end.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"执行完成"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法更为简单，且可以被复用，运行之后可以看到一开始是集结了5个线程之后，才会继续运行下去，这表示了CyclicBarrier的阻塞作用它后面的线程，CyclicBarrier主要的方法就是await()；方法，值得注意的是，CyclicBarrier有了更多的异常处理：BrokenBarrierException e 这个异常处理表示如果发生了意外使得线程破损，无法继续运行，那就让那个线程中断，防止阻塞后面的线程，而之所以CountDownLatch不这样做，是因为，它的特性就是必须全部都集合了之后才能运行，所以没有这个异常处理。</p><h4 id="线程的阻塞工具：LockSupport"><a href="#线程的阻塞工具：LockSupport" class="headerlink" title="线程的阻塞工具：LockSupport"></a>线程的阻塞工具：LockSupport</h4><p>之前说过线程的挂起(suspend)和继续执行(resume)，这个在之后有了一个比较灵活的类去代替，它就是LockSupport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class test implements Runnable &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t&#x3D;new Thread(new test());</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+&quot;执行run方法中,已经被阻塞&quot;);</span><br><span class="line">        LockSupport.park();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unpark传入参数表示要解锁的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unpark方法也会和resume方法一样先于park（suspend）方法执行，但是与其不同的是，unpark就算先执行了，也不会产生死循环，因为unpark会产生一个特别的许可，这个许可，不可叠加且只有一个，只会被park所获取，所以就算unpark先于park发生，只要产生了这个许可，park就能够获取这个许可并且停止阻塞继续运行</p><h4 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h4><p>我们在对一个对象进行操作的时候，无论是读取还是写入，为了保持原子性，都用以synchronized包围，但是，在很多实际应用中，读取操作都是要远大于写入操作的，但是却全都用synchronized去上锁，这无疑降低了某些方面的效率，于是乎，设计者根据这种情况，设计了一个叫做读写锁的类，将读取操作与写入操作分离，使两个线程在读取同一个对象的时候，不阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock read=reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line">        Runnable readrunnable=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.handleRead(read);</span><br><span class="line">                    <span class="comment">//demo.handleRead(lock);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">18</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(readrunnable).start();<span class="comment">//开启线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个方法开启的时候，在休眠一秒后加了锁，按道理来说，18个线程至少要等18秒才能运行完成，但是对于锁类型是读写锁的线程而言，可以被多个线程重复进入，重入锁和读写锁的区别在于，重入锁是对于本线程的行为可以被重复进入而不加锁，读写锁则是对于多个不进行修改操作的线程，都可以进入而不加锁。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>int getReadLockCount()</td><td>获取读锁的数量，此时读锁的数量不一定等于获取锁的数量，因为锁可以重入，可能有线程重入了读锁</td></tr><tr><td>int getReadHoldCount()</td><td>获取当前线程重入读锁的次数</td></tr><tr><td>int getWriteHoldCount()</td><td>获取当前线程重入写锁的次数</td></tr><tr><td>int isWriteLocked()</td><td>判断锁的状态是否是写锁，返回true，表示锁的状态是写锁</td></tr></tbody></table><h5 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h5><p>读写锁和重入锁在设计上都继承了AQS队列同步器，相关描述来自掘金作者天堂同志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><ul><li>在AQS中，通过int类型的全局变量state来表示同步状态，即用state来表示锁。ReentrantReadWriteLock也是通过AQS来实现锁的，但是ReentrantReadWriteLock有两把锁：读锁和写锁，它们保护的都是同一个资源，那么如何用一个共享变量来区分锁是写锁还是读锁呢？答案就是按位拆分。</li><li>由于state是int类型的变量，在内存中占用4个字节，也就是32位。将其拆分为两部分：高16位和低16位，其中高16位用来表示读锁状态，低16位用来表示写锁状态。当设置读锁成功时，就将高16位加1，释放读锁时，将高16位减1；当设置写锁成功时，就将低16位加1，释放写锁时，将第16位减1。如下图所示：</li></ul><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs4.jpg" alt="aqs4"></p><ul><li>那么如何根据state的值来判断当前锁的状态时写锁还是读锁呢？</li><li>假设锁当前的状态值为S，将S和16进制数0x0000FFFF进行与运算，即S&amp;0x0000FFFF，运算时会将高16位全置为0，将运算结果记为c，那么c表示的就是写锁的数量。如果c等于0就表示还没有线程获取锁；如果c不等于0，就表示有线程获取到了锁，c等于几就代表写锁重入了几次。</li><li>将S无符号右移16位（S&gt;&gt;&gt;16），得到的结果就是读锁的数量。当S&gt;&gt;&gt;16得到的结果不等于0，且c也不等于0时，就表示当前线程既持有了写锁，也持有了读锁。</li><li>当成功获取到读锁时，如何对读锁进行加1呢？S +（1&lt;&lt;16）得到的结果，就是将对锁加1。释放读锁是，就进行S - (1&lt;&lt;16)运算。</li><li>当成功获取到写锁时，令S+1即表示写锁状态+1；释放写锁时，就进行S-1运算。</li><li>由于读锁和写锁的状态值都只占用16位，所以读锁的最大数量为 <img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">)-1，写锁可被重入的最大次数为<img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">-1。</li></ul><h5 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h5><p>写锁是一个排它锁，只能被一个线程所获取，这个锁的主要方法，也来自于AQS同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// exclusiveCount()方法的作用是将同步变量与0xFFFF做&amp;运算，计算结果就是写锁的数量。</span></span><br><span class="line">    <span class="comment">// 因此w的值的含义就是写锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// 如果c不为0就表示锁被占用了，但是占用的是写锁还是读书呢？这个时候就需要根据w的值来判断了。</span></span><br><span class="line">    <span class="comment">// 如果c等于0就表示此时锁还没有被任何线程占用，那就让线程直接去尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 如果w为0，说明写锁的数量为0，而此时又因为c不等于0，说明锁被占用，但是不是写锁，那么此时锁的状态一定是读锁，</span></span><br><span class="line"><span class="comment">         * 既然是读锁状态，那么写锁此时来获取锁时，就肯定失败，因此当w等于0时，tryAcquire()方法返回false。</span></span><br><span class="line"><span class="comment">         * 2. 如果w不为0，说明此时锁的状态时写锁，接着进行current != getExclusiveOwnerThread()判断，判断持有锁的线程是否是当前线程</span></span><br><span class="line"><span class="comment">         * 如果不是当前线程，那么tryAcquire()返回false；如果是当前线程，那么就进行后面的逻辑。为什么是当前线程持有锁，就还能执行后面的逻辑呢？</span></span><br><span class="line"><span class="comment">         * 因为读写锁是支持重入的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面一行代码是判断，写锁的重入次数或不会超过最大限制，这个最大限制是：2的16次方减1</span></span><br><span class="line">        <span class="comment">// 为什么是2的16次方减1呢？因为state的低16位存放的是写锁，因此写锁数量的最大值是2的16次方减1</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. writerShouldBlock()方法的作用是判断当前线程是否应该阻塞，对于公平的写锁和非公平写锁的具体实现不一样。</span></span><br><span class="line"><span class="comment">     * 对于非公平写锁而言，直接返回false，因为非公平锁获取锁之前不需要去判断是否排队</span></span><br><span class="line"><span class="comment">     * 对于公平锁写锁而言，它会判断同步队列中是否有人在排队，有人排队，就返回true，表示当前线程需要阻塞。无人排队就返回false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 当writerShouldBlock()返回true时，表示当前线程还不能直接获取锁，因此tryAcquire()方法直接返回false。</span></span><br><span class="line"><span class="comment">     * 当writerShouldBlock()返回false时，表示当前线程可以尝试去获取锁，因此会执行if判断中后面的逻辑，即通过CAS方法尝试去修改同步变量的值，</span></span><br><span class="line"><span class="comment">     * 如果修改同步变量成功，则表示当前线程获取到了锁，最终tryAcquire()方法会返回true。如果修改失败，那么tryAcquire()会返回false，表示获取锁失败。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与排他锁的释放逻辑也几乎一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是当前线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 将state的值减去releases</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 调用exclusiveCount()方法，计算写锁的数量。如果写锁的数量为0，表示写锁被完全释放，此时将AQS的exclusiveOwnerThread属性置为null</span></span><br><span class="line">    <span class="comment">// 并返回free标识，表示写锁是否被完全释放</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">     * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">     * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">     * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// for死循环，直到满足相应的条件才会return退出，否则一直循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 锁的状态为写锁时，持有锁的线程不等于当期那线程，就说明当前线程获取锁失败，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 尝试设置同步变量的值，只要设置成功了，就表示当前线程获取到了锁，然后就设置锁的获取次数等相关信息</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 将修改同步变量的值（读锁状态减去1&lt;&lt;16）</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>读写锁会发生锁降级的事件，这里的锁降级指的是线程获取到了写锁，在没有释放写锁的情况下，又获取读锁。为什么不支持锁升级呢？举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">// 创建读锁</span></span><br><span class="line">    Lock readLock = lock.readLock();</span><br><span class="line">    <span class="comment">// 创建写锁</span></span><br><span class="line">    Lock writeLock = lock.writeLock();</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...处理业务逻辑</span></span><br><span class="line">        writeLock.lock();   <span class="comment">// 代码①</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，假如T1线程先获取到了读锁，然后执行后面的代码，在执行到代码①的上一行时，T2线程也去获取读锁，由于读锁是共享锁，且此时写锁还没有被获取，所以此时T2线程可以获取到读锁，当T1执行到代码①时，尝试去获取写锁，由于有T2线程占用了读锁，所以T1线程是无法获取到写锁的，只能等待，当T2也执行到代码①时，由于T1占有了读锁，导致T2无法获取到写锁，这样两个线程就一直等待，即获取不到写锁，也释放不掉读锁。因此锁是不支持锁升级的。</p><p>读写锁支持锁的降级，锁的降级是为了保证可见性。让T1线程对数据的修改对其他线程可见。读锁不支持条件等待队列。当调用ReadLock类的newCondition()方法时，会直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为读锁是共享锁，最大获取次数为<img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">-1，同一时刻可以被多个线程持有，对于读锁而言，其他线程没有必要等待获取读锁，Condition的等待唤醒毫无意义。</p><p>那么锁降级中，先获取到读锁有没有必要呢？答案是肯定的。如果当前线程不获取读锁而是直接释放写锁，假设此刻存在另一个线程获取了写锁并修改了数据，那么当前线程就无法感知到另一个线程的更新。如果当前线程获取到了读锁，遵循锁降级的步骤，则另一个线程就会被阻塞，直到当前的线程使用数据并释放读锁之后，另一个线程才能获取写锁进行数据更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（八）synchronized原理</title>
      <link href="/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><h2 id="synchronized的概念"><a href="#synchronized的概念" class="headerlink" title="synchronized的概念"></a>synchronized的概念</h2><h3 id="synchronized的简介"><a href="#synchronized的简介" class="headerlink" title="synchronized的简介"></a>synchronized的简介</h3><p>synchronized是一个在Java中比较常见的锁。可以选择在代码中加入synchronized代码块，也可以在方法头加入synchronized的声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译为字节码后，可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public void syncBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter   &#x2F;&#x2F; monitorenter指令进入同步块</span><br><span class="line">         4: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         7: ldc           #3                  &#x2F;&#x2F; String hello block</span><br><span class="line">         9: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit  &#x2F;&#x2F; monitorexit指令退出同步块</span><br><span class="line">        14: goto          22</span><br><span class="line">        17: astore_2</span><br><span class="line">        18: aload_1</span><br><span class="line">        19: monitorexit  &#x2F;&#x2F; monitorexit指令退出同步块</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: athrow</span><br><span class="line">        22: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             4    14    17   any</span><br><span class="line">            17    20    17   any</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public synchronized void syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED      &#x2F;&#x2F;添加了ACC_SYNCHRONIZED标记</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #5                  &#x2F;&#x2F; String hello method</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         8: return</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javac在编译的时候，在第3行生成了monitorenter指令，表示这同步块的进入，在13行使用monitorexit表示同步块的退出。之所以会有两个monitorexit是因为：在保证抛出异常的情况下，也能够释放锁，就相当于Java里面的try-final语句块。</p><p>而对于synchronized的方法而言，javac为它生成了一个<strong>ACC_SYNCHRONIZED</strong>关键字，在JVM进行方法调用的时候，会发现这个关键字，并先尝试去获得锁。</p><h3 id="锁的几种形式"><a href="#锁的几种形式" class="headerlink" title="锁的几种形式"></a>锁的几种形式</h3><p>在JDK5以及之前，synchronized是重量级锁，每次运行需要同步的代码块的时候，总是锁住所有需要进入的线程，来保持原子性。所以synchronized在这之前都不如其他的同步函数，但在JKD6开始，java引入了新的机制：<strong>锁升级</strong>。当然，JVM种的锁也是能降级的，只不过条件很苛刻。</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>首先就要提到对象头。因为在Java中，任何的对象都可以被加锁，所以必然需要一个映射关系，存储该对象以及其对应的锁信息，这样才能知道当前哪个线程持有锁，哪些线程需要等待。有一种很直观的方法是，使用一个全局的Map，来存储这个映射关系，但这又会涉及到一些问题，比如这个Map怎么保持线程安全，不同的synchronized之间又会出现互相的影响，性能比较差，如果需要同步的对象比较多的话，该Map所占用的内存也会增多。</p><p>所以，不如将这些映射关系存储在目标的对象头好了。因为对象头本身也有一些关于hashcode、GC相关的数据，不妨就将这些锁的信息一并封装起来。</p><p>在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。</p><p>类型指针是指向该对象所属类对象的指针，mark word 用于存储对象的hashcode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32字节，64位系统上长度为64字节。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize1.jpg" alt="s"></p><p>这就是整个mark word所存储的信息了。可以看到，锁的信息也存在于对象的mark word当中。<strong>当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</strong></p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量锁就是传统意义上的锁，在JDK5以及之前，使用的都是这样的锁。重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。</p><p>一个monitor对象包括这么几个关键字段：ContentionList，EntryList ，WaitSet，owner。</p><p>其中ContentionList ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize2.jpg" alt="s2"></p><p>每当有一个线程尝试去获得锁的时候，如果该锁已经被占用，重量锁就会讲该线程封装成一个ObjectWaiter对象插入到ContentionList队列的尾部，然后暂停当前线程。然后在锁的持有者释放锁之前，会将ContentionList中的所有元素移动到EntryList中去，并唤醒在EntryList的队首线程。</p><p>如果一个线程在同步块中调用了Object.wait()方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中等待，然后释放锁。当wait的线程被Object.notify()之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。继续等待持有锁的线程释放锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>JVM的设计者认为，在很多情况下，在运行java程序时，很多同步块的代码可能都不存在所谓的竞争关系，同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p><p>在线程执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其中包括一个用于存储对象头中的mark word 以及一个指向对象的指针。下图中右边的就是Lock Record：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize3.jpg" alt="s3"></p><h5 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h5><p>1.在线程栈中创建一个Lock Record，将其Object reference字段指向锁对象。</p><p>2.<strong>如果成功使用CAS将对象头重的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋(循环等待)来获取锁。</strong></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分(Displaced Mark Word)为null，起到了一个重入计数器的作用。然后结束。</p><p>4.走到这一步说明发生了竞争，需要膨胀为重量级锁。</p><h5 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h5><p>1.遍历线程栈,找到所有Object reference字段等于当前锁对象的Lock Record。</p><p>2.如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将Object reference设置为null后继续。</p><p>3.如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的 Mark Word 恢复成为Displaced Mark Word。如果成功则继续，负责膨胀为重量级锁。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Java是支持多线程的语言，因此在很多二方包、基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如synchronized这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo1 syncDemo1 = <span class="keyword">new</span> SyncDemo1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">"test:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了synchronized的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的’一个‘、’多个‘数量词只是针对该demo，并不适用于所有场景）。</p><p>在JDK1.6中为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的CAS命令。我们来看看偏向锁是如何做的。</p><h5 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h5><p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的mark word将是可偏向状态，此时mark word中的thread_id（参见上文偏向状态下的mark word格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p><h5 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h5><p>1.当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程ID。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</p><p>2.当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</p><p>3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</p><p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p><h5 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h5><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。</p><p>下图展示了锁状态的转换流程：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize4.jpg" alt="s4"></p><p>另外，偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令 -XX:BiasedLockingStartupDelay=0在虚拟机中来关闭延迟。</p><h5 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h5><p>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p><p>1.一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p><p>2.存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p><p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p><p>其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</p><p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（七）Java内存模型</title>
      <link href="/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h3><p>我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。</p><p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。</p><p>java内存模型（不仅仅是JVM内存分区）：调用栈和本地变量存放在线程栈上，对象存放在堆上。</p><p><img src="https://pic2.zhimg.com/80/v2-bd607bd9a5598a8330ad329033e04b91_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-a1a75c9f7264cf78d0927663371ca9d2_hd.jpg" alt=""></p><ul><li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li><li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</li></ul><h4 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a><strong>硬件内存架构</strong></h4><p>现代硬件内存模型与Java内存模型有一些不同，理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。</p><p>现代计算机硬件架构的简单图示：</p><p><img src="https://pic1.zhimg.com/80/v2-67833188e191c5e7a11d34e613ca352c_hd.jpg" alt=""></p><ul><li><strong>多CPU</strong>：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li><li><strong>CPU寄存器</strong>：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li><li><strong>高速缓存cache</strong>：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li><li><strong>内存</strong>：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li><li><strong>运作原理</strong>：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</li></ul><p><strong>一些问题：（多线程环境下尤其）</strong></p><ul><li><strong>缓存一致性问题</strong>：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-1a021d2833b7a537dcdfdf0025f52a6c_hd.jpg" alt=""></p><p><strong>指令重排序问题</strong>：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化</p><h4 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a><strong>Java内存模型和硬件内存架构之间的桥接</strong></h4><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-1a7b7bb752799b6c067a0eaca0a1a9b2_hd.jpg" alt=""></p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：</p><ul><li><p>线程之间的共享变量存储在主内存（Main Memory）中</p></li><li><p>每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。</p></li><li><p>从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</p></li><li><p>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。</p></li></ul><p><img src="https://pic3.zhimg.com/80/v2-af520d543f0f4f205f822ec3b151ad46_hd.jpg" alt=""></p><h4 id="JMM模型下的线程间通信"><a href="#JMM模型下的线程间通信" class="headerlink" title="JMM模型下的线程间通信"></a>JMM模型下的线程间通信</h4><p>线程间通信必须要经过主内存。</p><p>如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：</p><p>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p><p>2）线程B到主内存中去读取线程A之前已更新过的共享变量。</p><p><img src="https://pic2.zhimg.com/80/v2-8750cb14ecaa93509e3f1981563513e1_hd.jpg" alt=""></p><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h4 id="Java内存模型解决的问题"><a href="#Java内存模型解决的问题" class="headerlink" title="Java内存模型解决的问题"></a>Java内存模型解决的问题</h4><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。Java内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争race condition）。</p><h5 id="1、多线程读同步与可见性"><a href="#1、多线程读同步与可见性" class="headerlink" title="1、多线程读同步与可见性"></a>1、多线程读同步与可见性</h5><p><strong>可见性（共享对象可见性）</strong>：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改</p><p><strong>线程缓存导致的可见性问题：</strong></p><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中，然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</p><p>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。</p><p><img src="https://pic2.zhimg.com/80/v2-7abd7500588012315f4f0e068e20e341_hd.jpg" alt=""></p><p>解决这个内存可见性问题你可以使用：</p><ul><li>Java中的volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</li><li>Java中的synchronized关键字：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。</li><li>Java中的final关键字：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）</li></ul><p><strong>重排序导致的可见性问题：</strong></p><p>Java程序中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：</p><ul><li>volatile关键字本身就包含了禁止指令重排序的语义</li><li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul><p><strong>指令序列的重排序：</strong></p><p>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p><img src="https://pic1.zhimg.com/80/v2-a92ef160e8ba8d33541fb57b8a32de9c_hd.jpg" alt=""></p><p>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序：</p><p><img src="https://pic4.zhimg.com/80/v2-f8a75081bcad888a7e73b4785a672e5b_hd.jpg" alt=""></p><p><strong>数据依赖：</strong></p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑）</p><p><img src="https://pic4.zhimg.com/80/v2-36500a7455955c58d02138913d5c0cd7_hd.jpg" alt=""></p><p><strong>指令重排序对内存可见性的影响：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-8ef063a1b514d9cfbdf059984f83ed2f_hd.jpg" alt=""></p><p>当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。这样的结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p><p><strong>指令重排序改变多线程程序的执行结果例子：</strong></p><p><img src="https://pic3.zhimg.com/80/v2-111bfd93bcd92fd2ee495a12cb34f9aa_hd.jpg" alt=""></p><p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？</p><p>答案是：不一定能看到。</p><p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p><p><strong>as-if-serial语义：</strong></p><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。（编译器、runtime和处理器都必须遵守as-if-serial语义）</p><p><strong>happens before：</strong></p><p>从JDK 5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性：在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ul><p>一个happens-before规则对应于一个或多个编译器和处理器重排序规则</p><p><strong>内存屏障禁止特定类型的处理器重排序：</strong></p><p>重排序可能会导致多线程程序出现内存可见性问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p><img src="https://pic2.zhimg.com/80/v2-6db326ce298332a673151117edcb1fcd_hd.jpg" alt=""></p><p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p><h5 id="2、多线程写同步与原子性"><a href="#2、多线程写同步与原子性" class="headerlink" title="2、多线程写同步与原子性"></a>2、多线程写同步与原子性</h5><p><strong>多线程竞争（Race Conditions）问题</strong>：当读，写和检查共享变量时出现race conditions。</p><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p><p>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增加了两次，每个CPU缓存中一次。如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次：</p><p><img src="https://pic2.zhimg.com/80/v2-02ae4be429d4b48a18442efe91131155_hd.jpg" alt=""></p><p>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p><p><strong>使用原子性保证多线程写同步问题：</strong></p><p><strong>原子性：</strong>指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。</p><p><strong>实现原子性：</strong></p><ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，我们大致可以认为基本数据类型变量、引用类型变量、声明为volatile的任何类型变量的访问读写是具备原子性的（long和double的非原子性协定：对于64位的数据，如long和double，Java内存模型规范允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，即如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。但由于目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此在编写代码时一般也不需要将用到的long和double变量专门声明为volatile）。这些类型变量的读、写天然具有原子性，但类似于 “基本变量++” / “volatile++” 这种复合操作并没有原子性。</li><li>如果应用场景需要一个更大范围的原子性保证，需要使用同步块技术。Java内存模型提供了lock和unlock操作来满足这种需求。虚拟机提供了字节码指令monitorenter和monitorexist来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步快——synchronized关键字。</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>通常在进行并发编程的时候，我们总会遇到一些数据不一致的问题，接下，就这一问题开始讨论和解决。如一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"="</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次</span></span><br><span class="line">=<span class="number">13118</span></span><br><span class="line">=<span class="number">13921</span></span><br><span class="line"><span class="comment">//第二次</span></span><br><span class="line">=<span class="number">10937</span></span><br><span class="line">=<span class="number">10937</span></span><br></pre></td></tr></table></figure><p>我们发现无论怎么运行都差不多是这两种情况，要么两个数字都不一样，要么两个数字一样但都不是20000，这是什么情况呢？我想，第一种是因为两个线程在不断的使用i的过程中，某一个线程先完成了计算，还有一个线程仍在继续着循环，导致两次数字不一样，且第一次数字都小于第二次，第二种情况是两个线程交替执行，导致最后虽然同时完成，但是仍然损失了很多数字。</p><p>那么好，我们试着将两个变量都设置为volatile关键字试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">=<span class="number">13144</span></span><br><span class="line">=<span class="number">13144</span></span><br></pre></td></tr></table></figure><p>发现它们仅仅是变得一样而已，并没有出现其20000的数字。</p><p>最后在设置为synchronize试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//此时volatile可加可不加</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//此时volatile可加可不加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> test instance=<span class="keyword">new</span> test();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"="</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">=<span class="number">10000</span></span><br><span class="line">=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>看，设置成了synchronize之后就没有了数据的损失，完全就变成了一个接着一个运行的机制，这样就输出了正确的数值。但是，我想要两个都为20000，这样怎么改造呢?想到线程之间协同关系，当然是要用之前讲过的wait()方法和notify()方法啦，这里先不说，大家想一想把。</p><p>接下来，可能会有人觉得奇怪，为什么声明了volatile还是会出现损失呢？，volatile的原理是什么呢？这里先简单讲一下，为什么这个例子没有保证它的原子性。那是因为，Volatile并不能保证count++的原子性，count++在执行的时候，实际上是完成了：读取—修改—写入。这三个操作，在多个线程进行读取和修改的时候，可能会遇到这种状况：</p><ol><li>线程A读取到count=1；</li><li>线程B读取到count=1；</li><li>线程A复制一个副本修改i的值为2；</li><li>线程B复制一个副本修改i的值为2；</li><li>线程A写回i；</li><li>线程B发现i的值已经为2，放弃写入；</li></ol><p>其实当我们进行到步骤2的时候，Volatile就已经无法保证i的原子性了，可以看到，如果线程A和线程B几乎同时读取到i的值为1，而不是线程A先于线程B读取修改并写入count的话，那么就已经无法保证i的原子性了，因为Volatile关键字并没有对count进行加锁，虽然声明了Volatile，会让count只会被一个单位所修改，但是在读取这个操作中，其实是不加以限制的。</p><p>volatile具有可见性和有序性，并不具备原子性，volatile只能确保一个线程修改了数据之后，另一个线程能够看到这个改动，当两个线程同时修改一个数据时，仍然会产生冲突。</p><h4 id="Volatile不能保证原子性"><a href="#Volatile不能保证原子性" class="headerlink" title="Volatile不能保证原子性"></a>Volatile不能保证原子性</h4><p>我们的所有的代码，实际运行的空间其实是在Java虚拟机当中，而Java虚拟机中的Java堆，使用的就是计算的内存。CPU在读取一个值的时候，初次是需要从主内存中读取，读取到缓存中来，之后只要每次读取都会从缓存当中读取值，直到缓存时间过期或者是缓存地址被修改，才会重新去主存中读取值。</p><p>volatile声明了一个对象后，将那个对象转为汇编代码，可以发现那个对象的已经加了lock前缀去处理。它会在主存和CPU之间中使用缓存一致性协议，此刻的主存会在CPU的每一个缓存中使用嗅探器去嗅探自己的缓存是否过期了，当发现自己的缓存被修改了，就会使在缓存的对象无效化，让在缓存中的对象重新去主存读取新的值。</p><p>下面就以一张图去表述吧：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/volatileyuanli.png" alt="volatile"></p><p>而在修改了被声明为volatile的对象后，该缓存就会通过嗅探器得知，然后去通知其他的缓存，lock#信号就会锁住其他的缓存，不让它被读取，然后将该CPU的缓存中所修改的值，写回主存中去，其他缓存需要从主存中获取到新值后才能解锁。</p><p>讲到这里，为什么还是不能保证原子性呢？我们再次拿出上面讲的例子来：</p><p>当 i=1 的时候A,B两个线程同时读入了 i 的值， 然后A线程执行了 temp = i + 1的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了 temp = i + 1的操作，注意，此时A，B两个线程保存的 i 的值都是1，temp 的值都是2， 然后A线程执行了 i = temp （2）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是2，同时B线程保存的 temp 还仍然是2， 然后B线程执行 i=temp （2），然后B线程就以为自己已经成功读取到了新的值，这样下来，就损失了一个1。</p><h4 id="锁缓存还是锁总线"><a href="#锁缓存还是锁总线" class="headerlink" title="锁缓存还是锁总线"></a>锁缓存还是锁总线</h4><p>前面讲到，volatile会锁住全部缓存，使得它们必须更新新的值。除此之外，volatile还可以选择锁住总线，让该cpu暂时独占整个内存，完成所需操作。但是一般都不会去使用锁总线的方式，因为锁总线的开销实在是太大了，但有时候却不得不去锁总线，一是当前操作的数据跨越了多个缓存行，只能使用总线锁，二是设备不支持(现在很少)。默认情况下，Lock前缀都是通过锁缓存来保证一致性的。</p><h4 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h4><p>volatile 变量的内存可见性是基于内存屏障（Memory Barrier）实现。</p><p>内存屏障，又称内存栅栏，是一个 CPU 指令。<br>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>缓存是分段（line）的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。</p><ul><li>为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。</li><li>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探（snooping）” 协议。</li><li>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。</li><li>缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个 CPU 缓存可以读写内存）。</li><li>CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。</li><li>当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。</li><li>只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</li></ul><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 会针对编译器制定 volatile 重排序规则表。</p><p><img src="https://upload-images.jianshu.io/upload_images/5714666-390c861ed043ef94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p><p>“ NO “ 表示禁止重排序。</p><ul><li>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</li><li>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul></li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/5714666-42b7250449160dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5714666-cce9ccf139acf1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/801/format/webp" alt=""></p><h3 id="happens-before-关系"><a href="#happens-before-关系" class="headerlink" title="happens-before 关系"></a>happens-before 关系</h3><p>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before，从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。</p><p><strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</strong></p><p>happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面我们就一个简单的例子稍微了解下happens-before ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设线程A执行writer方法，线程B执行reader方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;              <span class="comment">// 1 线程A修改共享变量</span></span><br><span class="line">        flag = <span class="keyword">true</span>;        <span class="comment">// 2 线程A写volatile变量</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3 线程B读同一个volatile变量</span></span><br><span class="line">        <span class="keyword">int</span> i = a;          <span class="comment">// 4 线程B读共享变量</span></span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5714666-04e61c5e5c4e91c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/587/format/webp" alt=""></p><p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p><p>happens-before原则定义如下：</p><p><strong>1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong><br><strong>2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</strong></p><p>下面是happens-before原则规则：</p><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ol><p>我们来详细看看上面每条规则：</p><p><strong>程序次序规则</strong>：一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。</p><p><strong>锁定规则</strong>：这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p><p><strong>volatile变量规则</strong>：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</p><p><strong>传递规则</strong>：提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</p><p><strong>线程启动规则</strong>：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p><p><strong>线程终结规则</strong>：假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p><p>上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则：</p><ol><li>将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作</li><li>将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作</li><li>在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作</li><li>释放Semaphore许可的操作Happens-Before获得许可操作</li><li>Future表示的任务的所有操作Happens-Before Future#get()操作</li><li>向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作</li></ol><p>这里再说一遍happens-before的概念：<strong>如果两个操作不存在上述（前面8条 + 后面6条）任一一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序。如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（六）隐蔽的错误</title>
      <link href="/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="隐蔽的错误"><a href="#隐蔽的错误" class="headerlink" title="隐蔽的错误"></a>隐蔽的错误</h3><p>在编程当中遇到错误，可能会让你头疼，但能提示出是哪里出现了某某错误，也许只是一两分钟就能解决的问题，最可怕的是，程序出错了，却没有任何提示，得自己慢慢的去找，在几十万行代码的工程当中，可能分分钟就猝死了。所以，写任何代码时，都要想一想各种会出现的问题，最简单的不可见错误如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1=<span class="number">1073741827</span>;</span><br><span class="line"><span class="keyword">int</span> v2=<span class="number">1431655768</span>;</span><br><span class="line"><span class="keyword">int</span> a=v1+v2;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><p>程序不会提示出你的代码错误，甚至可以说，从逻辑上而言完全没有错误，但隐藏的错误就是，值溢出了，这会使最后的结果出现了错误。</p><p>并且，在并行开发中，这样的隐藏错误还会有更多更多。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList在java中是一个经常被使用的容器。它的就相当于一个可以存放任何类型的、自动扩容的数组。我们看看下面这段代码，看它为什么线程不安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; a=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">10</span></span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:<span class="number">463</span>)</span><br><span class="line">at test.run(test.java:<span class="number">19</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">100009</span></span><br></pre></td></tr></table></figure><p>第一种情况，就是如上所述，数组越界的错误，我们看看为什么会数组越界，首先这个越界发生在add这个方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此时，t1线程和t2线程同时对ArrayList进行扩容：<br>t1发现list为10，不够存放，需要扩容到11，调用ensureCapacityInterna进行判断</li><li>t2发现list为10，不够存放，需要扩容到11，也调用ensureCapacityInterna进行判断</li><li>t1发现扩容后大小为11，可以容纳，不再扩容，返回</li><li>t2也发现扩容后大小为11，可以容纳，直接返回（这里的t2的判断容量的过程恰好在t1刚扩容完后）</li><li>t1开始进行设置值操作， elementData[size++] = e 操作。此时size变为11</li><li>t2也开始进行设置值操作，它尝试设置elementData[11] = e，而elementData没有进行过扩容，它的下标最大为10。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException</li></ol><p>于是乎，错误就这么诞生了，所以ArrayList线程不安全，可以使用vector代替，而vector之所以线程安全，那是因为它在扩容过程中使用了synchronize进行加锁，ArrayList代表效率，vector代表安全，看各种情况去使用它们。</p><p>第二种情况，它运气极好，没有发生冲突，恰好为200000。</p><p>第三种情况，183274，这种情况是一种非常隐蔽的错误，它既没有显式的表达出错误，也没有计算正确，这是因为两个线程同时对i进行赋值，导致的错误，这种错误不是属于逻辑上的错误，所以不会直接的表达，而是直接的被略过。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="HashMap的原理"><a href="#HashMap的原理" class="headerlink" title="HashMap的原理"></a>HashMap的原理</h5><p>HashMap是一个非常之重要的容器，几乎每一个互联网公司的面试都会问及HashMap的实现和原理，hashmap首先是一个可扩容的数组，然后每个数组底下可以存放多个内容，被存放的内容就像链表一样，一个接着一个，在一个数组存放的链表大于8个的时候，链表就会转化为红黑树的数据结构,这里先简要概述HashMap的原理</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap.png" alt="hashmap"></p><p>hashmap的设计可以说非常的及精妙，它结合了数组和链表的特点，数组是寻址容易，修改和插入困难，而链表反之，hashmap不仅仅寻址容易，插入和删除也容易。所以，hashmap可以看成是一个带有链表的数组，它的使用方法和图一样，一个key值，一个value值。</p><p>我们先看看hashmap的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//看看DEFAULT_LOAD_FACTOR</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>这里写出了，hashmap的构造和扩容的机制，在构造的时候设置了负载因子0.75，以用来在hashmap的元素在达到其四分之三的时候，便会自发的发生扩容，为什么必须是0.75的时候呢，在这里，设计者给出了一个解释 nodes in bins follows a Poisson distribution。什么是poisson分布呢，用通俗的语言来说，世界上的概率都是可以通过计算得来的，比如硬币的概率是二分之一，但是若要涉及的各种各样的因素，比如风力，重力，地球的自转，或许就会与实际相差那么一点点，于是可以把概率分成有大数据支持的概率（正态分布），没大数据支持的概率（二项式分布），现实生活中的概率（poisson分布）。使用poisson分布在hashmap中，是为了减少hash冲突（又称碰撞）。</p><p>什么是哈希冲突？哈希冲突是指哈希码被放入到hashmap的时候发生的重叠，也可以看作为：两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t.put(<span class="number">17</span>,<span class="string">"you"</span>);</span><br><span class="line"><span class="comment">//将key和value加入map，下面看看put的内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//put加入的值，除了本身之外，还有一个hash的函数，这个就是hash码了，我们看看是怎么将key值转为hash码的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以看到如果key值不为空，就将key值赋给一个int型变量h，h再与h右移16位(二进制位移)进行异或操作，该方法主要是将Object转换成一个整型。</span></span><br><span class="line"><span class="comment">//通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过h &amp; (table.length -1)来得到该对象在数据中保存的位置。</span></span><br><span class="line"><span class="comment">//&gt;&gt;&gt;    :     无符号右移，忽略符号位，空位都以0补齐</span></span><br></pre></td></tr></table></figure><p>再回来看看put函数返回的putval函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果存储元素的table为空，则进行必要字段的初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;    <span class="comment">// 获取长度（16）</span></span><br><span class="line">        <span class="comment">// 如果根据hash值获取的结点为空，则新建一个结点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)      <span class="comment">// 此处 &amp; 代替了 % （除法散列法进行散列）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果新插入的结点和table中p结点的hash值，key值相同的话</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果是红黑树结点的话，进行红黑树插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 代表这个单链表只有一个头部结点，则直接新建一个结点即可</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 链表长度大于8时，将链表转红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 及时更新p</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果存在这个映射就覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 判断是否允许覆盖，并且value是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);     <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;     <span class="comment">// 更改操作次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)     <span class="comment">// 大于临界值</span></span><br><span class="line">            <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">            <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">            resize();  </span><br><span class="line">        <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结为是通过hash(key)%len的方式，将hashcode其存放在hashmap当中，于是put里的key值17就变成了hashcode：1</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashcode.png" alt="hashcode"></p><p>而且，hashmap虽然在构造的时候,可以传入任意参数但其实，无论传入什么参数，最后都会变成2的次幂。</p><p>长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于hashcode后几位的值。只要输入的hashcode本身分布均匀，Hash算法的结果就是均匀的。所以，hashmap中的&amp;位必须为奇数（Length - 1）</p><p>因为2的次幂可以很好的去减少hash碰撞,并且呢，虽然我们说hashcode其实是对容量取余获得的，但是由于取余这个方法在计算中并不是那么有效率，所以实际上还是通过位运算的方式去取得余，不过我们可以概念性的看作为取余，方便运算，并且位运算还有一个好处就是，可以解决负数的问题。</p><p>为什么可以使用位运算(&amp;)来实现取模运算(%)呢？这实现的原理如下：</p><ul><li>X % 2^n = X &amp; (2^n – 1)</li><li>2^n表示2的n次方，也就是说，一个数对2^n取模 == 一个数和(2^n – 1)做按位与运算 。</li><li>假设n为3，则2^3 = 8，表示成2进制就是1000。2^3 -1 = 7 ，即0111。</li><li>此时X &amp; (2^3 – 1) 就相当于取X的2进制的最后三位数。</li><li>从2进制角度来看，X / 8相当于 X &gt;&gt; 3，即把X右移3位，此时得到了X / 8的商，而被移掉的部分(后三位)，则是X % 8，也就是余数。</li></ul><p>而通常解决hash碰撞有这几种方法：</p><ul><li>开放定址法：<ul><li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li></ul></li><li>链地址法<ul><li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li></ul></li><li>再哈希法<ul><li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li></ul></li><li>建立公共溢出区<ul><li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul></li></ul><h5 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全"></a>为什么HashMap线程不安全</h5><p>我们先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">addthread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">addthread</span><span class="params">(<span class="keyword">int</span> object)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start=object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;<span class="number">100000</span> ; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                map.put(Integer.toString(i),Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> addthread(<span class="number">0</span>));</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> addthread(<span class="number">1</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和ArrayList非常类似，也会出现三种情况</p><p>第一种情况就是运行结果为100000，也就是运气极佳，完美运行，但这种情况很少</p><p>第二种情况就是有结果，但结果少于100000，这是因为访问时出现了数据的不一致</p><p>但更多的是第三种情况，出现了程序一直在运行，无限循环的情况，为什么会出现这种情况呢，想必大家第一时间能想的到是因为put方法，对，没错，不同ArrayList的数组越界错误，hashmap出现了死循环</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmapdead.jpg" alt="死循环"></p><p>hashmap扩容的时候，会出现链表互为对方的next的情况，从而导致一个死循环</p><p>不过jdk1.8之后，已经不存在这个问题了（jdk1.7及以下仍然存在），即使这样，hashmap在多线程中也要谨慎使用，最好的方法是使用concurrenthashmap去代替hashmap</p><h4 id="错误的加锁"><a href="#错误的加锁" class="headerlink" title="错误的加锁"></a>错误的加锁</h4><p>这里要提到一个新的观点，被synchronize包围的对象，就一定能保持原子性吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> test instance=<span class="keyword">new</span> test();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">100000</span> ; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，这是一个比较简单的事例，一个计数器，最后算出结果，我们从表面上看，这个列子完全没有问题，所用的对象i也完全被包围，那么我们看一下结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">153039</span></span><br></pre></td></tr></table></figure><p>这并不等于200000。很可能是在读写的过程中发生了数据不一致的错误。这是为什么呢？我们来看看Integer的实现。</p><p>我们发现了Integer的增长过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，valueof实际上是一个工厂方法，它会返回一个指定数值的Integer实例，因此这里的i++本质上是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=Integer.valueOf(i.intValue()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>因为在多个线程之间，i在不断地变动，所以我们锁住的Integer都是过去的Integer，想要修正这个问题，也很简单，只要把synchronize那一部分变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (instance)&#123;</span><br><span class="line">                i++; &#125;</span><br></pre></td></tr></table></figure><p>这样锁住的部分就变成了该线程本身。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（五）线程的管理</title>
      <link href="/2019/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2019/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的管理"><a href="#线程的管理" class="headerlink" title="线程的管理"></a>线程的管理</h3><p>当我们在一个系统中使用了非常之多的线程的时候，就非常不方便去管理，于是乎，设计者便设计了一个名为线程组的类，去好好的管理线程。线程组类的名字叫做ThreadGroup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup tg=<span class="keyword">new</span> ThreadGroup(<span class="string">"printGroup"</span>);</span><br><span class="line"><span class="comment">//创建线程组</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(tg,<span class="string">"T1"</span>);</span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(tg,<span class="string">"T2"</span>);</span><br><span class="line"><span class="comment">//线程加入线程组</span></span><br></pre></td></tr></table></figure><p>我们看看这个thread的构造函数和别的有什么不同吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> </span>&#123;</span><br><span class="line">        init(group, target, name, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里第一个要传入的参数叫ThreadGroup类，第三个叫名字，表示这个线程属于什么什么线程组，什么什么名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tg.activeCount()</span><br><span class="line"><span class="comment">//可以获得活动中的总线程数，但是活动中的线程数只是一个估计值，无法精确</span></span><br><span class="line">tg.list();</span><br><span class="line"><span class="comment">//而list方法则可以打印出所有的线程信息</span></span><br></pre></td></tr></table></figure><p>最后运行一段程序看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadGroup tg=<span class="keyword">new</span> ThreadGroup(<span class="string">"printGroup"</span>);</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(tg,<span class="keyword">new</span> test(),<span class="string">"T1"</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(tg,<span class="keyword">new</span> test(),<span class="string">"T2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(tg.activeCount());</span><br><span class="line">        tg.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String group=Thread.currentThread().getThreadGroup().getName()+<span class="string">"-"</span>+Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"i am "</span>+group);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">i am printGroup-T1</span><br><span class="line">i am printGroup-T2</span><br><span class="line">java.lang.ThreadGroup[name=printGroup,maxpri=<span class="number">10</span>]</span><br><span class="line">    Thread[T1,<span class="number">5</span>,printGroup]</span><br><span class="line">    Thread[T2,<span class="number">5</span>,printGroup]</span><br></pre></td></tr></table></figure><h3 id="线程的后台"><a href="#线程的后台" class="headerlink" title="线程的后台"></a>线程的后台</h3><p>这里的后台不是指靠山的意思，就是单纯的后台，每个活动都会有后台，很多次要的事物，都是在幕后运行的。比如一家饭馆，等客人就是主场，服务员就是后台，等主场人走光了，后台也就不必继续服务了，这里说线程的后台，就是指的这个意思。有些主线程在不断的消耗资源进行运算，而后台线程则负责资源垃圾的回收，等主线程结束以后，后台线程便会自然结束。</p><p>设置后台线程的方法很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread t1= <span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//注意不能够颠倒次序，必须先setdaemon，才能start</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test2());</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//一直在运行</span></span><br><span class="line">                System.out.println(<span class="string">"i am alive"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);<span class="comment">//等待5秒结束</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br></pre></td></tr></table></figure><p>如上述代码块所示，线程便会在运行后，开始寻找主线程，等待主线程，如果发现没有主线程，或主线程已经结束，只有后台线程才存活，便会结束线程。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>从上面可以看到，线程与线程之间存在着主次关系，那么主线程与主线程之间也有高低之分吗？答案是有的。为了更好的完成线程之间的调度问题，必然有方法也可以控制着线程的优先级，最常用的方式就是主动的去设置线程的优先级setPriority（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个方法中传入一个数字，代表着线程的优先级，优先级更高的线程便拥有着更高的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">high</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"high is win"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">low</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span> (count&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"low is win"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread(<span class="keyword">new</span> high());</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(<span class="keyword">new</span> low());</span><br><span class="line">        t1.setPriority(<span class="number">10</span>);<span class="comment">//设置优先级</span></span><br><span class="line">        t2.setPriority(<span class="number">1</span>);<span class="comment">//设置优先级</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">high is win</span><br><span class="line">low is win</span><br></pre></td></tr></table></figure><p>但我们常说事无绝对，哪怕是再冰冷的机器也是如此，设置优先级并不代表一定会优先获得，只不过是获得的概率比较大而已，再多试试几次，也会有低优先级的线程先执行完的时候。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（四）线程的基本使用2</title>
      <link href="/2019/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2019/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Thread类的基本使用（二）"><a href="#Thread类的基本使用（二）" class="headerlink" title="Thread类的基本使用（二）"></a>Thread类的基本使用（二）</h3><h4 id="线程的join（等待线程结束）和yield（谦让线程）"><a href="#线程的join（等待线程结束）和yield（谦让线程）" class="headerlink" title="线程的join（等待线程结束）和yield（谦让线程）"></a>线程的join（等待线程结束）和yield（谦让线程）</h4><p>线程的join方法的意思是，如果有对象在该线程中执行，但是又有别的线程要调用这个对象，join方法会让别的线程阻塞，直到该线程执行完毕为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();<span class="comment">//如果没有，打印出来的就会为0</span></span><br><span class="line">        System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;  i&lt;<span class="number">10000</span> ; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=10000</span></span><br></pre></td></tr></table></figure><p>这里可以看到的是，t线程一直在执行run方法，如果此时没有join方法的话，就直接执行了之后的print方法，这样打印出来的数值就是0因为join方法阻塞了主线程调用print方法去打印i。</p><p>再看看join的内部构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内部表示可以向join传入一个参数，表示等待的时间，看看我们传入了100ms之后，会出现什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;  i&lt;<span class="number">1000000000</span> ; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=155033164</span></span><br></pre></td></tr></table></figure><p>看，线程t在100ms后便不再阻塞主线程，任由其打印了。</p><p>那么再看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">              wait(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>这个while循环会一直判断，是否一直存活，若存活则一直继续，若不为存活，则直接跳出循环并使用wait(delay)方法，它会传入参数，在调用notifyAll()方法，唤醒全部线程。</p><p>线程谦让：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>线程谦让表示该线程愿意让出CPU资源，给其他线程去调用，但这并不表示该线程就不执行了，它仅仅是表明了，“我愿意让出这个资源，大家再度公平竞争”，这通常会在某些运算中运用到，比如有一个线程调用了大量的cpu资源去给线程a运算一个一千万循环的for语句，和一百循环的for语句，这样相比cpu会给极大的资源给线程a运算第一个for，但当其运算完成后，第二个for想必不用调用这么多cpu资源去运算，那么便可以使用线程谦让，使得它们再次平衡下来。</p><h4 id="线程的suspend（线程挂起）和resume（继续执行）"><a href="#线程的suspend（线程挂起）和resume（继续执行）" class="headerlink" title="线程的suspend（线程挂起）和resume（继续执行）"></a>线程的suspend（线程挂起）和resume（继续执行）</h4><p>线程的suspend方法和resume方法早已被废弃，不过这里还是简单讲一下：</p><p>线程挂起的意思就是将当前的线程阻塞，不让其继续使用，等待线程收到resume命令之后才会继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> t.start();</span><br><span class="line">        t.suspend();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        i=<span class="number">1</span>;</span><br><span class="line">        t.resume();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ok!!!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>但是这样方法在某些情况的使用是致命的，因为被挂起的线程是不会释放任何资源的，如果线程此时被上了锁，那将会有非常多的线程去等待一个线程释放资源，从而导致长时间的阻塞，而且，在另一个线程去调用resume的同时，你也不能确定resume方法一定会在suspend之后执行，因为在并行计算中，这一切不一定完全有序，这样会导致死锁的产生，所以这两个方法被废弃了。</p><p>那有什么可以代替的呢？</p><h4 id="线程的wait（等待）和notify（通知）"><a href="#线程的wait（等待）和notify（通知）" class="headerlink" title="线程的wait（等待）和notify（通知）"></a>线程的wait（等待）和notify（通知）</h4><p>这里可以引入到两个新的方法wait和notify，wait方法和suspend方法一样，会让线程阻塞，然后等待通知了才会继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，wait方法的使用是被锁包围的，首先wait在执行之前会被锁给锁住，不让其它线程获取本线程(线程a)的对象资源，而使用了wait后，他会自动且暂时的释放当前的锁，然后阻塞该线程，等待需要访问该对象的线程b获得对象锁，再使用notify方法后，执行完成线程b的synchronize代码块后，再唤醒线程a，继续执行线程a。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"test1 wait"</span>);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"test1 end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">"test2 end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> test1();</span><br><span class="line">        Thread t2=<span class="keyword">new</span> test2();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line">test1 wait</span><br><span class="line">test2</span><br><span class="line">test2 end</span><br><span class="line">test1 end</span><br></pre></td></tr></table></figure><p>区别的核心在于:<br>1、suspend()在引起当前所在线程阻塞后，不会释放线程占用的锁（如果占用了的话）<br>2、wait() 引起当前所在线程阻塞后，会释放占用的锁，并且必须 wait对象的锁必须被当前线程持有<br>3、wait与notify 需要  synchronized 锁来包裹</p><p>4、suspend会产生死锁问题，而wait不会</p><h4 id="线程的stop（终止）和interrupted（中断）"><a href="#线程的stop（终止）和interrupted（中断）" class="headerlink" title="线程的stop（终止）和interrupted（中断）"></a>线程的stop（终止）和interrupted（中断）</h4><p>线程可以在执行过程中被强行结束吗？当然可以，但是，强行被结束是会出现很多问题的，最初使用的方法叫stop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkAccess();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123; security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            resume();</span><br><span class="line">        &#125;</span><br><span class="line">        stop0(<span class="keyword">new</span> ThreadDeath());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>想必大家也很容易的猜得到，stop方法被弃用的原因是会破坏对象原子性，即使在被synchronize包围时也是如此，因为stop方法是先去释放锁，再去停止整个线程的，这样在释放锁的过程中，可能会出现一释放锁，该锁立马被别的线程锁获取，并发生了修改对象操作后，便停止了线程，这种数据错误不容易在众多代码出找出来，可以说是非常致命，那么对应的又有什么方式去代替它呢，当然有，那就是interrupt()方法，线程中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个interrupt要如何使用呢，直接像stop一样使用吗？ 并不对，这样其实并不会停止线程。interrupt仅仅是产生了一个中断标记，表示该线程即将要中断了，至于什么时候中断，则是由设计者决定的了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread.interrupt() //中断线程<br>Thread.isInterrupted()判断是否被中断<br>Thread.interrupted()判断是否被中断,并清除当前中断状态</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（三）线程的基本使用</title>
      <link href="/2019/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Thread类的基本使用（一）"><a href="#Thread类的基本使用（一）" class="headerlink" title="Thread类的基本使用（一）"></a>Thread类的基本使用（一）</h3><h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><p>线程的启动很简单，要知道所谓线程，其实也是属于Java的一个类而已，你可以通过继承这个类去使用它，也能够直接去使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//这样线程就已经启动啦</span></span><br></pre></td></tr></table></figure><p>不过这样的线程并没有任何实体，你可以尝试去启动这个线程，不过这个，这个线程并没有什么实体，已启动就结束了。因为这个线程并没有重写run方法，当然也可以在测试类继承thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure><p>然后再重写run方法，发现……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"xxx"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出 xxx。这样就成功了？？这又是什么个逻辑呢</p><p>为什么呢，我们点开thread类的源码，看看start方法是怎么回事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">        * and the group's unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>好吧，这里有点长，我画一下重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> start0();</span><br><span class="line"><span class="comment">//这个启动了一个新的线程</span></span><br></pre></td></tr></table></figure><p>再看一下start0是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们发现，这个方法居然没有实体？？不，不对，你仔细看看，它是一个native函数，这是什么，继续深挖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* openjdk\jdk\src\share\native\java\lang\Thread.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jvm.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"java_lang_Thread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THD <span class="meta-string">"Ljava/lang/Thread;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ <span class="meta-string">"Ljava/lang/Object;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE <span class="meta-string">"Ljava/lang/StackTraceElement;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR <span class="meta-string">"Ljava/lang/String;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STR</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这居然是一个c++函数，我们可以看到我们几乎在thread类中的所有操作都有所涉及。</p><p>主要是这个 JVM_StartThread 方法，这又是什么呢，我们尝试着打开jvm.cpp文件，搜索一下JVM_StartThread ，发现它被一个叫做JVM_ENTRY给调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We must release the Threads_lock before we can post a jvmti event</span></span><br><span class="line">  <span class="comment">// in Thread::start.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      jlong <span class="built_in">size</span> =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">      <span class="keyword">size_t</span> sz = <span class="built_in">size</span> &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) <span class="built_in">size</span> : <span class="number">0</span>;</span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Note: the current thread is not being used within "prepare".</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>其中有一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br></pre></td></tr></table></figure><p>有native_thread，那这个JavaThread将一个thread_entry这个指针放入了构造函数中，看一看这个thread_entry</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">    <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">    JavaCalls::call_virtual(&amp;result,obj,</span><br><span class="line">    KlassHandle(THREAD,SystemDictionary::Thread_klass()),</span><br><span class="line">    vmSymbolHandles::run_method_name(),    </span><br><span class="line">    vmSymbolHandles::void_method_signature(),THREAD);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个vmSymbolHandles::run_method_name(),调用了run的方法，可是，光看方法名还是不能确定是不是run</p><p>所以我们在看看这个vmSymbolHandles,正好发现里面有这样一条语句，</p><figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>(run_method_name,<span class="string">"run"</span>)</span><br></pre></td></tr></table></figure><p>成功的调用了run方法，所以，难怪在thread类中始终找不到相应的方法调用，原来是藏在了jvm的实现，cpp里面。</p><p>原来这就是它们之间的联系，从start到start0，再到native，再到jvm，再到cpp，其中的一个宏对象调用了run方法，那么我们再看看，这个run方法又写了啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>)</span><br><span class="line">    &#123;        target.run();    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里有一个target，通过它来判断，而这个target又在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure><p>哦，原来target在thread这个类中又是runnable所定义了，那runnable又是什么？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，俄罗斯套娃也终于结束了，所谓的runnable是一个接口，接口又声明必须要重写run这个方法。</p><p>也就是说，要么我们再开头创建的时候</p><p>要直接继承thread去声明，</p><p>要么直接在测试类中去接口一个runnable，这样才能够启动线程。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxxx"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（二）线程的基本认知</title>
      <link href="/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的各个术语"><a href="#线程的各个术语" class="headerlink" title="线程的各个术语"></a>线程的各个术语</h3><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><p>进程可以比喻为一个app，淘宝，美团，微信都是一个进程，<strong>线程是属于进程的</strong>。就好似微信里面的群发就是多个线程在工作。也可以比喻为，进程是一户人家，家里有多个人（线程），每个人都有各自的职业，在大多数时候一起分工合作（提高效率），少数时候发生冲突，比如一起抢一个厕所（线程阻塞）。</p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>在线程这个类中，有一个枚举类，枚举了线程的各个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NEW表示尚未启动的线程的线程状态</p><p>RUNNABLE表示它是一个正在运行的线程</p><p>BLOCKED表示线程被阻塞，无法获得想要获得的资源，可能是资源正在被锁定，或等待被解锁</p><p>WAITING由于调用其中一个线程，线程处于等待状态</p><p>TIMED_WAITING具有指定等待时间的等待线程的线程状态</p><p>TERMINATED终止线程的线程状态</p><p>我们可以通过接取一个Runnable接口来使用并行的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">        t.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NEW</span></span><br><span class="line"><span class="comment">//RUNNABLE</span></span><br><span class="line"><span class="comment">//xxxx</span></span><br><span class="line"><span class="comment">//TERMINATED</span></span><br></pre></td></tr></table></figure><p>使用thread.getstate()获得此线程此刻的状态</p><h4 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h4><p>CPU通过<strong>时间片</strong>分配算法来循环执行任务，当前任务执行<strong>一个时间片后会</strong>切换到下一个任务。</p><p>在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。</p><p>所以任务从保存到再加载的过程就是<strong>一次线程切换</strong></p><h4 id="并发的级别"><a href="#并发的级别" class="headerlink" title="并发的级别"></a>并发的级别</h4><p><strong>1 阻塞</strong></p><p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。阻塞可以分很多情况，一种是临时阻塞，就是当时要访问的资源暂时被锁住的了无法访问，所以就停留在此地，另一种是碰到了死锁，就会一直被阻塞，直到设计者发现它。</p><p><strong>2 无饥饿（Starvation-Free）</strong></p><p>如果线程之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。也就是说，对于同一个资源的分配，是不公平的。锁也分公平锁和非公平锁，对于非公平锁来说，系统允许高优先级的线程插队。这样就有可能导致低优先级的线程产生饥饿。但是如果是公平锁，满足先来后到，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。这样所有的线程都有机会执行。</p><p><strong>3 无障碍（Obstruction-Free）</strong></p><p>无障碍是一种最弱的非阻塞调度。无障碍表示两个线程可以畅通无阻的行动，但也会出现一些矛盾，比如一起访问同一个资源，又一起修改一个资源，那样就会出现数据的不可见性，对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。</p><p><strong>4 无锁（Lock-Free）</strong></p><p>无锁的并行都是无障碍的。但是这样会出现很多很多问题，比如说也是同时访问和修改资源，如果发生了资源的争夺，可能会陷入长时间的阻塞或者是直接奔溃，这对于程序来说，无疑是致命的。</p><p><strong>5 无等待（Wait-Free）</strong></p><p>无锁只要求一个线程可以在有限步数内完成操作，而无等待则是在无锁的基础上更进一步进行扩展，它要求所有的线程都必须在有限步数内完成，这样就不会引起线程饥饿问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（一）并发的概念</title>
      <link href="/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="并发是什么？"><a href="#并发是什么？" class="headerlink" title="并发是什么？"></a>并发是什么？</h3><hr><h4 id="并发是什么？-1"><a href="#并发是什么？-1" class="headerlink" title="并发是什么？"></a>并发是什么？</h4><p>顾名思义，同时发生，一起行动。单纯从Java上讲，并发是个一个thread类，它通过集成这个类，获得对应的api，提高程序的运行效率。不过这里暂时不讲和代码有关的事物，我们先为什么会诞生并发开始讲。</p><p>这里会引入一个新的词叫<strong>摩尔定律</strong>，“每隔18个月到24个月，计算机的性能会翻一倍”。这条定律持续了半个世纪之久，在此期间，计算机的能力也正如定律所描述的一样，不断的倍增。但是在几十年前，这条定律有点不管用了。你可以很简单的看作为，我们不再能够制造出性能更好的芯片，单核的能力已经很难再往上升了，所以在21世纪初，人们开始把多个芯片集成起来，企图用数量的增长去代替质量的不足，thread类，也正因此走进了程序员的视野。复杂的并发远远比单核的串行困难的多，所以，程序员的噩梦来了。</p><h4 id="并发一定优于串行吗？"><a href="#并发一定优于串行吗？" class="headerlink" title="并发一定优于串行吗？"></a>并发一定优于串行吗？</h4><p>这里可以很直接的告诉大家，<strong>并发在大多数的情况下都优于串行。</strong></p><p>举一个例子：</p><p>小明被告知明天要上台演讲，而小明今晚开始到明天要做的事情为</p><p>吃饭（半小时）—&gt;洗澡（半小时）—&gt;构思并撰写演讲稿（1.5+1.5=3小时）—&gt;睡觉（8小时）</p><p>我们可以通过面向对象的编程写出代码，其预计的执行时间为12小时，而引入的并行这个方式，让小明可以边吃饭边思考，边洗澡边思考，让其撰写演讲稿的时间减少一小时</p><p>这样最后的执行时间就变成了11小时，但是呢，无论增加多少线程，都只能让小明的构思时间减少1.5小时，其吃饭洗澡睡觉的时间是无法被改变的，也就是说，极限时间为10.5小时。</p><p>从上面的例子可以得出，并行在绝大多数的情况下都优于串行。少数情况下和串行是没有区别的。这里先不谈特殊情况下出现的并行比串行更差劲的事例，因为这并没有太多意义。要记住，我们是<strong>面向对象编程</strong>。 </p><p>所以，学会怎么利用并行，在当今，显得是多么的重要。</p><p>这里不得不提到关于并行这个概念，所拥有的三大特性</p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>顾名思义，具有原子的特性，无法被分割。在程序中可以看作为，这个操作不可被中断，各个线程想要执行这个操作也得一个一个来。</p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性的意思就是，我们所执行的操作，是可见的。就像我们写一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">a=<span class="number">2</span>;</span><br><span class="line">b=a;</span><br></pre></td></tr></table></figure><p>程序就会把a赋值为1，b赋值为2。这看上去貌似很寻常，因为在串行的情况下运行时，可以永远保持可见性。</p><p>而在并行情况下运行时，却不一定可见，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>在线程1和线程2一起运行之时，你并不能确定，此时的j到底取值是多少，因为此时的i是在两个线程之间共享的，它可以是0，也可以是2，这样对我们并不可见。但我们也可以深挖其中的原理。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/kjx.jpg" alt="可见性"></p><p>先看图示，我们的在定义了值为0之后，就会被写入到主内存，而我们在多个线程取i的值的时候，首先会把i加入到本地的缓存当中，读取值就从缓存中读取，因为这样多个线程就不会总从主内存读取，从而提高读取的效率，但是我们在更改了i的值的时候因为有一个线程嗅探的机制，一旦改了i的值，比如a线程修改了i的值后，就会向所有的线程发出一个警告，告诉所有线程i的值已经被更改了，需要重新从主内存中读取。但是呢，发出这样一个信息也是需要时间的，线程b也会因为时间差的关系导致了不能及时获得最新的值。</p><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>这里会讲到一个新的概念，叫<strong>指令重排</strong>，意思就是程序在实际运行的时候，代码段运行的顺序会和你写的顺序不一样。</p><p>像下面这段代码，可能会出现一个问题，那就是先执行a=3再去执行a=1，这样会造成了最终结果不太一样，不过没关系，这种情况在串行条件下不会发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">2</span>;</span><br><span class="line">a=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>但是，在并行条件下，指令重排是怎么发生的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程一</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=i;</span><br><span class="line">k=i;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line">j=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>像这样，两边线程看似互不干扰，各自有各自的工作，但是我们看到了j和k都在读取同一个变量i，而i在这种情况下会被读取两次，而此时如果发生了指令重排，结果就会变成为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程一</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=i;</span><br><span class="line">k=j;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line">j=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>而如果线程二发生在j=i之后的话，会出现这样一个状况，线程二修改了j的值，然后线程一再读取了j的值，这样导致最后的结果k=2。你可以看到，其实如果一直按照它本来的写法，这段代码是不可能出问题了，而一旦指令重排出现了这样的问题，谁又能在几十万行代码中找出来呢？</p><p>你说为什么会出现指令重排呢？不发生重排不就没有这样的问题了吗？其实设计者的初衷很简单，<strong>一切都是为了提高效率</strong>。</p><p>为什么这样能够提高效率？这里就要涉及到汇编语言的问题了。简而言之就是，读取和修改一个值需要分很多个步骤，如果将多个步骤一起进行的话会提高效率，从而导致的指令重排，汇编的机制这里暂且不讲。</p><p>那怎样才能解决呢，最简单的方法就是声明volatile关键字，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure><p>这样谁都不能够对i进行指令重排了，后面会讲到其他的办法，比如synchronized等。</p><p>这里仅仅是对并行这个概念做一个非常简单的介绍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
