<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小世界</title>
  
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/"/>
  <updated>2024-01-16T14:55:40.381Z</updated>
  <id>https://github.com/Pandalee99/pandalee99.github.io/</id>
  
  <author>
    <name>攀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SOFASTACK/SOFA-RPC</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/07/opensource1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/07/opensource1/</id>
    <published>2024-01-07T15:55:53.000Z</published>
    <updated>2024-01-16T14:55:40.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>这里会去介绍一下关于我的小小的开源经历 SOFASTACK/SOFA-RPC和Apache/fury<br>看起来是两个，但是其实是一个，因为主要是在做如何将fury融入到sofa-rpc里面，这里做了很多工作，特别是要感谢 <strong>@EvenLjj @Lo1n  @chaokunyang</strong><br>下面直接开始介绍：<br>首先是对sofa-rpc的改造，这里最大的需求是需要读取一个黑白名单作为配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackAndWhiteListFileLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger      LOGGER                     = LoggerFactory</span><br><span class="line">                                                                    .getLogger(BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SOFA_SERIALIZE_BLACK_LIST  = loadBlackListFile(<span class="string">"/sofa-rpc/serialize_blacklist.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SOFA_SERIALIZER_WHITE_LIST = loadWhiteListFile(<span class="string">"/sofa-rpc/serialize_whitelist.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadBlackListFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; blackPrefixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readToList(input, <span class="string">"UTF-8"</span>, blackPrefixList);</span><br><span class="line">            &#125;</span><br><span class="line">            String overStr = SofaConfigs.getOrCustomDefault(SERIALIZE_BLACKLIST_OVERRIDE, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overStr)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"Serialize blacklist will override with configuration: &#123;&#125;"</span>, overStr);</span><br><span class="line">                &#125;</span><br><span class="line">                overrideBlackList(blackPrefixList, overStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isErrorEnabled()) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> blackPrefixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadWhiteListFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; whitePrefixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readToList(input, <span class="string">"UTF-8"</span>, whitePrefixList);</span><br><span class="line">            &#125;</span><br><span class="line">            String overStr = SofaConfigs.getOrCustomDefault(SERIALIZE_WHITELIST_OVERRIDE, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overStr)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"Serialize whitelist will override with configuration: &#123;&#125;"</span>, overStr);</span><br><span class="line">                &#125;</span><br><span class="line">                overrideWhiteList(whitePrefixList, overStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isErrorEnabled()) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> whitePrefixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读文件，将结果丢入List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input           输入流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encoding        编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blackPrefixList 保持黑名单前缀的List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readToList</span><span class="params">(InputStream input, String encoding, List&lt;String&gt; blackPrefixList)</span> </span>&#123;</span><br><span class="line">        InputStreamReader reader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> InputStreamReader(input, encoding);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">            String lineText;</span><br><span class="line">            <span class="keyword">while</span> ((lineText = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String pkg = lineText.trim();</span><br><span class="line">                <span class="keyword">if</span> (pkg.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    blackPrefixList.add(pkg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isWarnEnabled()) &#123;</span><br><span class="line">                LOGGER.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(bufferedReader);</span><br><span class="line">            closeQuietly(reader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Override blacklist with override string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originList  Origin black list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> overrideStr The override string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">overrideBlackList</span><span class="params">(List&lt;String&gt; originList, String overrideStr)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; adds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] overrideItems = StringUtils.splitWithCommaOrSemicolon(overrideStr);</span><br><span class="line">        <span class="keyword">for</span> (String overrideItem : overrideItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overrideItem)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (overrideItem.startsWith(<span class="string">"!"</span>) || overrideItem.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                    overrideItem = overrideItem.substring(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"*"</span>.equals(overrideItem) || <span class="string">"default"</span>.equals(overrideItem)) &#123;</span><br><span class="line">                        originList.clear();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        originList.remove(overrideItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!originList.contains(overrideItem)) &#123;</span><br><span class="line">                        adds.add(overrideItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            originList.addAll(adds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">overrideWhiteList</span><span class="params">(List&lt;String&gt; originList, String overrideStr)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; adds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] overrideItems = StringUtils.splitWithCommaOrSemicolon(overrideStr);</span><br><span class="line">        <span class="keyword">for</span> (String overrideItem : overrideItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overrideItem)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!originList.contains(overrideItem)) &#123;</span><br><span class="line">                    adds.add(overrideItem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            originList.addAll(adds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的主要作用是加载黑名单和白名单文件，并将文件中的内容读取到对应的列表中。<br>具体来说，这段代码包含以下主要功能：</p><ol><li>loadBlackListFile方法：加载黑名单文件并将文件中的内容读取到blackPrefixList列表中。首先，通过BlackAndWhiteListFileLoader.class.getResourceAsStream(path)方法获取黑名单文件的输入流。然后，使用readToList方法将输入流中的内容按行读取，并将非空的行添加到blackPrefixList列表中。最后，根据配置文件中的覆盖字符串，通过overrideBlackList方法对黑名单列表进行覆盖操作。</li><li>loadWhiteListFile方法：加载白名单文件并将文件中的内容读取到whitePrefixList列表中。与loadBlackListFile方法类似，它通过相同的步骤读取白名单文件，并根据配置文件中的覆盖字符串，通过overrideWhiteList方法对白名单列表进行覆盖操作。</li><li>readToList方法：将输入流中的内容按行读取，并将非空的行添加到指定的列表中。</li><li>overrideBlackList方法：根据覆盖字符串对原始的黑名单列表进行覆盖操作。根据覆盖字符串中的规则，可以添加、删除或清空黑名单列表中的元素。</li><li>overrideWhiteList方法：根据覆盖字符串对原始的白名单列表进行覆盖操作。根据覆盖字符串中的规则，可以添加白名单列表中不存在的元素。</li></ol><p>总体而言，这段代码的主要作用是加载黑名单和白名单文件，并提供方法来对这些列表进行覆盖操作，以便在后续的逻辑中使用这些列表进行过滤或其他处理<br>这是一个最基本的需求，就是通过读取一个黑白名单文件，这里也可以展示一下文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clojure.core$constantly</span><br><span class="line">clojure.main$eval_opt</span><br><span class="line">com.alibaba.citrus.springext.support.parser.AbstractNamedProxyBeanDefinitionParser$ProxyTargetFactory</span><br><span class="line">com.alibaba.citrus.springext.support.parser.AbstractNamedProxyBeanDefinitionParser$ProxyTargetFactoryImpl</span><br><span class="line">com.alibaba.citrus.springext.util.SpringExtUtil.AbstractProxy</span><br><span class="line">com.alipay.custrelation.service.model.redress.Pair</span><br><span class="line">com.caucho.hessian.test.TestCons</span><br><span class="line">com.mchange.v2.c3p0.JndiRefForwardingDataSource</span><br><span class="line">com.mchange.v2.c3p0.WrapperConnectionPoolDataSource</span><br><span class="line">com.rometools.rome.feed.impl.EqualsBean</span><br><span class="line">com.rometools.rome.feed.impl.ToStringBean</span><br><span class="line">com.sun.jndi.rmi.registry.BindingEnumeration</span><br><span class="line">com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>格式就是这样，具体就不全部放出了<br>然后从设计模式上，会使用一个枚举类去展示出有哪些情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lipan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FurySecurityMode &#123;</span><br><span class="line"></span><br><span class="line">    WHITELIST_MODE(<span class="string">"whitelist"</span>), BLACKLIST_MODE(<span class="string">"blacklist"</span>), NONE_MODE(<span class="string">"none"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String securityMode;</span><br><span class="line"></span><br><span class="line">    FurySecurityMode(String securityMode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.securityMode = securityMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecurityMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就只会出现三种情况，黑名单，白名单，什么都不使用<br>会有一个判断逻辑去判断会出现那种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not use any configuration</span></span><br><span class="line"><span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.NONE_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker noChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.DISABLE);</span><br><span class="line">    f.getClassResolver().setClassChecker(noChecker);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.BLACKLIST_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker blackListChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.WARN);</span><br><span class="line">    List&lt;String&gt; blackList = BlackAndWhiteListFileLoader.SOFA_SERIALIZE_BLACK_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackListChecker);</span><br><span class="line">    blackListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// BlackList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : blackList) &#123;</span><br><span class="line">        blackListChecker.disallowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.WHITELIST_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker blackAndWhiteListChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.STRICT);</span><br><span class="line">    List&lt;String&gt; whiteList = BlackAndWhiteListFileLoader.SOFA_SERIALIZER_WHITE_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackAndWhiteListChecker);</span><br><span class="line">    blackAndWhiteListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// WhiteList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : whiteList) &#123;</span><br><span class="line">        blackAndWhiteListChecker.allowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; blackList = BlackAndWhiteListFileLoader.SOFA_SERIALIZE_BLACK_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackAndWhiteListChecker);</span><br><span class="line">    blackAndWhiteListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// BlackList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : blackList) &#123;</span><br><span class="line">        blackAndWhiteListChecker.disallowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里涉及到fury的两个能力，一个是注册过的类 进行序列化/反序列化的时候效率会更高，一个是可以通过checker去判断，当前的类是否在名单内。<br>然后下面进入了编码阶段，这里其实会对不同请求进行区别，将SOFA请求和普通的类区分开来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractByteBuf <span class="title">encode</span><span class="params">(<span class="keyword">final</span> Object object, <span class="keyword">final</span> Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> buildSerializeError(<span class="string">"Unsupported null message!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fury.setClassLoader(contextClassLoader);</span><br><span class="line">        CustomSerializer customSerializer = getObjCustomSerializer(object);</span><br><span class="line">        <span class="keyword">if</span> (customSerializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> customSerializer.encodeObject(object, context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MemoryBuffer writeBuffer = MemoryBuffer.newHeapBuffer(<span class="number">32</span>);</span><br><span class="line">            writeBuffer.writerIndex(<span class="number">0</span>);</span><br><span class="line">            fury.serialize(writeBuffer, object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayWrapperByteBuf(writeBuffer.getBytes(<span class="number">0</span>, writeBuffer.writerIndex()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> buildSerializeError(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fury.clearClassLoader(contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个方法的实现，用于将对象编码为字节缓冲区（ByteBuf）。<br>具体来说，这段代码的作用如下：<br>首先，检查传入的对象是否为null，如果是null，则抛出一个序列化错误异常。获取当前线程的上下文类加载器（contextClassLoader），以便后续使用。然后会设置fury（一个自定义序列化框架）的类加载器为上下文类加载器，以确保在序列化过程中使用正确的类加载器加载所需的类。<br>获取对象的自定义序列化器（customSerializer），如果存在自定义序列化器，则使用自定义序列化器对对象进行编码，并返回编码后的字节缓冲区。<br>如果不存在自定义序列化器，则创建一个内存缓冲区（MemoryBuffer），并使用fury对对象进行序列化，将序列化后的数据写入内存缓冲区。<br>将内存缓冲区中的字节数据封装到一个ByteArrayWrapperByteBuf对象中，并返回该对象作为编码后的结果。需要注意的是，在整个过程中，如果发生任何异常，都会抛出一个序列化错误异常，并将异常信息作为错误消息进行构建。<br>这段代码的主要作用是根据对象的类型和上下文信息，使用自定义序列化器或默认的fury序列化框架，将对象编码为字节缓冲区。<br>这里可以着重讲一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure><p>这个设计的主要目的是为了获得当前线程最新的类加载器，因为在这里会遇到一个场景，那就是当客户端在发送rpc的时候，服务端的rpc协议或者说类变更了，这样会导致两端不一样的问题， 所以需要通过这种方式去实时更新类。动态类加载和热更新：使用动态类加载和热更新的机制，可以在运行时动态加载和更新类。这样可以避免重启应用程序或重新部署的麻烦，使得类的变更能够及时生效。<br>然后就是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomSerializer customSerializer = getObjCustomSerializer(object);</span><br></pre></td></tr></table></figure><p>这里实际上是，会有自己的序列化器去实现这个CustomSerializer接口，然后这里会通过判断这个object的class是否为CustomSerializer的实现类，然后CustomSerializer有自己的处理方式。<br>然后看看它的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractByteBuf <span class="title">encodeObject</span><span class="params">(SofaRequest object, Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryBuffer writeBuffer = MemoryBuffer.newHeapBuffer(<span class="number">32</span>);</span><br><span class="line">        writeBuffer.writerIndex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据SerializeType信息决定序列化器</span></span><br><span class="line">        <span class="keyword">boolean</span> genericSerialize = context != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            isGenericRequest(context.get(RemotingConstants.HEAD_GENERIC_TYPE));</span><br><span class="line">        <span class="keyword">if</span> (genericSerialize) &#123;</span><br><span class="line">            <span class="comment">// TODO support generic call</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Generic call is not supported for now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fury.serialize(writeBuffer, object);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = object.getMethodArgs();</span><br><span class="line">        fury.serialize(writeBuffer, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayWrapperByteBuf(writeBuffer.getBytes(<span class="number">0</span>, writeBuffer.writerIndex()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里默认会去构造一个buffer，将序列化的实例的写入buffer里面，并且同时需要将每个参数也同步写入。同时定好fury的序列化模式，然后转为byte数组传回去。这里涉及到fury的底层实现，比较难说为什么要这么做，但是做法确实比较直观和简洁。<br>然后，就是进行反序列化了，但在这里有一个不同的实现方式，sofa会去定义是否要将结果直接反序列化到传入的实例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SofaRequest <span class="title">decodeObject</span><span class="params">(AbstractByteBuf data, Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    MemoryBuffer readBuffer = MemoryBuffer.fromByteArray(data.array());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SofaRequest sofaRequest = (SofaRequest) fury.deserialize(readBuffer);</span><br><span class="line">        String targetServiceName = sofaRequest.getTargetServiceUniqueName();</span><br><span class="line">        <span class="keyword">if</span> (targetServiceName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Target service name of request is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String interfaceName = ConfigUniqueNameGenerator.getInterfaceName(targetServiceName);</span><br><span class="line">        sofaRequest.setInterfaceName(interfaceName);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = (Object[]) fury.deserialize(readBuffer);</span><br><span class="line">        sofaRequest.setMethodArgs(args);</span><br><span class="line">        <span class="keyword">return</span> sofaRequest;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decodeObjectByTemplate</span><span class="params">(AbstractByteBuf data, Map&lt;String, String&gt; context, SofaRequest template)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.readableBytes() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Deserialized array is empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryBuffer readBuffer = MemoryBuffer.fromByteArray(data.array());</span><br><span class="line">        SofaRequest tmp = (SofaRequest) fury.deserialize(readBuffer);</span><br><span class="line">        String targetServiceName = tmp.getTargetServiceUniqueName();</span><br><span class="line">        <span class="keyword">if</span> (targetServiceName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Target service name of request is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy values to template</span></span><br><span class="line">        template.setMethodName(tmp.getMethodName());</span><br><span class="line">        template.setMethodArgSigs(tmp.getMethodArgSigs());</span><br><span class="line">        template.setTargetServiceUniqueName(tmp.getTargetServiceUniqueName());</span><br><span class="line">        template.setTargetAppName(tmp.getTargetAppName());</span><br><span class="line">        template.addRequestProps(tmp.getRequestProps());</span><br><span class="line">        String interfaceName = ConfigUniqueNameGenerator.getInterfaceName(targetServiceName);</span><br><span class="line">        template.setInterfaceName(interfaceName);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = (Object[]) fury.deserialize(readBuffer);</span><br><span class="line">        template.setMethodArgs(args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体操作比较类似，就是读出对应的实例和参数。<br>然后，这个sofa-rpc也是使用扩展机制，去将序列化方式融入到整体当中的。</p><h2 id="Fury"><a href="#Fury" class="headerlink" title="Fury"></a>Fury</h2><p>这里我还在fury这个项目中做了点贡献，尤其是对StringBuilder的修改：<br>在 JDK 8 和 JDK 11 中，StringBuilder 类的底层实现数组的方式有一些区别。<br>在 JDK 8 中，StringBuilder 类使用的是一个字符数组（char[]）作为底层的缓冲区。初始时，该字符数组的长度为 16。当需要追加更多字符时，StringBuilder 会检查当前缓冲区是否有足够的空间，如果没有，则会创建一个新的字符数组，将原有的字符数组内容复制到新数组中，并将新的字符数组作为底层缓冲区。<br>在 JDK 11 中，StringBuilder 类的底层实现有所改进。它引入了一个新的类，称为 CompactStrings。CompactStrings 类使用的是一个字节数组（byte[]）作为底层的缓冲区。这个字节数组中的每个字节都可以存储一个字符，而不仅仅是一个字节。这样可以节省内存空间，特别是对于包含大量 ASCII 字符的字符串。<br>在 JDK 11 中，默认情况下，CompactStrings 是启用的。当字符串中的字符都可以用一个字节表示时，CompactStrings 会将字符串存储在字节数组中。只有当字符串中包含无法用一个字节表示的字符时，才会使用字符数组来存储字符串。<br>这种改进的底层实现方式可以提供更高的内存效率，特别是对于包含大量 ASCII 字符的字符串。它可以减少内存的使用量，并提高性能。需要注意的是，CompactStrings 的启用与否可以通过 JVM 的参数进行配置。在某些情况下，可能需要手动禁用 CompactStrings，以便与旧版本的 JDK 兼容或满足特定的需求。<br>于是，即使是面对同样的类，也要有不一样的序列化方式，当然，这里其实可以通过启动时去获取jdk版本，然后做区分操作，现在要展示的是，如何在版本不同的StringBuilder下做出不同的序列化结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ToIntFunction GET_CODER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Function GET_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  GET_VALUE = (Function) makeGetterFunction(StringBuilder.class.getSuperclass(), "getValue");</span><br><span class="line">  ToIntFunction&lt;CharSequence&gt; getCoder;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Method getCoderMethod = StringBuilder.class.getSuperclass().getDeclaredMethod("getCoder");</span><br><span class="line">    getCoder = (ToIntFunction&lt;CharSequence&gt;) makeGetterFunction(getCoderMethod, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    getCoder = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  GET_CODER = getCoder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个静态代码块，用于初始化两个私有静态变量 GET_VALUE 和 GET_CODER。<br>首先，代码使用 makeGetterFunction 方法创建了一个函数对象 GET_VALUE，该函数对象用于获取 StringBuilder 类的父类的 getValue 方法。接下来，代码尝试通过反射获取 StringBuilder 类的父类的 getCoder 方法，并将其转换为 ToIntFunction<CharSequence> 类型。如果找不到该方法，则将 GET_CODER 设置为 null。最终，将获取到的 getCoder 赋值给 GET_CODER 变量。<br>这段代码的目的是为了获取 StringBuilder 类的父类的 getValue 方法和 getCoder 方法，并将它们分别赋值给 GET_VALUE 和 GET_CODER 变量。这些变量可能在后续的代码中使用，用于执行相应的操作。<br>因为既然它们的底层实现不一样，就需要通过反射的方式去获取到实际的底层数组，这里只需要做区分了。然后，写入的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(MemoryBuffer buffer, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GET_CODER != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> coder = GET_CODER.applyAsInt(value);</span><br><span class="line">      <span class="keyword">byte</span>[] v = (<span class="keyword">byte</span>[]) GET_VALUE.apply(value);</span><br><span class="line">      buffer.writeByte(coder);</span><br><span class="line">      <span class="keyword">if</span> (coder == <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.writePrimitiveArrayWithSizeEmbedded(v, Platform.BYTE_ARRAY_OFFSET, value.length());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coder != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported coder "</span> + coder);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.writePrimitiveArrayWithSizeEmbedded(</span><br><span class="line">            v, Platform.BYTE_ARRAY_OFFSET, value.length() &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">char</span>[] v = (<span class="keyword">char</span>[]) GET_VALUE.apply(value);</span><br><span class="line">      <span class="keyword">if</span> (StringSerializer.isLatin(v)) &#123;</span><br><span class="line">        stringSerializer.writeCharsLatin(buffer, v, value.length());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stringSerializer.writeCharsUTF16(buffer, v, value.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，代码检查 GET_CODER 是否为 null，如果不为 null，则说明 StringBuilder 对象使用了编码器（coder）。在这种情况下，代码通过调用 GET_CODER.applyAsInt(value) 获取编码器的值，并将其写入 buffer 中。<br>接下来，根据编码器的值进行不同的处理。如果编码器的值为 0，表示使用 Latin 编码，此时将 byte[] 类型的值 v 写入 buffer，并使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将数组的内容写入 buffer。如果编码器的值不为 0 或 1，则抛出 UnsupportedOperationException 异常。如果编码器的值为 1，表示使用 UTF-16 编码，此时将 byte[] 类型的值 v 写入 buffer，并将数组的长度乘以 2，然后使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将数组的内容写入 buffer。<br>如果 GET_CODER 为 null，则说明 StringBuilder 对象没有使用编码器。在这种情况下，代码通过调用 GET_VALUE.apply(value) 获取 char[] 类型的值 v，然后根据 v 是否为 Latin 编码来决定使用 stringSerializer 的 writeCharsLatin 方法还是 writeCharsUTF16 方法将字符数组写入 buffer。<br><strong>为什么要区分Latin 和UTF-16呢？Latin 编码和 UTF-16 编码所占的位数是不同的！</strong><br>Latin 编码是一种字符编码方式，它使用一个字节（8位）来表示一个字符。它主要用于表示拉丁字母字符集，包括英文字母和一些特殊字符。由于使用一个字节表示一个字符，Latin 编码可以节省存储空间，但它只能表示有限的字符集。<br>UTF-16 编码是一种可变长度的字符编码方式，它使用 16 位（2个字节）来表示一个字符。它可以表示几乎所有的字符，包括拉丁字母、非拉丁字母、符号、表情符号等。UTF-16 编码可以表示更广泛的字符集，但相对于 Latin 编码，它在存储空间上需要更多的字节。<br>因此，当将字符数组序列化时，如果使用 Latin 编码，每个字符只需要一个字节来表示；而如果使用 UTF-16 编码，每个字符需要两个字节来表示。在代码中，根据编码器的值选择适当的序列化方式，可以根据编码器的值来确定使用 Latin 编码还是 UTF-16 编码，并相应地调整序列化的字节数。</p><h3 id="高效的判断是否是Latin"><a href="#高效的判断是否是Latin" class="headerlink" title="高效的判断是否是Latin"></a>高效的判断是否是Latin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLatin</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numChars = chars.length;</span><br><span class="line">  <span class="keyword">int</span> vectorizedLen = numChars &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> vectorizedChars = vectorizedLen &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> endOffset = Platform.CHAR_ARRAY_OFFSET + (vectorizedChars &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">boolean</span> isLatin = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> offset = Platform.CHAR_ARRAY_OFFSET; offset &lt; endOffset; offset += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">// check 4 chars in a vectorized way, 4 times faster than scalar check loop.</span></span><br><span class="line">    <span class="comment">// See benchmark in CompressStringSuite.latinSuperWordCheck.</span></span><br><span class="line">    <span class="keyword">long</span> multiChars = Platform.getLong(chars, offset);</span><br><span class="line">    <span class="keyword">if</span> ((multiChars &amp; MULTI_CHARS_NON_LATIN_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">      isLatin = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isLatin) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vectorizedChars; i &lt; numChars; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (chars[i] &gt; <span class="number">0xFF</span>) &#123;</span><br><span class="line">        isLatin = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isLatin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先获取字符数组的长度 numChars，然后计算出向量化长度 vectorizedLen，即将字符数组长度右移两位得到的结果。接着，根据向量化长度计算出向量化字符数 vectorizedChars，即将向量化长度左移两位得到的结果。然后，根据向量化字符数计算出结束偏移量 endOffset，即将字符数组的偏移量 Platform.CHAR_ARRAY_OFFSET 加上向量化字符数左移一位得到的结果。<br>接下来，函数使用一个布尔变量 isLatin 来表示字符数组是否全部由 Latin 字符组成，初始值为 true。<br>然后，函数通过一个循环，从字符数组的偏移量开始，每次增加 8，以向量化方式检查字符数组中的四个字符。具体地，函数使用 Platform.getLong(chars, offset) 获取一个长整型数，其中包含了四个字符的信息。然后，函数将这个长整型数与 MULTI_CHARS_NON_LATIN_MASK 进行按位与操作，如果结果不为 0，说明存在非 Latin 字符，此时将 isLatin 设置为 false 并跳出循环。<br>如果在向量化检查中没有发现非 Latin 字符，函数会继续进行后续的检查。函数使用一个循环，从向量化字符数开始，逐个检查字符数组中的字符。如果发现字符的值大于 0xFF（即超过一个字节的范围），则说明存在非 Latin 字符，此时将 isLatin 设置为 false 并跳出循环。<br>最后，函数返回 isLatin 的值，表示字符数组是否全部由 Latin 字符组成。<br>这个函数的目的是通过向量化方式快速检查字符数组中是否存在非 Latin 字符，以及通过逐个检查剩余字符的方式进一步确认是否全部为 Latin 字符。这样可以提高判断的效率，并且可以在序列化过程中根据判断结果选择合适的序列化方式。</p><h3 id="根据类型会有不同的写入方式"><a href="#根据类型会有不同的写入方式" class="headerlink" title="根据类型会有不同的写入方式"></a>根据类型会有不同的写入方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCharsLatin</span><span class="params">(MemoryBuffer buffer, <span class="keyword">char</span>[] chars, <span class="keyword">final</span> <span class="keyword">int</span> strLen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> writerIndex = buffer.writerIndex();</span><br><span class="line">  <span class="comment">// The `ensure` ensure next operations are safe without bound checks,</span></span><br><span class="line">  <span class="comment">// and inner heap buffer doesn't change.</span></span><br><span class="line">  buffer.ensure(writerIndex + <span class="number">9</span> + strLen);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] targetArray = buffer.getHeapMemory();</span><br><span class="line">  <span class="keyword">if</span> (targetArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetIndex = buffer.unsafeHeapWriterIndex();</span><br><span class="line">    <span class="keyword">int</span> arrIndex = targetIndex;</span><br><span class="line">    targetArray[arrIndex++] = LATIN1;</span><br><span class="line">    arrIndex += MemoryUtils.writePositiveVarInt(targetArray, arrIndex, strLen);</span><br><span class="line">    writerIndex += arrIndex - targetIndex + strLen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      targetArray[arrIndex + i] = (<span class="keyword">byte</span>) chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buffer.unsafePut(writerIndex++, LATIN1);</span><br><span class="line">    writerIndex += buffer.unsafePutPositiveVarInt(writerIndex, strLen);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] tmpArray = getByteArray(strLen);</span><br><span class="line">    <span class="comment">// Write to heap memory then copy is 60% faster than unsafe write to direct memory.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      tmpArray[i] = (<span class="keyword">byte</span>) chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.put(writerIndex, tmpArray, <span class="number">0</span>, strLen);</span><br><span class="line">    writerIndex += strLen;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCharsUTF16</span><span class="params">(MemoryBuffer buffer, <span class="keyword">char</span>[] chars, <span class="keyword">int</span> strLen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numBytes = MathUtils.doubleExact(strLen);</span><br><span class="line">  <span class="keyword">if</span> (Platform.IS_LITTLE_ENDIAN) &#123;</span><br><span class="line">    buffer.writeByte(UTF16);</span><br><span class="line">    <span class="comment">// FIXME JDK11 utf16 string uses little-endian order.</span></span><br><span class="line">    buffer.writePrimitiveArrayWithSizeEmbedded(chars, Platform.CHAR_ARRAY_OFFSET, numBytes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The `ensure` ensure next operations are safe without bound checks,</span></span><br><span class="line">    <span class="comment">// and inner heap buffer doesn't change.</span></span><br><span class="line">    <span class="keyword">int</span> writerIndex = buffer.writerIndex();</span><br><span class="line">    buffer.ensure(writerIndex + <span class="number">9</span> + numBytes);</span><br><span class="line">    <span class="keyword">byte</span>[] targetArray = buffer.getHeapMemory();</span><br><span class="line">    <span class="keyword">if</span> (targetArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> targetIndex = buffer.unsafeHeapWriterIndex();</span><br><span class="line">      <span class="keyword">int</span> arrIndex = targetIndex;</span><br><span class="line">      targetArray[arrIndex++] = UTF16;</span><br><span class="line">      arrIndex += MemoryUtils.writePositiveVarInt(targetArray, arrIndex, strLen);</span><br><span class="line">      <span class="comment">// Write to heap memory then copy is 250% faster than unsafe write to direct memory.</span></span><br><span class="line">      <span class="keyword">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = arrIndex, end = i + numBytes; i &lt; end; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[charIndex++];</span><br><span class="line">        targetArray[i] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.HI_BYTE_SHIFT);</span><br><span class="line">        targetArray[i + <span class="number">1</span>] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.LO_BYTE_SHIFT);</span><br><span class="line">      &#125;</span><br><span class="line">      writerIndex += arrIndex - targetIndex + numBytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer.unsafePut(writerIndex++, UTF16);</span><br><span class="line">      writerIndex += buffer.unsafePutPositiveVarInt(writerIndex, numBytes);</span><br><span class="line">      <span class="keyword">byte</span>[] tmpArray = getByteArray(strLen);</span><br><span class="line">      <span class="keyword">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBytes; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[charIndex++];</span><br><span class="line">        tmpArray[i] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.HI_BYTE_SHIFT);</span><br><span class="line">        tmpArray[i + <span class="number">1</span>] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.LO_BYTE_SHIFT);</span><br><span class="line">      &#125;</span><br><span class="line">      buffer.put(writerIndex, tmpArray, <span class="number">0</span>, numBytes);</span><br><span class="line">      writerIndex += numBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码包含了两个函数：writeCharsLatin 和 writeCharsUTF16，用于将字符数组按照 Latin 编码或 UTF-16 编码写入到内存缓冲区 buffer 中。<br>writeCharsLatin 函数首先获取当前写入位置 writerIndex，然后通过 buffer.ensure 方法确保内存缓冲区有足够的空间来写入字符数组。接下来，函数检查 buffer 是否是基于堆内存的，如果是，则使用堆内存的方式进行写入。<br>在堆内存方式下，函数将 Latin 编码的标识符 LATIN1 写入到目标数组中，并使用 MemoryUtils.writePositiveVarInt 方法将字符数组的长度写入到目标数组中。然后，函数使用一个循环，将字符数组中的每个字符转换为字节，并写入到目标数组中。最后，函数更新写入位置 writerIndex，并将其设置为新的值。<br>如果 buffer 不是基于堆内存的，函数使用直接内存的方式进行写入。函数先将 Latin 编码的标识符 LATIN1 写入到 buffer 中，然后使用 buffer.unsafePutPositiveVarInt 方法将字符数组的长度写入到 buffer 中。接着，函数创建一个临时的字节数组 tmpArray，并使用一个循环，将字符数组中的每个字符转换为字节，并写入到 tmpArray 中。最后，函数使用 buffer.put 方法将 tmpArray 中的字节写入到 buffer 中，并更新写入位置 writerIndex。<br>writeCharsUTF16 函数首先根据字符数组的长度计算出需要的字节数 numBytes。如果当前平台是小端序（little-endian），函数先将 UTF-16 编码的标识符 UTF16 写入到 buffer 中，然后使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将字符数组按照 UTF-16 编码写入到 buffer 中。<br>如果当前平台不是小端序，函数使用与 writeCharsLatin 函数类似的逻辑进行写入。函数首先获取当前写入位置 writerIndex，然后通过 buffer.ensure 方法确保内存缓冲区有足够的空间来写入字符数组。接下来，函数检查 buffer 是否是基于堆内存的，如果是，则使用堆内存的方式进行写入。<br>在堆内存方式下，函数将 UTF-16 编码的标识符 UTF16 写入到目标数组中，并使用 MemoryUtils.writePositiveVarInt 方法将字符数组的长度写入到目标数组中。然后，函数使用一个循环，将字符数组中的每个字符转换为字节，并按照 UTF-16 编码的规则写入到目标数组中。最后，函数更新写入位置 writerIndex。<br>如果 buffer 不是基于堆内存的，函数使用直接内存的方式进行写入。函数先将 UTF-16 编码的标识符 UTF16 写入到 buffer 中，然后使用 buffer.unsafePutPositiveVarInt 方法将字符数组的长度写入到 buffer 中。接着，函数创建一个临时的字节数组 tmpArray，并使用一个循环，将字符数组中的每个字符按照 UTF-16 编码的规则转换为字节，并写入到 tmpArray 中。最后，函数使用 buffer.put 方法将 tmpArray 中的字节写入到 buffer 中，并更新写入位置 writerIndex。<br>这两个函数的目的是将字符数组按照 Latin 编码或 UTF-16 编码写入到内存缓冲区中，以便进行后续的序列化操作。具体的写入方式根据 buffer 是否基于堆内存以及当前平台的字节序来确定。</p><h3 id="获取器函数"><a href="#获取器函数" class="headerlink" title="获取器函数"></a>获取器函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">makeGetterFunction</span><span class="params">(Method method, Class&lt;?&gt; returnType)</span> </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = _JDKAccess._trustedLookup(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Why `lookup.findGetter` doesn't work?</span></span><br><span class="line">      <span class="comment">// MethodHandle handle = lookup.findGetter(field.getDeclaringClass(), field.getName(),</span></span><br><span class="line">      <span class="comment">// field.getType());</span></span><br><span class="line">      MethodHandle handle = lookup.unreflect(method);</span><br><span class="line">      <span class="keyword">return</span> _JDKAccess.makeGetterFunction(lookup, handle, returnType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个静态方法 makeGetterFunction，用于创建一个获取器函数（getter function）。该方法接受两个参数：method 和 returnType。method 是一个方法对象，表示要创建获取器函数的方法；returnType 是一个 Class 对象，表示方法的返回类型。<br>首先，方法通过 _JDKAccess._trustedLookup 方法获取一个 MethodHandles.Lookup 对象，用于执行方法句柄的查找操作。然后，使用 lookup.unreflect 方法将 method 转换为一个方法句柄（MethodHandle）对象，以便后续的操作。<br>接下来，方法调用 _JDKAccess.makeGetterFunction 方法，传递 lookup、handle 和 returnType 作为参数，以创建获取器函数。具体的实现细节在该方法内部。如果在获取方法句柄或创建获取器函数的过程中发生了 IllegalAccessException 异常，方法将捕获该异常并抛出一个 RuntimeException，将原始异常作为其原因。<br>总体而言，该方法的目的是通过反射和方法句柄机制，创建一个获取器函数，用于获取指定方法的返回值。</p><ol><li>writeCharsLatin 函数用于将字符数组按照 Latin 编码写入到内存缓冲区中。</li><li>writeCharsUTF16 函数用于将字符数组按照 UTF-16 编码写入到内存缓冲区中。</li><li>这两个函数根据内存缓冲区是否基于堆内存以及当前平台的字节序来确定写入方式。</li><li>makeGetterFunction 方法用于创建获取器函数，通过反射和方法句柄机制获取指定方法的返回值。</li><li>makeGetterFunction 方法使用 _JDKAccess._trustedLookup 方法获取方法句柄的查找对象。</li><li>方法句柄通过 lookup.unreflect 方法将方法对象转换为方法句柄。</li><li>_JDKAccess.makeGetterFunction 方法使用方法句柄和返回类型创建获取器函数。</li><li>如果在获取方法句柄或创建获取器函数的过程中发生 IllegalAccessException 异常，将抛出 RuntimeException。</li><li>这些代码涉及了字节转换、内存缓冲区操作、反射和方法句柄等底层操作。</li><li>目的是实现字符编码的写入和获取器函数的创建，用于后续的序列化和数据访问操作。</li></ol><h3 id="热加载能力"><a href="#热加载能力" class="headerlink" title="热加载能力"></a>热加载能力</h3><p>其实这个能力并非是本人设计的，是根据原理去利用的：</p><p>在Java中，类加载器（ClassLoader）用于加载类和资源。每个类加载器都有其特定的加载范围和优先级。线程的上下文类加载器（Context ClassLoader）是一个特殊的类加载器，它与当前线程相关联，并且可以在加载类和资源时被使用。</p><p>上下文类加载器的设置可以由应用程序自行决定，通常用于解决类加载器层次结构中的资源查找问题。在某些情况下，应用程序可能需要使用第三方库或框架，而这些库或框架使用了自定义的类加载器。在这种情况下，上下文类加载器可以被设置为第三方类加载器，以确保正确加载所需的类和资源。</p><p>因此，Thread.currentThread().getContextClassLoader() 方法返回的类加载器可以是第三方类加载器，它可能是应用程序中使用的自定义类加载器或其他第三方库中的类加载器。</p><p>于是可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="comment">//获取第三方加载器</span></span><br></pre></td></tr></table></figure><p>ref: <a href="https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/" target="_blank" rel="noopener">https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开源经历更多的是提升了自己的创造力和动手能力，更多的时候是去编写一些从未有过的代码逻辑，没有多少参考代码是可以直接复用的。从一方面说，需要根据这个项目的需求，去从零到一的去实现这个逻辑，有时候会感觉每一行代码都写的很生涩很不好，但是写的代码多了，再回过去去思考，又可以发现自己不足的地方，然后继续去优化原有的代码块，提高代码质量，我想很多项目都是通过反复思考，推导，才会让自己的项目更加的完善。另一方面，这其实也是挺有乐趣的一件事，这其实也让我找到了当初学习数据结构的时候的那种乐趣，老师给你一个二叉树或者是图的逻辑，然后一点一点的去完成它，中途可能会碰到各种问题，但是将这个逻辑彻底实现为你的代码中，也会感到一些成就感，这给你的反馈也是一种特殊的礼物。虽然，开源看起来也是一件比较困难的事情，但是每一点的努力都会让你有所提升，这也是很值得去投入的事情，相信，道阻且长，行则将至。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RPC&quot;&gt;&lt;a href=&quot;#RPC&quot; class=&quot;headerlink&quot; title=&quot;RPC&quot;&gt;&lt;/a&gt;RPC&lt;/h2&gt;&lt;p&gt;这里会去介绍一下关于我的小小的开源经历 SOFASTACK/SOFA-RPC和Apache/fury&lt;br&gt;看起来是两个，但是其实是</summary>
      
    
    
    
    
    <category term="open source" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/open-source/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝技术说明书</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/05/zero-copy/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/05/zero-copy/</id>
    <published>2024-01-05T12:33:44.000Z</published>
    <updated>2024-02-18T13:13:32.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>零拷贝技术（Zero-copy）是一种优化数据传输和处理的技术，旨在减少数据在内存之间的复制次数，提高系统性能和效率。</p><p>在传统的数据传输过程中，当数据从一个缓冲区（如磁盘或网络）复制到另一个缓冲区（如应用程序的内存），通常需要经过多次数据复制操作。这些复制操作会占用CPU时间和内存带宽，降低系统的性能。</p><p>而零拷贝技术通过避免数据的中间复制，直接在数据源和目标之间传输数据，从而减少了数据复制的次数。它可以通过以下几种方式实现：</p><ol><li>零拷贝文件传输：在传输文件时，使用操作系统提供的零拷贝API，如sendfile()或splice()，将文件数据直接从磁盘传输到网络，避免了数据在用户空间和内核空间之间的复制。</li><li>零拷贝网络传输：在网络传输中，使用操作系统提供的零拷贝API，如sendfile()或scatter-gather I/O，将数据直接从应用程序的内存传输到网络设备，避免了数据在内核空间和用户空间之间的复制。</li><li>零拷贝内存操作：在内存操作中，使用内存映射（mmap）或共享内存（shared memory）等技术，将数据直接映射到应用程序的地址空间，避免了数据在不同缓冲区之间的复制。</li></ol><p>通过使用零拷贝技术，可以减少数据复制的次数，降低CPU和内存的负载，提高数据传输和处理的效率。这对于高性能计算、大规模数据处理和网络通信等场景非常有益。</p><p><strong>下面开始举例子</strong></p><p>当使用零拷贝技术时，数据在传输过程中避免了额外的数据复制，从而提高了性能和效率。为了展示使用零拷贝和不使用零拷贝的区别，提供两个示例代码。</p><p>首先，我们来看一下不使用零拷贝的传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputFile = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">            FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputFile.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputFile.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inputFile.close();</span><br><span class="line">            outputFile.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"文件传输完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用传统的方式进行文件复制。我们创建了一个缓冲区（byte数组），然后从输入文件中读取数据到缓冲区，再将缓冲区中的数据写入输出文件。这个过程中，数据在内存中进行了多次复制，从输入缓冲区到输出缓冲区，然后再写入输出文件。这些复制操作会占用CPU时间和内存带宽，降低系统的性能。</p><p>接下来，我们来看一下使用零拷贝技术的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputFile = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">            FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>);</span><br><span class="line"></span><br><span class="line">            FileChannel inputChannel = inputFile.getChannel();</span><br><span class="line">            FileChannel outputChannel = outputFile.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> fileSize = inputChannel.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接将输入通道的数据传输到输出通道，避免了数据复制</span></span><br><span class="line">            inputChannel.transferTo(<span class="number">0</span>, fileSize, outputChannel);</span><br><span class="line"></span><br><span class="line">            inputChannel.close();</span><br><span class="line">            outputChannel.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"文件传输完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用了FileChannel的transferTo()方法，直接将输入通道的数据传输到输出通道。这样，数据在传输过程中避免了额外的复制，提高了性能和效率。</p><p>通过对比这两个示例代码，你可以清楚地看到使用零拷贝技术相对于传统方式的优势，它避免了数据在内存中的多次复制，提高了系统的性能和效率。</p><p><strong>当然，也可以使用一个很简单的例子去说明</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"Hello, "</span>);</span><br><span class="line">        sb.append(<span class="string">"world!"</span>);</span><br><span class="line"></span><br><span class="line">        String result = sb.toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个StringBuilder对象，并使用append()方法将两个字符串进行拼接。最后，我们使用toString()方法将StringBuilder对象转换为一个不可变的字符串对象。</p><p>尽管这个例子中没有直接涉及到零拷贝的概念，但是通过使用StringBuilder，我们可以避免创建多个中间字符串对象，从而提高了字符串拼接的效率。这种技术在处理大量字符串拼接的场景下特别有用，因为它避免了频繁创建和销毁字符串对象的开销。</p><h2 id="为什么不一开始就用零拷贝？"><a href="#为什么不一开始就用零拷贝？" class="headerlink" title="为什么不一开始就用零拷贝？"></a>为什么不一开始就用零拷贝？</h2><p>那么零拷贝似乎是一开始就可以这么做的吧。那么，为什么设计者在一开始就不通过传递变量的方式来实现他的编程逻辑，而是要采用多次复制呢？</p><p>零拷贝的概念并不是一开始就存在的，而是随着计算机系统和网络技术的发展逐渐被提出和应用的。在早期的计算机系统中，内存和网络传输的速度相对较慢，因此多次复制数据是为了提高数据访问和传输的效率。</p><p>设计者在一开始采用多次复制的方式，主要是出于以下几个原因：</p><ol><li>简化编程逻辑：通过多次复制数据，可以将数据从一个地方复制到另一个地方，使得编程逻辑更加简单和直观。这种方式在早期的计算机系统中更容易实现和理解。</li><li>数据安全性：通过多次复制数据，可以确保数据在不同的内存区域或网络传输中的安全性。每次复制都可以创建数据的副本，以防止原始数据被修改或损坏。</li><li>兼容性和可移植性：在早期的计算机系统中，硬件和操作系统的支持可能有限，无法直接实现零拷贝技术。因此，通过多次复制数据可以在不同的系统和平台上实现数据的传输和处理。</li></ol><p>随着计算机系统和网络技术的进步，零拷贝的概念逐渐被提出和应用。通过使用零拷贝技术，可以避免数据在内存和网络传输中的多次复制，提高数据访问和传输的效率。现代的操作系统和网络协议栈已经提供了对零拷贝技术的支持，使得开发者可以更方便地应用零拷贝技术来优化系统性能。</p><h2 id="那原来为什么还要涉及缓冲区？"><a href="#那原来为什么还要涉及缓冲区？" class="headerlink" title="那原来为什么还要涉及缓冲区？"></a>那原来为什么还要涉及缓冲区？</h2><p>在之前的代码示例中，使用了一个缓冲区（buffer）来读取文件数据并写入到输出文件中。这是因为在实际的文件读写操作中，使用缓冲区可以提高读写的效率。</p><p>缓冲区是一块内存区域，用于临时存储数据。它可以减少对底层存储设备的频繁访问，从而提高读写操作的效率。当我们从输入流中读取数据时，可以将数据先存储到缓冲区中，然后再一次性地将缓冲区中的数据写入到输出流中，而不是每次读取一个字节或一个字符就立即写入。</p><p>在示例代码中，buffer是一个字节数组，用于存储从输入流中读取的数据。bytesRead是实际读取的字节数。通过使用缓冲区，我们可以一次性读取多个字节，并将它们存储在缓冲区中。然后，我们使用outputFile.write(buffer, 0, bytesRead)将缓冲区中的数据写入到输出文件中。</p><p>使用缓冲区的好处是可以减少对磁盘或网络的频繁访问，从而提高读写操作的效率。通过一次性读取和写入多个字节，可以减少系统调用的次数，减少了读写操作的开销。此外，缓冲区还可以提供一些额外的功能，如数据的预读取和预写入，以进一步优化读写操作的性能</p><h2 id="缓冲区能减少磁盘I-O，是不是更好呢？"><a href="#缓冲区能减少磁盘I-O，是不是更好呢？" class="headerlink" title="缓冲区能减少磁盘I/O，是不是更好呢？"></a>缓冲区能减少磁盘I/O，是不是更好呢？</h2><p>虽然使用缓冲区可以提高读写操作的效率，但它仍然需要将数据从内核空间复制到用户空间，然后再从用户空间复制到输出通道（如磁盘或网络）。这些复制操作会增加额外的CPU和内存开销，并且可能成为性能瓶颈。</p><p>相比之下，零拷贝技术可以避免数据在内核空间和用户空间之间的多次复制，从而减少了CPU和内存的开销，提高了读写操作的效率。零拷贝技术通过直接在内核空间中操作数据，将数据从输入通道传输到输出通道，而无需在用户空间和内核空间之间复制数据。</p><p>使用零拷贝技术的好处包括：</p><ol><li>减少数据复制：零拷贝技术避免了数据在内核空间和用户空间之间的多次复制，减少了CPU和内存的开销。</li><li>提高系统吞吐量：通过减少数据复制和降低CPU和内存开销，零拷贝技术可以提高系统的吞吐量，使得系统能够更高效地处理大量的数据。</li><li>减少磁盘IO：零拷贝技术可以直接将数据从输入通道传输到输出通道，减少了对磁盘IO的需求，从而提高了读写操作的效率。</li></ol><p>需要注意的是，零拷贝并不是在所有情况下都比缓冲区更好。它的应用场景通常是在需要高性能和大数据处理的场景下，例如高速网络传输、大规模数据处理等。在一些简单的场景中，使用缓冲区已经足够满足需求，并且更易于实现和理解。因此，在选择使用零拷贝还是缓冲区时，需要根据具体的应用场景和需求进行权衡和选择。</p><p>没错，最后得出了最关键的要素，<strong>内核空间和用户空间</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;零拷贝技术（Zero-copy）是一种优化数据传输和处理的技术，旨在减少数据在内存之间的复制次数，提高系统性能和效率。&lt;/p&gt;
&lt;p&gt;在传统</summary>
      
    
    
    
    
    <category term="zero-copy" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/zero-copy/"/>
    
  </entry>
  
  <entry>
    <title>实践经验</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/12/20/Python-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/12/20/Python-1/</id>
    <published>2023-12-20T14:49:10.000Z</published>
    <updated>2024-02-18T13:10:58.128Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始对实习过程中的工程进行简单的总结，不涉及业务。</p><p>这里使用的py去实现一个后端架构，但是这里使用的后台框架并非是类似于Django或者是flask等框架。而是单纯使用原生的方式去实现，用法其实和C++写后台没有本质的区别，仅仅是因为编程语言不同。</p><p>这里的后端，其实也大绝大多数的后端架构类似，都是采用B/S三层架构，有专门的Controller层去接受请求，也有专门的ORM层去DB访问数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1703151599325-7ee23777-53cb-4f72-9931-2417cdabd6ab.png" alt="img"></p><p>这样的系统还是比较类似的，但是也有着很大的不同。</p><h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>比如说，这里的Controller层接受的不在是http请求，而是rpc请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service.reg(name='ExactReCall')</span></span><br><span class="line"><span class="meta">@rpc_log</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">ExactReCallUpdateEvaluateTask</span><span class="params">(ctx, req: mm_pb2.ExactReCallReq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        resp: mm_pb2.ExactReCallResp)</span>:</span></span><br></pre></td></tr></table></figure><p>这里的rpc协议请求使用的都是proto文件去定义的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.py -s=combo -f=ModifyBizTemplateSave --build</span><br></pre></td></tr></table></figure><p>通过命令去rebuild proto，s是模块，f是方法，这样会生成相应的proto映射文件</p><p>看到这里大家可能会感到疑惑，这个接口全都是rpc调用，难道前端会发起rpc请求吗？那当然不会，前端发起的显然都是http请求，不过中间有一层网关，会将所有的http请求都转为rpc请求，这一层的主要目的与单体服务无关，之所以要这么做最大的目的是为<strong>让所有的服务都能够互通</strong>。</p><p>这里可能和传统的Spring全家桶的微服务不一样，在以往的微服务架构之间，所有的前端发起，后端接收的请求都是http，而服务与服务之间发送的请求基本都是RPC，这可能是一种规范，为了提升效率的规范。但是我目前工作中使用的架构全都是基于Service Mesh的，也就是说，在所有的服务下面都有一层Mesh层，服务与服务之间不能够直接通信，就算是显示的发送RPC请求，服务的链路都是先传入底下的mesh层，再由mesh层传到目标服务的。</p><p>这种解决方案目的其实也是为了解开耦合，从而提供<strong>高内聚</strong>的能力，基本每个服务根本不用去在意自己的rpc，自己的基础设施，应该是什么样的版本，什么样的协议与组件。可以说，因为有了mesh层，可以极大的杜绝了重复造轮子导致的资源浪费。</p><h2 id="orm"><a href="#orm" class="headerlink" title="orm"></a>orm</h2><p>使用session = get_session()，可以根据需要去获取当前的session。目的是为了获取一个数据库会话对象。这里做了层层的封装，比如说当前的orm是否需要事务等等，都会进行一定程度的判定，最后才会返回一个最终的实例，我们就是通过操作这个实例，去进行保存和更新的。</p><p><strong>这里的做法不像是Spring全家桶的风格，不过倒是和Go后端非常相似</strong></p><p>可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017803857459008" target="_blank" rel="noopener">使用SQLAlchemy - 廖雪峰的官方网站</a></p><p>通过session.query去获取表后，根据使用需求进行操作，比如</p><p>session.query(表名).filter(</p><p>​    表名.属性 == aaa.bbb, 表名.属性 == aaa.bbb</p><p>).first()</p><p>这样就可以获取到相应的数据了，这种写法非常简单，基本没有什么特别难的点</p><p>我们还可以进入MySQL，show create table，  SHOW INDEX FROM 数据表；查看表信息，这些都是基本的操作了</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>梳理一下逻辑，现在主要学习如何去排查问题，这里使用原生的调试器，去排查问题。</p><p>Pdb是Python自带的调试器，它可以帮助你在程序运行时暂停程序的执行，查看变量的值，执行代码行，以及跟踪程序的执行流程。使用Pdb可以帮助你快速定位代码中的错误，并且可以提高代码的可读性和可维护性。</p><p>使用Pdb非常简单，只需要在代码中插入一行 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb; </span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(proto_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> proto_path:</span><br><span class="line">        pdb.set_trace()</span><br></pre></td></tr></table></figure><p>当程序执行到这一行时，程序会暂停执行并进入Pdb调试模式。在Pdb模式下，你可以使用一系列命令来查看变量的值，执行代码行，以及跟踪程序的执行流程。</p><p>例如：</p><p>可以使用p命令来查看变量的值</p><p>使用n命令来执行下一行代码</p><p>使用c命令来继续执行程序。</p><p>使用h命令是查看有哪些命令</p><p>可以使用args查看具体是什么问题</p><p>使用u和d分别对应上游和下游</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始对实习过程中的工程进行简单的总结，不涉及业务。&lt;/p&gt;
&lt;p&gt;这里使用的py去实现一个后端架构，但是这里使用的后台框架并非是类似于Django或者是flask等框架。而是单纯使用原生的方式去实现，用法其实和C++写后台没有本质的区别，仅仅是因为编程语言不同。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>补偿框架</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/11/02/compensate/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/11/02/compensate/</id>
    <published>2023-11-02T15:29:00.000Z</published>
    <updated>2024-02-18T13:13:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>这个框架主要的目的是为了当我们的服务涉及到与外部系统交互的时候，我们服务的事务和外部接口可能由于各种问题不能保证一致，出现两个系统数据不一致的情况，往往需要去手动处理数据。</p><h2 id="理论解决方案"><a href="#理论解决方案" class="headerlink" title="理论解决方案"></a>理论解决方案</h2><p>当服务涉及与外部系统交互时，确保数据一致性是一个重要的问题。以下是一些解决方案：</p><ol><li>使用分布式事务：如果外部系统支持分布式事务，可以使用分布式事务管理器（如Atomikos、Bitronix、Narayana等）来确保服务和外部接口的事务一致性。通过将服务和外部接口的操作纳入同一个分布式事务中，可以在两者之间实现原子性和一致性。</li><li>异步消息队列：将服务与外部接口的交互改为异步方式，使用消息队列作为中间件。服务将需要与外部接口交互的数据发送到消息队列中，然后由消费者异步处理。这样可以将服务和外部接口的事务解耦，即使其中一个失败，也不会影响另一个。如果发生故障，可以通过重试机制来保证数据最终一致性。</li><li>补偿机制：在服务与外部接口交互时，记录交互的操作和状态信息，以便在发生故障或数据不一致时进行补偿。可以使用补偿模式来处理这种情况，例如在服务中实现一个补偿机制，当发生故障时，自动触发补偿操作来修复数据不一致性。</li><li>重试和回滚：在与外部接口交互时，可以使用重试机制来处理临时的通信故障。如果发生故障，可以尝试重新发送请求，直到成功为止。另外，如果服务的事务失败，可以回滚事务并进行相应的错误处理。</li><li>监控和报警：建立监控系统来实时监测服务与外部接口的交互情况。通过监控指标和日志，可以及时发现潜在的数据不一致问题，并触发相应的报警机制，以便及时采取措施解决问题。</li></ol><p>这里其实最常见的是使用分布式事务去解决，但是其实这种解决方式其实不一定能适用于所有情况，比如说</p><ul><li>复杂性：分布式事务的实现相对复杂，需要引入额外的组件和技术栈，如分布式事务管理器、消息队列等。这增加了系统的复杂性和维护成本。</li><li>性能影响：分布式事务通常需要进行多次网络通信和资源协调，这可能导致性能开销增加。特别是在高并发和大规模系统中，分布式事务的性能问题可能会成为瓶颈。</li><li>扩展性限制：分布式事务在跨多个服务和数据库进行协调时，可能会受到扩展性的限制。当系统需要水平扩展时，分布式事务可能会成为限制因素，因为它需要全局锁和协调。</li><li>依赖外部系统：使用分布式事务时，需要确保外部系统也支持分布式事务。如果外部系统不支持或与服务的事务管理器不兼容，可能需要进行额外的工作来解决这个问题。</li><li>高可用性和故障恢复：分布式事务的高可用性和故障恢复是一个挑战。当分布式事务管理器或其他组件发生故障时，需要有相应的机制来处理故障并保证数据的一致性。</li><li>学习和开发成本：使用分布式事务需要对相关技术和概念有一定的了解，并且需要在开发过程中遵循一些规范和最佳实践。这可能需要额外的学习和培训成本。</li></ul><p>综上所述，尽管分布式事务可以解决数据一致性的问题，但也需要权衡其复杂性、性能开销和扩展性限制等因素。在设计和选择系统架构时，需要综合考虑业务需求、系统规模和可用性要求，选择适合的事务处理方式。</p><p>所以为了避免将整个系统变得更加复杂，这里其实并不建议使用分布式事务，其次，这里还涉及到需要去增加维护，增加耦合，其实是非常不推荐的做法，也比如说使用MQ，其实也是一样的，需要多一个维护。</p><p>再细说一下MQ的解决方案</p><p>补偿机制和消息队列（MQ）是两种不同的处理方式，适用于不同的场景。以下是一些情况下可以考虑使用补偿机制而不使用消息队列：</p><ol><li>低延迟要求：如果系统对低延迟有较高要求，即需要实时或近实时的处理能力，使用补偿机制可能更为合适。补偿机制通常是同步或异步的方式，可以直接在服务内部进行处理，而不需要依赖消息队列的异步处理和传递。</li><li>简化架构：使用消息队列需要引入额外的组件和技术栈，如消息中间件、消息生产者和消费者等。如果系统的架构相对简单，没有复杂的异步消息传递需求，使用补偿机制可以简化系统架构，减少复杂性和维护成本。</li><li>有限的系统规模：如果系统规模相对较小，没有大规模的并发和高吞吐量的需求，使用补偿机制可以更轻量级地处理事务和数据一致性，而不需要引入消息队列的复杂性。</li><li>事务性操作：如果需要进行事务性的操作，即需要保证一组操作的原子性和一致性，使用补偿机制可能更为合适。补偿机制可以在事务内部进行操作和补偿，而不需要依赖消息队列的事务性支持。</li></ol><p>但是结合我们的场景，其实并不需要低延迟，而更多的是需要调通不同渠道的接口，所以，这里需要去实现简单，无侵入式，高可用，低耦合的框架，所以，再三选择之下，还是补偿机制更合适。</p><p>这里推荐使用自己去实现一个补偿机制</p><h3 id="补偿机制"><a href="#补偿机制" class="headerlink" title="补偿机制"></a>补偿机制</h3><p>补偿机制和分布式事务是两种不同的处理方式，适用于不同的场景。以下是一些情况下可以考虑使用补偿机制而不是分布式事务：</p><ol><li>高可扩展性要求：如果系统需要高度可扩展性，即需要支持大规模的并发和水平扩展，使用分布式事务可能会成为限制因素。在这种情况下，可以考虑使用补偿机制，将服务的事务解耦，通过异步处理和补偿操作来保证数据的一致性。</li><li>异构系统集成：当系统需要与多个异构的外部系统进行集成时，这些外部系统可能不支持分布式事务或与服务的事务管理器不兼容。在这种情况下，使用补偿机制可以更灵活地处理与外部系统的交互，通过记录操作和状态信息，进行补偿操作来保证数据的一致性。</li><li>高可用性和故障恢复：补偿机制可以更好地应对系统的高可用性和故障恢复需求。当发生故障或数据不一致时，补偿机制可以自动触发补偿操作来修复数据，而无需依赖全局的分布式事务协调。</li><li>非关键业务操作：对于一些非关键的业务操作，数据一致性要求可能相对较低。在这种情况下，使用补偿机制可以提供更好的性能和可扩展性，而不需要引入复杂的分布式事务。</li></ol><h2 id="生产环境遇到的问题"><a href="#生产环境遇到的问题" class="headerlink" title="生产环境遇到的问题"></a>生产环境遇到的问题</h2><p>目前常见的处理手段及存在的问题</p><p>手段1: 本地数据库操作和外部接口调用放在同一个事务中</p><p>问题：外部接口成功，本地事务由于异常原因回滚，数据不一致</p><p>手段2:本地数据库事务提交后，再调用外部接口</p><p>问题：本地事务成功后，外部接口失败或者机器挂掉，数据不一致</p><p>手段3:使用mq、redis临时存储消息，后续消费</p><p>问题：mq、redis本身就是一个外部系统，一样存在问题</p><p>rocketmq提供了和本地事务一致的机制，但是需要申请维护mq且实现一套消费逻辑</p><h3 id="设计一个补偿框架"><a href="#设计一个补偿框架" class="headerlink" title="设计一个补偿框架"></a>设计一个补偿框架</h3><p>这里考虑到无侵入式，和开箱即用，所以考虑将整个流程，融入到Spring的生命周期。并且，使用注解的方式去标注需要调用外部接口的方法，然后当接口调用失败的时候，会存入数据库，然后隔一段时间再去调用，并且为了加强效率，也会使用线程池去增强实现。</p><p>现在设计的补偿框架，主要有几个功能：</p><ul><li>在启动的时候，可以扫描整个包，看看哪里用到了@Component注解，将所有用到了这个注解的，都加入到hashmap中，从而全局持有这个方法的信息。</li><li>然后，可以去使用执行链设计模式，去创建一个执行链，将需要的方法通通加入链上，分批次执行相关的方法</li><li>对于每次执行方法，必然会出现成功或者是失败的状况，如果出现执行失败的情况，可以将其写入到数据库中，等待后续再逐步从数据库中读出相应的数据，然后去尝试不断的重新执行方法。</li><li>在执行方法的时候，可以使用一个AOP切面，去根据注解信息去拦截想要执行的方法，然后先将方法持久化到数据库中，再执行相关的方法，如果执行成功，再去删除相应的ID，其次，如果执行失败，则暂时不做任何行为，因为还有定时任务去执行。</li><li>那么对于那些执行失败的任务怎么办？对于失败的任务，就会定时的去数据库中读取出来，然后去进行反复的重试，直到成功为止。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个框架主要的目的是为了当我们的服务涉及到与外部系统交互的时候，我们服务的事务和外部接口可能由于各种问题不能保证一致，出现两个系统数据不一致的情况，往往需要去手动处理数据。&lt;/p&gt;
&lt;h2 id=&quot;理论解决方案&quot;&gt;&lt;a href=&quot;#理论解决方案&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring高级注解与接口</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/08/28/ab-12yebjavab/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/08/28/ab-12yebjavab/</id>
    <published>2023-08-28T13:33:31.000Z</published>
    <updated>2024-02-18T13:11:25.856Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始记录一些学到的强力的注解和接口</p><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>CommandLineRunner是Spring Boot框架中的一个接口，用于定义在应用程序启动后执行的任务。它包含一个run方法，该方法在应用程序启动后被调用，并接收命令行参数作为参数。<br>具体来说，CommandLineRunner接口的作用是允许开发人员在应用程序启动后执行一些初始化或后续操作的逻辑。通过实现CommandLineRunner接口并重写run方法，你可以在应用程序启动后执行自定义的逻辑代码。<br>当应用程序启动时，Spring Boot会自动扫描并检测实现了CommandLineRunner接口的Bean，并在启动后调用它们的run方法。这样，你可以在应用程序启动后执行一些必要的初始化任务，例如加载数据、启动定时任务、建立连接等。<br>在CommandLineRunner接口的run方法中，你可以编写任何你希望在应用程序启动后执行的代码。该方法可以抛出Exception异常，因此你可以在其中处理任何可能发生的异常情况。<br>总结起来，CommandLineRunner接口允许你在应用程序启动后执行自定义的逻辑代码。通过实现该接口并重写run方法，你可以在应用程序启动后执行一些初始化或后续操作的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"ConfigProperties properties:&#123;&#125;"</span>, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>@PostConstruct是Java标准库中的一个注解，它用于标记一个方法，在对象创建后立即执行。在Spring框架中，@PostConstruct注解被用于定义在Bean初始化之后执行的方法。</p><p>具体来说，当一个Bean被实例化并完成依赖注入后，Spring容器会检测该Bean中是否存在被@PostConstruct注解标记的方法。如果存在，Spring容器会在Bean初始化完成后立即调用该方法。</p><p>@PostConstruct注解的作用是允许开发人员在Bean初始化之后执行一些自定义的初始化逻辑。这些逻辑可以包括数据加载、资源初始化、建立连接等操作。通过在方法上添加@PostConstruct注解，你可以确保在Bean完全初始化之后执行这些操作。</p><p>需要注意的是，@PostConstruct注解只能用于非静态方法，并且只能标记一个方法。如果在一个类中存在多个被@PostConstruct注解标记的方法，它们的执行顺序是不确定的。</p><p>总结起来，@PostConstruct注解用于标记一个方法，在Bean初始化之后立即执行。它允许开发人员在Bean初始化完成后执行一些自定义的初始化逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String targetService = properties.getTargetService();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(targetService))&#123;</span><br><span class="line">        targetService = System.getenv(<span class="string">"TService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CompensateContextHolder.setTargetService(targetService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p>@ConditionalOnProperty是Spring Boot框架中的一个条件注解，用于根据配置属性的值来决定是否启用或禁用特定的组件或配置。<br>具体来说，@ConditionalOnProperty注解用于在特定的配置属性满足条件时才加载或启用某个组件。它接收一个或多个属性参数，用于指定要检查的配置属性的名称和期望的值。<br>比如：@ConditionalOnProperty注解的value参数设置为”compensate.enabled”，表示要检查名为”compensate.enabled”的配置属性。而havingValue参数设置为”true”，表示期望该配置属性的值为”true”。<br>因此，当配置属性”compensate.enabled”的值为”true”时，被注解的组件或配置将被加载或启用。如果配置属性的值不是”true”，则被注解的组件或配置将被禁用或忽略。<br>这个注解通常用于根据配置属性的值来决定是否启用某些特定的功能或组件。通过使用@ConditionalOnProperty注解，你可以根据配置属性的值来动态地控制应用程序的行为，使其更加灵活和可配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"compensate.enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompensateManager <span class="title">compensateManager</span><span class="params">(DataSource dataSource, CompensateExecutionChain chain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompensateManager(properties, dataSource, chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NestedConfigurationProperty"><a href="#NestedConfigurationProperty" class="headerlink" title="@NestedConfigurationProperty"></a>@NestedConfigurationProperty</h2><p>@NestedConfigurationProperty是Spring框架中的一个注解，用于指示一个属性应该被视为嵌套的配置属性。它通常用于嵌套类中的属性，以便在配置文件中以嵌套的方式组织属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="keyword">private</span> String country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Employee类包含一个嵌套类Address，它表示员工的地址信息。Address类具有三个属性：street、city和country。<br>通过这种方式，可以在Employee类中组织员工的信息，并将地址信息作为嵌套类的属性。这样，可以更清晰地表示员工对象的结构，并在配置文件中以嵌套的方式配置地址信息。<br>在配置文件中，可以使用以下方式配置Employee对象的属性和Address对象的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">employee.name=John Doe</span><br><span class="line">employee.age=<span class="number">30</span></span><br><span class="line">employee.address.street=<span class="number">123</span> Main St</span><br><span class="line">employee.address.city=New York</span><br><span class="line">employee.address.country=USA</span><br></pre></td></tr></table></figure><p>这样，就可以通过嵌套类的方式组织和配置复杂的对象结构。</p><h2 id="InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessorAdapter</h2><p>InstantiationAwareBeanPostProcessorAdapter是Spring框架中的一个接口，它是InstantiationAwareBeanPostProcessor接口的适配器类。这个接口在Spring的Bean生命周期中扮演着重要的角色。<br>InstantiationAwareBeanPostProcessor接口定义了一组回调方法，用于在Spring容器实例化Bean之前和之后进行自定义处理。而InstantiationAwareBeanPostProcessorAdapter是一个适配器类，它提供了默认的空实现，使得我们可以只关注我们感兴趣的回调方法，而不需要实现接口中的所有方法。<br>这个接口的作用是允许开发者在Bean实例化的不同阶段进行自定义的处理。它提供了以下几个重要的回调方法：<br>postProcessBeforeInstantiation(): 在实例化Bean之前调用，允许开发者返回一个自定义的Bean实例，或者返回null来使用默认的实例化机制。<br>postProcessAfterInstantiation(): 在实例化Bean之后调用，允许开发者对实例进行自定义的处理，例如修改属性值或执行其他初始化操作。<br>postProcessPropertyValues(): 在Bean的属性注入之前调用，允许开发者对属性值进行自定义的处理，例如修改属性值或验证属性的合法性。<br>通过实现InstantiationAwareBeanPostProcessor接口或使用InstantiationAwareBeanPostProcessorAdapter适配器类，开发者可以在Bean实例化的不同阶段进行自定义的处理。这样，我们可以在Spring容器实例化Bean时，对Bean进行额外的操作或修改，以满足特定的需求。<br>以下是一个简单的示例，展示了如何使用InstantiationAwareBeanPostProcessorAdapter接口来自定义处理Bean实例化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == MyBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之前，返回一个自定义的Bean实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">"Custom Instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null，使用默认的实例化机制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyBean) &#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之后，对其进行自定义的处理</span></span><br><span class="line">            MyBean myBean = (MyBean) bean;</span><br><span class="line">            myBean.setSomeProperty(<span class="string">"Custom Property Value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个名为CustomBeanPostProcessor的类，它继承自InstantiationAwareBeanPostProcessorAdapter适配器类。我们重写了postProcessBeforeInstantiation()和postProcessAfterInstantiation()方法来实现自定义的处理逻辑。<br>在postProcessBeforeInstantiation()方法中，我们检查要实例化的Bean是否是MyBean类。如果是，我们返回一个自定义的MyBean实例，否则返回null，使用默认的实例化机制。<br>在postProcessAfterInstantiation()方法中，我们检查实例化后的Bean是否是MyBean类的实例。如果是，我们对其进行自定义的处理，例如设置属性值。<br>通过使用CustomBeanPostProcessor类，我们可以在Bean实例化的过程中对特定的Bean进行自定义处理。这样，我们可以根据需要修改Bean的实例或属性，以满足特定的业务逻辑或需求。</p><h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><p>ApplicationContextAware接口是Spring框架中的一个接口，用于实现对应用程序上下文（ApplicationContext）的感知。<br>该接口继承自Aware接口，通过实现ApplicationContextAware接口，可以让Bean获取对应用程序上下文的引用，并在需要时进行操作。<br>具体来说，ApplicationContextAware接口定义了一个方法setApplicationContext(ApplicationContext var1)，当Bean被实例化并注入到Spring容器中时，Spring容器会自动调用该方法，并将当前的应用程序上下文作为参数传递进来。<br>通过实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文的引用，并利用它来进行一些操作，例如获取其他Bean、发布事件、访问资源等。<br>一般来说，这么整就行了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来，ApplicationContextAware接口的作用是让Bean获取对应用程序上下文的引用，以便在需要时进行操作。通过实现该接口并实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文，并利用它进行各种操作。</p><h2 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h2><p>@Aspect注解是Spring框架中的一个注解，用于声明一个切面（Aspect）。切面是一种用于横切关注点（Cross-cutting Concerns）的模块化方式，它可以定义一组通用的横切逻辑，并将其应用到多个目标对象中。<br>具体来说，@Aspect注解用于标记一个类为切面类，该类中定义了一些通用的横切逻辑，例如日志记录、性能监控、事务管理等。切面类通常包含一些切点（Pointcut）和通知（Advice）的定义。</p><ul><li>切点（Pointcut）：切点定义了在哪些连接点（Join Point）上应用通知。连接点是程序执行过程中可以插入切面逻辑的点，例如方法调用、方法执行、异常抛出等。切点通过表达式或注解来定义，用于匹配符合条件的连接点。</li><li>通知（Advice）：通知定义了在切点上执行的具体逻辑。通知可以在切点之前、之后、抛出异常时等不同的时机执行。常见的通知类型包括前置通知（Before）、后置通知（After）、返回通知（AfterReturning）和异常通知（AfterThrowing）等。</li></ul><p>通过使用@Aspect注解，Spring框架可以识别并将切面类纳入到AOP（面向切面编程）的管理中。在运行时，Spring会根据切点和通知的定义，将切面逻辑织入到目标对象的相应连接点上，从而实现横切关注点的功能。<br>要使用切面，需要完成以下步骤：</p><ol><li>在Spring配置文件中启用AOP的自动代理功能。可以使用<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a>标签或@EnableAspectJAutoProxy注解来实现。这将告诉Spring框架在运行时自动创建代理对象，并将切面逻辑织入到目标对象的连接点上。</li><li>创建目标对象。目标对象是需要应用切面逻辑的对象。可以是任何Spring管理的Bean，例如服务类、控制器等。</li><li>创建切面类。切面类是包含切点和通知的类。使用@Aspect注解标记切面类，并在其中定义切点和通知的方法。</li><li>在切面类中定义切点。切点定义了在哪些连接点上应用通知。可以使用表达式或注解来定义切点，以匹配符合条件的连接点。</li><li>在切面类中定义通知。通知定义了在切点上执行的具体逻辑。可以使用@Before、@After、@AfterReturning、@AfterThrowing等注解来定义不同类型的通知。</li><li>运行应用程序。当目标对象的方法被调用时，切面逻辑会自动织入到连接点上，根据切点和通知的定义执行相应的逻辑。</li></ol><p>以下是一个简单的示例，演示如何使用切面类来实现日志记录的横切逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        MyService myService = context.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        myService.doSomething();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Doing something..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.example.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethodExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个MyService类作为目标对象，其中包含一个doSomething()方法。我们还创建了一个LoggingAspect类作为切面类，其中定义了一个前置通知，用于在目标对象的方法执行之前记录日志。<br>在MainApp类中，我们使用AnnotationConfigApplicationContext来加载Spring配置，并获取MyService的实例。当调用myService.doSomething()方法时，切面类中的前置通知会被触发，输出日志信息：”Before method execution: Logging…”。<br>通过以上步骤，我们成功地将切面逻辑应用到目标对象的连接点上，实现了日志记录的横切逻辑<br>总结起来，@Aspect注解用于声明一个切面类，该类中定义了切点和通知，用于实现横切关注点的功能。通过使用@Aspect注解，Spring框架可以识别并管理切面类，将切面逻辑织入到目标对象的连接点上。</p><h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>@Around是一个用于定义环绕通知的注解。在Spring AOP中，环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。<br>使用@Around注解可以将一个方法标记为环绕通知方法。这个方法会在目标方法执行之前和之后执行，可以在这个方法中编写自定义的逻辑来控制目标方法的执行。<br>环绕通知方法需要满足一些要求：</p><ul><li>方法的返回类型可以是任意类型，通常是Object。</li><li>方法的参数可以是ProceedingJoinPoint类型，用于执行目标方法，也可以是其他参数，根据需要进行定义。</li></ul><p>在环绕通知方法中，可以通过调用ProceedingJoinPoint对象的proceed()方法来执行目标方法。在调用proceed()方法之前，可以在目标方法执行前进行一些前置操作，而在调用proceed()方法之后，可以在目标方法执行后进行一些后置操作。通过使用@Around注解，我们可以更灵活地控制目标方法的执行过程，例如在执行前后进行日志记录、性能监控、事务管理等操作。<br>比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.example.service.MyService.doSomething(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"After method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个LoggingAspect切面类，并在其中使用@Around注解标记了一个环绕通知方法aroundAdvice()。该方法接受一个ProceedingJoinPoint参数，用于执行目标方法。<br>在aroundAdvice()方法中，我们首先输出了一条日志信息，表示在目标方法执行之前的前置操作。然后，通过调用joinPoint.proceed()方法，执行了目标方法。最后，我们又输出了一条日志信息，表示在目标方法执行之后的后置操作。<br>通过这个示例，我们可以在目标方法执行前后添加自定义的逻辑，例如记录日志、计算方法执行时间等。这样，每次调用MyService的doSomething()方法时，都会触发切面的环绕通知方法。</p><h3 id="Aspect和-Around"><a href="#Aspect和-Around" class="headerlink" title="@Aspect和@Around"></a>@Aspect和@Around</h3><p>@Aspect和@Around是Spring AOP框架中的两个不同的注解，它们在AOP的实现中扮演不同的角色。</p><ul><li>@Aspect注解用于标记一个类为切面类。切面类是包含切面逻辑的类，它定义了在哪些连接点上应用切面逻辑，并且可以包含多个通知类型（如前置通知、后置通知、环绕通知等）。通过使用@Aspect注解，我们可以将一个普通的类声明为切面类，以便在Spring AOP中使用。</li><li>@Around注解是一个通知类型的注解，用于定义环绕通知。环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。通过使用@Around注解，我们可以将一个方法标记为环绕通知方法，以便在切面中定义自定义的逻辑。</li></ul><p>因此，@Aspect注解用于标记切面类，而@Around注解用于标记环绕通知方法。切面类可以包含多个通知类型的方法，而环绕通知方法是其中的一种。切面类通过@Aspect注解告诉Spring AOP框架它是一个切面类，而环绕通知方法通过@Around注解告诉框架它是一个环绕通知方法。</p><p>综上所述，@Aspect和@Around是Spring AOP框架中的两个不同的注解，用于不同的目的。@Aspect用于标记切面类，而@Around用于标记环绕通知方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里开始记录一些学到的强力的注解和接口&lt;/p&gt;
&lt;h2 id=&quot;CommandLineRunner&quot;&gt;&lt;a href=&quot;#CommandLineRunner&quot; class=&quot;headerlink&quot; title=&quot;CommandLineRunner&quot;&gt;&lt;/a&gt;CommandL</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>高性能队列：Disruptor</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/04/14/Disruptor-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/04/14/Disruptor-1/</id>
    <published>2023-04-14T14:01:04.000Z</published>
    <updated>2023-12-14T14:02:57.819Z</updated>
    
    <content type="html"><![CDATA[<p><a name="oYoyt"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易所中的低延迟和高吞吐量需求而设计的。它主要用来解决在多线程环境中生产者和消费者之间的数据传递问题。Disruptor 由 LMAX 的 Martin Thompson 和 Dave Farley 于 2011 年发明，现在是一个开源项目。</p><blockquote><p>The Disruptor is the result of our efforts to build the world’s highest performance financial exchange at LMAX. Early designs focused on architectures derived from SEDA [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_1" target="_blank" rel="noopener">1</a>] and Actors [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_2" target="_blank" rel="noopener">2</a>] using pipelines for throughput. After profiling various implementations it became evident that the queuing of events between stages in the pipeline was dominating the costs. We found that queues also introduced latency and high levels of jitter. We expended significant effort on developing new queue implementations with better performance. However it became evident that queues as a fundamental data structure are limited due to the conflation of design concerns for the producers, consumers, and their data storage. The Disruptor is the result of our work to build a concurrent structure that cleanly separates these concerns.</p></blockquote><p>Disruptor 的核心思想是，通过使用环形的数据结构（RingBuffer）和避免锁来实现数据的高速传递。RingBuffer 类似于一个循环队列，内部包含一个预先分配好的对象数组，该数组的大小为 2 的幂次方。这样设计的一个原因是可以通过位运算快速计算数组中的索引，提升性能。创建此环形数据结构后，生产者可以将事件（通常是某个类的实例）发布到 RingBuffer 的下一个可用位置，同时消费者可以从 RingBuffer 中读取和处理事件。通过使用序号（Sequence）来表示 RingBuffer 中各个条目的位置，生产者和消费者之间可以实现非阻塞的协同工作模式，从而达到最大的性能优势。<br />Disruptor 还支持多个生产者和多个消费者的场景，消费者可以独立处理事件，也可以按照依赖关系顺序进行处理。这使得Disruptor 可以在保持低延迟的同时，实现并行处理并提高整体系统吞吐量。</p><p>那Disruptor相比于Java内置的队列而言，有什么优势呢，这里需要进一步的分析<br><a name="CVc3m"></a></p><h2 id="Java的内置队列"><a href="#Java的内置队列" class="headerlink" title="Java的内置队列"></a>Java的内置队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232326187-0473b7b4-ba77-4943-a805-2a343871d150.png#averageHue=%23e1e1e1&clientId=u294810c7-fb47-4&from=paste&height=186&id=ud6f9c576&originHeight=372&originWidth=1212&originalType=binary&ratio=2&rotation=0&showTitle=false&size=68156&status=done&style=none&taskId=ub09db3d5-5196-46d9-acc2-89707ac10fe&title=&width=606" alt="image.png"><br />在Java中ArrayBlockingQueue是靠锁去控制它的并发安全的，而且是有界的队列。</p><p>ArrayBlockingQueue（数组阻塞队列）通过内部的锁（ReentrantLock）和两个条件变量（Condition）notEmpty和notFull来保证线程安全。</p><ol><li>ReentrantLock（可重入锁）：ArrayBlockingQueue使用ReentrantLock作为内部的锁来控制对队列的访问。在读取、写入、删除等操作时，需要先获取锁，完成操作后再释放锁。使用lock及unlock方法对数据进行保护，确保同一时刻只有一个线程能执行特定的操作。 </li><li>条件变量（Condition）：ArrayBlockingQueue有两个Condition，分别是notEmpty和notFull。当队列为空时，使用notEmpty.await()方法阻塞读线程；当队列满时，使用notFull.await()方法阻塞写线程。当数据被删除后，notEmpty.signal()唤醒读线程继续读取；当数据被添加后，notFull.signal()唤醒写线程继续写入。 </li></ol><p>通过这些同步措施，ArrayBlockingQueue确保了在多线程环境下的线程安全性<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232394025-16fa469d-9921-4e33-acb5-4c8d725374d4.png#averageHue=%232d2d2d&clientId=u294810c7-fb47-4&from=paste&height=236&id=u00680c6f&originHeight=472&originWidth=1282&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44409&status=done&style=none&taskId=u06f63704-23cf-4250-8d9c-269cc5fecf6&title=&width=641" alt="image.png"><br />而LinkedTransferQueue都是通过原子变量CAS这种不加锁的方式来实现的，但是它们都是使用链表的方式去实现的，这种方式的会出现两个问题，一个是由于无界导致的OOM，一个是这种数据结构也会影响到JVM的GC效率，所以，在大多数时候，还是使用ArrayBlockingQueue比较的常见，那么，ArrayBlockingQueue 有什么问题呢。</p><p><a name="oLbbN"></a></p><h3 id="加锁导致的效率问题"><a href="#加锁导致的效率问题" class="headerlink" title="加锁导致的效率问题"></a>加锁导致的效率问题</h3><p>这里引用LMAX交易所的数据：</p><blockquote><p>We will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which increments a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel Westmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar across all languages with the same basic primitives.<br>Once a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up significantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results of this simple experiment are shown in the table below:</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233609316-d2ddb2d5-2975-480c-a740-3463916fb39e.png#averageHue=%23fbfafa&clientId=u294810c7-fb47-4&from=paste&height=367&id=ua84c85bb&originHeight=734&originWidth=2064&originalType=binary&ratio=2&rotation=0&showTitle=false&size=113743&status=done&style=none&taskId=u86ed9446-fa4e-421c-9e57-fa897f4eea4&title=&width=1032" alt="image.png"><br />这里LMAX使用一个程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。测试结果显然，加锁与CAS的差别还是比较大的。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233889498-6c9beec5-949e-4088-b74e-00bdb38af9a0.png#averageHue=%232b2b2b&clientId=u294810c7-fb47-4&from=paste&height=492&id=ub7be082a&originHeight=984&originWidth=1434&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126074&status=done&style=none&taskId=uced54ebb-973c-4a4b-a939-456ce64a777&title=&width=717" alt="image.png"><br />这个加锁加在了offer，以此来保证线程的安全性，但是这样的方式显然会损失不少性能。<br />而CAS的呢，这里则使用了unsafe去使用魔法，使其不加锁的情况下，仍然可以保证线程安全：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234138046-0d2ed826-05bc-459f-87de-af5aa633a9e4.png#averageHue=%232d2c2b&clientId=u294810c7-fb47-4&from=paste&height=189&id=u78cb1884&originHeight=378&originWidth=1370&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79015&status=done&style=none&taskId=uad351660-7a33-427d-a31f-ae88e1069cb&title=&width=685" alt="image.png"></p><p>那为什么ArrayBlockingQueue非要加锁<br />看到这里大家可能会有一个疑惑，那为什么ArrayBlockingQueue不用cas而选择加锁呢？<br />使用ArrayBlockingQueue而非CAS的原因主要包括以下几点：</p><ol><li>锁的简化。ArrayBlockingQueue适用于生产者和消费者的场景。当队列为空时，消费者线程需要等待；当队列已满时，生产者线程需要等待。这种有固定边界的队列在这种场景下可以简化设计。通过使用锁，可以简化这种等待-通知的逻辑。锁本身支持等待-通知机制，使用条件变量Condition实现。 </li><li>性能。考虑到在有边界的队列情况下，竞争可能会比较激烈。当队列为空或已满时，CAS操作可能会导致大量的失败尝试和自旋。这会影响性能，并消耗更多的CPU资源。而在这些竞争激烈的情况下，锁的性能往往优于CAS操作。 </li><li>简单性。相比于使用CAS操作实现的非阻塞数据结构，使用锁实现的数据结构通常更容易理解和实现。这意味着更少的错误和更容易维护的代码。 </li></ol><p>而Disruptor是一个高性能队列库，它的设计初衷是为了解决高并发、低延迟的场景。Disruptor之所以能够使用CAS（Compare And Swap）操作，主要是基于以下几个原因：</p><ol><li>缓存行填充。Disruptor利用缓存行填充（Cache Line Padding）来减少伪共享（False Sharing）的问题。伪共享会导致缓存行失效，从而影响性能。通过将生产者和消费者的指针放置在不同的缓存行上，避免了伪共享问题，从而提高了使用CAS操作的性能。 </li><li>锁消除。Disruptor消除了锁的使用，通过使用原子操作（如CAS）进行并发控制。这减少了锁带来的开销，提高了性能。在高并发场景下，锁的竞争可能会导致严重的性能问题，而CAS操作可以更好地支持这些场景。 </li><li>数据结构设计。Disruptor的数据结构设计是基于环形缓冲区（Ring Buffer）的，这使得它在内存分配和管理上更加高效。通常情况下，无锁队列的设计和实现相对复杂，但Disruptor通过使用环形缓冲区，将其复杂程度降低，使得CAS操作的实现变得可行。 </li><li>无阻塞。Disruptor采用无阻塞算法，避免了死锁、阻塞等问题。在高并发场景下，无阻塞算法通常具有更好的伸缩性。当线程之间存在很多竞争时，锁定资源可能会导致性能瓶颈。而CAS操作提供了一种无锁的方式来解决资源竞争问题。 </li><li>批处理。Disruptor支持批处理，它可以将多个操作组合在一起执行。这样可以充分利用CPU缓存、减少上下文切换，从而提高CAS操作的性能。 </li></ol><p>Disruptor之所以能够使用CAS操作，主要是因为其数据结构设计、缓存行填充、无锁算法和批处理等技术的应用。这些技术使得Disruptor在高并发和低延迟场景下具有优秀的性能，满足了高性能队列的需求。<br><a name="XJbbR"></a></p><h3 id="被破坏的共享"><a href="#被破坏的共享" class="headerlink" title="被破坏的共享"></a>被破坏的共享</h3><p>这里需要提一提一个比较底层的知识，那就是CPU的三级cache：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238904423-7c2ab82a-340e-4193-933d-f40108692896.png#averageHue=%23f4f4f4&clientId=u294810c7-fb47-4&from=paste&height=703&id=u96748072&originHeight=1406&originWidth=1502&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275200&status=done&style=none&taskId=u7bb6a08a-075c-48ad-ade2-9790ddae633&title=&width=751" alt="4-modified.png"><br />CPU的三级缓存，即L1、L2和L3缓存，是一种位于CPU内部的高速存储器。它们主要用于存储那些频繁使用的数据和指令，从而提高CPU处理速度。<br />L1缓存（一级缓存）：它是CPU内部最接近执行单元的缓存，速度非常快，但存储容量相对较小，通常在32KB-64KB之间。L1缓存通常分为数据缓存（用于存储操作数）和指令缓存（用于存储已经预取的指令）。<br />L2缓存（二级缓存）：它位于L1缓存之后，速度略低于L1缓存，但具有较大的存储容量，通常在256KB到8MB之间。L2缓存通常用于存储那些不太频繁使用的数据和指令。在某些CPU设计中，L2缓存可能是共享的，这意味着它可以存储来自不同执行单元的数据和指令。<br />L3缓存（三级缓存）：它位于L2缓存之后，速度低于L2缓存，但在容量和访问速度方面，它将较之主存储器（例如DDR RAM）有很大优势。L3缓存容量范围通常在8MB至32MB之间，但在某些高端处理器中可能更大。L3缓存主要用于在L2缓存中未命中的数据和指令的存储，它可以在多个核之间共享。<br />这种分级存储的方式有效地将处理器的计算能力靠近主存储器的速度。当CPU需要访问数据或指令时，它首先检查L1缓存，然后是L2缓存，最后是L3缓存。如果三级缓存都未命中，CPU将从主存储器中获取数据。由于L1、L2和L3缓存的访问速度逐级降低，但存储容量逐级增加，因此它们一起建立了一个高效的层次结构，将最频繁使用的内容存储在越来越快的缓存中，从而提高处理速度。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234350571-75b183be-3153-4664-aaa3-c841032acea7.png#averageHue=%23e5e5e5&clientId=u294810c7-fb47-4&from=paste&height=135&id=u26a1a90a&originHeight=226&originWidth=1246&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35435&status=done&style=none&taskId=u35f7847f-ab8f-4446-9329-30b47597cde&title=&width=742" alt="image.png"><br><a name="zGraA"></a></p><h4 id="共享缓存带来的影响"><a href="#共享缓存带来的影响" class="headerlink" title="共享缓存带来的影响"></a>共享缓存带来的影响</h4><p>缓存由许多缓存行组成。通常情况下，每个缓存行包含64字节，它们有效地引用了主内存中的一系列地址。在这种情况下，一个Java的long类型变量占用8字节，所以一个缓存行可以容纳8个long类型的变量。<br />当CPU从主存中获取数据时，相邻的数据也会被存储到相同的缓存行中。<br />在访问一个long类型的数组时，如果数组中的一个值被加载到缓存中，相邻的7个值也会自动被加载。这使得你可以快速地遍历该数组。实际上，在连续的内存块中分配的任何数据结构都可以被快速遍历。<br />以下示例展示了利用缓存行特性与不利用缓存行特性之间效果的对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineEffect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//考虑一般缓存行大小是64字节，一个 long 类型占8字节</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">long</span>[][] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">                sum = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">1024</span> * <span class="number">1024</span>;j++)&#123;</span><br><span class="line">                sum = arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234667637-b701dcd8-2230-437d-8483-dd0adece47f8.png#averageHue=%23303030&clientId=u294810c7-fb47-4&from=paste&height=62&id=uc4c05076&originHeight=124&originWidth=622&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10940&status=done&style=none&taskId=u021fd135-9ce1-4a0c-a783-98314c511c7&title=&width=311" alt="image.png"><br><a name="NRlFb"></a></p><h4 id="那么缓存与ArrayBlockingQueue有什么关系呢？"><a href="#那么缓存与ArrayBlockingQueue有什么关系呢？" class="headerlink" title="那么缓存与ArrayBlockingQueue有什么关系呢？"></a><strong>那么缓存与ArrayBlockingQueue有什么关系呢？</strong></h4><p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量<br />这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234428482-ef2034bb-27f7-41f5-a649-5ecfd622a3b3.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=327&id=u0f02d98d&originHeight=654&originWidth=1966&originalType=binary&ratio=2&rotation=0&showTitle=false&size=131679&status=done&style=none&taskId=u1010804e-920f-4f30-9e79-f63781197f8&title=&width=983" alt="3-modified.png"><br />如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。<br />这种无法充分使用缓存行特性的现象，称为伪共享。<br />对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。<br /><strong>不知道大家有没有看过《Java并发编程艺术》，那本书也写了有无共享缓存导致的区别</strong><br /><strong>而解决伪共享的最好方法，就是填充</strong><br />下面是一个验证程序，去表达有填充和无填充导致的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValueNoPadding[] longs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            runTest(i);</span><br><span class="line">            System.out.println(<span class="string">"Thread num "</span> + i + <span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        longs = <span class="keyword">new</span> ValueNoPadding[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> ValueNoPadding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235086298-b4fd3d05-611f-47b2-a3cf-ee5403674406.png#averageHue=%23383838&clientId=u294810c7-fb47-4&from=paste&height=236&id=uebb152fa&originHeight=472&originWidth=550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=51500&status=done&style=none&taskId=uafd42923-c20d-4e89-9d3a-492afc10140&title=&width=275" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235220121-d84e6b19-a9b3-426c-a382-4eca89265e03.png#averageHue=%23393939&clientId=u294810c7-fb47-4&from=paste&height=227&id=ua3371d3a&originHeight=454&originWidth=484&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46562&status=done&style=none&taskId=ud852761a-cefd-4547-9b5d-2fe30fbd767&title=&width=242" alt="image.png"><br />左边是ValueNoPadding，右边是ValuePadding。</p><p>由此可见，有无共享导致的区别还是挺大的。<br />那么这么明显的问题，他们都没有注意到吗？那当然不是，事实上，已经有一个注解@Contended去解决了这个问题：<br /><code>@Contended</code> 注解用于在Java类及其字段上提高内存访问性能。它可以显式地向JVM表示，被修饰的元素（通常是字段）可能会产生伪共享（false sharing）问题。<br />伪共享是指多个线程频繁访问不同变量，但这些变量位于同一个缓存行上。这会导致缓存行频繁失效和重载，从而降低多线程程序的性能。<br /><code>@Contended</code> 注解提示JVM在分配内存时为标注元素添加额外的内存填充，以确保它们分布在不同的缓存行上。这有助于消除伪共享，从而提高线程间的并发性能。<br />要注意的是，<code>@Contended</code> 支持并不是所有JVM版本都有。在Oracle的Hotspot JVM上，默认情况下仅在Java 9及以上版本可用。 若要在低于Java 9的JVM版本上使用<code>@Contended</code>, 需要启动JVM时添加 <code>-XX:-RestrictContended</code> 参数。<br />示例使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.vm.annotation.Contended;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value1 &amp; Value2 with padding to avoid False Sharing</span></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，<code>Foo</code> 类及其字段 <code>value1</code> 和 <code>value2</code> 使用了 <code>@Contended</code> 注解，以避免伪共享问题。</p><p><a name="e83UL"></a></p><h2 id="Disruptor的设计"><a href="#Disruptor的设计" class="headerlink" title="Disruptor的设计"></a>Disruptor的设计</h2><p><a name="aaV5Q"></a></p><h3 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h3><p>Disruptor是一个高性能、低延迟的并发框架，最初由LMAX公司开发。它用于解决在复杂多线程环境下数据共享和并发访问的问题。Disruptor的设计目标是使开发人员能够在高负载场景下编写出较低延迟和高吞吐量的应用程序。其的核心设计模式主要包括以下几个方面：</p><ol><li>Ring Buffer（环形缓冲区）：Disruptor框架的核心数据结构。Ring Buffer用于存储和共享数据。它是一个环形的数组，长度固定且是2的整数次幂。由于是环形，当写入到达计数器尾部时，将回到数组的开头覆盖旧数据。Ring Buffer提高了数据存储和访问效率，同时降低了并发冲突的可能性。并且，由于数组的特性对处理器的缓存机制更加友好。</li><li>Producer（生产者）：生产者将事件数据添加到Ring Buffer中。在Disruptor框架中，可以有多个生产者同时添加事件。</li><li>Sequence Barrier（序列屏障）：提供了一种协调机制，以确保生产者和消费者在并行执行时可以正确访问Ring Buffer。</li><li>Consumer（消费者）：消费者是处理Ring Buffer中事件的实际执行者。Disruptor支持多个消费者同时处理事件，可以为消费者定义依赖关系。当多个消费者同时访问Ring Buffer时，事件将根据消费者依赖关系顺序处理。</li><li>WaitStrategy（等待策略）：Disruptor提供了一组内置的等待策略，用于控制生产者和消费者在等待事件处理时的行为。例如，线程执行、空轮询、阻塞等待等。</li></ol><p>使用Disruptor可以高效地处理多线程的并发问题。相比传统的阻塞队列和锁，Disruptor通过这些设计模式实现了更低的延迟和更高的吞吐量，适用于高性能需求的场景。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235832610-789e1be7-524d-4d8f-80c8-e187a86cd8ba.png#averageHue=%23f5f5f5&clientId=u294810c7-fb47-4&from=paste&height=719&id=ud1e82361&originHeight=1438&originWidth=1964&originalType=binary&ratio=2&rotation=0&showTitle=false&size=267070&status=done&style=none&taskId=u81cba5c1-7ebd-4d0e-9fa9-ce68b93ba42&title=&width=982" alt="image.png"><br><a name="yFUmD"></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Disruptor还具有元素位置定位和无锁这两个优势特点，它们可以进一步提高Disruptor的性能。接下来详细介绍这三个特点：</p><ol><li>元素位置定位：<br />在Disruptor的Ring Buffer中，每个元素（事件）的位置都是通过一个序列号（Sequence）来表示的。这个序列号对应于Ring Buffer数组的一个索引位置。根据序列号计算索引位置的公式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; sequence % bufferSize</span><br></pre></td></tr></table></figure><p>其中<code>sequence</code>表示元素的序列号（从0开始递增），<code>bufferSize</code>表示Ring Buffer的大小（长度）。<br />由于Ring Buffer的长度是2的整数次幂，这样的设计使得计算索引位置非常高效。只需要进行按位与（<code>sequence &amp; (bufferSize - 1)</code>）操作即可完成计算，避免了除法和取余运算，从而提高了性能。</p><ol start="2"><li>无锁：<br />Disruptor在设计时确保了多个生产者和消费者在操作Ring Buffer时都无需使用锁。利用了无锁数据结构的原子操作，例如CAS（Compare And Swap）等，确保了在高并发环境下正确、高效地访问共享数据。无锁设计相对于基于锁的同步方式减少了线程上下文切换的开销，降低了竞争冲突，从而大幅提高了应用程序的性能。</li><li>环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好（CPU加载空间局部性原则）。</li></ol><p>在Disruptor框架中，生产者和消费者都使用单调递增的序列号（Sequence）来表示所操作的元素。当生产者或消费者需要添加或处理事件时，它们会使用CAS操作更新相应的Sequence。因此，消费者之间即使在并行执行时，也能够正确地知道对方的处理进度，这样消费者之间可以互不干扰地处理事件。</p><p><a name="KDa9A"></a></p><h3 id="使用无锁的设计"><a href="#使用无锁的设计" class="headerlink" title="使用无锁的设计"></a>使用无锁的设计</h3><p>Disruptor中的主要无锁设计是通过RingBuffer来实现的。RingBuffer是Disruptor中一个循环的缓冲区，使用无锁技术实现高性能的并发访问。<br />在Disruptor中，生产者和消费者共同操作RingBuffer。生产者发布事件时(下面的demo有示例)，会通过<strong>next()</strong>方法申请序号，并一次性地预分配多个序列号。消费者根据序列号处理相应的事件，确保消费者事件间无锁、无阻塞地运行。<br />Disruptor通过使用设计如<strong>Sequence</strong>、<strong>Sequencer</strong>和<strong>Cursor</strong>等类和遵循一定的规则，在高并发环境下保证了生产者和消费者间的正确交互，实现了高性能的无锁设计。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239186747-7e49977c-3b81-43e7-bd05-adc3aa5de15f.png#averageHue=%233a3734&clientId=u294810c7-fb47-4&from=paste&height=331&id=udce0dff4&originHeight=662&originWidth=2358&originalType=binary&ratio=2&rotation=0&showTitle=false&size=223750&status=done&style=none&taskId=u1b7af166-361f-4a85-b8d1-4f7f7f12eb0&title=&width=1179" alt="image.png"></p><p><a name="xlu1z"></a></p><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>Disruptor的RingBuffer是一个环形缓冲区，它是Disruptor框架的核心组件。它采用环形数据结构使得生产者和消费者能够高效地在无锁的情况下共享数据。下面详细讲解RingBuffer的原理：</p><ol><li>数据结构：RingBuffer实际上是一个包含预定义大小的对象数组，这个数组的大小必须为2的幂。之所以使用2的幂，是因为这样可以优化某些计算，例如通过位运算取模运算，提高性能。数组中的每个元素对应一个事件（Event），生产者负责产生事件，消费者负责处理事件。 </li><li>序列号（Sequence）：在Disruptor中，生产者和消费者通过序列号（Sequence）来定位RingBuffer中的位置。序列号是一个单调递增的long值，用于表示事件的位置。生产者申请序列号时，序列号递增。消费者处理事件时，根据序列号在RingBuffer中找到相应的事件。 </li><li>环形缓冲区：由于RingBuffer是环形的，当数组的末尾已经用完时，生产者可以从数组的开头开始重用位置。这样，在RingBuffer不满的情况下，生产者总是可以写入事件而不会遇到阻塞。当然，在RingBuffer满的情况下，生产者可能需要等待消费者消费事件来释放空间。 </li><li>索引计算：由于RingBuffer的长度是2的幂，例如长度为8的RingBuffer，可以通过位运算得到索引：<code>index = sequence &amp; (bufferSize - 1)</code>。这比取模运算效率更高。 </li><li>生产者-消费者交互：在Disruptor中，生产者和消费者通过遵循一定的规则实现环形缓冲区的无锁访问，提高并发性能。主要有以下规则：a) 生产者只需要关心最慢的消费者，因为只有当所有消费者完成对当前事件的处理，才能确保生产者可以安全地覆盖之前的事件；b) 消费者之间可能存在依赖关系，可以通过屏障（Barrier）等方法确保消费者按照顺序处理事件。 </li></ol><p>下面通过一个过程示例，来表达Disruptor的解决思路：<br />启动时，将预先分配环形缓冲区的所有内存。环形缓冲区可以存储指向 entry 的指针数组，也可以存储表示 entry 的结构数组。这些 entry 中的每一个通常不是传递的数据本身，类似对象池机制，而是它的容器。这种 entry 的预分配消除了支持垃圾回收的语言中的问题，因为 entry 将被重用，并在整个 Disruptor 实例存活期间都有效。这些 entry 的内存是同时分配的。<br />一般的数据结构是像下面这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239747113-fa180ee3-e71d-44be-9b6c-ba59c58dff57.png#averageHue=%23f6f6f6&clientId=u294810c7-fb47-4&from=paste&height=518&id=u09798d04&originHeight=1426&originWidth=1536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=214415&status=done&style=none&taskId=u0a61dd2e-e675-4e3e-b624-e76156bbf00&title=&width=558" alt="5-modified.png"><br />我们可以使用一个环状的数组结构改进成下面这样：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239757886-48ce5b14-d7fa-4a54-a762-b2f41cff6647.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=623&id=u749158d5&originHeight=1658&originWidth=958&originalType=binary&ratio=2&rotation=0&showTitle=false&size=203627&status=done&style=none&taskId=uaf451706-9b1e-4450-8a06-017678ed102&title=&width=360" alt="6-modified.png"><br />数组的连续多个元素会一并加载到 CPU Cache 里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。遍历访问时 CPU 层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。</p><p>在像 Java 这样的托管运行时环境中开发低延迟系统时，垃圾收集机制可能会带来问题。分配的内存越多，给垃圾收集器带来的负担就越大。当对象的寿命很短或实际上是常驻的时候，垃圾收集器工作得最好。在环形缓冲区中预先分配 entry 意味着它对于垃圾收集器来说是常驻内存的，垃圾回收的负担就很轻。同时，数组结构对处理器的缓存机制更加友好。数组长度 2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心 index 溢出的问题。index 是 long 类型，即使 100 万 QPS 的处理速度，也需要 30 万年才能用完。</p><p>一般的 Cache Line 大小在 64 字节左右，然后 Disruptor 在非常重要的字段前后加了很多额外的无用字段。可以让这一个字段占满一整个缓存行，这样就可以避免未共享导致的误杀。</p><p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。<br><a name="hIbfE"></a></p><h4 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h4><p>下面用非环形的结构模拟无锁读写：</p><ol><li>申请写入m个元素</li><li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素</li><li>若是返回的正确，则生产者开始写入元素</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239966093-8f5b4adc-c6a0-43b7-8194-be501aa8c466.png#averageHue=%23f7f7f7&clientId=u294810c7-fb47-4&from=paste&height=555&id=ub77b53b5&originHeight=1550&originWidth=1108&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146321&status=done&style=none&taskId=u0824520d-67aa-42c3-897e-9eec115f60d&title=&width=397" alt="7-modified.png"><br><a name="CqVJN"></a></p><h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor 的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过 CAS 很容易达到。只需要在分配元素的时候，通过 CAS 判断一下这段空间是否已经分配出去即可。</p><p>但如何防止读取的时候，读到还未写的元素。Disruptor 在多个生产者的情况下，引入了一个与 Ring Buffer 大小相同的 buffer，Available Buffer。当某个位置写入成功的时候，便把 Availble Buffer 相应的位置置位，标记为写入成功。读取的时候，会遍历 Available Buffer，来判断元素是否已经就绪。<br><a name="XHwEt"></a></p><h5 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h5><p>生产者多线程写入的情况会复杂很多：</p><p>申请读取到序号n；<br />若 writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从 reader cursor 开始读取 available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；<br />消费者读取元素。<br />如下图所示，读线程读到下标为 2 的元素，三个线程 Writer1/Writer2/Writer3 正在向 RingBuffer 相应位置写数据，写线程被分配到的最大元素下标是 11。</p><p>读线程申请读取到下标从3到11的元素，判断 writer cursor&gt;=11。然后开始读取 availableBuffer，从 3 开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p><p>然后，消费者读取下标从 3 到 6 共计 4 个元素（多个生产者情况下，消费者消费过程示意图）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240468257-7e87656e-2609-4e11-892c-80c9499fcbfb.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=439&id=u20b89bf1&originHeight=1278&originWidth=1538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=186527&status=done&style=none&taskId=u6c6dc0d3-e25c-4be8-b703-9df811896ab&title=&width=528" alt="8-modified.png"></p><p><a name="H7wxf"></a></p><h5 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h5><p>多个生产者写入的时候：</p><ol><li>申请写入 m 个元素；</li><li>若是有 m 个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li><li>生产者写入元素，写入元素的同时设置 available Buffer 里面相应的位置，以标记自己哪些位置是已经写入成功的。</li></ol><p>如下图所示，Writer1 和 Writer2 两个线程写入数组，都申请可写的数组空间。Writer1 被分配了下标 3 到下表 5 的空间，Writer2 被分配了下标 6 到下标 9 的空间。<br />Writer1 写入下标 3 位置的元素，同时把 available Buffer 相应位置置位，标记已经写入成功，往后移一位，开始写下标 4 位置的元素。Writer2 同样的方式。最终都写入完成。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240479384-12ad2519-4832-4a2f-b322-be738d75bd89.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=454&id=ue940e65d&originHeight=1216&originWidth=1544&originalType=binary&ratio=2&rotation=0&showTitle=false&size=170725&status=done&style=none&taskId=uf080f650-c299-46f0-ab23-8b0a327bde7&title=&width=576" alt="9-modified.png"></p><p><a name="zLdit"></a></p><h3 id="解决伪共享的问题"><a href="#解决伪共享的问题" class="headerlink" title="解决伪共享的问题"></a>解决伪共享的问题</h3><p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可即缓存行填充（Padding），使一个对象占用的内存大小刚好为64bytes或它的整数倍，这样就保证了一个缓存行里不会有多个对象，这其实是一种以空间换时间的方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689237986676-153e1cdb-479e-47d0-9dba-e8146605e61a.png#averageHue=%232c2c2b&clientId=u294810c7-fb47-4&from=paste&height=433&id=ud05fae06&originHeight=866&originWidth=1384&originalType=binary&ratio=2&rotation=0&showTitle=false&size=90326&status=done&style=none&taskId=u010ab547-b40b-4b4e-a891-4c20e58822c&title=&width=692" alt="image.png"></p><p>而Sequence选择继承PhsPadding：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238216429-1e66812a-2ce7-40f6-9ff1-9c858e9cec60.png#averageHue=%232c2b2b&clientId=u294810c7-fb47-4&from=paste&height=639&id=u129d6da7&originHeight=1278&originWidth=1688&originalType=binary&ratio=2&rotation=0&showTitle=false&size=180493&status=done&style=none&taskId=uc4925b8e-d6e1-4cf4-9dc3-ebbf22379c1&title=&width=844" alt="image.png"></p><p>Sequence实际value变量的左右均被填充了7个long型变量，其自身也是long型变量，一个long型变量占据8个字节，所以序号与他上一个/下一个序号之间的最小内存距离为：158=120byte，加上对象头的8个字节，可以确保sequence大小128byte=264byte（有的CPU缓存行是128byte）<br />这样直接的代价就是增大的15倍的内存消耗空间，这样的设计导致不可能有两个cursor出现在同一个cpu cache line中, 就解决了”伪共享”问题。</p><p><a name="b5l5B"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后，官网也提供了很多测试用例：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241111749-4f61900f-733d-42ca-9517-7d8816ab5e9b.png#averageHue=%23745e3e&clientId=u294810c7-fb47-4&from=paste&height=631&id=u2b078ad4&originHeight=1262&originWidth=2372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=354512&status=done&style=none&taskId=uc7f47b10-d568-47a6-a524-bfaaf2ab59b&title=&width=1186" alt="image.png"><br><a name="h9Ao1"></a></p><h2 id="延迟性能测试"><a href="#延迟性能测试" class="headerlink" title="延迟性能测试"></a>延迟性能测试</h2><blockquote><p>To measure latency we take the three stage pipeline and generate events at less than saturation. This is achieved by waiting 1 microsecond after injecting an event before injecting the next and repeating 50 million times. To time at this level of precision it is necessary to use time stamp counters from the CPU. We chose CPUs with an invariant TSC because older processors suffer from changing frequency due to power saving and sleep states. Intel Nehalem and later processors use an invariant TSC which can be accessed by the latest Oracle JVMs running on Ubuntu 11.04. No CPU binding has been employed for this test. For comparison we use the ArrayBlockingQueue once again. We could have used ConcurrentLinkedQueueviii which is likely to give better results but we want to use a bounded queue implementation to ensure producers do not outpace consumers by creating back pressure. The results below are for 2.2Ghz Core i7-2720QM running Java 1.6.0_25 64-bit on Ubuntu 11.04. Mean latency per hop for the Disruptor comes out at 52 nanoseconds compared to 32,757 nanoseconds for ArrayBlockingQueue. Profiling shows the use of locks and signalling via a condition variable are the main cause of latency for the ArrayBlockingQueue.</p></blockquote><p>为了测量延迟，我们采用三级管道并在低于饱和度的情况下生成事件。这是通过在注入一个事件之后等待 1 微秒，然后再注入下一个事件并重复 5000 万次来实现的。为了达到这种精度水平，必须使用 CPU 的时间戳计数器。我们选择具有不变 TSC 的 CPU，因为较旧的处理器会因省电和睡眠状态而发生频率变化。Intel Nehalem 及更高版本的处理器使用不变的 TSC，可由 Ubuntu 11.04 上运行的最新 Oracle JVM 访问。此测试未使用 CPU 绑定。为了进行比较，我们再次使用 ArrayBlockingQueue。我们本可以使用 ConcurrentLinkedQueueviii，它可能会提供更好的结果，但我们希望使用有界队列实现来确保生产者不会因产生背压而超过消费者。以下结果适用于在 Ubuntu 11.04 上运行 Java 1.6.0_25 64 位的 2.2Ghz Core i7-2720QM。Disruptor 的每跳平均延迟为 52 纳秒，而 ArrayBlockingQueue 的平均每跳延迟为 32,757 纳秒。分析显示，使用锁和通过条件变量发送信号是 ArrayBlockingQueue 延迟的主要原因。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241005080-b62ef96a-8687-4c10-95b5-5cd418cf4500.png#averageHue=%23fafaf9&clientId=u294810c7-fb47-4&from=paste&height=315&id=ub74af72d&originHeight=630&originWidth=2000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=112876&status=done&style=none&taskId=u6f04c628-8884-4568-b617-d8c2d0d0ecc&title=&width=1000" alt="image.png"><br><a name="oXwBS"></a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Disruptor是一个高性能、低延迟的并发框架，源自LMAX公司，主要用于实现开发者在多线程程序中无锁队列的操作。ArrayBlockingQueue则是一个基于数组实现的有界阻塞队列，是Java标准库中的一个组件。两者各有优点和局限性，具体如下：</p><p>根据上面的分析，可以得出一个结论，Disruptor的性能远高于ArrayBlockingQueue。Disruptor采用一种基于环形数组的数据结构（RingBuffer），通过适当的同步策略和无锁优化技术，实现了非常高的并发性能。因此，在高并发、低延迟场景下，Disruptor的吞吐量和延迟表现显著优于ArrayBlockingQueue。相比之下，ArrayBlockingQueue基于传统的锁和条件变量机制，性能较低、延迟能力有限。<br />但是，相对而言，想要更高的性能吗，就不得不放弃易用。，Disruptor编写相对复杂，可读性较差。由于Disruptor采用了更为底层的原理并使用了许多高级优化技术，例如缓存行填充，预分配对象，内存屏障等，使得其代码实现较为复杂，不易上手。而ArrayBlockingQueue实现相对简单，开发者能更容易理解和使用其原理。<br />最后，Disruptor对依赖环境要求较高。Disruptor的优化策略需要在特定的运行环境下生效，例如，其环形数组的大小需要设置为2的次幂，以充分利用硬件缓存。此外，Disruptor优化适用于JAVA SE环境，在ANDROID等其他环境尚未被广泛验证。而ArrayBlockingQueue作为JDK内置组件，在不同平台环境下的兼容性和稳定性更优。<br />所以，可以得出一个结论，Disruptor与ArrayBlockingQueue在性能、易用性和兼容性方面存在差异。若应用场景追求极致的并发性能、低延迟并能承担较高的开发成本，应选择Disruptor。但若应用场景对性能要求较低，需要简单、易用且兼容性强的阻塞队列，ArrayBlockingQueue则是更好的选择。总之，开发者需要根据实际需求权衡两者的优势和劣势。<br />写到这里，我想起了计算机界的经典名言：*<em>没有银弹  *</em>。意思是没有什么东西是最好最有效而又没有任何缺点的。<br />在软件工程中也是一样，没有最好的技术，只有最合适的技术。面对不同的场景，应该使用更加适合这个场景的技术，这样才能使得效率提高。我想，如何将手中的知识掌握好，然后在合适的环境中发挥它的效果，不仅仅是技术中的艺术，也是软件的工程。</p><p><a name="p6ZMt"></a></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><blockquote><p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started</a></p></blockquote><p>结合用例写一个demo<br />事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"LongEvent&#123;"</span> + <span class="string">"value="</span> + value + <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.ringBuffer 事件队列 下一个槽</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        Long data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.取出空的事件队列</span></span><br><span class="line">            LongEvent longEvent = ringBuffer.get(sequence);</span><br><span class="line">            data = byteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//3.获取事件队列传递的数据</span></span><br><span class="line">            longEvent.setValue(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者准备发送数据："</span>);</span><br><span class="line">            <span class="comment">//4.发布事件</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LongEventMain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F; 2.创建工厂</span><br><span class="line">        EventFactory&lt;LongEvent&gt; eventFactory &#x3D; new LongEventFactory();</span><br><span class="line">        &#x2F;&#x2F; 3.创建ringBuffer 大小</span><br><span class="line">        int ringBufferSize &#x3D; 1024 * 1024; &#x2F;&#x2F; ringBufferSize大小一定要是2的N次方</span><br><span class="line">        &#x2F;&#x2F; 4.创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,</span><br><span class="line">                ProducerType.SINGLE, new YieldingWaitStrategy());</span><br><span class="line">        &#x2F;&#x2F; 5.连接消费端方法</span><br><span class="line">        disruptor.handleEventsWith(new LongEventHandler());</span><br><span class="line">        &#x2F;&#x2F; 6.启动</span><br><span class="line">        disruptor.start();</span><br><span class="line">        &#x2F;&#x2F; 7.创建RingBuffer容器</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line">        &#x2F;&#x2F; 8.创建生产者</span><br><span class="line">        LongEventProducer producer &#x3D; new LongEventProducer(ringBuffer);</span><br><span class="line">        &#x2F;&#x2F; 9.指定缓冲区大小</span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;</span><br><span class="line">            byteBuffer.putLong(0, i);</span><br><span class="line">            producer.onData(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;10.关闭disruptor和executor</span><br><span class="line">        disruptor.shutdown();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689236784814-f6573ce5-7ae5-4dbb-8ab5-23494429c7db.png#averageHue=%23313131&clientId=u294810c7-fb47-4&from=paste&height=219&id=uc5f85ba0&originHeight=438&originWidth=1228&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67544&status=done&style=none&taskId=u9e26cf5a-6617-4ad3-ac64-93a6fc72847&title=&width=614" alt="image.png"><br /></p><p><a name="Ohdad"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_memory_barriers" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/disruptor.html</a><br><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a><br><a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/</a><br><a href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/18/disruptor.html</a><br><a href="https://zhuanlan.zhihu.com/p/229338771" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/229338771</a><br><a href="https://zhuanlan.zhihu.com/p/513468454" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/513468454</a><br><a href="https://qin.news/disruptor/" target="_blank" rel="noopener">https://qin.news/disruptor/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;oYoyt&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易</summary>
      
    
    
    
    
    <category term="队列" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="Disruptor" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>实现Spring框架中的IOC和AOP</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/</id>
    <published>2023-01-05T05:59:20.000Z</published>
    <updated>2023-03-26T16:39:37.398Z</updated>
    
    <content type="html"><![CDATA[<p><a name="Bk5lF"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a><br /></h1><p><a name="vHThd"></a></p><h1 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h1><p><a name="GCsad"></a></p><h2 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h2><p>我们知道Java 是一门面向对象的语言，在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586204787-8e47e2aa-7ad0-4df8-8c02-ab5b48ccf51b.png#averageHue=%23fcfcfc&clientId=u426a4097-24c8-4&from=paste&height=271&id=u2625783a&name=image.png&originHeight=406&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62561&status=done&style=none&taskId=u59dd5fa3-6a83-4d1d-a27d-f26295c1a96&title=&width=388" alt="image.png"></p><p>这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586265815-d527e12e-f00d-495f-ae51-7e3e8d3cdf8e.png#averageHue=%23fdfdfd&clientId=u426a4097-24c8-4&from=paste&height=265&id=ud4222345&name=image.png&originHeight=398&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48632&status=done&style=none&taskId=u1d036425-b7d4-4fd4-94b3-985ef332386&title=&width=400.6666666666667" alt="image.png"></p><p>这个时候我们发现，我们类之间的关系都由 IoC 框架负责维护类，同时将类注入到需要的类中。也就是类的使用者只负责使用，而不负责维护。把专业的事情交给专业的框架来完成。大大的减少开发的复杂度。<br><a name="KMNbL"></a></p><h2 id="IOC的实现步骤"><a href="#IOC的实现步骤" class="headerlink" title="IOC的实现步骤"></a>IOC的实现步骤</h2><ol><li>初始化 IoC 容器。</li><li>读取配置文件。</li><li>将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition</li><li>利用数据结构依次实例化相应的对象</li><li>注入对象之间的依赖关系</li></ol><p><a name="iZZUZ"></a></p><h2 id="bean-定义了框架的数据结构"><a href="#bean-定义了框架的数据结构" class="headerlink" title="bean 定义了框架的数据结构"></a>bean 定义了框架的数据结构</h2><p>定义了bean的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] interfaceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;PropertyArg&gt; propertyArgs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了对象的 name，class的名称。如果是接口的实现，还有该对象实现的接口。以及构造函数的传参的列表 constructorArgs 和需要注入的参数列表 propertyArgs</p><p><a name="rgpUm"></a></p><h2 id="Utils工具包"><a href="#Utils工具包" class="headerlink" title="Utils工具包"></a>Utils工具包</h2><p><a name="pETF3"></a></p><h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefultClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefultClassLoader().loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ClassUtils，提供了两个静态方法：</p><ol><li>getDefultClassLoader() 方法返回当前线程的上下文类加载器（Context Class Loader）；</li><li>loadClass(String className) 方法用于根据类名加载对应的 Class 对象，首先调用 getDefultClassLoader() 方法获取默认的类加载器，然后使用该类加载器加载指定的类。如果指定的类名不存在，该方法将会打印异常栈信息，并返回 null。</li></ol><p>这个工具类可以方便地加载任何类，尤其在使用反射技术时非常有用，因为你可以通过类名动态地获取 Class 对象。同时，由于使用了线程的上下文类加载器，也可以避免一些类加载器隔离的问题。<br><a name="Hd0uf"></a></p><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instanceByCglib</span><span class="params">(Class&lt;T&gt; clz,Constructor ctr,Object[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clz);</span><br><span class="line">        enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ctr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create(ctr.getParameterTypes(),args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 BeanUtils，提供了一个静态方法 instanceByCglib，用于创建对象。具体而言：</p><ol><li>Class<T> 参数表示要创建的对象的类；</li><li>Constructor 参数表示要使用的构造方法，可以为 null；</li><li>Object[] 参数表示构造方法的参数数组，如果 Constructor 参数为 null，则此参数也应为 null。</li></ol><p>该方法使用 CGLIB 库创建对象。首先创建一个 Enhancer 对象，并设置其父类为 clz，然后设置回调为 NoOp.INSTANCE，这意味着创建的对象不会被代理。如果 ctr 为 null，则直接通过 enhancer.create() 创建对象，否则通过 enhancer.create(ctr.getParameterTypes(), args) 使用指定的构造方法创建对象。</p><p>CGLIB 是一个基于 ASM 库的代码生成库，可以用于创建动态代理、增强类等。在本代码中，CGLIB 用于创建对象并调用构造方法。这种方式相对于使用 new 运算符创建对象，具有更高的灵活性和动态性。</p><p><a name="Ts732"></a></p><h4 id="用法举例：AOP"><a href="#用法举例：AOP" class="headerlink" title="用法举例：AOP"></a>用法举例：AOP</h4><p>这个也是aop的用法<br />在cglib包下，Enhancer这个类的作用是为指定的类创建代理类。具体来说，Enhancer类可以动态地生成一个指定类的子类，该子类可以用来拦截指定类中的方法调用，从而实现代理模式。<br />Enhancer类的使用方法类似于Java动态代理中的Proxy类。首先，需要创建一个Enhancer对象，并设置要代理的目标类和回调方法。然后，通过调用Enhancer对象的create方法，生成代理类的实例。这个代理类会继承目标类，同时实现回调方法，从而实现对目标类方法的拦截和处理。<br />Enhancer类的使用比较灵活，可以代理任意的类，包括没有实现任何接口的类。但是，由于Enhancer是通过生成目标类的子类来实现代理的，所以目标类必须有默认的构造函数，并且不能是final类。<br />假设我们有一个简单的UserService接口，其中定义了一个getUser方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想为该接口创建一个代理类，记录getUser方法的调用次数。我们可以使用cglib的Enhancer类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceProxy(target));</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getUser"</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个UserServiceProxy类，它实现了MethodInterceptor接口，用于拦截目标对象的方法调用。在构造方法中，我们传入了目标对象target，并使用Enhancer类生成一个UserService的代理对象。在intercept方法中，我们记录了getUser方法的调用次数，并使用MethodProxy类来调用目标对象的对应方法。<br />接下来，我们可以使用该代理类来调用getUser方法，并检查调用次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = UserServiceProxy.createProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">userService.getUser(<span class="number">1</span>);</span><br><span class="line">userService.getUser(<span class="number">2</span>);</span><br><span class="line">System.out.println(userService.getCount()); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们首先使用createProxy方法创建了UserService的代理对象，并调用了getUser方法两次。最后，我们打印了代理对象的调用次数，发现它的确记录了两次getUser方法的调用。<br /><strong>它为什么要这么做呢，直接new难道不行吗？</strong><br />使用代理模式的一个主要目的是在不改变原有代码的情况下，为现有对象添加额外的行为或功能。在上面的例子中，我们通过使用cglib的Enhancer类创建了一个代理对象，使得我们可以在不修改原有UserServiceImpl类的情况下，为getUser方法添加了记录调用次数的功能。<br />如果直接new一个新的对象，虽然可以实现类似的功能，但是需要对原有代码进行修改，将原有的对象替换成新的对象，这样就不太符合“开闭原则”，即对扩展开放，对修改关闭的设计原则。同时，在某些情况下，我们可能无法直接访问到原有对象的构造函数，这就导致了不能直接创建新对象的限制。<br />使用代理模式，可以通过创建代理对象来扩展原有对象的行为，而不需要修改原有对象的代码。同时，代理对象还可以在原有对象的基础上增加额外的行为，提高代码的可扩展性和可维护性。</p><p><a name="uyyXf"></a></p><h3 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectField</span><span class="params">(Field field,Object obj,Object value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ReflectionUtils，提供了一个静态方法 injectField，用于设置某个对象的属性值。具体而言：</p><ol><li>Field 参数表示要设置的属性的字段；</li><li>Object 参数表示要设置属性值的对象；</li><li>Object 参数表示要设置的属性值。</li></ol><p>该方法首先判断 field 是否为空，如果不为空则将其设置为可访问，然后使用 field.set(obj, value) 方法设置对象的属性值。如果属性为 final 修饰的静态变量，则此方法将无法修改其值。</p><p>这个工具类可以方便地在代码中设置对象的属性值，尤其在使用反射技术时非常有用，因为你可以通过反射动态修改对象的属性。但是，使用反射技术也有一些缺点，例如性能较低、容易引起安全问题等，需要谨慎使用。<br><a name="UZCBE"></a></p><h3 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a>JsonUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*JsonUtils 的作用就是为了解析我们的json配置文件。代码比较长，与我们的 IoC 原理关系不大*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is,Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is,cls);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">writeValue</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] writeByteValue(Object entity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsBytes(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line">        mapper.getDeserializationConfig().withoutFeatures(<span class="keyword">new</span> DeserializationFeature[]&#123;DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES&#125;);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_YAML_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类，封装了基于Jackson库的Json序列化和反序列化功能。具体作用如下：</p><ul><li>定义了一个ObjectMapper对象，用于将Java对象转化为JSON格式，或将JSON格式转化为Java对象。</li><li>提供了多个readValue()和writeValue()方法，用于不同类型之间的转化。其中，readValue()方法支持将JSON格式的字符串、输入流或字节数组反序列化成Java对象，而writeValue()方法则将Java对象序列化成JSON格式的字符串或字节数组。</li><li>设置了一些序列化和反序列化的配置，如格式化输出、忽略空值、支持单引号、允许注释等。</li><li>如果反序列化失败，则返回null</li></ul><p><a name="fz6Ke"></a></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>先定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有对应的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryImpl</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefineMap= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//查找对象是否已经实例化过</span></span><br><span class="line">        Object bean = beanMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环依赖问题</span></span><br><span class="line">        Object earlyBean = earlySingletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span> (earlyBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生了循环依赖，提前返回尚未加载完成的bean:"</span> + name);</span><br><span class="line">            <span class="keyword">return</span> earlyBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有实例化，那就需要调用createBean来创建对象</span></span><br><span class="line">        BeanDefinition beanDefinition = beanDefineMap.get(name);</span><br><span class="line">        bean = createBean(beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为了解决循环依赖，先添加到早期单例中</span></span><br><span class="line">            earlySingletonObjects.put(name, bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对象创建成功以后，注入对象需要的参数</span></span><br><span class="line">            populateBean(bean,beanDefinition);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再吧对象存入Map中方便下次使用。</span></span><br><span class="line">            beanMap.put(name,bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从早期单例Map中移除</span></span><br><span class="line">            earlySingletonObjects.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束返回</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, BeanDefinition bd)</span></span>&#123;</span><br><span class="line">        beanDefineMap.put(name,bd);</span><br><span class="line">        beanNameSet.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String beanName = beanDefinition.getClassName();</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        Class&lt;?&gt; clz = ClassUtils.loadClass(beanName);</span><br><span class="line">        <span class="keyword">if</span>(clz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"can not find bean by beanName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取构造器参数</span></span><br><span class="line">        List&lt;ConstructorArg&gt; constructorArgs = beanDefinition.getConstructorArgs();</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty())&#123;</span><br><span class="line">            List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConstructorArg constructorArg : constructorArgs) &#123;</span><br><span class="line">                <span class="comment">//放入Map</span></span><br><span class="line">                objects.add(getBean(constructorArg.getRef()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,clz.getConstructor(),objects.toArray());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(Object bean, BeanDefinition bd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;PropertyArg&gt; propertyArgs = bd.getPropertyArgs();</span><br><span class="line">        <span class="keyword">if</span> (propertyArgs != <span class="keyword">null</span> &amp;&amp; !propertyArgs.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历在json中配置的属性</span></span><br><span class="line">            <span class="keyword">for</span> (PropertyArg arg : propertyArgs) &#123;</span><br><span class="line">                String propertyName = arg.getName();</span><br><span class="line">                String value = arg.getValue();</span><br><span class="line">                String ref = arg.getRef();</span><br><span class="line">                Object injectValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接赋值</span></span><br><span class="line">                    injectValue = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(ref)) &#123;</span><br><span class="line">                    <span class="comment">//获取bean</span></span><br><span class="line">                    injectValue = getBean(ref);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">                method.invoke(bean, injectValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取具体某个属性的setter方法</span></span><br><span class="line"><span class="comment">     * 此处做法比较简单粗暴</span></span><br><span class="line"><span class="comment">     * 实际上Spring在读取配置文件时就已经将各属性，方法，getter/setter都读取好了。</span></span><br><span class="line"><span class="comment">     * 在这就只需要调用BeanWrapper的方法来为属性赋值就可以了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getPropertySetter</span><span class="params">(BeanDefinition bd, String propertyName, Object injectValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = Class.forName(bd.getClassName());</span><br><span class="line">        Class&lt;?&gt; injectClazz = injectValue.getClass();</span><br><span class="line">        Class&lt;?&gt; supClass = injectValue.getClass().getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (supClass != <span class="keyword">null</span> &amp;&amp; supClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            injectClazz = supClass;</span><br><span class="line">        &#125;</span><br><span class="line">        propertyName = propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">        Method setter = beanClass.getMethod(<span class="string">"set"</span> + propertyName, injectClazz);</span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了一个简单的Bean工厂，主要功能是通过Bean的名字获取Bean的实例，实现了Bean的创建、注入属性和循环依赖的处理。</p><p>其中，BeanFactoryImpl类实现了BeanFactory接口，定义了三个ConcurrentHashMap类型的变量，分别用来存储Bean实例、Bean定义和Bean名称集合。它还包含了一个earlySingletonObjects成员变量，用来处理循环依赖的问题。</p><p><a name="TT8Dj"></a></p><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><p>getBean 方法是 Spring 框架中的一个核心方法，用于从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例。该方法接收一个参数 name，表示需要获取的 Bean 的名称。该方法会根据给定的名称先在 BeanFactory 中查找是否已经有该名称对应的 Bean 实例，如果没有找到，则尝试创建一个新的实例并将其注册到 BeanFactory 中。<br />在实现类 BeanFactoryImpl 中，该方法会先从 beanMap 中查找是否已经有该名称对应的 Bean 实例，如果找到了则直接返回该实例。如果没有找到，则需要通过 createBean 方法创建一个新的实例。在创建实例之前，该方法会检查 earlySingletonObjects 中是否已经有该名称对应的早期单例对象，如果有则说明存在循环依赖的问题，此时会返回早期单例对象，避免出现死锁的情况。<br />getBean 方法会调用 createBean 方法创建 Bean 实例，然后调用 populateBean 方法为实例注入需要的属性。在注入属性之后，该方法会将创建好的 Bean 实例注册到 beanMap 中，以备下次获取时直接返回。<br />总之，getBean 方法的作用是从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例，如果找不到则创建一个新的实例，并且可以解决循环依赖的问题。<br><a name="qkBoo"></a></p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>createBean 方法的作用是通过传入的 BeanDefinition 对象，使用反射来实例化一个 Java 对象，并返回该对象的实例。该方法首先通过 BeanDefinition 对象中的类名获取该类的 Class 对象，然后根据该对象获取相应的构造函数，如果有构造函数的参数，则递归调用 getBean 方法获取构造函数的参数，最后使用 CGLIB 库的 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果构造函数没有参数，则直接使用 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果获取 Class 对象失败，会抛出异常。<br><a name="kaiGR"></a></p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>populateBean方法的作用是为一个JavaBean对象注入它所依赖的其他对象或属性，这些对象或属性在BeanDefinition中被定义，并且在配置文件中被配置好。populateBean方法会根据BeanDefinition中的属性列表，将对应的属性值设置到JavaBean对象中。属性的值可能是简单类型的值，也可能是其他JavaBean对象的引用。<br />具体而言，populateBean方法会遍历BeanDefinition中的属性列表，对于每一个属性，它会根据属性的名称、值或引用，找到JavaBean对象中对应的setter方法，然后调用该方法将属性值设置到JavaBean对象中。需要注意的是，setter方法的名称是根据属性名生成的，例如，如果属性名是foo，那么setter方法的名称就是setFoo。<br />populateBean方法的实现比较简单粗暴，实际上，Spring框架在读取配置文件时已经将各属性、方法、getter/setter都读取好了，并且使用了更加高效和灵活的方式来为JavaBean对象注入属性值。</p><p>这两行代码的作用是为一个Java Bean对象的属性赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">method.invoke(bean, injectValue);</span><br></pre></td></tr></table></figure><p>第一行代码使用getPropertySetter方法获取一个指定属性的Setter方法。getPropertySetter方法根据属性名称、注入值类型和Bean定义，动态地获取该属性的Setter方法。这里使用反射机制，构造出要调用的方法，以便在第二行代码中使用。<br />第二行代码使用反射机制调用Java Bean对象的Setter方法，并把该属性的值作为参数传入。这里的bean是要赋值的Java Bean对象，injectValue是要注入的值。<br><a name="E6WQy"></a></p><h3 id="getPropertySetter"><a href="#getPropertySetter" class="headerlink" title="getPropertySetter"></a>getPropertySetter</h3><p>getPropertySetter方法的作用是根据传入的BeanDefinition、属性名和属性值，获取对应的setter方法，并返回该方法。在populateBean方法中，会根据BeanDefinition中配置的属性名、属性值以及对应的setter方法，将属性值设置到对象中，实现对对象属性的注入。getPropertySetter方法通过反射获取类的setter方法，并根据属性值的类型确定setter方法的参数类型，最终返回setter方法，供populateBean方法调用。<br><a name="ptLbT"></a></p><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>这段代码实现了一个简单的 Bean 工厂。主要功能包括：</p><ol><li>实现了 BeanFactory 接口，提供了 getBean() 方法来获取指定名称的 Bean 实例。</li><li>实现了注册 BeanDefinition 的方法 registerBean()，用来将 BeanDefinition 存储到 Map 中。</li><li>使用 ConcurrentHashMap 来存储 Bean 实例对象和 BeanDefinition 对象。</li><li>支持循环依赖。通过使用 ConcurrentHashMap 存储早期的 Bean 实例对象，解决了循环依赖问题。</li><li>支持注入属性。通过在 BeanDefinition 中配置 PropertyArg 属性参数列表，来对 Bean 实例对象进行属性注入。</li><li>支持构造器注入。通过在 BeanDefinition 中配置 ConstructorArg 构造器参数列表，来对 Bean 实例对象进行构造器注入。</li><li>支持通过反射创建 Bean 实例对象，使用 CGLib 动态代理技术生成代理对象。</li></ol><p>总体来说，这段代码实现了一个简单的 IoC 容器，能够解决基本的 Bean 创建、管理和依赖注入的问题。但是这个容器还有一些限制，例如只支持单例模式、只支持 setter 注入、只能通过 BeanDefinition 来配置 Bean 等等。真正的 IoC 容器，例如 Spring，还有更多更复杂的功能和特性。</p><p><a name="zPI4R"></a></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        loadFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = JsonUtils.readValue(is,<span class="keyword">new</span> TypeReference&lt;List&lt;BeanDefinition&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(beanDefinitions != <span class="keyword">null</span> &amp;&amp; !beanDefinitions.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">                registerBean(beanDefinition.getName(), beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为JsonApplicationContext的类，继承了BeanFactoryImpl类。JsonApplicationContext类的作用是通过从Json文件中读取bean定义来初始化IoC容器。它包含了一个构造方法和两个私有方法：init()和loadFile()。<br />构造方法JsonApplicationContext(String fileName)接收Json文件的名称，并将其存储在fileName变量中。<br />方法init()用于初始化IoC容器，它调用了loadFile()方法从Json文件中加载bean定义。<br />方法loadFile()用于加载Json文件并注册bean定义到IoC容器中。它首先通过当前线程的类加载器获取Json文件的输入流，然后通过JsonUtils.readValue()方法将输入流转换成BeanDefinition对象列表。最后，它遍历BeanDefinition列表，并调用registerBean()方法注册bean定义到IoC容器中。<br />总之，这段代码是一个简单的IoC容器实现，它可以从Json文件中读取bean定义，并将其注册到容器中，以供应用程序使用。<br><a name="ADAO4"></a></p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679590784248-a8543b7e-dd3d-46b8-abdd-300c77964292.png#averageHue=%23f5f3f2&clientId=u426a4097-24c8-4&from=paste&height=209&id=u14ed6355&name=image.png&originHeight=313&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27393&status=done&style=none&taskId=u042025fc-fe77-4110-8479-550549e9f78&title=&width=651.3333333333334" alt="image.png"></p><p><a name="P6I4h"></a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br /></h2><p><a name="fFT0I"></a></p><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><br /></h1><p><a name="xvv2L"></a></p><h1 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h1><p><a name="lvOkY"></a></p><h2 id="Aop-是什么"><a href="#Aop-是什么" class="headerlink" title="Aop 是什么"></a>Aop 是什么</h2><p>面向切面的程序设计（aspect-oriented programming，AOP）。通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。</p><p><a name="rbIL5"></a></p><h2 id="为什么需要使用Aop"><a href="#为什么需要使用Aop" class="headerlink" title="为什么需要使用Aop"></a>为什么需要使用Aop</h2><p>面向切面编程，实际上就是通过预编译或者动态代理技术在不修改源代码的情况下给原来的程序统一添加功能的一种技术。我们看几个关键词，第一个是“动态代理技术”，这个就是Spring Aop实现底层技术。第二个“不修改源代码”，这个就是Aop最关键的地方，也就是我们平时所说的非入侵性。。第三个“添加功能”，不改变原有的源代码，为程序添加功能。</p><p>举个例子：如果某天你需要统计若干方法的执行时间，如果不是用Aop技术，你要做的就是为每一个方法开始的时候获取一个开始时间，在方法结束的时候获取结束时间。二者之差就是方法的执行时间。如果对每一个需要统计的方法都做如上的操作，那代码简直就是灾难。如果我们使用Aop技术，在不修改代码的情况下，添加一个统计方法执行时间的切面。代码就变得十分优雅。具体这个切面怎么实现？<br />Spring Aop实现的代码非常非常的绕。也就是说 Spring 为了灵活做了非常深层次的抽象。同时 Spring为了兼容 @AspectJ 的Aop协议，使用了很多 Adapter （适配器）模式又进一步的增加了代码的复杂程度。<br />Spring 的 Aop 实现主要以下几个步骤：</p><ol><li>初始化 Aop 容器。</li><li>读取配置文件。</li><li>将配置文件装换为 Aop 能够识别的数据结构 – Advisor。这里展开讲一讲这个advisor。Advisor对象中包又含了两个重要的数据结构，一个是 Advice，一个是 Pointcut。Advice的作用就是描述一个切面的行为，pointcut描述的是切面的位置。两个数据结的组合就是”在哪里，干什么“。这样 Advisor 就包含了”在哪里干什么“的信息，就能够全面的描述切面了。</li><li>Spring 将这个 Advisor 转换成自己能够识别的数据结构 – AdvicedSupport。Spirng 动态的将这些方法拦截器织入到对应的方法。</li><li>生成动态代理代理。</li><li>提供调用，在使用的时候，调用方调用的就是代理方法。也就是已经织入了增强方法的方法</li></ol><p><a name="acqJR"></a></p><h2 id="Invocation"><a href="#Invocation" class="headerlink" title="Invocation"></a>Invocation</h2><p>先定义好方法调用接口和代理方法调用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] getArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理方法的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyMethodInvocation</span> <span class="keyword">extends</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="AkGkM"></a></p><h3 id="CglibMethodInvocation"><a href="#CglibMethodInvocation" class="headerlink" title="CglibMethodInvocation"></a>CglibMethodInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title">ReflectioveMethodeInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibMethodInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(proxy, target, method, arguments, interceptorList);</span><br><span class="line">        <span class="keyword">this</span>.methodProxy = methodProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是定义了一个基于CGLIB动态代理的方法调用类CglibMethodInvocation，它继承了ReflectiveMethodeInvocation类，其中包含了目标对象、目标方法、方法参数以及一组方法拦截器，它们一起构成了一个完整的方法调用链。CglibMethodInvocation在父类的基础上增加了一个MethodProxy类型的属性methodProxy，并重写了invokeOriginal()方法，该方法使用methodProxy对象调用目标方法，实现了方法的调用。该类主要在AOP中使用，用于执行目标方法，并将方法拦截器应用于目标方法之前或之后的操作。</p><p><a name="G0Nbp"></a></p><h3 id="ReflectioveMethodeInvocation"><a href="#ReflectioveMethodeInvocation" class="headerlink" title="ReflectioveMethodeInvocation"></a>ReflectioveMethodeInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectioveMethodeInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectioveMethodeInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] arguments = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行完所有的拦截器后，执行目标方法</span></span><br><span class="line">        <span class="keyword">if</span>(currentInterceptorIndex == <span class="keyword">this</span>.interceptorList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeOriginal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代的执行拦截器。回顾上面的讲解，我们实现的拦击都会执行 im.proceed() 实际上就在调用这个方法。</span></span><br><span class="line">        AopMethodInterceptor interceptor = interceptorList.get(++currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invokeMethodUseReflection(target,method,arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基础的反射方法调用的实现类 ReflectiveMethodInvocation，实现了 ProxyMethodInvocation 接口。在 Spring 的 AOP 中，每个被拦截的方法都会被包装成一个 MethodInvocation，这个包装类里包含了目标对象、方法、参数等信息，并提供了一个 proceed 方法用来执行下一个拦截器或目标方法。</p><p>ReflectiveMethodInvocation 中的 proceed 方法主要用于按照拦截器链依次执行 AopMethodInterceptor 的拦截逻辑。如果拦截器都执行完成，最后就会调用 invokeOriginal 方法来执行目标方法。另外，这个类也提供了获取代理对象、获取方法、获取参数等方法。</p><p><a name="osu7V"></a></p><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeMethodAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeforeMethodAdvice advice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeforeMethodAdviceInterceptor</span><span class="params">(BeforeMethodAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        advice.before(mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterRunningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AfterRunningAdvice advice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterRunningAdviceInterceptor</span><span class="params">(AfterRunningAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnVal = mi.proceed();</span><br><span class="line">        advice.after(returnVal,mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <strong>mi.proceed()</strong>才是执行原有的方法。而advice我们上文就说过，是描述增强的方法”干什么“的数据结构，所以对于这个before拦截器，我们就把advice对应的增强方法放在了真正执行的方法前面。而对于after拦截器而言，就放在了真正执行的方法后面。<br />这里主要是定义拦截器，一个before，一个after。<br><a name="Kqika"></a></p><h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//干什么</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line">    <span class="comment">//在哪里</span></span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AopMethodInterceptor&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptor</span><span class="params">(AopMethodInterceptor interceptor)</span></span>&#123;</span><br><span class="line">        list.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptors</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptors)</span></span>&#123;</span><br><span class="line">        list.addAll(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个AdvisedSupport就是我们Aop框架能够理解的数据结构，这个时候问题就变成了<strong>对于哪个目标，增加哪些拦截器</strong>。这里的AopMethodInterceptor 是一个接口，before拦截器和after拦截器都实现了这个接口。都能够使用这个功能。<br><a name="a0X2d"></a></p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p><a name="yJ9IG"></a></p><h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] constructorArgTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; rootClass = advised.getTargetSource().getTagetClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)&#123;</span><br><span class="line">            classLoader = ClassUtils.getDefultClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(rootClass.getSuperclass());</span><br><span class="line">        <span class="comment">//增加拦截器的核心方法</span></span><br><span class="line">        Callback callbacks = getCallBack(advised);</span><br><span class="line">        enhancer.setCallback(callbacks);</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; constructorArgs.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> enhancer.create(constructorArgTypes,constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Callback <span class="title">getCallBack</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是实现 Cglib AOP 代理的核心逻辑。其中 CglibAopProxy 类实现了 AopProxy 接口，用于创建代理对象，而 AdvisedSupport 是 AOP 配置信息的载体。<br />具体来说，getProxy() 方法返回代理对象，getProxy(ClassLoader classLoader) 方法返回通过指定类加载器加载的代理对象。在这两个方法中，通过使用 CGLIB 提供的 Enhancer 类，实现代理对象的创建和设置拦截器。<br />在 getCallBack(AdvisedSupport advised) 方法中，通过将 AdvisedSupport 中的拦截器链和目标对象传递给 DynamicAdvisedInterceptor，最终得到一个 Callback 对象，它是 Enhancer 的回调函数。<br />回到 getProxy() 和 getProxy(ClassLoader classLoader) 方法，它们的核心是通过 Enhancer 的 setSuperclass 方法，设置代理对象的父类，然后通过 setCallback 方法，将 Callback 对象设置为拦截器。<br />在这个过程中，如果 constructorArgs 不为空，则使用带参数的 enhancer.create 方法创建代理对象。否则，使用不带参数的 enhancer.create 方法创建代理对象。<br />最后，通过调用 enhancer.create 方法返回代理对象。<br />看看核心方法：<br>:::info<br>//增加拦截器的核心方法<br />Callback callbacks = getCallBack(advised);<br>:::</p><blockquote><p>private Callback getCallBack(AdvisedSupport advised) {<br />    return new DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());<br />}</p></blockquote><p><a name="xdGBY"></a></p><h3 id="DynamicAdvisedInterceptor"><a href="#DynamicAdvisedInterceptor" class="headerlink" title="DynamicAdvisedInterceptor"></a>DynamicAdvisedInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptorList, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">        <span class="keyword">this</span>.targetSource = targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了CGLib动态代理中的拦截器，它实现了MethodInterceptor接口。在intercept方法中，它接收了被代理的对象(obj)、目标方法(method)、方法参数(args)以及方法代理(proxy)，然后使用这些参数创建一个CglibMethodInvocation对象，然后调用该对象的proceed()方法，实现拦截器的链式执行。这个拦截器类将所有的AOP拦截器封装成了一个拦截器链，同时传入了目标对象的引用(TargetSource)，以便执行目标方法。在实际调用的时候，这个拦截器会按照拦截器列表依次调用所有的拦截器，并在最后调用目标方法，实现了AOP拦截器的动态织入。</p><p>而其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法正是：<strong>CglibMethodInvocation</strong></p><p><a name="IBgca"></a></p><h2 id="AopBeanFactoryImpl"><a href="#AopBeanFactoryImpl" class="headerlink" title="AopBeanFactoryImpl"></a>AopBeanFactoryImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopBeanFactoryImpl</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AopBeanDefinition&gt; aopBeanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; aopBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object aopBean = aopBeanMap.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBeanDefinitionMap.containsKey(name))&#123;</span><br><span class="line">            AopBeanDefinition aopBeanDefinition = aopBeanDefinitionMap.get(name);</span><br><span class="line">            AdvisedSupport advisedSupport = getAdvisedSupport(aopBeanDefinition);</span><br><span class="line">            aopBean = <span class="keyword">new</span> CglibAopProxy(advisedSupport).getProxy();</span><br><span class="line">            aopBeanMap.put(name,aopBean);</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, AopBeanDefinition aopBeanDefinition)</span></span>&#123;</span><br><span class="line">        aopBeanDefinitionMap.put(name,aopBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AdvisedSupport <span class="title">getAdvisedSupport</span><span class="params">(AopBeanDefinition aopBeanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        List&lt;String&gt; interceptorNames = aopBeanDefinition.getInterceptorNames();</span><br><span class="line">        <span class="keyword">if</span>(interceptorNames != <span class="keyword">null</span> &amp;&amp; !interceptorNames.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (String interceptorName : interceptorNames) &#123;</span><br><span class="line"></span><br><span class="line">                Advice advice = (Advice) getBean(interceptorName);</span><br><span class="line"></span><br><span class="line">                Advisor advisor = <span class="keyword">new</span> Advisor();</span><br><span class="line">                advisor.setAdvice(advice);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> BeforeMethodAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = BeforeMethodAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> AfterRunningAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = AfterRunningAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">new</span> TargetSource();</span><br><span class="line"></span><br><span class="line">        Object object = getBean(aopBeanDefinition.getTarget());</span><br><span class="line"></span><br><span class="line">        targetSource.setTagetClass(object.getClass());</span><br><span class="line">        targetSource.setTagetObject(object);</span><br><span class="line"></span><br><span class="line">        advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisedSupport;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个AOP Bean Factory，它是一个扩展了普通Bean Factory的类，用于创建和管理AOP bean。该类继承了BeanFactoryImpl，并重写了getBean方法，用于检查所请求的Bean是否已经是AOP bean，如果是则返回AOP bean。如果不是AOP bean，则继续通过调用父类的getBean方法获取普通bean。AopBeanFactoryImpl还有registerBean方法，用于将定义的AOP bean注册到AOP Bean Factory的aopBeanDefinitionMap中。</p><p>在getAdvisedSupport方法中，它会创建一个AdvisedSupport对象，将目标对象和增强器（Advice）封装到Advisor对象中，并根据Advice类型将它们转化为对应的AopMethodInterceptor对象，然后将所有的AopMethodInterceptor对象添加到AdvisedSupport对象中。最后将目标对象封装到TargetSource对象中，并设置到AdvisedSupport对象中。然后返回AdvisedSupport对象。</p><p>当getBean方法检测到所请求的Bean是AOP bean时，它会从aopBeanDefinitionMap中获取Bean的定义，并创建相应的AdvisedSupport对象。然后创建一个CglibAopProxy对象，并使用该对象创建代理对象，最后将代理对象添加到aopBeanMap中。最终返回代理对象。</p><p><a name="BIrI3"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a name="mlhhh"></a></p><h3 id="TestClass"><a href="#TestClass" class="headerlink" title="TestClass"></a>TestClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"开始计时"</span>);</span><br><span class="line">        ThreadLocalUtils.set(startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印随机数值: "</span>+ UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndTimeAfterMethod</span> <span class="keyword">implements</span> <span class="title">AfterRunningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">after</span><span class="params">(Object returnVal, Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> startTime = ThreadLocalUtils.get();</span><br><span class="line">        ThreadLocalUtils.remove();</span><br><span class="line">        System.out.println(<span class="string">"方法耗时："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a test method"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JGPr2"></a></p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"beforeMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"StartTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"processMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"ProcessTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"afterMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"EndTimeAfterMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"TestService"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testServiceProxy"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"core.ProxyFactoryBean"</span>,</span><br><span class="line">    <span class="attr">"target"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"interceptorNames"</span>:[</span><br><span class="line">      <span class="string">"beforeMethod"</span>,</span><br><span class="line">      <span class="string">"processMethod"</span>,</span><br><span class="line">      <span class="string">"afterMethod"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a name="Z3M5m"></a></p><h3 id="MainTest"><a href="#MainTest" class="headerlink" title="MainTest"></a>MainTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AopApplictionContext aopApplictionContext = <span class="keyword">new</span> AopApplictionContext(<span class="string">"application.json"</span>);</span><br><span class="line">        aopApplictionContext.init();</span><br><span class="line">        TestService testService = (TestService) aopApplictionContext.getBean(<span class="string">"testServiceProxy"</span>);</span><br><span class="line">        testService.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="hemjx"></a></p><h3 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679659265097-017a1abd-1cbb-4840-9849-5c67b070dbed.png#averageHue=%23f7f6f5&clientId=u4abc7da4-0982-4&from=paste&height=171&id=u5b9f1a31&name=image.png&originHeight=256&originWidth=1143&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18875&status=done&style=none&taskId=ue6550e3c-a161-4300-b134-338c0010524&title=&width=762" alt="image.png"></p><p><a name="FXW4m"></a></p><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><a name="SO1vU"></a></p><h2 id="Jdk动态代理和Cglib动态代理什么关系"><a href="#Jdk动态代理和Cglib动态代理什么关系" class="headerlink" title="Jdk动态代理和Cglib动态代理什么关系"></a>Jdk动态代理和Cglib动态代理什么关系</h2><p>JDK动态代理和Cglib动态代理是两种常用的Java动态代理方式，它们都是用于在运行时动态地创建代理对象，实现对目标对象的增强功能。<br />JDK动态代理是通过Java反射机制来实现的，它只能为接口创建代理对象，而无法为类创建代理对象。JDK动态代理通过实现目标对象所实现的接口，在运行时生成一个代理类，代理类中包含了目标对象的引用以及拦截器对象的引用，从而可以在调用代理对象的方法时，将方法调用转发给拦截器对象进行处理。<br />Cglib动态代理则是通过生成目标对象的子类来实现的，它可以为类创建代理对象。Cglib动态代理在运行时通过生成目标对象的子类，重写目标对象的方法，并将目标对象的引用注入到代理对象中。当调用代理对象的方法时，代理对象会先调用目标对象的方法，然后再调用拦截器对象的方法进行增强处理。<br />虽然JDK动态代理和Cglib动态代理实现方式不同，但它们都可以实现对目标对象的增强功能，常用于实现AOP（面向切面编程）功能。在实际开发中，根据需要选择不同的动态代理方式，如果目标对象实现了接口，则可以使用JDK动态代理；如果目标对象没有实现接口，则可以使用Cglib动态代理。</p><p><a name="qRBPD"></a></p><h3 id="那是不是Cglib效率更高？为什么还需要JDK动态代理-？"><a href="#那是不是Cglib效率更高？为什么还需要JDK动态代理-？" class="headerlink" title="那是不是Cglib效率更高？为什么还需要JDK动态代理 ？"></a>那是不是Cglib效率更高？为什么还需要JDK动态代理 ？</h3><p>一般情况下，使用CGLIB生成代理类的效率确实比使用JDK动态代理更高，因为CGLIB是通过在编译时生成字节码来实现代理的，相对于JDK动态代理而言，不需要在运行时动态生成代理类。因此，在需要频繁生成代理类的场景下，使用CGLIB可能更适合。</p><p>然而，需要注意的是，CGLIB生成的代理类通常比原始类的大小要大，且CGLIB代理使用了更多的内存，这在创建大量代理对象的场景下可能会成为性能瓶颈。此外，由于CGLIB使用了底层字节码操作库，因此在某些环境下可能存在兼容性问题，需要额外考虑。</p><p>因此，在选择代理方式时，需要考虑实际场景和需求，并根据具体情况选择合适的代理方式。如果需要生成大量代理对象，并且不考虑内存占用问题，CGLIB可能更适合；如果需要更轻量级的代理方式，或者需要支持多态性、继承等特性，则JDK动态代理可能更合适。</p><p><a name="iHnyN"></a></p><h2 id="AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别"><a href="#AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别" class="headerlink" title="(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别"></a>(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别</h2><p>假设我们有一个接口UserService和一个实现类UserServiceImpl，其中UserService提供了一个getUserById()方法用于获取用户信息。我们需要对getUserById()方法进行日志记录，以便监控用户信息查询情况。<br><a name="VA788"></a></p><h3 id="使用JDK动态代理实现AOP功能："><a href="#使用JDK动态代理实现AOP功能：" class="headerlink" title="使用JDK动态代理实现AOP功能："></a>使用JDK动态代理实现AOP功能：</h3><p>我们可以使用JDK动态代理来创建UserService接口的代理对象，并将一个实现了InvocationHandler接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的invoke()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class[]&#123;UserService.class&#125;, proxy);</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="uzJJw"></a></p><h3 id="使用Cglib动态代理实现AOP功能："><a href="#使用Cglib动态代理实现AOP功能：" class="headerlink" title="使用Cglib动态代理实现AOP功能："></a>使用Cglib动态代理实现AOP功能：</h3><p>我们可以使用Cglib动态代理来创建UserServiceImpl类的代理对象，并将一个实现了MethodInterceptor接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的intercept()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceInterceptor());</span><br><span class="line"></span><br><span class="line">        UserServiceImpl userServiceProxy = (UserServiceImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述示例代码可以看出，使用JDK动态代理时，需要创建一个实现了InvocationHandler接口的拦截器对象，并将其注入到代理对象中；而使用Cglib动态代理时，需要创建一个实现了MethodInterceptor接口的拦截器对象，并将其注入到代理对象中。在JDK动态代理中，代理对象必须实现目标对象所实现的接口；而在Cglib动态代理中，代理对象</p><p><a name="lHuvV"></a></p><h2 id="IOC-使用反射、JDK、Cglib去实现依赖注入的区别"><a href="#IOC-使用反射、JDK、Cglib去实现依赖注入的区别" class="headerlink" title="(IOC)使用反射、JDK、Cglib去实现依赖注入的区别"></a>(IOC)使用反射、JDK、Cglib去实现依赖注入的区别</h2><p><a name="MOXbp"></a></p><h3 id="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用Cglib和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"></a>只使用反射与使用Cglib和反射来完成依赖注入有什么区别？</h3><p>在Spring中，依赖注入可以通过只使用反射或使用Cglib和反射来完成。下面是它们之间的一些区别：</p><ol><li>实现方式：只使用反射时，Spring通过反射机制来动态创建对象并设置属性值。而使用Cglib和反射时，Spring通过Cglib在运行时动态创建代理类，并在代理类中使用反射来设置属性值。</li><li>性能：只使用反射时，每次获取Bean时都需要通过反射机制来动态创建对象和设置属性值，因此在性能上可能存在一定的开销。而使用Cglib和反射时，Spring可以在第一次获取Bean时创建代理类，并缓存代理类实例，之后每次获取Bean时都可以直接使用代理类，从而提高了性能。</li><li>功能扩展：只使用反射时，Spring的功能扩展比较有限，因为只能使用Java反射机制来动态创建对象和设置属性值。而使用Cglib和反射时，Spring可以通过Cglib来实现更多的功能扩展，比如实现AOP切面等。</li></ol><p>总的来说，只使用反射相对于使用Cglib和反射来完成依赖注入，性能可能会稍差一些，但是在一些场景下可能会更加灵活，因为不需要引入Cglib这样的第三方库。而使用Cglib和反射来完成依赖注入则能够更好地支持一些功能扩展，比如实现AOP切面等。</p><p>举一个简单的例子，假设有一个名为UserService的服务类，它依赖于名为UserDao的DAO类。下面是使用只使用反射和使用Cglib和反射来实现依赖注入的代码示例：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring会通过反射来动态创建UserService和UserDao对象，并在运行时调用setUserDao方法来设置依赖关系。</p><p>使用Cglib和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDaoInterceptor拦截器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法执行前做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"Before method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="comment">// 在方法执行后做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"After method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDaoProxy"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoProxy"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cglib.proxy.Enhancer"</span></span><br><span class="line">        factory-method=<span class="string">"create"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"interceptor"</span></span><br><span class="line">        ref=<span class="string">"userDaoInterceptor"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoInterceptor"</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDaoInterceptor"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring使用Cglib创建一个名为userDaoProxy的代理类，这个代理类继承自UserDao类，并在运行时动态生成。代理类中有一个拦截器UserDaoInterceptor，它会在UserDao类的方法执行前后做一些额外的处理，比如日志记录等。当Spring需要注入UserDao依赖时，会注入userDaoProxy代理类，代理类会使用反射来设置依赖关系。此外，当调用UserService的saveUser方法时，userDaoProxy代理类会通过反射调用UserDao的save方法，并在方法执行前后调用UserDaoInterceptor的相关方法。</p><p><a name="jlq4z"></a></p><h3 id="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"></a>只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？</h3><p>使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象。<br />举个例子，假设有一个UserService接口和UserService实现类，实现类需要注入一个UserDao对象。下面分别使用反射和JDK动态代理来完成依赖注入：<br />使用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            userDao = (UserDao) constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用Class.forName方法获取UserDaoImpl类的Class对象，然后使用反射获取构造函数，并创建UserDaoImpl对象。</p><p>使用JDK动态代理和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            Object dao = constructor.newInstance();</span><br><span class="line">            method.invoke(target, dao);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">this</span>);</span><br><span class="line">        ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">        userDao = (UserDao) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; UserDao<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">proxy</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个UserServiceProxy代理类，实现了InvocationHandler接口，并重写了invoke方法。在invoke方法中，如果是set方法，我们使用反射获取UserDaoImpl类的Class对象和构造函数，创建UserDaoImpl对象，并通过反射调用set方法来完成依赖注入。否则，我们通过反射调用目标对象的方法。</p><p>然后，在UserServiceImpl构造方法中，我们创建了UserServiceProxy代理对象，并使用Proxy.newProxyInstance方法创建了一个UserDao的代理对象。这个代理对象会拦截所有UserDao的方法调用，并通过InvocationHandler的invoke方法进行处理。</p><p>需要注意的是，由于代理对象实现了UserDao接口，因此在使用代理对象时，需要将其转换为UserDao类型。</p><p>总的来说，使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象，可以对其方法进行拦截和处理。</p><p><a name="j91gI"></a></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><a name="AQ3Uy"></a></p><h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3><p>Cglib是通过字节码生成技术来实现动态代理的，它会在运行时动态生成被代理类的子类，并在子类中覆盖被代理类的方法，从而实现方法拦截和增强。</p><p>在Spring中，当使用Cglib代理时，Spring会在运行时动态生成被代理类的子类，并在子类中实现依赖注入。Cglib会通过反射机制获取被代理类的构造函数和参数，然后通过Constructor.newInstance方法创建被代理类的实例。</p><p>具体来说，Spring会在运行时动态生成一个类，继承被代理类，并重写其中需要拦截和增强的方法。同时，它还会在生成的类中添加一个无参构造函数，并在其中通过反射机制实例化被代理类，并完成依赖注入。在这个过程中，Cglib会使用asm字节码操作库来生成字节码，完成类的定义和加载。</p><p>因此，使用Cglib代理时，它会通过字节码生成技术来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用JDK动态代理，不需要被代理类实现接口，可以拦截和增强非public方法，但是会比JDK动态代理更消耗内存和CPU资源。<br><a name="Mu6c3"></a></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过反射机制来实现动态代理的，它会在运行时动态生成一个实现了被代理接口的代理类，并在代理类中实现方法拦截和增强。</p><p>在Spring中，当使用JDK动态代理时，Spring会使用Java提供的Proxy类来生成代理类，并在代理类中实现依赖注入。具体来说，Spring会使用Proxy类的newProxyInstance方法来生成代理类，该方法需要传入一个ClassLoader对象、一组被代理的接口、和一个InvocationHandler对象。在生成代理类的过程中，JDK动态代理会通过反射机制获取被代理接口的方法，然后通过InvocationHandler对象的invoke方法来进行方法的拦截和增强。</p><p>因此，使用JDK动态代理时，它会通过反射机制来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用Cglib代理，需要被代理类实现接口，不能拦截和增强非public方法，但是会比Cglib代理更节省内存和CPU资源。<br><a name="UrKkw"></a></p><h3 id="Cglib相对于JDK动态代理"><a href="#Cglib相对于JDK动态代理" class="headerlink" title="Cglib相对于JDK动态代理"></a>Cglib相对于JDK动态代理</h3><p>Cglib相对于JDK动态代理来说，有以下两个方面的优势，导致它在一些情况下可能比JDK动态代理更快：</p><ol><li><p>Cglib代理不需要被代理类实现接口，可以拦截和增强非public方法，而JDK动态代理只能代理实现了接口的类。因此，在需要拦截非public方法的情况下，Cglib代理可能比JDK动态代理更适合。</p></li><li><p>在拦截方法调用的时候，Cglib代理不需要调用被代理类的方法，而JDK动态代理需要通过反射调用被代理类的方法。因此，在需要进行大量方法调用的情况下，Cglib代理可能比JDK动态代理更快。</p></li></ol><p>总的来说，Cglib代理和JDK动态代理各有优缺点，在具体的应用场景中需要根据实际情况选择合适的代理方式。</p><p><a name="aSPZk"></a></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><a name="eXFA4"></a></p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理是基于继承来实现代理，它会在运行时动态生成目标对象的子类，并在子类中重写目标对象的非final方法，从而实现对目标对象的代理。这个子类会被当作代理类，被加载到JVM中，并用来完成方法调用。</p><p>具体来说，Cglib会使用ASM等字节码操作库生成代理类的字节码，然后通过ClassLoader将其加载到JVM中。生成的代理类会继承目标对象的类，并重写目标对象的非final方法。在生成代理类后，Cglib会创建代理对象，这个代理对象实际上就是生成的代理类的实例。当代理对象调用目标对象的方法时，实际上是调用了生成的代理类中重写的方法，从而实现了代理的功能。</p><p>因此，Cglib生成的子类会替代原始的目标对象，成为代理对象的实现。这个子类重写了目标对象的方法，从而实现了对目标对象方法的增强和拦截。<br><a name="r0cru"></a></p><h3 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是基于接口来实现代理的，它会在运行时动态生成一个代理接口的代理类，并将这个代理类实例化成代理对象。这个代理类会实现目标对象实现的接口，并且会拦截所有接口中定义的方法调用。</p><p>具体来说，JDK动态代理会在运行时使用Java反射机制动态生成代理类的字节码，并将其加载到JVM中。生成的代理类会实现目标对象实现的接口，并在代理类中实现对目标对象方法的拦截和增强。当代理对象调用目标对象的方法时，实际上是通过反射机制调用了代理类中的方法，从而实现了代理的功能。</p><p>因此，JDK动态代理实现了对接口的代理，可以通过实现一个代理接口来实现代理功能，而且可以在运行时动态生成代理类，并将其加载到JVM中，实现了对目标对象的动态代理。同时，由于是基于接口来实现代理的，所以在类型上更加灵活，但也因为这个原因，只能代理实现了接口的类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;Bk5lF&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;br /&gt;&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;vHThd&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现IOC&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于循环依赖的见解</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-12-18T12:20:46.000Z</published>
    <updated>2023-04-26T10:14:11.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于循环依赖的见解"><a href="#关于循环依赖的见解" class="headerlink" title="关于循环依赖的见解"></a>关于循环依赖的见解</h1><p>关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章（虽然很多是错误的）。</p><p>发现，<strong>其实二级缓存就能够解决循环依赖问题，根本不需要三级缓存</strong>。</p><p>首先，在单纯IOC的状态下，出现了循环依赖问题，在Bean不涉及代理对象的情况下，是只需要二级缓存的，但是很多文章说，因为涉及到AOP产生了代理对象，所以需要三级缓存，因为二级缓存和三级缓存存的对象不一样。但实际上，就算直接使用二级缓存，也是可以解决循环依赖问题，即使他们不一样。</p><p><strong>在任何状态下，二级缓存都能够完全的解决循环依赖问题，不管Bean有没有产生代理</strong>。</p><p>证明：(代补充)</p><p>但是Spring 为什么还是要使用三级缓存呢？因为设计者对于AOP一直都有一个原则：<strong>在对象初始化完毕后，再去创建代理对象</strong> </p><p>所以<strong>设计者一直在试图延迟代理对象的创建</strong>：</p><p>举例：</p><p>只有二级缓存：</p><p>1、发生了循环依赖，自然，在需要的时候就创建出来代理对象，放入缓存</p><p>2、没发生循环依赖，但是还是每一个对象在创建出原始对象后，就都会去创建代理对象</p><p>有三级缓存：</p><p>1、发生了循环依赖，在需要的时候就创建出来代理对象，放入二级缓存。</p><p>2、没发生循环依赖，正常的在初始化的后置处理器中创建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于循环依赖的见解&quot;&gt;&lt;a href=&quot;#关于循环依赖的见解&quot; class=&quot;headerlink&quot; title=&quot;关于循环依赖的见解&quot;&gt;&lt;/a&gt;关于循环依赖的见解&lt;/h1&gt;&lt;p&gt;关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty+Nacos+Protobuf制作RPC框架</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/11/02/srpc/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/11/02/srpc/</id>
    <published>2022-11-02T06:39:27.000Z</published>
    <updated>2023-04-18T08:23:57.368Z</updated>
    
    <content type="html"><![CDATA[<p><a name="ly3F9"></a></p><h1 id="使用Netty-Nacos-Protobuf制作RPC框架"><a href="#使用Netty-Nacos-Protobuf制作RPC框架" class="headerlink" title="使用Netty+Nacos+Protobuf制作RPC框架"></a>使用Netty+Nacos+Protobuf制作RPC框架</h1><p><a name="KeQ2k"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a name="FQTT2"></a></p><h3 id="显现的功能"><a href="#显现的功能" class="headerlink" title="显现的功能"></a>显现的功能</h3><p>这个RPC实现了一些基本的功能：</p><ul><li>使用Netty来进行网络传输，效率比起传统的NIO要高很多。</li><li>使用单例模式，在Netty获取Channel的过程中，会有一个ChannelProvider去提供Channel单例。</li><li>使用Nacos作为服务的注册中心，用于管理注册的服务，当客户端请求发过来时，Nacos会寻找合适的服务返回给客户端消费。</li><li>实现了负载均衡的功能，，客户端对于Nacos返回的服务列表，会使用负载均衡算法，选择一个自己需要的服务加入，目前实现了轮询算法和随机选取算法。</li><li>加入了心跳检测机制，并不会发送完消息立即结束，而是保持的长连接，提高效率。</li><li>使用Potobuf作为对象的的序列化工具，实现Netty中的编/解码的功能，提高了效率。</li><li>实现了钩子函数，当服务端下线的时候会自动去Nacos注销服务。</li><li>使用CompletableFuture来接受客户端返回的结果。</li></ul><p><a name="UlREa"></a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>由于使用Nacos，调试比较简单：<br />下载好Nacos，无论是win版还是linux版，在官网都有，比较方便；<br />但是由于Nacos一般都要配置数据库，为了方便测试，可以使用命令先进行单机运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">114514</span>, <span class="string">"Client send a Message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> NettyServer(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后会有一个测试结果：<br />客户端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513541152-f58818bf-b30d-438c-bebd-3374cb6f6b3f.png#averageHue=%23f5ecea&clientId=ucfcf756b-0ecd-4&from=paste&height=400&id=uc9973f1d&name=image.png&originHeight=600&originWidth=2205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111506&status=done&style=none&taskId=ubbd01eee-67bf-4697-b872-6eef4c3b304&title=&width=1470" alt="image.png"><br />服务端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513584290-393ae7f9-f650-4a6d-b6a2-ad58cd7c2360.png#averageHue=%23f5ebe9&clientId=ucfcf756b-0ecd-4&from=paste&height=301&id=u72da898a&name=image.png&originHeight=452&originWidth=2307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88585&status=done&style=none&taskId=u57f54541-d548-4720-aca7-051e4b65050&title=&width=1538" alt="image.png"></p><p><a name="VFwOu"></a></p><h2 id="服务端分析"><a href="#服务端分析" class="headerlink" title="服务端分析"></a>服务端分析</h2><p>首先服务端都会实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.PROTOBUF_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口通常定义了默认的序列化方法，开始方法，和发布服务的方法。<br />接着会有一个抽象类去实现这个接口：<br><a name="DbRAB"></a></p><h3 id="AbstractRpcServer"><a href="#AbstractRpcServer" class="headerlink" title="AbstractRpcServer"></a>AbstractRpcServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"启动类缺少 @ServiceScan 注解"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"出现未知错误"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service<span class="class">.<span class="keyword">class</span>).<span class="title">name</span>()</span>;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"创建 "</span> + clazz + <span class="string">" 时有错误发生"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">""</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    这段代码是在判断 Service 注解中的 name 属性是否为空，如果为空，</span></span><br><span class="line"><span class="comment">                    则说明该服务实现类实现了多个接口，并且需要将每个接口都发布成一个独立的服务。</span></span><br><span class="line"><span class="comment">                    所以，代码通过获取该服务实现类的所有接口，然后将每个接口都作为一个独立的服务进行发布。</span></span><br><span class="line"><span class="comment">                    如果 name 属性不为空，则说明只需要将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                    此时，代码直接将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanServices 的作用：这段代码是服务扫描的核心实现，它通过获取启动类的信息，获取服务扫描的基础包路径，然后扫描该路径下的所有类，判断是否有@Service注解，如果有，就将该服务发布到注册中心。<br />具体的实现流程如下：</p><ol><li>调用ReflectUtil.getStackTrace()方法获取当前方法调用的栈信息，得到启动类的全限定名。</li><li>使用Class.forName()方法加载启动类，判断启动类是否被@ServiceScan注解所标注，如果没有则抛出异常。</li><li>获取@ServiceScan注解的参数值，即基础包路径。</li><li>调用ReflectUtil.getClasses()方法获取指定包下的所有类，遍历这些类，判断是否被@Service注解所标注。</li><li>如果被@Service注解所标注，则获取@Service注解的参数值，即服务名称，如果未指定服务名称，则获取该服务实现类实现的所有接口，并将该服务发布到注册中心。</li><li>如果指定了服务名称，则直接将该服务发布到注册中心。</li></ol><p>该方法主要的功能就是扫描服务，将服务发布到注册中心，为后续的服务调用提供依据<br />接着我们来看看这个所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务扫描的基包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上述提到的ReflectUtil这个类是一个比较常见的类，这个类是一个工具类，提供了两个静态方法：getStackTrace(): 返回当前调用栈顶部的类名。利用Java的反射机制，调用 new Throwable().getStackTrace() 方法获取当前调用栈信息，返回调用栈顶部的类名。<br />getClasses(String packageName): 获取指定包名下所有的类。该方法通过输入一个包名，然后通过反射机制查找该包下的所有类，返回一个 Set&lt;Class&lt;?&gt;&gt; 对象。该方法实现的过程比较复杂，具体过程为：</p><ol><li>通过 Thread.currentThread().getContextClassLoader().getResources(packageDirName) 获取指定包名下的所有资源。</li><li>遍历所有资源，如果是文件，则通过递归方式查找该文件夹下所有的类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li><li>如果是 Jar 包，则通过 JarFile 对象查找该 Jar 包中的所有类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li></ol><p>该工具类可以用于类加载器等需要动态加载类的场景，例如 Spring 框架中的 Bean 加载、RPC 框架中的服务注册等</p><p><a name="azGEB"></a></p><h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><p>接着便是这个RPC服务端的逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同时也继承了serviceRegistry和serviceProvider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 256)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"启动服务器时有错误发生: "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类实现了一个基于Netty框架的RPC服务器，它继承了抽象类AbstractRpcServer，并且拥有服务注册表（serviceRegistry）和服务提供者（serviceProvider）的实例。<br />在构造函数中，传入了服务器的主机名和端口号，以及序列化器（serializer）。在构造函数中还调用了扫描服务的方法scanServices()。<br />在start()方法中，创建了两个EventLoopGroup，用于处理连接和IO的事件。然后使用ServerBootstrap创建了一个服务端的引导类，通过设置一系列的选项和处理器来配置Netty服务器。其中，ChannelInitializer是一个特殊的处理器，用于在Channel被创建时执行一些初始化操作。在这个ChannelInitializer中，注册了一个IdleStateHandler用于处理空闲连接，以及自定义的编解码器和处理器。<br />最后，通过调用bind()方法绑定主机名和端口号，并且调用sync()方法等待服务器启动完成。当关闭服务器时，调用shutdownGracefully()方法优雅地关闭EventLoopGroup。<br />这就是这个类的大体流程，接下来，可以一个个分开来看<br />其中，NacosServiceRegistry会返回一个服务注册器实例，但是这个实例实际上会调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"注册服务时有错误发生:"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是NacosUtil去实现服务注册：<br><a name="Q2Adh"></a></p><h4 id="NacosUtil"><a href="#NacosUtil" class="headerlink" title="NacosUtil"></a>NacosUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">"127.0.0.1:8848"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接到Nacos时有错误发生: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"注销服务 &#123;&#125; 失败"</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个Nacos工具类，用于连接到Nacos服务注册中心并与之进行交互。主要包含以下几个方法：</p><ol><li>getNacosNamingService()方法用于获取NacosNamingService实例。</li><li>registerService(String serviceName, InetSocketAddress address)方法用于向Nacos注册服务实例，即将提供服务的服务地址和端口注册到Nacos中，以便客户端可以通过服务名称查找到该服务。</li><li>getAllInstance(String serviceName)方法用于获取指定服务名称下的所有服务实例，返回一个Instance列表。</li><li>clearRegistry()方法用于清空注册中心中注册的服务实例，即将服务注销。</li></ol><p>通过这个工具类，我们可以将服务注册到Nacos服务注册中心，并通过Nacos中心来查找并获取服务实例，以便客户端可以通过服务名称调用相应的服务。<br><a name="wIRIl"></a></p><h4 id="ServiceProviderImpl"><a href="#ServiceProviderImpl" class="headerlink" title="ServiceProviderImpl"></a>ServiceProviderImpl</h4><p>而ServiceProviderImpl默认的服务注册表，保存服务端本地服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">"向接口: &#123;&#125; 注册服务: &#123;&#125;"</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个服务提供者的默认实现类，它实现了 ServiceProvider 接口中的方法，可以将提供者实例添加到服务注册表中，提供了一种方便地访问服务的方式。在服务注册表中，服务名与服务实例之间的映射关系是使用 ConcurrentHashMap 实现的。它有两个主要方法：</p><ol><li>addServiceProvider(T service, String serviceName)：将服务提供者添加到服务注册表中，当服务名已经存在于注册表中时，则不进行任何操作。</li><li>getServiceProvider(String serviceName)：根据服务名从服务注册表中获取相应的服务实例。如果服务不存在，则抛出 RpcException 异常，表示未找到服务。</li></ol><p><a name="RA6ZR"></a></p><h4 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h4><p>当一个服务开启之后，也会开始一个钩子函数，它的Runtime类会使用getRuntime().addShutdownHook()方法，在服务结束前，注销掉所有的在Nacos的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"关闭后将自动注销所有服务"</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个单例，它提供了一个静态方法getShutdownHook()来获取一个实例。它注册了一个JVM shutdown hook，该hook会在JVM关闭前被执行，清除所有注册到Nacos服务注册中心上的服务和所有线程池。这个类的作用是确保在JVM关闭前执行清除操作，避免可能的资源泄漏和数据一致性问题。</p><p><a name="klHf5"></a></p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>这里在SocketChannel中加入了一个IdleStateHandler，使其具有心跳检测功能<br />在 Netty 中，IdleStateHandler 是一个用于处理空闲状态的处理器。它可以在 Channel 上检测特定类型的空闲时间，并在这些时间段内未发生读取、写入或读写事件时触发相应的事件。常用的空闲状态类型有三种：READER_IDLE，WRITER_IDLE 和 ALL_IDLE。<br />IdleStateHandler 可以用于实现心跳机制，可以通过配置空闲时间间隔和触发事件来判断是否需要发送心跳包。它可以被添加到 Netty 的 ChannelPipeline 中，以监视 Channel 上的空闲事件，以便可以采取适当的措施，例如关闭连接或发送心跳消息。</p><p><a name="fWDhA"></a></p><h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><p>这里也同时添加了一个NettyServerHandler去处理在Channel中发生的时间。<br />先拿上面的心跳检测为例子，如果收到了一个心跳包，便会打印一条日志，告诉服务端收到了。而在长时间没有收到心跳包后，则会关闭上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">"接收到客户端心跳包..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"服务器接收到请求: &#123;&#125;"</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"通道不可写"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"处理过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"长时间未收到心跳包，断开连接..."</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleChannelInboundHandler 是 Netty 中的一个基础类，实现了 ChannelInboundHandler 接口。它主要用于处理入站事件，即从对等端接收到的数据或状态更改事件，例如对等端连接或断开连接。与 ChannelInboundHandlerAdapter 不同的是，SimpleChannelInboundHandler 可以自动释放资源，因此不需要显示地调用 ReferenceCountUtil.release() 释放资源。<br />当数据从远程节点传入时，SimpleChannelInboundHandler 将自动将其转换为指定类型的对象，并在调用 channelRead0() 方法时向你提供该对象，你只需要处理传入的数据。可以使用这个类来构建各种应用程序，例如聊天应用程序、游戏服务器、文件传输应用程序等。<br />而这里的requestHandler是一个单例，表示全程都使用这个单例去处理请求，这样就不会浪费大量的资源去重复创建实例。<br><a name="MTSdN"></a></p><h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">"服务:&#123;&#125; 成功调用方法:&#123;&#125;"</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个RequestHandler使用的方法不多，最为主要的方法还是：<br>:::info<br>result = method.invoke(service, rpcRequest.getParameters());<br>:::<br>这个方法会调用Method实例的invoke方法，去执行相应的请求。<br />在Java中，Method类是反射机制的一部分，它代表一个类中的一个方法。可以使用Method类来获取关于方法的信息，如方法名、参数列表、返回类型、修饰符等，并且可以使用Method类来调用该方法。Method类提供了许多用于获取和调用方法的方法，如invoke()、getName()、getParameterTypes()、getReturnType()等。反射机制中的Method类可以使得在运行时动态地获取和调用类中的方法。</p><p><a name="Le2TA"></a></p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器可以说是整个RPC框架中最为重要的一部分，那么RPC为什么需要编解码器呢？<br />因为在RPC通信过程中，数据需要在网络中传输。在不同的计算机之间通信需要将对象序列化为字节流，传输完成后再反序列化为对象。编解码器的作用就是将对象序列化和反序列化的过程封装起来，让开发者可以更方便地进行通信。在Netty中，SimpleChannelInboundHandler类可以自动完成消息的解码和编码，大大简化了编解码器的编写过程。<br />那为什么不用直接用序列化？<br />虽然序列化可以将对象转换成字节流进行网络传输，但是它并不能满足RPC的需求。<br />RPC需要一个通用的方式来序列化和反序列化各种类型的消息，包括基本数据类型、复合数据类型和自定义类型等。而不同的序列化实现可能只支持特定的类型或数据格式，因此无法满足这个需求。<br />此外，RPC需要支持不同的编解码器，以便兼容不同的协议和框架。使用编解码器可以使得不同的实现之间相互兼容，也方便进行协议升级和兼容性处理。<br />因此，编解码器是RPC中必不可少的组件，它能够实现通用的序列化和反序列化，同时兼容不同的协议和框架，满足RPC的需求。</p><p><a name="BVL84"></a></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>MessageToByteEncoder 是 Netty 提供的编码器抽象类，用于将消息转换为字节流进行网络传输。在 Netty 应用中，可以使用它将自定义的消息对象编码为二进制数据，以便通过网络进行传输。<br />实现 MessageToByteEncoder 需要重写 encode() 方法，该方法会在消息被写入通道前被自动调用。在 encode() 方法中，我们需要将消息对象转换为字节流，并将字节流写入到 ByteBuf 中。写入到 ByteBuf 中的字节流会在后续的 ChannelHandler 中被传递，最终通过网络传输到远程节点。<br />MessageToByteEncoder 中还提供了一些辅助方法，如 writeXXX() 系列方法可以将不同类型的数据写入到 ByteBuf 中，以及提供了一些钩子方法，可以在编码过程中对消息进行处理，比如对消息进行压缩、加密等操作。<br />总之，MessageToByteEncoder 是 Netty 提供的编码器抽象类，通过继承它可以实现自定义的消息编码器。<br />CommonEncoder继承了MessageToByteEncoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 Netty 中的编码器类，用于将消息对象转换为二进制字节流，以便在网络上进行传输。在 RPC 中，消息通常是由客户端和服务端之间相互传递的。因为在不同的机器之间传递数据时，需要将数据序列化为二进制流，才能在网络中传输。但是，不同的序列化方式可能具有不同的数据格式和协议，所以需要使用编解码器来统一数据格式和协议。这个类实现了 Netty 中的 MessageToByteEncoder 类，并将消息对象编码为二进制流，遵循了一个特定的协议，包括一个魔数、消息类型、序列化方式、消息长度和消息内容。其中，魔数用于识别协议版本，消息类型用于标识消息是请求还是响应，序列化方式用于指定消息内容的序列化方式，消息长度用于指定消息内容的长度，消息内容就是序列化后的消息体。这个类是 RPC 通信中必不可少的一部分。</p><p><a name="Mudkb"></a></p><h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>ReplayingDecoder是Netty提供的一种特殊类型的解码器。与普通解码器不同，ReplayingDecoder可以在缓冲区数据不足时进行暂停，并在数据可用时恢复处理，而不是等待缓冲区填满。<br />具体来说，ReplayingDecoder类通过继承ByteToMessageDecoder类并使用状态机模式实现。状态机模式通过在每个状态中重写decode()方法来定义不同的处理行为。当状态更改时，它将转移到下一个状态，直到解码完成为止。<br />ReplayingDecoder的主要作用是简化解码器的实现，尤其是对于一些不确定数据长度的解码器。通过使用ReplayingDecoder，可以避免手动跟踪缓冲区中的字节数，从而减少出错的可能性。同时，ReplayingDecoder还可以提供更好的性能，因为它只需要处理缓冲区中实际可用的数据，而不是缓冲区中的所有数据<br />CommonDecoder继承了ReplayingDecoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的协议包: &#123;&#125;"</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的数据包: &#123;&#125;"</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的反序列化器: &#123;&#125;"</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个Netty解码器，用于将字节流转换为对象。具体来说，它的作用是将从网络中接收到的字节流解码为指定的Java对象，以供后续处理。<br />在方法decode()中，它首先读取一个整数值，如果它不等于预定义的一个常量值，就会抛出一个RpcException异常，这表示该字节流不是正确的RPC协议包。接下来，它读取协议包类型和序列化器类型，并检查它们是否为预期值，否则将抛出异常。然后，它读取字节流的长度，并将剩余的字节读入到字节数组中。最后，它使用指定的序列化器将字节流反序列化为预期的Java对象，并将其添加到输出列表中</p><p><a name="y5CbI"></a></p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protocol Buffers（简称protobuf）是一种轻便高效的数据序列化格式，由Google开发。它与XML和JSON等格式相比，具有更小的数据体积和更快的解析速度，同时也可以生成各种编程语言的代码，从而方便了跨语言的数据交换和通信。在Java中，我们可以通过使用Protobuf库来实现Protobuf的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; schemaCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        Class clazz = obj.getClass();</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        Object obj = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">"PROTOBUF"</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Schema <span class="title">getSchema</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = schemaCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(schema)) &#123;</span><br><span class="line">            <span class="comment">// 这个schema通过RuntimeSchema进行懒创建并缓存</span></span><br><span class="line">            <span class="comment">// 所以可以一直调用RuntimeSchema.getSchema(),这个方法是线程安全的</span></span><br><span class="line">            schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(schema)) &#123;</span><br><span class="line">                schemaCache.put(clazz, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个实现了CommonSerializer接口的类，用于将Java对象序列化为Protobuf格式的字节数组，或者将字节数组反序列化为Java对象。<br />具体来说，该类中的serialize方法将一个Java对象序列化为Protobuf格式的字节数组，实现过程如下：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>使用该Schema对象和LinkedBuffer对象调用ProtostuffIOUtil.toByteArray方法将Java对象序列化为字节数组。</li><li>最后清空LinkedBuffer对象并返回序列化后的字节数组。</li></ol><p>而deserialize方法则是将字节数组反序列化为Java对象：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>调用schema.newMessage()创建一个该类的空对象。</li><li>使用字节数组和Schema对象调用ProtostuffIOUtil.mergeFrom方法将字节数组反序列化为Java对象并返回。</li></ol><p>同时，为了提高性能，该类中使用了缓存机制，通过ConcurrentHashMap缓存Schema对象，以便在下次序列化或反序列化时能够更快地获取Schema对象，避免了重复创建的开销。</p><p>在具体的分析下面类的作用：<br><a name="RoCQJ"></a></p><h4 id="LinkedBuffer"><a href="#LinkedBuffer" class="headerlink" title="LinkedBuffer"></a>LinkedBuffer</h4><p>LinkedBuffer是Protostuff序列化库中的一个类，用于在序列化过程中存储数据。它是一个基于链表的动态缓存区，它会自动根据当前写入数据的大小来调整缓存区的大小。<br />具体来说，LinkedBuffer维护了一个字节数组（即缓存区），一个指向缓存区首部的指针和一个指向缓存区尾部的指针。当我们往缓存区写入数据时，LinkedBuffer会先检查当前剩余的空间是否足够，如果不够则会自动扩展缓存区。扩展时会新建一个更大的缓存区，并将当前缓存区中的数据复制到新缓存区中，然后将新缓存区设置为当前缓存区。<br />LinkedBuffer使用链表来管理多个缓存区，每次扩展时都会新建一个缓存区并添加到链表尾部。这样做的好处是可以避免频繁的内存分配和拷贝，从而提高序列化性能。<br />在上面的代码中，LinkedBuffer被用于在ProtobufSerializer类中序列化对象时存储数据。当我们调用ProtostuffIOUtil.toByteArray()方法将一个对象序列化为字节数组时，需要传入一个LinkedBuffer对象作为参数，这个对象会在序列化过程中被自动扩展。当序列化完成后，我们需要手动调用LinkedBuffer.clear()方法清空缓存区，以便下次使用。<br><a name="I3nN9"></a></p><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>在 Protobuf 序列化中，Schema 是一个用于描述消息结构的类，类似于 Java 对象中的 Class。Schema 类的实例提供了一些方法来获取消息的字段和类型信息，从而可以将消息序列化和反序列化为二进制数据。<br />在使用 Protobuf 进行序列化时，我们需要为每个消息类创建一个 Schema 对象，并将其缓存起来以供重复使用。这样可以提高序列化和反序列化的效率，避免重复创建和解析 Schema 对象。<br />在上面提供的 ProtobufSerializer 类中，getSchema 方法用于获取指定类型的 Schema 对象。如果缓存中已经存在该类型的 Schema 对象，则直接返回；否则，使用 RuntimeSchema.getSchema 方法创建一个新的 Schema 对象，并将其存入缓存中。这样，在序列化和反序列化时，就可以直接使用缓存中的 Schema 对象，提高了性能。<br><a name="FAUkt"></a></p><h4 id="ProtostuffIOUtil"><a href="#ProtostuffIOUtil" class="headerlink" title="ProtostuffIOUtil"></a>ProtostuffIOUtil</h4><p>ProtostuffIOUtil是Protostuff序列化框架中的一个工具类，主要提供了将Java对象序列化成byte数组和将byte数组反序列化成Java对象的功能。<br />它提供了以下主要的静态方法：</p><ul><li>toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)：将一个Java对象序列化成byte数组。</li><li>fromByteArray(byte[] data, T message, Schema<T> schema)：将一个byte数组反序列化成Java对象。</li><li>mergeFrom(byte[] data, T message, Schema<T> schema)：将一个byte数组中的数据合并到一个Java对象中。</li></ul><p>其中，Schema是Protostuff序列化框架中的一个关键接口，用于描述Java对象的序列化格式。而LinkedBuffer则是一个可扩容的缓冲区，用于存储序列化后的数据。在使用Protostuff进行序列化时，可以通过LinkedBuffer.allocate()方法创建一个缓冲区，用于存储序列化后的数据。<br><a name="S4KTX"></a></p><h4 id="RuntimeSchema"><a href="#RuntimeSchema" class="headerlink" title="RuntimeSchema"></a>RuntimeSchema</h4><p>RuntimeSchema是Protostuff库的一个类，它提供了将Java类转换为Protobuf格式的Schema的功能。在使用Protobuf进行序列化和反序列化时，需要提供一个Schema来指定序列化的字段、类型等信息。RuntimeSchema的作用就是根据Java类的结构生成一个对应的Schema。<br />通常情况下，使用Protobuf进行序列化和反序列化时，需要手动定义一个Proto文件来描述消息的结构。而使用RuntimeSchema，可以将Java类当作Proto文件来使用，它会自动生成一个对应的Schema。<br />需要注意的是，由于RuntimeSchema是在运行时生成的，因此会对性能产生一定影响。在高性能场景中，建议使用预编译的Proto文件来进行序列化和反序列化。</p><p><a name="njTxV"></a></p><h2 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a>客户端分析</h2><p>要实现客户端的逻辑，最基本的就是要实现动态代理：<br />InvocationHandler 是 Java 标准库中的一个接口，它用于实现动态代理。<br />动态代理是一种运行时生成代理对象的技术。使用动态代理可以在运行时动态地创建一个实现特定接口的代理类，这个代理类可以将所有方法调用委托给指定的对象或方法。在委托调用前或调用后，代理类可以执行额外的逻辑，例如统计方法调用次数、记录方法调用日志等。<br />InvocationHandler 接口定义了一个方法 invoke，该方法会在代理类每次调用方法时被调用。该方法有三个参数：</p><ol><li>proxy：代理对象</li><li>method：被调用的方法</li><li>args：被调用方法的参数列表</li></ol><p>invoke 方法的返回值是 Object 类型，它表示被调用方法的返回值。因此，当我们想要使用动态代理技术时，需要实现 InvocationHandler 接口并重写 invoke 方法，来控制代理类如何处理方法调用<br><a name="mEV6K"></a></p><h3 id="RpcClientProxy"><a href="#RpcClientProxy" class="headerlink" title="RpcClientProxy"></a>RpcClientProxy</h3><p>RpcClientProxy 将实现 InvocationHandler 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用方法: &#123;&#125;#&#123;&#125;"</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"方法调用请求发送失败"</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个远程调用的客户端代理类RpcClientProxy，实现了InvocationHandler接口，用于生成一个远程服务接口的代理对象。其中，RpcClient是一个抽象类，NettyClient和SocketClient分别是其子类，用于不同的网络传输方式进行远程调用。<br />该类中的getProxy方法，使用了Java动态代理技术，生成了一个实现了远程服务接口的代理对象，该代理对象的所有方法调用都会被拦截并转化为远程调用，从而实现了RPC远程调用的透明化。<br />在invoke方法中，通过封装一个RpcRequest对象来表示对远程服务的调用，并通过客户端发送请求获取到返回结果RpcResponse，最后将返回结果中的数据返回给调用方。在发送远程调用请求之前，还进行了一些简单的参数检查，确保请求的正确性和完整性。<br><a name="Jo1Tm"></a></p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机轮询策略来进行负载均衡</span></span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//另一个构造方法，表示自定义负载均衡策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注入服务发现</span></span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="comment">//序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="comment">//保留意见</span></span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"未设置序列化器"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"客户端发送消息: %s"</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">"发送消息时有错误发生: "</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基于Netty的RPC客户端，实现了RpcClient接口，并且封装了发送请求的具体细节。<br />在类的静态代码块中，创建了一个EventLoopGroup和一个Bootstrap对象，用于配置Netty客户端。EventLoopGroup是处理事件循环的抽象类，Bootstrap则是用于客户端引导的类。在其中使用了NioEventLoopGroup和NioSocketChannel类来实现NIO客户端，这里用到了Netty的API。<br />接着在类的构造方法中，初始化了一个服务发现对象和一个序列化器对象。服务发现对象是用于从服务注册中心获取服务地址的。序列化器对象是用于将请求和响应对象序列化和反序列化的，该类的序列化器可以通过传入参数来选择使用哪种类型的序列化器。<br />在sendRequest方法中，首先判断序列化器是否为空，如果为空则抛出异常。然后通过服务发现对象获取到远程服务的地址，根据地址获取一个Channel对象，ChannelProvider.get方法会返回一个新的Channel或者已有的Channel，如果没有就会创建一个新的Channel。在获取到Channel对象后，使用Netty的writeAndFlush方法将请求对象发送到服务端，使用addListener添加一个ChannelFutureListener监听器，可以在发送成功或失败时执行相应的操作，如打印日志或者回调。发送请求时还将该请求的请求ID和响应结果对应的CompletableFuture对象存储到一个全局的UnprocessedRequests对象中。<br />最后，sendRequest方法返回一个CompletableFuture对象，用于异步等待响应结果。在响应结果到达时，UnprocessedRequests对象会将响应结果的CompletableFuture对象取出并使用complete方法设置结果。而调用sendRequest方法的线程会在CompletableFuture对象的get方法上阻塞，直到CompletableFuture对象的complete方法被调用为止，然后会返回响应结果。<br />接着我们一步步看这个客户端有哪些用到的类：</p><p><a name="Fzlss"></a></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡会共用一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有着其对应的实现。<br />随机策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮询策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以看到，无论是哪一种策略，都是要先获取到Instance实例，然后使用相应的负载均衡策略，那么这个实例，则是Nacos包提供的一个类，那么我们也自然需要一个Nacos方法来提供。</p><p><a name="fLeqg"></a></p><h3 id="NacosServiceDiscovery"><a href="#NacosServiceDiscovery" class="headerlink" title="NacosServiceDiscovery"></a>NacosServiceDiscovery</h3><p>服务发现类，同时也对上述的负载均衡做出了解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"找不到对应的服务: "</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"获取服务时有错误发生:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个 NacosServiceDiscovery 类，实现了 ServiceDiscovery 接口，主要用于在基于 Nacos 注册中心的服务发现中获取服务地址。具体作用如下：</p><ol><li>NacosServiceDiscovery 类有一个构造方法，用于初始化负载均衡策略，如果未指定，则默认使用随机负载均衡策略。</li><li>lookupService 方法用于获取指定服务名对应的 InetSocketAddress，通过调用 NacosUtil 工具类获取所有的服务实例，然后使用负载均衡策略选择一个实例，最终返回该实例的地址信息。</li><li>如果找不到对应的服务，则会抛出 RpcException 异常，并记录错误日志。</li></ol><p>总之，该类用于实现基于 Nacos 注册中心的服务发现功能，可以根据服务名从注册中心获取服务实例并进行负载均衡选择，返回可用的服务地址。</p><p><a name="XrnMt"></a></p><h3 id="UnprocessedRequests"><a href="#UnprocessedRequests" class="headerlink" title="UnprocessedRequests"></a>UnprocessedRequests</h3><p>这个类名为 UnprocessedRequests，用于处理未处理的RPC请求。同时也是更好的控制数据的获取，因为如果使用Netty自带的阻塞获取方法，太过于复杂了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中，使用了一个静态的 ConcurrentHashMap 对象，用于存储未处理的RPC请求。<br />其中，Key 值为请求的ID，Value 值为一个 CompletableFuture<RpcResponse> 对象，用于异步获取 RPC 响应结果。<br />这可以用来记录客户端发送的请求并等待响应。主要包含以下方法：</p><ol><li>put(String requestId, CompletableFuture<RpcResponse> future)：将请求 ID 和对应的 CompletableFuture 存储到 ConcurrentHashMap 中。</li><li>remove(String requestId)：从 ConcurrentHashMap 中删除指定的请求 ID。</li><li>complete(RpcResponse rpcResponse)：根据响应中的请求 ID 找到对应的 CompletableFuture 并将响应数据传递给它。如果没有找到对应的 CompletableFuture，则抛出 IllegalStateException 异常。</li></ol><p>这个类的作用是确保客户端发送的每个请求都有一个对应的 CompletableFuture 实例，用来等待服务器响应。在客户端收到服务器响应后，可以使用 UnprocessedRequests.complete() 方法将响应数据传递给对应的 CompletableFuture。这种机制使得客户端可以异步发送请求并等待响应，而不需要阻塞线程。<br><a name="rkJoD"></a></p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture类是Java8引入的一个异步编程工具，用于处理异步操作的结果。它提供了一些方法来处理异步任务的结果，例如将结果传递给下一个任务，等待任务完成，组合多个任务等。<br />在异步编程中，通常会使用回调函数来处理异步任务的结果，但这种方式会使代码变得冗长且难以维护。CompletableFuture类的出现，使得异步编程变得更加简单和可读。<br />CompletableFuture类有以下几个主要特点：</p><ol><li>可以将一个异步操作的结果传递给下一个操作，这种操作被称为”组合”。</li><li>可以等待一个异步操作的结果，并在操作完成后执行一些操作，例如打印日志、释放资源等。</li><li>可以在多个异步操作完成后执行一些操作，例如将它们的结果组合起来，计算它们的平均值等。</li><li>可以通过异常处理机制来处理异步操作中的异常。</li></ol><p>使用CompletableFuture类，可以更加方便地处理异步任务，提高代码的可读性和可维护性。同时，它也是Java并发编程中非常有用的工具之一。<br><a name="PP3yo"></a></p><h3 id="ChannelProvider"><a href="#ChannelProvider" class="headerlink" title="ChannelProvider"></a>ChannelProvider</h3><p>这段代码实现了一个用于获取客户端 Channel 的工具类 ChannelProvider。它维护了一个 Map 类型的 channels 成员变量，用于缓存已经连接的 Channel 对象，通过 get 方法获取指定地址的 Channel 对象。</p><ol><li>在 get 方法中，首先根据地址和序列化器生成 key，从 channels 缓存中查找是否已有对应的 Channel 对象。如果有，就返回已有的 Channel 对象；如果没有，就通过 bootstrap 进行连接。在连接成功后，将新建的 Channel 对象存入 channels 缓存，并返回该对象。如果连接失败，返回 null。</li><li>在 connect 方法中，通过 CompletableFuture 异步获取连接结果。在连接成功后，将 Channel 对象作为 CompletableFuture 的返回值。</li><li>initializeBootstrap 方法则初始化 Bootstrap 对象，并设置一些常用的参数，如连接超时时间、是否启用 TCP 底层心跳机制等。</li></ol><p>ChannelProvider 为客户端连接提供了一个通用的方法，简化了客户端连接的过程，提高了代码的复用性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接客户端时有错误发生"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"客户端连接成功!"</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, 5000)</span></span><br><span class="line"><span class="class">                //是否开启 <span class="title">TCP</span> 底层心跳机制</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                //<span class="title">TCP</span>默认开启了 <span class="title">Nagle</span> 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。<span class="title">TCP_NODELAY</span> 参数的作用就是控制是否启用 <span class="title">Nagle</span> 算法。</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细一点的说：<br />这段代码实现了一个用于获取Netty客户端Channel的工具类ChannelProvider。它提供了一个get方法，该方法接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取与指定服务提供者（IP地址和端口号）之间的连接。该方法首先将InetSocketAddress和序列化器的编码方式作为key，从Map中查找已有的Channel。如果找到的Channel是可用的，那么直接返回这个Channel。如果找到的Channel不可用，那么将它从Map中删除。接下来创建一个新的Channel，该Channel使用了上述编码方式进行了初始化，并且连接到了指定的服务提供者，最后将新创建的Channel保存到Map中。<br />在ChannelProvider类中，包含了一个静态的EventLoopGroup类型的变量eventLoopGroup和一个静态的Bootstrap类型的变量bootstrap。在类初始化时，这些变量被初始化为一个NioEventLoopGroup和一个Bootstrap实例。Bootstrap实例会初始化连接到远程服务提供者的客户端的参数，包括TCP连接、超时时间、TCP底层心跳机制等。这就是Channel的模板，创建一次就好了，不用每次都创建一次，这样可以很好的减少代码冗余和提高复用性。</p><ul><li>get()方法是ChannelProvider的主要方法。它接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取连接到指定服务提供者的Channel。首先，根据传入的参数，生成一个唯一的key，用于从Map中查找是否已经存在一个可用的Channel。如果找到的Channel是可用的，直接返回这个Channel对象。否则，创建一个新的Channel，并且将它保存到Map中。最后，返回新创建的Channel对象。</li><li>initChannel()方法用于初始化客户端Channel的pipeline。在这里，我们首先添加了一个自定义的序列化编解码器，然后添加了一个心跳检测处理器IdleStateHandler、一个通用解码器CommonDecoder和一个客户端处理器NettyClientHandler。这些处理器将按照顺序添加到客户端Channel的pipeline中。</li><li>connect()方法用于创建连接到指定服务提供者的Channel，并返回连接成功后的Channel对象。为了处理异步连接的结果，它使用了一个CompletableFuture对象completableFuture，该对象用于接收连接结果。当连接成功时，completableFuture将被设置为连接成功的Channel对象；当连接失败时，completableFuture将抛出异常。</li></ul><p>这个Channel包含的一个NettyClientHandler，有相应对收到请求的处理：<br><a name="ie8Yn"></a></p><h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">"客户端接收到消息: %s"</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"发送心跳包 [&#123;&#125;]"</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Netty 客户端处理器，用于处理服务器发送的响应消息。它继承了 Netty 的 SimpleChannelInboundHandler 类，实现了其中的 channelRead0() 方法和 exceptionCaught() 方法。<br />在channelRead0()方法中，通过UnprocessedRequests对象的complete()方法处理返回的RpcResponse对象。在此方法中，使用logger打印接收到的消息，然后调用UnprocessedRequests.complete()方法，将对应的CompletableFuture对象标记为完成，并将RpcResponse对象作为结果<br />在 exceptionCaught() 方法中，发生异常时，会先记录日志，然后关闭客户端通道。<br />另外，该类还重写了 userEventTriggered() 方法，用于发送心跳包。如果客户端在一段时间内没有发送数据，则会自动触发该方法，并向服务器发送一个心跳包。当客户端发送心跳包时，会调用 ChannelProvider 类的 get() 方法获取一个 Channel 对象，并向该 Channel 对象写入一个标记了心跳标志的 RpcRequest 对象，最后调用 close() 方法关闭该 Channel。</p><p><a name="RGhhY"></a></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;ly3F9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用Netty-Nacos-Protobuf制作RPC框架&quot;&gt;&lt;a href=&quot;#使用Netty-Nacos-Protobuf制作RPC框架&quot; class=&quot;headerlink&quot; title=&quot;使用Nett</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
    <category term="RPC" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>用Go语言编写一个web与分布式应用</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-web-study/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-web-study/</id>
    <published>2022-04-27T15:29:13.000Z</published>
    <updated>2023-03-26T14:20:53.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Go语言编写一个web应用"><a href="#使用Go语言编写一个web应用" class="headerlink" title="使用Go语言编写一个web应用"></a>使用Go语言编写一个web应用</h1><h2 id="初始知识"><a href="#初始知识" class="headerlink" title="初始知识"></a>初始知识</h2><h3 id="go语言的学习"><a href="#go语言的学习" class="headerlink" title="go语言的学习"></a>go语言的学习</h3><p>其实很简单，就不详细写了。</p><p>可以去类似于去菜鸟教程这个网站，去初步的了解编程语言的写法。</p><p>或者是类似于哔哔哔哩这样的视频网站，直接照这视频一步一步的去学习它的写法，不过这种方法比较消耗时间。但是我觉得如果你有一定的编程基础，学这个go真的很简单，没有什么复杂地方。你仅需要注意的是，语法有些不同，你可能要花一段时间去适应它的写法。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然网上很多教程都是使用VScode去写的，但是我觉得不是很好，可能自己对于这种轻量级的工具不是很适应。</p><p>我使用的是IntelliJ IDEA ，然后安装了go的插件之后去写的，我觉得这样写起来比较轻松，这个要看个人了。</p><h3 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h3><p>这个编程语言去做一个web服务的话，有点像cpp一样复古的写法，但是相比于cpp这样语言来肯定要简单得多。不过，如果你有一定的基础的话，会比较轻松吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//初始化一个函数，让其能对web应用进行响应</span></span><br><span class="line"><span class="comment">//第一个参数是路由地址，第二个参数是函数主要功能是收到请求并响应</span></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务器，第一个参数是网络地址，第二个参数是处理方式</span></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后就可以看到结果了。</p><h2 id="正式编写"><a href="#正式编写" class="headerlink" title="正式编写"></a>正式编写</h2><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h4><p>首先要编写一个go程序，就如上面的例子一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := myHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: &amp;mh, <span class="comment">//Handler实际上是一个接口</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，所有的网址都会输出同样的信息，因为每个请求都是使用同一个Handler。而我们应该使用：DefaultServeMux 去进行处理不同的Handler，而我们就需要对每个Handler进行注册，这样才能进行出结果。</p><p>所以我们应该这么改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于我们把我们需要自定义的Handler，根据自己的需要去更改，最后注册到DefaultServeMux当中，完成对不同请求产生不同的响应。</p><h4 id="HandleFunc"><a href="#HandleFunc" class="headerlink" title="HandleFunc"></a>HandleFunc</h4><p>但前面的处理完全可以简写为一个方式，增加可读性，于是乎，我们就要用到这个函数HandleFunc：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HandleFunc</span></span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个HandleFunc本质上还是调用Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把上述代码中的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>其结果也是一样的。因为这其实是接口型函数，表示函数的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是go语言精妙的地方了。你可以面对多种不一样的处理方式，但是只用放在同一个接口当中，这就是go语言使用组成而不是继承的原因。</p><p>总结，如何注册DefaultServeHTTP</p><p>方法一、使用http.Handle（第二个参数是Handler）</p><p>方法二、使用http.HandleFunc（第二个参数是Handler函数）</p><p>方法三、http.HandlerFunc可以进行类型转换，将Handler函数转化成Handler（结构体）来使用</p><h3 id="内置Handler"><a href="#内置Handler" class="headerlink" title="内置Handler"></a>内置Handler</h3><ul><li>func NotFoundHandler() Handler<br>返回一个 handler，它给每个请求的响应都是“404 page not found”</li><li>func RedirectHandler(url string, code int) Handler<br>返回一个 handler，它把每个请求使用给定的状态码跳转到指定的 URL。<br>url，要跳转到的 URL<br>code，跳转的状态码（3xx），常见的：StatusMovedPermanently、StatusFound 或 StatusSeeOther 等</li><li>func StripPrefix(prefix string, h handler) Handler<br>返回一个 handler，它从请求 URL 中去掉指定的前缀，然后再调用另一个 handler。<br>如果请求的 URL 与提供的前缀不符，那么 404<br>略像中间件<br>prefix，URL 将要被移除的字符串前缀<br>h，是一个 handler，在移除字符串前缀之后，这个 handler 将会接收到请求<br>修饰了另一个 Handler </li><li>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler<br>返回一个 handler，它用来在指定时间内运行传入的 h。<br>也相当于是一个修饰器<br>h，将要被修饰的 handler<br>dt，第一个 handler 允许的处理时间<br>msg，如果超时，那么就把 msg 返回给请求，表示响应时间过长</li><li>func FileServer(root FileSystem) Handler<br>返回一个 handler，使用基于 root 的文件系统来响应请求<br>type FileSystem interface {<pre><code>Open(name string) (File, error)</code></pre>  }<br>使用时需要用到操作系统的文件系统，所以还需要委托给：<br>type Dir string<br>func (d Dir) Open(name string) (File, error)</li></ul><h4 id="代码演示：FileServer"><a href="#代码演示：FileServer" class="headerlink" title="代码演示：FileServer"></a>代码演示：FileServer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8888"</span>, http.FileServer(http.Dir(<span class="string">"root"</span>)))</span><br></pre></td></tr></table></figure><p>可以通过这个方法指定root这个根路径，这样打开文件的时候直接去root，直接找到需要的url路径，加载文件</p><h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p> 最基本的肯定是：</p><ul><li><p>HTTP Request 和 HTTP Response（请求和响应）</p></li><li><p>它们具有相同的结构：</p><ul><li><p>​    请求（响应）行</p></li><li><p>​    0 个或多个 Header</p></li><li><p>​    空行</p></li><li><p>​    可选的消息体（Body）</p></li></ul></li></ul><p>而 <strong>net/http</strong> 包提供了用于表示 HTTP 消息的结构，其中Reqeust（是个 struct），代表了客户端发送的 HTTP 请求消息</p><h4 id="URL类型"><a href="#URL类型" class="headerlink" title="URL类型"></a>URL类型</h4><h5 id="URL-Query"><a href="#URL-Query" class="headerlink" title="URL Query"></a>URL Query</h5><p>RawQuery 会提供实际查询的字符串。</p><p>例如： <a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>它的 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>还有一个简便方法可以得到 Key-Value 对：通过 Request 的 Form 字段（以后再说）</p><h5 id="URL-Fragment"><a href="#URL-Fragment" class="headerlink" title="URL Fragment"></a>URL Fragment</h5><p>如果从浏览器发出的请求，那么你无法提取出 Fragment 字段的值</p><p>浏览器在发送请求时会把 fragment 部分去掉</p><p>但不是所有的请求都是从浏览器发出的（例如从 HTTP 客户端包）。</p><h5 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h5><p>请求和响应（Request、Response）的 headers 是通过 Header 类型来描述的，它是一个 map，用来表述 HTTP Header 里的 Key-Value 对。</p><p>Header map 的 key 是 string 类型，value 是 []string</p><p>设置 key 的时候会创建一个空的 []string 作为 value，value 里面第一个元素就是新 header 的值；</p><p>为指定的 key 添加一个新的 header 值，执行 append 操作即可</p><h5 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h5><p>请求和响应的 bodies 都是使用 Body 字段来表示的</p><p>Body 是一个 io.ReadCloser 接口</p><p>一个 Reader 接口</p><p>一个 Closer 接口</p><p>Reader 接口定义了一个 Open 方法：</p><p>参数：[]byte</p><p>返回：byte 的数量、可选的错误</p><p>Closer 接口定义了一个 Close 方法：</p><p>没有参数，返回可选的错误</p><h5 id="代码演示-Fragment"><a href="#代码演示-Fragment" class="headerlink" title="代码演示:Fragment"></a>代码演示:Fragment</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/url"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.URL.Fragment)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过这种方式，看看自己请求有没有Fragment</p><h5 id="代码演示-Header"><a href="#代码演示-Header" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/header"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.Header)</span><br><span class="line">fmt.Fprintln(writer, request.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">fmt.Fprintln(writer, request.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman测试：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/header</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[Accept:[*&#x2F;*] Accept-Encoding:[gzip, deflate, br] Connection:[keep-alive] Postman-Token:[9ddda678-d6f8-42d2-aea5-67816a86c3d7] User-Agent:[PostmanRuntime&#x2F;7.28.3]]</span><br><span class="line">[gzip, deflate, br]</span><br><span class="line">gzip, deflate, br</span><br></pre></td></tr></table></figure><h5 id="代码演示-Header-1"><a href="#代码演示-Header-1" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/post"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">length := request.ContentLength</span><br><span class="line">body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">request.Body.Read(body)</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个方式去展现出body的内容</p><h4 id="URL-Query-1"><a href="#URL-Query-1" class="headerlink" title="URL Query"></a>URL Query</h4><p>例如：<a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>r.URL.RawQuery 会提供实际查询的原始字符串，因为 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>r.URL.Query()，会提供查询字符串对应的 map string string</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">url := request.URL</span><br><span class="line">query := url.Query() <span class="comment">//得到一个map</span></span><br><span class="line"></span><br><span class="line">id := query[<span class="string">"id"</span>]</span><br><span class="line">log.Println(id)</span><br><span class="line"></span><br><span class="line">name := query.Get(<span class="string">"name"</span>)</span><br><span class="line">log.Println(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/home?id=123&amp;name=panda&amp;id=456&amp;name=fox</span><br></pre></td></tr></table></figure><p>控制台显示结果为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[123 456]</span><br><span class="line">panda</span><br></pre></td></tr></table></figure><p>这表明 query[“id”] 是获取所有的值，而query.Get(“name”) 只会获取第一个值</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><h4 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a>enctype</h4><p>接下来看看，如何处理表单类的数据。</p><p>HTML 表单里面的数据会以 name-value 对的形式，通过 POST 请求发送出去，它的数据内容会放在 POST 请求的 Body 里面。</p><p>通过 POST 发送的 name-value 数据对的格式可以通过表单的 Content Type 来指定，也就是 enctype 属性。</p><p>默认值是：application/x-www-form-urlencoded<br>浏览器被要求至少要支持： application/x-www-form-urlencoded 、multipart/form-data。HTML 5 的话，还需要支持 text/plain</p><p>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：    first_name=sau%20sheong&amp;last_name=chang</p><p>如果 enctype 是 multipart/form-data，那么：每一个 name-value 对都会被转换为一个MIME消息部分，每一个部分都有自己的 Content Type 和 Content Disposition</p><p>那么，改如何选择enctype呢？</p><ol><li>简单文本：表单 URL 编码</li><li>大量数据，例如上传文件：multipart-MIME，甚至可以把二进制数据通过选择 Base64 编码，来当作文本进行发送</li></ol><h4 id="Form字段"><a href="#Form字段" class="headerlink" title="Form字段"></a>Form字段</h4><p>Request 上的函数允许我们从 URL 或/和 Body 中提取数据，通过这些字段：    </p><ul><li>Form</li><li>PostForm</li><li>MultipartForm</li></ul><p>Form 里面的数据是 key-value 对。通常的做法是：先调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.Form)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会打印出一个map，包含传入的所有的值。包括url的值和表单的值。</p><p>如果只想要表单的 key-value 对，不要 URL 的，可以使用 PostForm 字段。<br>PostForm 只支持 application/x-www-form-urlencoded</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就只有一个字段</p><p>而想要得到 multipart key-value 对，必须使用 MultipartForm 字段。</p><p>想要使用 MultipartForm 这个字段的话，首先需要调用ParseMultipartForm 这个方法，该方法会在必要时调用 ParseForm 方法<br>，参数是需要读取数据的长度<br>MultipartForm 只包含表单的 key-value 对，返回类型是一个 struct 而不是 map。这个 struct 里有两个 map：1、key 是 string，value 是 []string 。2、空的（key 是 string，value 是文件）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="FormValue-和-PostFormValue-方法"><a href="#FormValue-和-PostFormValue-方法" class="headerlink" title="FormValue 和 PostFormValue 方法"></a>FormValue 和 PostFormValue 方法</h5><ul><li>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用 ParseForm 或 ParseMultipartForm</li><li>PostFormValue 方法也一样，但只能读取 PostForm</li><li>FormValue 和 PostFormValue 都会调用 ParseMultipartForm 方法</li><li>但如果表单的 enctype 设为 multipart/form-data，那么即使你调用ParseMultipartForm 方法，也无法通过 FormValue 获得想要的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.FormValue(<span class="string">"name"</span>))</span><br><span class="line">fmt.Fprintln(writer, request.PostFormValue(<span class="string">"name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>multipart/form-data 最常见的应用场景就是上传文件（例子）：</p><ol><li>首先调用 ParseMultipartForm 方法</li><li>从 File 字段获得 FileHeader，调用其 Open 方法来获得文件</li><li>可以使用 ioutil.ReadAll 函数把文件内容读取到 byte 切片里</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)                      <span class="comment">//1024表示一次性加载到内存的最大字节数</span></span><br><span class="line">fileHeader := request.MultipartForm.File[<span class="string">"upload"</span>][<span class="number">0</span>] <span class="comment">//表示从upload字段获取值</span></span><br><span class="line">file, err := fileHeader.Open()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字如其意，非常简单。但是这部分代码仍然有改进的空间，比如使用FormFile</p><h5 id="FormFile"><a href="#FormFile" class="headerlink" title="FormFile()"></a>FormFile()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//request.ParseMultipartForm(1024)                      //1024表示一次性加载到内存的最大字节数</span></span><br><span class="line"><span class="comment">//fileHeader := request.MultipartForm.File["upload"][0] //表示从upload字段获取值</span></span><br><span class="line"><span class="comment">//file, err := fileHeader.Open()</span></span><br><span class="line"></span><br><span class="line">file, _, err := request.FormFile(<span class="string">"uploader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MultipartReader"><a href="#MultipartReader" class="headerlink" title="MultipartReader()"></a>MultipartReader()</h5><p>方法签名：func (r <em>Request) MultipartReader() (</em>multipart.Reader, error)<br>如果是 multipart/form-data 或 multipart 混合的 POST 请求：1、MultipartReader 返回一个 MIME multipart reader 2、否则返回 nil 和一个错误<br>可以使用该函数代替 ParseMultipartForm 来把请求的 body 作为 stream 进行处理。1、不是把表单作为一个对象来处理的，不是一次性获得整个 map。2、逐个检查来自表单的值，然后每次处理一个</p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h4><p>从服务器向客户端返回响应需要使用 ResponseWriter。ResponseWriter 是一个接口，handler 用它来返回响应。而真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response。</p><p>但是，为什么request是指针，而writer不用是呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(writer http.ResponseWriter, request *http.Request)</span><br></pre></td></tr></table></figure><p>其实，这两个都是按引用进行传递的，ResponseWriter是具有Header、Write、WriteHeader三种方法的接口，response指针实现了以上三种方法，故response是一种特殊的ResponseWriter。</p><p>并且，ResponseWriter还能使用writer.Write([]byte(str))方法，把字符串写入到body里面。</p><h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接收一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回<br>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader(http.StatusOK)，所以 WriteHeader 主要用来发送错误类的 HTTP 状态码<br>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p><h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改<br>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p><h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，包装一个 404 状态码和一个额外的信息<br>ServeFile 函数，从文件系统提供文件，返回给请求者<br>ServeContent 函数，它可以把实现了 io.ReadSeeker 接口的任何东西里面的内容返回给请求者，并且，还可以处理 Range 请求（范围请求），如果只请求了资源的一部分内容，那么 ServeContent 就可以如此响应。而 ServeFile 或 io.Copy 则不行。<br>Redirect 函数，告诉客户端重定向到另一个 URL</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>Web 模板就是预先设计好的 HTML 页面，它可以被模板引擎反复的使用，来产生 HTML 页面<br>Go 的标准库提供了 text/template，html/template 两个模板库，大多数 Go 的 Web 框架都使用这些库作为 默认的模板引擎</p><h4 id="Go-的模板和模板引擎"><a href="#Go-的模板和模板引擎" class="headerlink" title="Go 的模板和模板引擎"></a>Go 的模板和模板引擎</h4><p>go主要使用的是 text/template，HTML 相关的部分使用了 html/template，是个混合体。go模板可以完全无逻辑，但又具有足够的嵌入特性。和大多数模板引擎一样，Go Web 的模板位于无逻辑和嵌入逻辑之间的某个地方</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在 Web 应用中，通产是由 handler 来触发模板引擎。handler 调用模板引擎，并将使用的模板传递给引擎，通常是一组模板文件和动态数据。<br>模板引擎生成 HTML，并将其写入到 ResponseWriter，ResponseWriter 再将它加入到 HTTP 响应中，返回给客户端。</p><h5 id="模板的例子"><a href="#模板的例子" class="headerlink" title="模板的例子"></a>模板的例子</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go Web Programming<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模板必须是可读的文本格式，扩展名任意。对于 Web 应用通常就是 HTML，里面会内嵌一些命令（叫做 action）</span><br><span class="line">text/template 是通用模板引擎，html/template 是 HTML 模板引擎</span><br><span class="line">action 位于双层花括号之间：&#123;&#123; . &#125;&#125;。这里的 . 就是一个 action。它可以命令模板引擎将其替换成一个值。</span><br></pre></td></tr></table></figure><p>是不是有点像jsp</p><h5 id="使用模板引擎"><a href="#使用模板引擎" class="headerlink" title="使用模板引擎"></a>使用模板引擎</h5><ol><li>解析模板源（可以是字符串或模板文件），从而创建一个解析好的 模板的 struct</li><li>执行解析好的模板，并传入 ResponseWriter 和 数据。这会触发模板引擎组合解析好的模板和数据，来产生最终的 HTML，并将它传递给 ResponseWriter </li></ol><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">t, _ := template.ParseFiles(<span class="string">"mytest.html"</span>) <span class="comment">//去解析一个模板文件，一个也在这个包下的html文件，</span></span><br><span class="line">t.Execute(writer, <span class="string">"hello,my friends"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是鉴于现今几乎都是前后端分离的项目了，模板引擎已经几乎要绝迹了，随便学学吧。</p><h4 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h4><h5 id="ParseFiles"><a href="#ParseFiles" class="headerlink" title="ParseFiles"></a>ParseFiles</h5><p>解析模板文件，并创建一个解析好的模板 struct，后续可以被执行<br>ParseFiles 函数是 Template struct 上 ParseFiles 方法的简便调用<br>调用 ParseFiles 后，会创建一个新的模板，模板的名字是文件名<br>ParseFiles 的参数数量可变，但只返回一个模板，当解析多个文件时，第一个文件作为返回的模板（名、内容），其余的作为 map，供后续执行使用</p><h5 id="ParseGlob"><a href="#ParseGlob" class="headerlink" title="ParseGlob"></a>ParseGlob</h5><p>使用模式匹配来解析特定的文件</p><h5 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h5><p>可以解析字符串模板，其它方式最终都会调用 Parse</p><h5 id="Lookup-方法"><a href="#Lookup-方法" class="headerlink" title="Lookup 方法"></a>Lookup 方法</h5><p>通过模板名来寻找模板，如果没找到就返回 nil</p><h5 id="Must-函数"><a href="#Must-函数" class="headerlink" title="Must 函数"></a>Must 函数</h5><p>可以包裹一个函数，返回到一个模板的指针 和 一个错误。如果错误不为 nil，那么就 panic</p><h4 id="模板的Action"><a href="#模板的Action" class="headerlink" title="模板的Action"></a>模板的Action</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action 就是 Go 模板中嵌入的命令，位于两组花括号之间 &#123;&#123; xxx &#125;&#125;，就是一个 Action，而且是最重要的一个。它代表了传入模板的数据</span><br></pre></td></tr></table></figure><p>Action 主要可以分为五类：条件类，迭代/遍历类，设置类，包含类，定义类</p><h5 id="条件Action"><a href="#条件Action" class="headerlink" title="条件Action"></a>条件Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">  other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代-遍历-Action"><a href="#迭代-遍历-Action" class="headerlink" title="迭代/遍历 Action"></a>迭代/遍历 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">  Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>这类 Action 用来遍历数组、slice、map 或 channel 等数据结构，“.”用来表示每次迭代循环中的元素</p><h5 id="设置Action"><a href="#设置Action" class="headerlink" title="设置Action"></a>设置Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>它允许在指定范围内，让“.”来表示其它指定的值（arg）</p><h5 id="包含-Action"><a href="#包含-Action" class="headerlink" title="包含 Action"></a>包含 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template "name" &#125;&#125;</span><br><span class="line">它允许你在模板中包含其它的模板</span><br><span class="line">&#123;&#123; template "name" arg &#125;&#125;</span><br><span class="line">给被包含模板传递参数</span><br></pre></td></tr></table></figure><h4 id="函数与管道"><a href="#函数与管道" class="headerlink" title="函数与管道"></a>函数与管道</h4><h5 id="参数（argument）"><a href="#参数（argument）" class="headerlink" title="参数（argument）"></a>参数（argument）</h5><p>参数就是模板里面用到的值。可以是 bool、整数、string … ，也可以是 struct、struct 的字段、数组的 key 等等<br>参数可以是变量、方法（返回单个值或返回一个值和一个错误）或函数<br>参数可以是一个点“.”，也就是传入模板引擎的那个值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">这里的 arg 就是参数</span><br></pre></td></tr></table></figure><h5 id="在-Action-中设置变量"><a href="#在-Action-中设置变量" class="headerlink" title="在 Action 中设置变量"></a>在 Action 中设置变量</h5><p>可以在 action 中设置变量，变量以 $ 开头：$variable := value<br>一个迭代 action 的例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">  The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="管道（pipeline）"><a href="#管道（pipeline）" class="headerlink" title="管道（pipeline）"></a>管道（pipeline）</h5><p>管道是按顺序连接到一起的参数、函数和方法。和 Unix 的管道类似:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：&#123;&#123; p1 | p2 | p3 &#125;&#125;  ，p1、p2、p3 要么是参数，要么是函数</span><br><span class="line">管道允许我们把参数的输出发给下一个参数，下一个参数由管道（|）分隔开。</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>参数可以是一个函数，Go 模板引擎提供了一些基本的内置函数，功能比较有限。例如 fmt.Sprint 的各类变体等<br>开发者可以自定义函数，可以接收任意数量的输入参数<br>返回：一个值     或       一个值+一个错误</p><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define、template、block</span><br><span class="line">html、js、urlquery。对字符串进行转义，防止安全问题</span><br><span class="line">如果是 Web 模板，那么不会需要经常使用这些函数。</span><br><span class="line">index</span><br><span class="line">print/printf/println</span><br><span class="line">len</span><br><span class="line">with</span><br><span class="line">这些都是内置的函数</span><br></pre></td></tr></table></figure><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template.Funcs(funcMap FuncMap) *Template</span><br><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//value 是函数</span></span><br><span class="line"><span class="comment">//可以有任意数量的参数</span></span><br><span class="line"><span class="comment">//返回单个值的函数或返回一个值+一个错误的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个 FuncMap（map 类型）。</span></span><br><span class="line"><span class="comment">key 是函数名</span></span><br><span class="line"><span class="comment">value 就是函数</span></span><br><span class="line"><span class="comment">把 FuncMap 附加到模板</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>常见用法：template.New(“”).Funcs(funcMap).Parse(…)，调用顺序非常重要。可以在管道中使用，也可以作为正常函数使用。</p><h4 id="模板组合"><a href="#模板组合" class="headerlink" title="模板组合"></a>模板组合</h4><h5 id="Layout-模板"><a href="#Layout-模板" class="headerlink" title="Layout 模板"></a>Layout 模板</h5><p>Layout 模板就是网页中固定的部分，它可以被多个网页重复使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Include（包含）action 的形式：&#123;&#123; template "name" . &#125;，</span><br></pre></td></tr></table></figure><p>以这种方式做 layout 模板是不可行的。而正确的做法是在模板文件里面使用 define action 再定义一个模板。这种形式特别像thymeleaf，就是单纯的将HTML页面强行模块化，使其具有公共部分的属性，总体而言还是比较简单的。而也可以在多个模板文件里，定义同名的模板。</p><h5 id="使用-block-action-定义默认模板"><a href="#使用-block-action-定义默认模板" class="headerlink" title="使用 block action 定义默认模板"></a>使用 block action 定义默认模板</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">block action 可以定义模板，并同时就使用它</span><br><span class="line">template：模板必须可用</span><br><span class="line">block：模板可以不存在</span><br></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eq/ne</span><br><span class="line">lt/gt</span><br><span class="line">le/ge</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><p>字如其意。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>接下来看看如何使用golang去连接数据库，并进行基本的CRUD。</p><h4 id="https-www-jianshu-com-p-7e745fefb8af"><a href="#https-www-jianshu-com-p-7e745fefb8af" class="headerlink" title="https://www.jianshu.com/p/7e745fefb8af"></a><strong><a href="https://www.jianshu.com/p/7e745fefb8af" target="_blank" rel="noopener">https://www.jianshu.com/p/7e745fefb8af</a></strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//"用户名:密码@[连接方式](主机名:端口号)/数据库名"</span></span><br><span class="line">    db,_:=sql.Open(<span class="string">"mysql"</span>,<span class="string">"root:root@(127.0.0.1:3306)/testdatabases"</span>) <span class="comment">// 设置连接数据库的参数</span></span><br><span class="line">    <span class="keyword">defer</span> db.Close()    <span class="comment">//关闭数据库</span></span><br><span class="line">    err:=db.Ping()      <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"数据库连接失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作一：执行数据操作语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sql:="insert into stu values (2,'berry')"</span></span><br><span class="line"><span class="comment">    result,_:=db.Exec(sql)      //执行SQL语句</span></span><br><span class="line"><span class="comment">    n,_:=result.RowsAffected(); //获取受影响的记录数</span></span><br><span class="line"><span class="comment">    fmt.Println("受影响的记录数是",n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作二：执行预处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    stu:=[2][2] string&#123;&#123;"3","ketty"&#125;,&#123;"4","rose"&#125;&#125;</span></span><br><span class="line"><span class="comment">    stmt,_:=db.Prepare("insert into stu values (?,?)")      //获取预处理语句对象</span></span><br><span class="line"><span class="comment">    for _,s:=range stu&#123;</span></span><br><span class="line"><span class="comment">        stmt.Exec(s[0],s[1])            //调用预处理语句</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作三：单行查询</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    var id,name string</span></span><br><span class="line"><span class="comment">    rows:=db.QueryRow("select * from stu where id=4")   //获取一行数据</span></span><br><span class="line"><span class="comment">    rows.Scan(&amp;id,&amp;name)        //将rows中的数据存到id,name中</span></span><br><span class="line"><span class="comment">    fmt.Println(id,"--",name)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作四：多行查询</span></span><br><span class="line">    rows,_:=db.Query(<span class="string">"select * from stu"</span>)       <span class="comment">//获取所有数据</span></span><br><span class="line">    <span class="keyword">var</span> id,name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next()&#123;        <span class="comment">//循环显示所有的数据</span></span><br><span class="line">        rows.Scan(&amp;id,&amp;name)</span><br><span class="line">        fmt.Println(id,<span class="string">"--"</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>前面很多时候，都是使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>HandleFunc这种方式去进行路由控制，但是其实还有更为方便的写法。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>main()：设置类工作<br>controller：1、静态资源 。2、把不同的请求送到不同的 controller 进行处理</p><p>我们实际上应该这么设置才是最为正确的写法。</p><p>例子，先制作出两个页面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerWelcomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">_, err := writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将两个函数进行注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="comment">//RegisterRoutes 用于注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//这里还可以使用静态资源</span></span><br><span class="line">registerHomeRoutes()</span><br><span class="line">registerWelcomeRoutes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在主函数中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">server :&#x3D; http.Server&#123;</span><br><span class="line">Addr:    &quot;localhost:8888&quot;,</span><br><span class="line">Handler: nil,</span><br><span class="line">&#125;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">err :&#x3D; server.ListenAndServe()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是一种代码层面的解耦合，将我们的函数进一步模块化。</p><h4 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h4><p>静态路由：一个路径对应一个页面：</p><p>/home           或       /about</p><p>带参数的路由：根据路由参数，创建出一族不同的页面：</p><p>/companies/123               或            /companies/Google</p><p>这里使用HandlerFunc就可以了，将字符串传入URL，效果是相同的，与Spring+thymeleaf可以说是一模一样。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>现在讲究前后端分离，大多数数据都是使用JSON去传递数据，接下来看看如何在go中使用JSON对象。</p><h4 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h4><p>Go bool：JSON boolean<br>Go float64：JSON 数值<br>Go string：JSON strings<br>Go nil：JSON null.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于未知结构的-JSON"><a href="#对于未知结构的-JSON" class="headerlink" title="对于未知结构的 JSON"></a>对于未知结构的 JSON</h4><p>map[string]interface{} 可以存储任意 JSON 对象<br>[]interface{} 可以存储任意的 JSON 数组</p><h4 id="读取-JSON"><a href="#读取-JSON" class="headerlink" title="读取 JSON"></a>读取 JSON</h4><p>需要一个解码器：dec := json.NewDecoder(r.Body) ，参数需实现 Reader 接口<br>解码器上进行解码：dec.Decode(&amp;query)</p><h4 id="写入-JSON"><a href="#写入-JSON" class="headerlink" title="写入 JSON"></a>写入 JSON</h4><p>需要一个编码器：enc := json.NewEncoder(w)，参数需实现 Writer 接口<br>编码是：enc.Encode(results)</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//首先看看请求的类型</span></span><br><span class="line">dec := json.NewDecoder(request.Body) <span class="comment">//现在JSON就在这个body里边了，并且需要进行解码</span></span><br><span class="line">company := Company&#123;&#125;</span><br><span class="line">err := dec.Decode(&amp;company) <span class="comment">//将密码解码到company这个变量里边</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;             <span class="comment">//如果它不为空</span></span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则将客户端传过来的数据转化为json重新返回给客户端</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">err = enc.Encode(company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := server.ListenAndServe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman进行测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/companies</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">&#123;</span></span><br><span class="line">    "id": 123,</span><br><span class="line">    "name": "google",</span><br><span class="line">    "country": "USA"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码的类型：Marshal-和-Unmarshal"><a href="#编码的类型：Marshal-和-Unmarshal" class="headerlink" title="编码的类型：Marshal 和 Unmarshal"></a>编码的类型：Marshal 和 Unmarshal</h4><p>Marshal（编码）: 把 go struct 转化为 json 格式。MarshalIndent，带缩进<br>Unmarshal（解码）: 把 json 转化为 go struct</p><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "id": 123,</span></span><br><span class="line"><span class="string">    "name": "google",</span></span><br><span class="line"><span class="string">    "country": "USA"</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c := Company&#123;&#125;</span><br><span class="line">_ = json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;c)</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line">bytes, _ := json.Marshal(c)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">bytes2, _ := json.MarshalIndent(c, <span class="string">","</span>, <span class="string">"     "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果为：</span></span><br><span class="line">&#123;<span class="number">123</span> google USA&#125;</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">123</span>,<span class="string">"name"</span>:<span class="string">"google"</span>,<span class="string">"country"</span>:<span class="string">"USA"</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">,     <span class="string">"id"</span>: <span class="number">123</span>,</span><br><span class="line">,     <span class="string">"name"</span>: <span class="string">"google"</span>,</span><br><span class="line">,     <span class="string">"country"</span>: <span class="string">"USA"</span></span><br><span class="line">,&#125;</span><br></pre></td></tr></table></figure><p>区别：</p><p>针对 string 或 bytes：</p><ul><li>Marshal =&gt; String</li><li>Unmarshal &lt;= String</li></ul><p>针对 stream:</p><ul><li>Encode =&gt; Stream，把数据写入到 io.Writer</li><li>Decode &lt;= Stream，从 io.Reader 读取数据</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件大家都懂的，像消息队列，缓存，也是中间件。当然也可以自己捏一个中间件的处理逻辑。</p><h4 id="创建中间件"><a href="#创建中间件" class="headerlink" title="创建中间件"></a>创建中间件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//handler 如果是 nil：DefaultServeMux</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>像这个Handler接口，并可以支持中间件的处理。</p><p>首先创建一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m MyMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 在 next handler 之前做一些事情</span></span><br><span class="line">m.Next.ServeHTTP(w, r)</span><br><span class="line"><span class="comment">// 在 next handler 之后做一些事情</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>途中可以定义中间件需要做的事情。</p><h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ol><li>Logging，日志</li><li>安全，身份认证</li><li>请求超时，减少资源消耗</li><li>响应压缩，提升效率 </li></ol><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间件</span></span><br><span class="line"><span class="keyword">type</span> AuthMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *AuthMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> am.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">am.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//如果什么都没有，执行默认页面</span></span><br><span class="line">auth := request.Header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line"><span class="keyword">if</span> auth != <span class="string">""</span> &#123; <span class="comment">//说明存在身份，则执行逻辑</span></span><br><span class="line">am.Next.ServeHTTP(writer, request)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//否则报异常</span></span><br><span class="line">writer.WriteHeader(http.StatusUnauthorized) <span class="comment">//401未授权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是自定义的中间件类型，接着是主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="built_in">new</span>(middleware.AuthMiddleware))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该中间件注册过后，便可以执行逻辑。</p><p>使用Postman进行测试，一个带Authorization，而另一个不带,测试略。</p><h3 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h3><p>从请求的上下文中获取信息，以用于处理</p><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">Context</span><span class="params">()</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//返回当前请求的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//基于 Context 进行“修改”，（实际上）创建一个新的 Context</span></span><br></pre></td></tr></table></figure><p>有这么两种方式去处理上下文</p><p>看看里面实际上是什么：</p><h4 id="context-Context"><a href="#context-Context" class="headerlink" title="context.Context"></a>context.Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这些方法都是用于读取，不能进行设置</span></span><br></pre></td></tr></table></figure><p>这就是上下文接口里面的方法</p><p>context这个包，也有一些方法，可以返回新的context</p><h4 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h4><ul><li>WithCancel()，它有一个 CancelFunc</li><li>WithDeadline()，带有一个时间戳（time.Time）</li><li>WithTimeout()，带有一个具体的时间段（time.Duration）</li><li>WithValue()，在里面可以添加一些值</li></ul><h4 id="一个超时的例子"><a href="#一个超时的例子" class="headerlink" title="一个超时的例子"></a>一个超时的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeoutMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeoutMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tm.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">tm.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//处理和中间件的一般方式一样</span></span><br><span class="line"></span><br><span class="line">ctx := request.Context()                         <span class="comment">//获取上下文</span></span><br><span class="line">ctx, _ = context.WithTimeout(ctx, <span class="number">3</span>*time.Second) <span class="comment">//修改context的超时判断</span></span><br><span class="line">request.WithContext(ctx)                         <span class="comment">//用我们自定义的context去代替</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)                        <span class="comment">//意图在于，如果我们请求能够在3秒内完成的话，这个chan就会收到一个信号</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                                      <span class="comment">//使用goroutine</span></span><br><span class="line">tm.Next.ServeHTTP(writer, request) <span class="comment">//执行完这个方法后，发送一个信号</span></span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;                   <span class="comment">//发送信号</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//一个竞争的状态</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch: <span class="comment">//正常处理完，得到信号，返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//否则返回错误</span></span><br><span class="line">writer.WriteHeader(http.StatusRequestTimeout)</span><br><span class="line">&#125;</span><br><span class="line">ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先新造好这个中间件，然后注册到main函数里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/middleware"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//time.Sleep(4*time.Second)</span></span><br><span class="line"><span class="comment">//测试用</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, &amp;middleware.TimeoutMiddleware&#123;Next: <span class="built_in">new</span>(middleware.AuthMiddleware)&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后像之前一样去测试，即可。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>这是HTTP的流程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> HTTP/1.1</span><br><span class="line">…</span><br><span class="line">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure><p>都是明文传输的，所以我们有时候就需要HTTPS</p><h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><ul><li>http.ListenAndServe 函数</li><li>http.ListenAndServeTLS 函数</li></ul><p>可以使用ListenAndServeTLS去使其页面变为HTTPS类型，看看接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServeTLS(certFile, keyFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现需要安全证书，而我们的go就可以自己生成安全证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -h</span><br><span class="line">//看看帮助</span><br><span class="line"> -ca</span><br><span class="line">        whether this cert should be its own Certificate Authority</span><br><span class="line">  -duration duration</span><br><span class="line">        Duration that certificate is valid <span class="keyword">for</span> (default <span class="number">8760</span>h0m0s)</span><br><span class="line">  -ecdsa-curve string</span><br><span class="line">        ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521</span><br><span class="line">  -ed25519</span><br><span class="line">        Generate an Ed25519 key</span><br><span class="line">  -host string</span><br><span class="line">        Comma-separated hostnames and IPs to generate a certificate <span class="keyword">for</span></span><br><span class="line">  -rsa-bits int</span><br><span class="line">        Size of RSA key to generate. Ignored <span class="keyword">if</span> --ecdsa-curve is <span class="built_in">set</span> (default <span class="number">2048</span>)</span><br><span class="line">  -<span class="built_in">start</span>-<span class="built_in">date</span> string</span><br><span class="line">        Creation <span class="built_in">date</span> formatted as Jan <span class="number">1</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span> <span class="number">2011</span></span><br></pre></td></tr></table></figure><p>于是乎，便生成证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -host localhost</span><br><span class="line"> //wrote cert.pem</span><br><span class="line"> //wrote key.pem</span><br></pre></td></tr></table></figure><p>之后再测试，发现只有使用HTTPS的前缀，才能打开网页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go_web/controller"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">http.ListenAndServeTLS(<span class="string">"localhost:8888"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们使用的HTTP1.1协议就会自动升级到HTTP2.0协议</p><h3 id="HTTP的协议"><a href="#HTTP的协议" class="headerlink" title="HTTP的协议"></a>HTTP的协议</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>在HTTP/1.1的情况下：</p><ol><li>请求 header+body</li><li>响应 header+body</li></ol><p>这样请求和响应，他们的信息都无法被压缩，会导致传输效率低，但是HTTP2.0使得他们能够压缩加密</p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><p>在这个协议下，请求和响应都是使用Stream来进行的，把消息拆成多个Frame进行发送，每个Frame都可以单独的进行优化。</p><p>Frame类型：Headers、Continuation、Data等等，把请求和响应分成多个Frame，每个数据类型都可以单独优化。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><p>请求多路复用</p></li><li><p>Header 压缩</p></li><li><p>默认安全</p><p>​    HTTP ，但很多决定不支持 HTTP</p><p>​    HTTPS</p></li><li><p>Server Push</p></li></ul><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>在没有Server Push的情况下，每个页面的素材例如：css、html等都是必须发送一个单独的请求来进行的。</p><p>在有了Server Push的情况下，但我们的html页面包含css文件的时候，Server Push会自动传输css文件，即使这个html文件还没有进行对css的引用。这样一来，当html文件需要使用的时候，就不用再次发送请求了。节省了一些加载时间。</p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pusher, ok := writer.(http.Pusher); ok &#123; <span class="comment">//先做类型断言，看看存不存在push</span></span><br><span class="line">pusher.Push(<span class="string">"/css/app.css"</span>, &amp;http.PushOptions&#123; <span class="comment">//如果为真，则说明支持server push</span></span><br><span class="line">Header: http.Header&#123;<span class="string">"Content-Type"</span>: []<span class="keyword">string</span>&#123;<span class="string">"text/css"</span>&#125;&#125;, <span class="comment">//使其自加载这个文件</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后启动服务，进入页面，打开F12看看，结果就清晰明了了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来学习，如何对go web应用进行测试：</p><h4 id="测试-Model-层"><a href="#测试-Model-层" class="headerlink" title="测试 Model 层"></a>测试 Model 层</h4><p>可以编写一个单独的go程序进行测试，然后编写测试函数，并且应该注重命名：</p><ul><li><p>user_test.go</p><p>​    测试代码所在文件的名称以 _test 结尾</p><p>​    对于生产编译，不会包含以 _test 结尾的文件</p><p>​    对于测试编译，会包含以 _test 结尾的文件</p></li><li><p>func TestUpdatesModifiedTime(t *testing.T) { … }</p><p>​    测试函数名应以 Test 开头（需要导出）</p><p>​    函数名需要表达出被验证的特性</p><p>​    测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Company)</span> <span class="title">GetCompanyType</span><span class="params">()</span> <span class="params">(result <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(c.Name, <span class="string">".LTD"</span>) &#123;</span><br><span class="line">result = <span class="string">"Limited Liability Company"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = <span class="string">"Others"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用一个极为简易的例子去测试，判断公司的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCompany_GetCompanyType</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google.LTD"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">companyType := c.GetCompanyType() <span class="comment">//获取类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> companyType != <span class="string">"Limited Liability Company"</span> &#123; <span class="comment">//判断</span></span><br><span class="line">t.Error(<span class="string">"this is others!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果测试通过，则会直接显示PASS</span></span><br><span class="line"><span class="comment">//如果测试不通过。结果如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UN   TestCompany_GetCompanyType</span></span><br><span class="line"><span class="comment">    company_test.go:15: this is others!</span></span><br><span class="line"><span class="comment">--- FAIL: TestCompany_GetCompanyType (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这便是测试的结果。</p><h4 id="测试-Controller-层"><a href="#测试-Controller-层" class="headerlink" title="测试 Controller 层"></a>测试 Controller 层</h4><ol><li>为了尽量保证单元测试的隔离性，测试不要使用例如数据库、外部API、文件系统等外部资源。</li><li>模拟请求和响应</li><li>需要使用 net/http/httptest 提供的功能</li></ol><p>这里有几个函数值得关注：</p><h5 id="NewRequest-函数"><a href="#NewRequest-函数" class="headerlink" title="NewRequest 函数"></a>NewRequest 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//method：HTTP Method</span></span><br><span class="line"><span class="comment">//url：请求的 URL</span></span><br><span class="line"><span class="comment">//body：请求的 Body</span></span><br><span class="line"><span class="comment">//返回的 *Request 可以传递给 handler 函数</span></span><br></pre></td></tr></table></figure><h5 id="ResponseRecorder"><a href="#ResponseRecorder" class="headerlink" title="ResponseRecorder"></a>ResponseRecorder</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseRecorder &#123;</span><br><span class="line">  Code <span class="keyword">int</span> <span class="comment">// 状态码  200、500…</span></span><br><span class="line">HeaderMap http.Header <span class="comment">// 响应的 header</span></span><br><span class="line">Body *bytes.Buffer <span class="comment">// 响应的 body</span></span><br><span class="line">Flushed <span class="keyword">bool</span> <span class="comment">// 缓存是否被 flush 了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来捕获从 handler 返回的响应，只是做记录</span></span><br><span class="line"><span class="comment">//可以用于测试断言</span></span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutesController</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, handlerCompany)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerCompany</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := model.Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收到请求后使用JSON编码，并写到响应里面，并返回回去</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着写一个测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httptest"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandleCompanyCorrect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">r := httptest.NewRequest(http.MethodGet, <span class="string">"/companies"</span>, <span class="literal">nil</span>) <span class="comment">//模拟一个请求</span></span><br><span class="line">w := httptest.NewRecorder()                                 <span class="comment">//用于捕获和记录响应</span></span><br><span class="line">handlerCompany(w, r)                                        <span class="comment">//传入Handler</span></span><br><span class="line"></span><br><span class="line">result, _ := ioutil.ReadAll(w.Result().Body) <span class="comment">//获取响应，提取body</span></span><br><span class="line"></span><br><span class="line">c := model.Company&#123;&#125;</span><br><span class="line">json.Unmarshal(result, &amp;c) <span class="comment">//解码并重新放入c这个变量里边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.ID != <span class="number">123</span> &#123; <span class="comment">//然后判断</span></span><br><span class="line">t.Error(<span class="string">"this is a failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过就显示PASS</span></span><br><span class="line"><span class="comment">//否则显示：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">=== RUN   TestHandleCompanyCorrect</span></span><br><span class="line"><span class="comment">    company_test.go:23: this is a failed</span></span><br><span class="line"><span class="comment">--- FAIL: TestHandleCompanyCorrect (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这还是比较方便的</p><h3 id="Profiling-性能分析"><a href="#Profiling-性能分析" class="headerlink" title="Profiling 性能分析"></a>Profiling 性能分析</h3><h4 id="分析的对象"><a href="#分析的对象" class="headerlink" title="分析的对象"></a>分析的对象</h4><ul><li><p>内存消耗</p></li><li><p>CPU 使用</p></li><li><p>阻塞的 goroutine</p></li><li><p>执行追踪</p></li></ul><p>还有一个 Web 界面：应用的实时数据</p><h4 id="如何分析"><a href="#如何分析" class="headerlink" title="如何分析"></a>如何分析</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import _ “<span class="built_in">net</span>/http/pprof”</span><br><span class="line">引入一个包，设置一些监听的 URL，它们会提供各类诊断信息</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/heap   // 内存</span><br><span class="line">从应用获取内存 dump：应用在使用哪些内存，它们会去哪</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/profile    // CPU</span><br><span class="line">CPU 的快照，可以看到谁在用 CPU</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/block // goroutine</span><br><span class="line">看到阻塞的 goroutine</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/trace?seconds=<span class="number">5</span>  // trace</span><br><span class="line">监控这段时间内，什么在执行，什么在调用什么…</span><br><span class="line"></span><br><span class="line"><span class="function">http:// <span class="title">localhost</span>:8000/<span class="title">debug</span>/<span class="title">pprof</span> // 网页</span></span><br></pre></td></tr></table></figure><p>未完待续…….</p><h1 id="使用Go语言编写一个简易的分布式系统"><a href="#使用Go语言编写一个简易的分布式系统" class="headerlink" title="使用Go语言编写一个简易的分布式系统"></a>使用Go语言编写一个简易的分布式系统</h1><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>在一开始我要去学习用go语言编写一个分布式系统的时候。我会在想什么是分布式系统，分布式系统又跟以往的系统有什么很大的差异，或者说区别嘛。带着这个好奇，我去搜索一下什么才是真正的分布式系统，我以为是非常高深，又难以明白的一门学科，但是我仔细了解分布式系统的原理后。我发现我好像学过？！</p><p>以下资料是来源于我在网上搜索得出的信息：</p><blockquote><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h3><p>​            集  群: 同一个业务,部署在多个服务器上</p><p>​            分布式: 同一个业务,拆分成多个子业务,部署在不同的服务器上</p><p>​            微服务: 同一个业务,按照功能模块拆分,每一个服务只对应一个功能模块</p><h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二.区别"></a>二.区别</h3><p>​     <strong>集群</strong>是多台服务器一起处理同一个业务,可以使用负载均衡使得每一个服务器的负载相对平衡,集群中的一台服务器出现问题,该服务器所负责的业务可以由其他的服务器代为处理.集群是一种物理形态.</p><p>​     <strong>分布式</strong>是把一个业务拆分成多个子业务,给不同的服务器去处理,这里的服务器可以是单个的服务器,也可以是多个服务器集群,一旦处理该业务的服务器出现问题,那么该业务就无法实现了.分布式是一种工作方式.</p><p>​     <strong>微服务</strong>是把一个业务中的各种功能模块进行拆分,给不同的服务去处理,每个服务只处理一个功能模块,该服务可以是单个服务器也可以是多个服务器集群,每个服务之间都是低耦合的.微服务是一种架构风格.</p><p>​    <strong>为什么说分布式不一定是微服务:</strong></p><p>​    假设有一个很大应用,拆分成几个小应用,但还是很庞大,即便使用了分布式,但其依旧不算是微服务,因为微服务的核心要素是微小,简单来说就是这个应用还不够小(嗯..没错就是这样!)</p><p>​            所以我们可以理解为:微服务是分布式的一个子集</p><h3 id="三-应用场景"><a href="#三-应用场景" class="headerlink" title="三.应用场景"></a>三.应用场景</h3><p>假设有一个业务,该业务有5个功能,每个功能单独处理需要1个小时.</p><p>此时,如果只部署一台服务器,则需要5个小时才能处理完该业务,若采用集群或者分布式来处理,结果如下:</p><p>​            1.采用集群处理:提供5台服务器一起处理该业务,则处理每个功能只需12分钟,即处理整个业务只需1个小时</p><p>​    2.采用分布式处理:提供5台服务器,每个服务器处理不同的功能,则一共也只需要一个小时.</p><p>​            该情况下,微服务和分布式的工作原理和最终结果是一样的.</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>​            分布式中的每一个节点,都可以做集群.而集群并不一定就是分布式的.</p><p>​            微服务肯定是分布式的,但分布式不一定是微服务的.</p><p>作者：晔歌歌<br>链接：<a href="https://www.jianshu.com/p/5f157ac8efcf" target="_blank" rel="noopener">https://www.jianshu.com/p/5f157ac8efcf</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>所以说分布式系统其实是一个非常广泛的概念，很多的应用都可以是一个分布式系统，所以我想以我曾经学过的知识微服务，这一方面去了解，或者说是使用：<strong>如何用go编写一个微服务</strong>，也就是分布式系统。</p><p>注：我觉得写go还用前后端耦合，并且还用模板，是非常愚蠢的行为。而微服务是天生前后端分离的（战术后仰）。</p><p>总体分为三个部分：服务注册，服务发现，状态监控。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="创建自定义的日志服务"><a href="#创建自定义的日志服务" class="headerlink" title="创建自定义的日志服务"></a>创建自定义的日志服务</h3><h4 id="实现基本逻辑"><a href="#实现基本逻辑" class="headerlink" title="实现基本逻辑"></a>实现基本逻辑</h4><p>目的在于接受请求，并把请求写入到log里面，是很多应用必备的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为标准库也有一个log，所以可以起一个别名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log *stlog.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的在于把日志写入文件系统</span></span><br><span class="line"><span class="keyword">type</span> fileLog <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fl fileLog)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//首先要打开文件，才能写入</span></span><br><span class="line"><span class="comment">//fl文件路径，os...表示没有则创造，只写，只附加，</span></span><br><span class="line">f, err := os.OpenFile(<span class="keyword">string</span>(fl), os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//defer表示程序最后一定会执行的，这句的意思是必须把文件关闭</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">return</span> f.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把log指向某个文件地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(destination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log = stlog.New(fileLog(destination), <span class="string">"go"</span>, stlog.LstdFlags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/log"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//如果请求是post</span></span><br><span class="line">msg, err := ioutil.ReadAll(request.Body) <span class="comment">//先读取内容</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(msg) == <span class="number">0</span> &#123;         <span class="comment">//如果有错误</span></span><br><span class="line">writer.WriteHeader(http.StatusBadRequest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有错误则写入日志</span></span><br><span class="line">write(<span class="keyword">string</span>(msg))</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//对于其他情况，方法就不进行，直接返回</span></span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%v\n"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写好一个基本的日志服务的逻辑，逻辑较为简单。但还需要完善，接下来就要实现能够运行的日志服务。也就是说，还需要把web服务集中化管理，使其能够正常的运行。</p><p>接着创立一个service，去完善服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, serviceName, host, port <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, serviceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完善了服务启动的逻辑，接着还需要去使这个服务能够正常的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line"><span class="string">"Log service"</span>,</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>接着启动服务，并使用postman进行测试:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:4000/log</span></span><br></pre></td></tr></table></figure><p>输入任意文字，就会看到在根目录下，有一个日志文件生成了。</p><h3 id="服务注册的基本逻辑"><a href="#服务注册的基本逻辑" class="headerlink" title="服务注册的基本逻辑"></a>服务注册的基本逻辑</h3><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>首先需要去尝试编写一下，一个可以将服务都注册进去的注册中心。</p><p>先写一个数据结构，注册中心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注册中心包含了各个服务的名字的地址，紧接着，编写服务注册进去之后的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之后，需要让服务独立运行</p><h4 id="独立服务"><a href="#独立服务" class="headerlink" title="独立服务"></a>独立服务</h4><p>接着就需要将之前的服务，注册到服务中心中。</p><p>这就需要创建一个服务中心主要运行逻辑了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将之前的处理逻辑注册进去</span></span><br><span class="line">http.Handle(<span class="string">"/services"</span>, registry.RegistryService&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的逻辑一样，需要有取消功能，当然其实你在ide中能直接打断，但在大型服务中，每秒都要运行。还是需要自定义取消功能的</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">//一样是定义服务的地址</span></span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = registry.ServerPort</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"注册中心 的服务开始。按任意键停止. \n"</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"结束服务注册"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和日志服务的注册类似，没什么特别的,接着测试：</p><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:3000/services</span></span><br></pre></td></tr></table></figure><p>接着输入json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">     <span class="attr">"serviceName"</span>: <span class="string">"study service"</span>,</span><br><span class="line">    <span class="attr">"serviceURL"</span> : <span class="string">" http://localhost/5000/study"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着显示服务注册成功：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">接受请求：</span><br><span class="line">增加服务：study service ，该服务的//localhost/<span class="number">5000</span>/study</span><br></pre></td></tr></table></figure><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><h4 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h4><p>首先微服务的基本含义是：注册中心是一个服务，然后其他的服务注册到注册中心，然后由主要控制台相互控制和调用。</p><p>那么现在会需要一个客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着需要去改一下日志服务的逻辑，使得日志服务会主动去注册自己：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的<strong>registry.RegisterService(reg)</strong>实际上会去调用client的<strong>func RegisterService(r Registration)</strong>，这样会向注册中心发送一个post请求，去注册自己。</p><p>接着，要去改动日志服务的main函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: <span class="string">"log service"</span>,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是增加了<strong>serviceAddress</strong> ，也就是说所有服务都会使用这同一个逻辑。</p><h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>紧接着两个服务连续启动，先启动注册中心，后启动日志逻辑，结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:4000</span><br></pre></td></tr></table></figure><p>很简单对吧，和Spring cloud的微服务简直一模一样。</p><h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h3><p>那么我们把微服务注册进去了，自然能够调用，但是怎么主动去取消微服务呢？它肯定不是说我自己把自己的微服务关了就行了，同时也需要通知注册中心。</p><h4 id="修改注册中心"><a href="#修改注册中心" class="headerlink" title="修改注册中心"></a>修改注册中心</h4><p>直接在注册中心加上一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[i+<span class="number">1</span>:]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后直接在Switch里面增加一个情况Delete：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清晰，就是一模一样的移除服务，总体代码改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心取消服务的方法定义好了，那么也就需要在其他可注册服务的函数体中定义方法。为了进一步的解除耦合度，取消服务的方法和建立服务的方法一样，需要在client里面编写。</p><h4 id="修改客户端"><a href="#修改客户端" class="headerlink" title="修改客户端"></a>修改客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了ShutdownService去结束这个服务。</p><p>紧接着，去开始服务注册的函数里边，进行取消注册的修改：</p><h4 id="修改服务的注册功能"><a href="#修改服务的注册功能" class="headerlink" title="修改服务的注册功能"></a>修改服务的注册功能</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//启动服务，一旦发生可错误，就取消</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是两个goroutine的修改，使其具有取消服务的功能。</p><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>那么注册中心和服务的逻辑都修改好了，然后和上面的步骤一样，先启动注册中心，后启动日志逻辑，结果为:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止.</span><br><span class="line">q</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">移除服务： <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function"><span class="title">http</span>: <span class="title">Server</span> <span class="title">closed</span></span></span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>前面的服务注册都是一对一的，还体现不了分布式的特点。接下来进行多服务注册，使得一个学生成绩的服务既要使用日志服务，也要注册到注册中心</p><h3 id="业务服务"><a href="#业务服务" class="headerlink" title="业务服务"></a>业务服务</h3><h4 id="基本的数据结构与方法"><a href="#基本的数据结构与方法" class="headerlink" title="基本的数据结构与方法"></a>基本的数据结构与方法</h4><p>首先要编写一个学生的基础信息的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生信息</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">int</span></span><br><span class="line">FirstName <span class="keyword">string</span></span><br><span class="line">LastName  <span class="keyword">string</span></span><br><span class="line">Grades    []Grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分数</span></span><br><span class="line"><span class="keyword">type</span> Grade <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Type  GradeType</span><br><span class="line">Score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GradeType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">//考试类型</span></span><br><span class="line">GradeQuiz = GradeType(<span class="string">"Quiz"</span>)</span><br><span class="line">GradeTest = GradeType(<span class="string">"Test"</span>)</span><br><span class="line">GradeExam = GradeType(<span class="string">"Exam"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的平均成绩</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">Average</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">for</span> _, grade := <span class="keyword">range</span> s.Grades &#123;</span><br><span class="line">result += grade.Score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="keyword">float32</span>(<span class="built_in">len</span>(s.Grades))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找学生 by ID</span></span><br><span class="line"><span class="keyword">type</span> Students []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ss Students)</span> <span class="title">GetByID</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*Student, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ss &#123;</span><br><span class="line"><span class="keyword">if</span> ss[i].ID == id &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ss[i], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生的ID：  %d  未找到"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于外部的访问</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">students      Students</span><br><span class="line">studentsMutex sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着肯定得有一些学生的数据，来做测试，这些数据一开始就会被加载进数据结构中，这暂时是用来代替数据库的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">students = []Student&#123;</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">1</span>,</span><br><span class="line">FirstName: <span class="string">"Nick"</span>,</span><br><span class="line">LastName:  <span class="string">"Carter"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">85</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">82</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">2</span>,</span><br><span class="line">FirstName: <span class="string">"Roberto"</span>,</span><br><span class="line">LastName:  <span class="string">"Baggio"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">81</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">3</span>,</span><br><span class="line">FirstName: <span class="string">"Emma"</span>,</span><br><span class="line">LastName:  <span class="string">"Stone"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">67</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">75</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">4</span>,</span><br><span class="line">FirstName: <span class="string">"Rachel"</span>,</span><br><span class="line">LastName:  <span class="string">"McAdams"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">98</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">99</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">5</span>,</span><br><span class="line">FirstName: <span class="string">"Kelly"</span>,</span><br><span class="line">LastName:  <span class="string">"Clarkson"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">95</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">97</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，也肯定要有server，才能正常的启动服务，需要去编写基本的逻辑，比如获取全部学生信息，根据ID进行信息搜索，增加学生信息等功能：</p><h4 id="服务的逻辑"><a href="#服务的逻辑" class="headerlink" title="服务的逻辑"></a>服务的逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="built_in">new</span>(studentsHandler)</span><br><span class="line"><span class="comment">//这个两个地址是不同的，一个是单个页面</span></span><br><span class="line">http.Handle(<span class="string">"/students"</span>, handler)</span><br><span class="line"><span class="comment">//另一个是必须传入参数的页面</span></span><br><span class="line">http.Handle(<span class="string">"/students/"</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以一个链接需要处理很多情况</span></span><br><span class="line"><span class="comment">// /students 分割后长度是2</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125; 分割后长度是3</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125;/grades  分割后长度是4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//简单对字符进行处理：</span></span><br><span class="line">pathSegments := strings.Split(r.URL.Path, <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(pathSegments) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//获取全部信息</span></span><br><span class="line">sh.getAll(w, r)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//查询</span></span><br><span class="line"><span class="comment">//提取id</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.getOne(w, r, id)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//新增</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.addGrade(w, r, id)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取全部学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getAll</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将学生信息全部转为JSON，返回给data，最后写入</span></span><br><span class="line">data, err := sh.toJSON(students)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据ID，搜索学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getOne</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑与获取全部信息几乎一致</span></span><br><span class="line">data, err := sh.toJSON(student)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Printf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加学生成绩信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">addGrade</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的逻辑一样的，没什么好说</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着要从URL中获取到要传达的学生成绩信息</span></span><br><span class="line"><span class="keyword">var</span> g Grade</span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line">err = dec.Decode(&amp;g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这部分逻辑是获取成绩信息</span></span><br><span class="line"><span class="comment">//如果学生成绩获取正确，就附加信息</span></span><br><span class="line">student.Grades = <span class="built_in">append</span>(student.Grades, g)</span><br><span class="line">w.WriteHeader(http.StatusCreated) <span class="comment">//201</span></span><br><span class="line"></span><br><span class="line">data, err := sh.toJSON(g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"applicaiton/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化为JSON</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">toJSON</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">enc := json.NewEncoder(&amp;b)</span><br><span class="line">err := enc.Encode(obj)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，基础逻辑也已经完善了，接着就是在注册中心里增加服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后，得让web服务可以运行，在cmd文件夹下创建一个新的main函数，写入一样的逻辑代码：</p><h4 id="服务启动器"><a href="#服务启动器" class="headerlink" title="服务启动器"></a>服务启动器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么下来，这个业务服务也就完成了，他们可以互相不干扰的进行服务注册，但是现在grade服务还不能去调用日志服务。所以我们还需要服务发现。</p><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现作用能让grade服务可以请求log服务</p><h4 id="去引用日志服务"><a href="#去引用日志服务" class="headerlink" title="去引用日志服务"></a>去引用日志服务</h4><p>首先肯定是要给服务的数据结构增加一些基本信息，这样才能使得服务有这些基本的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该服务所依赖的其他服务。用slice去保存</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line"><span class="comment">//向外暴露的服务端口</span></span><br><span class="line">ServiceUpdateURL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一条目</span></span><br><span class="line"><span class="keyword">type</span> patchEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Name ServiceName</span><br><span class="line">URL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务变化</span></span><br><span class="line"><span class="keyword">type</span> patch <span class="keyword">struct</span> &#123;</span><br><span class="line">Added   []patchEntry</span><br><span class="line">Removed []patchEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以想想，一个服务如果还依赖着其他的服务。那么，当这个服务正要注册的时候，或者说要加入服务群体的时候。就会在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span></span></span><br></pre></td></tr></table></figure><p>进行服务注册，那么这个时候如果服务还依赖其他服务，比如正要注册的grade服务还依赖log服务，这时候就正好可以去获取依赖。</p><p>修改后代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个找到所需要服务并将其注册的过程。</p><p>接着，grade服务会向注册中心请求这些服务，但是注册中心也需要地方去存储这些请求的服务。</p><p>log服务就会向grade服务提供服务，那么会需要一些数据结构去存储：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去实现它的逻辑，总体修改后代码如下：</p><h4 id="服务的提供者"><a href="#服务的提供者" class="headerlink" title="服务的提供者"></a>服务的提供者</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务注册中心要向URL更新一些信息</span></span><br><span class="line">serviceUpdateURL, err := url.Parse(r.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(serviceUpdateURL.Path, &amp;serviceUpdateHandler&#123;&#125;)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err = enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新服务的处理</span></span><br><span class="line"><span class="keyword">type</span> serviceUpdateHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suh serviceUpdateHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先进行解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line">err := dec.Decode(&amp;p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf("收到更新： %v\n", p)</span></span><br><span class="line">prov.Update(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受到patch的时候，需要进行更新，</span></span><br><span class="line"><span class="keyword">var</span> prov = providers&#123;</span><br><span class="line">services: <span class="built_in">make</span>(<span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span>),</span><br><span class="line">mutex:    <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span> <span class="title">Update</span><span class="params">(pat patch)</span></span> &#123;</span><br><span class="line"><span class="comment">//对传进来的patch更新provider</span></span><br><span class="line">p.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增的情况</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Added &#123;</span><br><span class="line"><span class="comment">//如果这个服务名目前还不存在，就创建新的slice</span></span><br><span class="line"><span class="keyword">if</span> _, ok := p.services[patchEntry.Name]; !ok &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在的话，就在值后边附加URL</span></span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(p.services[patchEntry.Name],</span><br><span class="line">patchEntry.URL)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少的情况</span></span><br><span class="line"><span class="comment">//遍历，对比，移除</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Removed &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs, ok := p.services[patchEntry.Name]; ok &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> providerURLs &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs[i] == patchEntry.URL &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(providerURLs[:i],</span><br><span class="line">providerURLs[i+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后还需要，根据服务的名称来找到它所依赖服务的url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span> <span class="title">get</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">providers, ok := p.services[name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"没有可提供服务的提供商： %v"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机数</span></span><br><span class="line">idx := <span class="keyword">int</span>(rand.Float32() * <span class="keyword">float32</span>(<span class="built_in">len</span>(providers)))</span><br><span class="line"><span class="keyword">return</span> providers[idx], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于这个get方法是私有的，对外再套一个函数：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvider</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> prov.get(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端的client"><a href="#客户端的client" class="headerlink" title="客户端的client"></a>客户端的client</h4><p>log服务现在有服务端的逻辑，但是客户端的服务想使用这个client还是比较麻烦的，所以还需要对log服务有一个自己的client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写日志，把日志写到server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetClientLogger</span><span class="params">(serviceURL <span class="keyword">string</span>, clientService registry.ServiceName)</span></span> &#123;</span><br><span class="line">stlog.SetPrefix(fmt.Sprintf(<span class="string">"[%v] - "</span>, clientService))</span><br><span class="line">stlog.SetFlags(<span class="number">0</span>)</span><br><span class="line">stlog.SetOutput(&amp;clientLogger&#123;url: serviceURL&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> clientLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">url <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl clientLogger)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">b := bytes.NewBuffer([]<span class="keyword">byte</span>(data))</span><br><span class="line"><span class="comment">//写到服务端</span></span><br><span class="line">res, err := http.Post(cl.url+<span class="string">"/log"</span>, <span class="string">"text/plain"</span>, b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to send log message. Service responded with %d - %s"</span>, res.StatusCode, res.Status)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果都没有问题，返回数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以让本地的日志服务写好日志后发送到服务器端保存</p><h4 id="使main函数具有服务发现的功能"><a href="#使main函数具有服务发现的功能" class="headerlink" title="使main函数具有服务发现的功能"></a>使main函数具有服务发现的功能</h4><p>主要是使得两个启动器拥有新的功能：</p><h5 id="grading-service"><a href="#grading-service" class="headerlink" title="grading service"></a>grading service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: []registry.ServiceName&#123;registry.LogService&#125;,</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在服务启动之后使用log服务</span></span><br><span class="line"><span class="keyword">if</span> logProvider, err := registry.GetProvider(registry.LogService); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"发现日志服务: %s\n"</span>, logProvider)</span><br><span class="line">log.SetClientLogger(logProvider, r.ServiceName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="log-service"><a href="#log-service" class="headerlink" title="log service"></a>log service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.LogService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: <span class="built_in">make</span>([]registry.ServiceName, <span class="number">0</span>),</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来便可以测试了。</p><h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><p>按照：registryservice，logservice，gradingservice的顺序启动，测试结果如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span> </span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">GradingService 服务开始。按任意键停止.</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br></pre></td></tr></table></figure><p>这么一来就完成了。</p><h3 id="依赖变化"><a href="#依赖变化" class="headerlink" title="依赖变化"></a>依赖变化</h3><h4 id="重新发现服务"><a href="#重新发现服务" class="headerlink" title="重新发现服务"></a>重新发现服务</h4><p>可以从上述的情况下看到一些不那么方便的点，一是：启动必须按照顺序来，不能随意。二是：当log服务下线后，再上线的话不会被再次发现。这都是服务极为脆弱的表现。那么解决这个问题的最好方法是：使服务具有依赖变化时进行通知的功能。</p><p>可以在服务中更改，使其具备通知的功能,主要是有notify函数，总体修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务通知，当服务上线，而这个服务又被依赖时，告知依赖服务自己上线了</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Added: []patchEntry&#123;</span><br><span class="line">patchEntry&#123;</span><br><span class="line">Name: reg.ServiceName,</span><br><span class="line">URL:  reg.ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">notify</span><span class="params">(fullPatch patch)</span></span> &#123;</span><br><span class="line">r.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> r.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//看看服务的依赖在patch里面存不存在</span></span><br><span class="line"><span class="comment">//对已经注册的服务循环遍历</span></span><br><span class="line"><span class="keyword">for</span> _, reg := <span class="keyword">range</span> r.registrations &#123;</span><br><span class="line"><span class="comment">//并发的发出通知</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reg Registration)</span></span> &#123;</span><br><span class="line"><span class="comment">//对服务所需要的服务进行循环</span></span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line">p := patch&#123;Added: []patchEntry&#123;&#125;, Removed: []patchEntry&#123;&#125;&#125;</span><br><span class="line"><span class="comment">//标志位，为TRUE表示有需要更新的地方</span></span><br><span class="line">sendUpdate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, added := <span class="keyword">range</span> fullPatch.Added &#123;</span><br><span class="line"><span class="comment">//如果添加的服务正好是某个服务的依赖项</span></span><br><span class="line"><span class="keyword">if</span> added.Name == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, added)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看有哪些服务停止了</span></span><br><span class="line"><span class="keyword">for</span> _, removed := <span class="keyword">range</span> fullPatch.Removed &#123;</span><br><span class="line"><span class="comment">///如果停掉的服务正好是所被依赖的服务</span></span><br><span class="line"><span class="keyword">if</span> removed.Name == reqService &#123;</span><br><span class="line">p.Removed = <span class="built_in">append</span>(p.Removed, removed)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后判断标志位，把更新发送到对应的服务</span></span><br><span class="line"><span class="keyword">if</span> sendUpdate &#123;</span><br><span class="line">err := r.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(reg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><p>接着再进行测试，可以看到，当log服务下线后，重新上线时，grading 服务就能够发现log服务了。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125; &#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br></pre></td></tr></table></figure><h4 id="服务下线告知"><a href="#服务下线告知" class="headerlink" title="服务下线告知"></a>服务下线告知</h4><p>接着也容易，把remove方法里面添加下线告知的功能就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下线也告知</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Removed: []patchEntry&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: registry.registrations[i].ServiceName,</span><br><span class="line">URL:  registry.registrations[i].ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//下线告知</span></span><br><span class="line"></span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这部分逻辑就完成了。接下来测试代码。</p><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><p>测试的步骤是先开启注册中心，再开启日志服务，后开始grade服务。然后使得日志服务停止，再重启。可以看到一系列的结果。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span></span><br><span class="line">移除服务： http://localhost:<span class="number">4000</span></span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line">收到更新： &#123;[] []&#125;</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"><span class="title">LogService</span> 服务开始。按任意键停止</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">GradingService</span> 服务开始。按任意键停止.</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br><span class="line"><span class="function">发现日志服务: <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function">收到更新： &#123;[] [&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;]&#125;</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br></pre></td></tr></table></figure><p>使用解除了耦合的网络接口，这也是Spring Cloud的微服务思想，同时也是分布式的一种类型。所以说分布式也没什么神奇之处，最核心的一处在于：<strong>把本地接口转化为了网络接口</strong>。能够理解这一过程，也就理解了分布式的思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Go语言编写一个web应用&quot;&gt;&lt;a href=&quot;#使用Go语言编写一个web应用&quot; class=&quot;headerlink&quot; title=&quot;使用Go语言编写一个web应用&quot;&gt;&lt;/a&gt;使用Go语言编写一个web应用&lt;/h1&gt;&lt;h2 id=&quot;初始知识&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Golang" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>go语言学习遇到的问题</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-language-error-problem/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-language-error-problem/</id>
    <published>2022-04-27T12:54:36.000Z</published>
    <updated>2023-03-11T10:08:21.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go语言学习遇到的问题"><a href="#go语言学习遇到的问题" class="headerlink" title="go语言学习遇到的问题"></a>go语言学习遇到的问题</h1><p>最近在努力学习go，这个编程语言语法和写法的都和其他的编程语言有着比较大的差异。所以特地记录一下学习go遇到的问题。</p><h2 id="GOPATH和go-module"><a href="#GOPATH和go-module" class="headerlink" title="GOPATH和go module"></a>GOPATH和go module</h2><p>这个问题比较神奇，也是我学习这个编程语言中遇到的比较拧巴的问题。网上的绝大多数的教程都会让你配置GOPATH，然后go程序都必须在GOPATH的SRC这个文件下运行，而这个GOPATH是你windows的环境变量。</p><p><strong>在以前GOPATH下会对go程序的编写严格进行，必须在src下，并且在很多包，或者git下其他的程序之后，整个项目就会变得非常混乱</strong>。</p><p>这样听起来很奇怪不是吗？身为一个比较新鲜的编程语言，既然会有这么愚蠢的方法。</p><p>而网上的教程绝大多数度是让你去配置环境，最后用vscode去编写go程序，但是我自己在用IDEA去写的时候却不会遇到要配置GOPATH这个问题，这是为什么呢？然后我去网上进行了一番搜索之后，了解了一个新鲜的事物，叫做go module。</p><p>而go 1.13版本之后就支持了go module，这使得程序的编写不用在指定的文件夹进行，而是用模块化的方式去编写程序。</p><p>而现在，在有了MODULE之后，GOPATH现在常用于存放第三方API，不进行程序编写了。go module允许go在任意地方进行编写，非常人性化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当你在GOPATH下使用go module时</span><br><span class="line">用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</span><br><span class="line"></span><br><span class="line">GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</span><br><span class="line">GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</span><br><span class="line">GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。</span><br><span class="line">但是我建议新开别的文件夹去写go程序，不要在GoPATH下</span><br></pre></td></tr></table></figure><p>所以，我们应该<strong>使用 go mod init your_project_name</strong></p><p>去实现go的模块化编写</p><h2 id="浅拷贝和深拷贝的问题"><a href="#浅拷贝和深拷贝的问题" class="headerlink" title="浅拷贝和深拷贝的问题"></a>浅拷贝和深拷贝的问题</h2><p>在我用go写leetcode39的时候，遇到了一个奇怪的问题，我加入ans的值是【2,2,2,3】，可是运行结果后，值就变为【2,2,2,1】了，真是奇怪。我在func中有且仅有一个对ans的操作，这真的让我思考了很久，然后一个一个的debug。。。。。。。。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">   ans = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">var</span> currentArray []<span class="keyword">int</span></span><br><span class="line">   <span class="comment">//不断递归搜索的问题</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">      currentArray = <span class="literal">nil</span></span><br><span class="line">      currentArray = <span class="built_in">append</span>(currentArray, candidates[i])</span><br><span class="line">      <span class="comment">//如果当前就是，那么久不用继续了</span></span><br><span class="line">      <span class="keyword">if</span> candidates[i] == target &#123;</span><br><span class="line">         singerAns := []<span class="keyword">int</span>&#123;candidates[i]&#125;</span><br><span class="line">         ans = <span class="built_in">append</span>(ans, singerAns)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//否则递归性搜索</span></span><br><span class="line">         combinationSumRecursiveFunction(candidates, currentArray, i, candidates[i], target)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//for i := 0; i &lt; len(ans); i++ &#123;</span></span><br><span class="line">   <span class="comment">// sum := 0</span></span><br><span class="line">   <span class="comment">// for j := 0; j &lt; len(ans[i]); j++ &#123;</span></span><br><span class="line">   <span class="comment">//    sum += ans[i][j]</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="comment">// if sum != target &#123;</span></span><br><span class="line">   <span class="comment">//    fmt.Println(ans[i])</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSumRecursiveFunction</span><span class="params">(candidates, currentArray []<span class="keyword">int</span>, begin, sum, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := begin; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> candidates[i]+sum == target &#123;</span><br><span class="line">         <span class="comment">//不要去改动currentArray</span></span><br><span class="line">         <span class="comment">//等于就加入ans</span></span><br><span class="line">       correctArr := currentArray</span><br><span class="line">         correctArr = <span class="built_in">append</span>(correctArr, candidates[i])</span><br><span class="line">         ans = <span class="built_in">append</span>(ans, correctArr)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> candidates[i]+sum &lt; target &#123;</span><br><span class="line">         <span class="comment">//小于则可以直接递归，再次搜索</span></span><br><span class="line">         smallerArr := currentArray</span><br><span class="line">         smallerArr = <span class="built_in">append</span>(smallerArr, candidates[i])</span><br><span class="line">         combinationSumRecursiveFunction(candidates, smallerArr, i, candidates[i]+sum, target)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//大于则没有继续搜索的必要了，什么都不做就可以了</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans [][]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>最后，我花了一个小时，终于找到了问题所在，问题在于这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">correctArr := currentArray</span><br><span class="line">correctArr = <span class="built_in">append</span>(correctArr, candidates[i])</span><br><span class="line"><span class="comment">//========================================================================================</span></span><br><span class="line">smallerArr := currentArray</span><br><span class="line">smallerArr = <span class="built_in">append</span>(smallerArr, candidates[i])</span><br></pre></td></tr></table></figure><p>它们之间是浅拷贝关系，我对smallerArr 进行append也会影响到已经加入了ans的数组！！！！！</p><ol><li>调用append函数时，当原有长度加上新追加的长度如果超过容量则会新建一个数组，新旧切片会指向不同的数组；</li><li>如果没有超过容量则在原有数组上追加元素，新旧切片会指向相同的数组，这时对其中一个切片的修改会同时影响到另一个切片。</li></ol><p>改动了正确代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">ans = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> currentArray []<span class="keyword">int</span></span><br><span class="line"><span class="comment">//不断递归搜索的问题</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">currentArray = <span class="literal">nil</span></span><br><span class="line">currentArray = <span class="built_in">append</span>(currentArray, candidates[i])</span><br><span class="line"><span class="comment">//如果当前就是，那么久不用继续了</span></span><br><span class="line"><span class="keyword">if</span> candidates[i] == target &#123;</span><br><span class="line">singerAns := []<span class="keyword">int</span>&#123;candidates[i]&#125;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, singerAns)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//否则递归性搜索</span></span><br><span class="line">combinationSumRecursiveFunction(candidates, currentArray, i, candidates[i], target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; len(ans); i++ &#123;</span></span><br><span class="line"><span class="comment">//sum := 0</span></span><br><span class="line"><span class="comment">//for j := 0; j &lt; len(ans[i]); j++ &#123;</span></span><br><span class="line"><span class="comment">//sum += ans[i][j]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//if sum != target &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println(ans[i])</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSumRecursiveFunction</span><span class="params">(candidates, currentArray []<span class="keyword">int</span>, begin, sum, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := begin; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> candidates[i]+sum == target &#123;</span><br><span class="line"><span class="comment">//不要去改动currentArray</span></span><br><span class="line"><span class="comment">//等于就加入ans</span></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line">correctArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(currentArray))</span><br><span class="line"><span class="built_in">copy</span>(correctArr, currentArray)</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="comment">//correctArr := currentArray</span></span><br><span class="line">correctArr = <span class="built_in">append</span>(correctArr, candidates[i])</span><br><span class="line">ans = <span class="built_in">append</span>(ans, correctArr)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> candidates[i]+sum &lt; target &#123;</span><br><span class="line"><span class="comment">//小于则可以直接递归，再次搜索</span></span><br><span class="line">smallerArr := currentArray</span><br><span class="line">smallerArr = <span class="built_in">append</span>(smallerArr, candidates[i])</span><br><span class="line">combinationSumRecursiveFunction(candidates, smallerArr, i, candidates[i]+sum, target)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//大于则没有继续搜索的必要了，什么都不做就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans [][]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>未完待续。。。。。</p><p><strong>1、深拷贝（Deep Copy）：</strong></p><p>拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。</p><p>值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。</p><p><strong>2、浅拷贝（Shallow Copy）：</strong></p><p>拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。</p><p>引用类型的数据，默认全部都是浅复制，Slice，Map。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go语言学习遇到的问题&quot;&gt;&lt;a href=&quot;#go语言学习遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;go语言学习遇到的问题&quot;&gt;&lt;/a&gt;go语言学习遇到的问题&lt;/h1&gt;&lt;p&gt;最近在努力学习go，这个编程语言语法和写法的都和其他的编程语言有着比</summary>
      
    
    
    
    
    <category term="Golang" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>项目--SpringBoot+Vue交易平台</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/02/06/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C3/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/02/06/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C3/</id>
    <published>2021-02-06T10:02:24.000Z</published>
    <updated>2022-11-27T10:39:04.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目–SpringBoot-Vue交易平台"><a href="#项目–SpringBoot-Vue交易平台" class="headerlink" title="项目–SpringBoot+Vue交易平台"></a>项目–SpringBoot+Vue交易平台</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人做了一个交易平台，后端是SpringBoot，前端是Vue。这个电商平台有分<strong>商家页面</strong>和<strong>普通用户页面</strong>，后续还会增加一个独属于<strong>管理员的页面</strong>。这个电商平台通过<strong>QQ登录进行注册</strong>，并且为每一个注册的的用户分配一个默认好友，可以进行聊天，每一个普通的用户都可以通过申请提交成为一名商家，成为商家之后才可以进行增加自家的商品。</p><p>其实本人之前也做过一个前后的耦合的thymeleaf和SpringBoot的商城，后续也曾想过下一个项目是不是该做一个博客，音乐平台，或者是视频网站，最后考虑到，用工具的方法有千千万万，重要的是对工具的了解程度如何，你能不能更加深入的对单个方面有较为深刻的理解，于是这个项目也是一个电商平台，但在实现了前后端分离的同时，还加入了很多新的技术，并且在一些方面有了更为优秀的解决方案。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>看文章有时候就和看别人家的注释一样，不一定能快速分清楚对方的注释是关键语句还是在水代码行数，所以前面先列出本人做的项目的特点，节约一下阅读的时间，后面会有较为详细的描述。</p><p><strong>实现的模板</strong>：基本CRUD和购物车，秒杀商品，搜索，Socket通信，security安全拦截，微服务等。</p><p><strong>一些特点</strong>：</p><ul><li>使用了redis，在用户访问商品时候会把商品放入redis缓存器，减少数据库的频繁访问，并且使用redis集群实现数据的安全</li><li>使用了redis实现了商品的秒杀，对突然间大量的请求会将其放入redis而不放入数据库，等秒杀活动过了一定时间再使用定时任务，慢慢写入数据库，由于redis的单线程保证了秒杀的安全，也减少了数据库的访问压力，后续的云服务还可以通过将商品放入消息队列的方式，进一步提高性能。</li><li>图片的类型是String，而不是流文件，这里结合了七牛云做图床，实现图片数据库和本地数据库的分离</li><li>每一个用户会有一个默认的好友，以用来测试socket模块，socket模块实现了用户的实时在线聊天，并且还会保存用户的聊天信息。</li><li>申请了QQ互联的功能，只需要QQ扫码便可以进行登录，QQ互联是和VUE 进行结合的，会产生一个全局的JWT来保证用户的权限认证，后端的security也是用JWT来和前端进行权限认证</li><li>搜索模块结合了Elasticsearch，以便于用户进行模糊类型的搜索</li><li>商品平台里面的数据是使用Jsoup爬虫从京东爬取而来的，并且使用雪花算法为每一个商品生成了一个全局唯一的UID</li><li>结合eureka和ribbon实现注册中心和负载均衡，降低访问压力</li></ul><h2 id="项目讲述"><a href="#项目讲述" class="headerlink" title="项目讲述"></a>项目讲述</h2><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><ol><li>SpringBoot （后端）</li><li>MySQL （数据库）</li><li>MyBatis （访问数据库）</li><li>swagger （集成文档）</li><li>SpringSecurity （登录与权限控制）</li><li>JWT （单点登录）</li><li>Jsoup （爬虫，用于补充数据库的数据）</li><li>fastjson （转JSON工具，用于前后端数据交互）</li><li>七牛云 （图床）</li><li>netty-socketio （用于用户之间的通信）</li><li>qq互联 （实现QQ登录）</li><li>redis （中间件，用于数据的缓存）</li><li>elasticsearch （搜索引擎）</li><li>spring-boot-admin （管理后台）</li><li>eureka （微服务的注册中心）</li><li>ribbon （负载均衡）</li><li>docker （容器化）</li><li>Nginx （反向代理）</li><li>aliyunEcs （服务器）</li><li>vue （前端）</li><li>axios （前端api） </li><li>Element-ui （前端UI）</li></ol><h3 id="基本CRUD"><a href="#基本CRUD" class="headerlink" title="基本CRUD"></a>基本CRUD</h3><p>无聊的操作总是千篇一律，有意思的源码也可能涉及跨域。</p><p>一个基本的CRUD，是由mybatis来操作mysql数据库来实现的，mybatis其实也很讲究，有一级缓存二级缓存等等很多原理，mysql也有innodb等等知识，然而这东西在讲系统时讲出来比较麻烦，所以在这篇展示项目的文章中，我仅仅根据我的所写的代码去讲述为什么需要这么写，暂时不写这些工具的原理。</p><p>这个是mybatis中mapper的规范，所有的命名都是根据以下来确定的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">countByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * delete by primary key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id primaryKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deleteCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert record to table</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> insert count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrUpdate</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrUpdateSelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert record to table selective</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> insert count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">selectByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * select by primary key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id primary key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object by primary key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Product <span class="title">selectByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleSelective</span><span class="params">(@Param(<span class="string">"record"</span>)</span> Product record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> ProductExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExample</span><span class="params">(@Param(<span class="string">"record"</span>)</span> Product record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> ProductExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update record selective</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the updated record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update record</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the updated record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBatch</span><span class="params">(List&lt;Product&gt; list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">batchInsert</span><span class="params">(@Param(<span class="string">"list"</span>)</span> List&lt;Product&gt; list)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中运用到了插件mybatiscodehelper</p><p>在控制层中有一个 <strong>BaseController</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而全部的控制器都是通过继承来实现依赖注入的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span>  <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样继承省去了很多代码量</p><p>在后端中，购物车模块的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/add_all_cart_order"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">add_all_cart_order</span><span class="params">(@Validated @RequestBody List&lt;OrderSheet&gt; orderSheets , HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    BigDecimal sum=<span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (OrderSheet o:orderSheets) &#123;<span class="comment">//List&lt;OrderSheet&gt; orderSheets</span></span><br><span class="line">        sum.add(o.getSumMoney());</span><br><span class="line">    &#125;</span><br><span class="line">    String state=<span class="string">"余额不足"</span>;</span><br><span class="line">    User user=userService.selectById(orderSheets.get(<span class="number">0</span>).getUserId());</span><br><span class="line">    BigDecimal money=user</span><br><span class="line">            .getMoney()</span><br><span class="line">            .subtract(sum);</span><br><span class="line">    <span class="keyword">if</span> (money.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">0</span>))==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (OrderSheet o:orderSheets) &#123;<span class="comment">//List&lt;OrderSheet&gt; orderSheets</span></span><br><span class="line">        o.setState(<span class="string">"未收货"</span>);</span><br><span class="line">        orderSheetService.insert(o);</span><br><span class="line">        shoppingCartService.deleteByPrimaryKey(o.getId());</span><br><span class="line">        user.setMoney(user.getMoney().subtract(sum));</span><br><span class="line">        userService.updateByPrimaryKey(user);</span><br><span class="line">        state=<span class="string">"支付成功"</span>;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(state);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数支付方面的代码都与其类似。</p><h3 id="秒杀商品"><a href="#秒杀商品" class="headerlink" title="秒杀商品"></a>秒杀商品</h3><p>首先我先举例一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addorder"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">add_order</span><span class="params">(@Validated @RequestBody OrderSheet orderSheet, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        orderSheet.setId(<span class="keyword">new</span> RandomId().nextId());</span><br><span class="line">        orderSheet.setTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        Product product=productService.selectOneById(orderSheet.getProductId());</span><br><span class="line">        orderSheet.setSumMoney(product.getPrice().multiply(<span class="keyword">new</span> BigDecimal(orderSheet.getAmount())));</span><br><span class="line"><span class="comment">//        redis缓存放入</span></span><br><span class="line">        Boolean success=orderRedis.addOrderByRedis(orderSheet);</span><br><span class="line">        String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(message, <span class="string">"抢购失败"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.succ(message);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        redis缓存放入</span></span><br><span class="line">        orderSheetService.insert(orderSheet);</span><br><span class="line">        <span class="keyword">return</span> Result.succ(JSONObject.toJSONString(orderSheet.getId(),<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>orderSheetService</strong>就是可以被替换为秒杀模块，通过<strong>orderRedis.addOrderByRedis</strong>来实现将商品放入redis，而不涉及数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRedisImpl</span> <span class="keyword">implements</span> <span class="title">OrderRedis</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">addOrderByRedis</span><span class="params">(OrderSheet orderSheet)</span> </span>&#123;</span><br><span class="line">        Long productId = orderSheet.getProductId();</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!jedis.exists(<span class="string">"product_stock_"</span>+productId))&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = jedis.get((<span class="string">"get_product_"</span>+productId).getBytes());</span><br><span class="line">                Product p =(Product) SerializeUtil.unserialize(bytes);</span><br><span class="line">                jedis.set(<span class="string">"product_stock_"</span>+productId,p.getStock()+<span class="string">""</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis.get(<span class="string">"product_stock_"</span>+productId).equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                jedis.decrBy(<span class="string">"product_stock_"</span>+productId , <span class="number">1</span>);</span><br><span class="line">                jedis.lpush((<span class="string">"order_product_"</span>+productId).getBytes() ,SerializeUtil.serialize(orderSheet));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.destroy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法比较简易，这里使用的是Jedis，通过从线程池里获取Jedis的方式保证了Jedis的线程安全，然后由于redis是单线程的，所以Jedis的API的所有操作都具有着原子性。以此实现线程安全的同时能够把数据放入redis 当中，然后通过<strong>TaskService</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 每天半夜1点钟开始执行任务</span></span><br><span class="line"><span class="comment">//    @Scheduled(cron = "0 0 1 * * ?")</span></span><br><span class="line">    <span class="comment">// 下面是用于测试的配置，每分钟执行一次任务</span></span><br><span class="line">     <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"定时任务开始......"</span>);</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; bytes=jedis.lrange(<span class="string">"order_product_885036"</span>.getBytes(), <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span>[] b:bytes) &#123;</span><br><span class="line">            OrderSheet orderSheet =(OrderSheet) SerializeUtil.unserialize(b);</span><br><span class="line">            System.out.println(JSON.toJSONString(orderSheet));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"定时任务结束......"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/// ... 当关闭应用程序时:</span></span><br><span class="line">        pool.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后半夜时分，再将任务写入数据库。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索模块用的是Elasticsearch，这里不得不吐槽一下Elasticsearch的Api更新速度飞快，版本更新也很快，动不动就方法废弃，部署起来真的是不容易：</p><p>现在版本，根据官方文档来看，需要配置  <strong>RestHighLevelClient</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientConfiguration configuration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">"192.168.78.128:9200"</span>)</span><br><span class="line"><span class="comment">//                .connectedTo("localhost:9200")</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//.withConnectTimeout(Duration.ofSeconds(5))</span></span><br><span class="line">                <span class="comment">//.withSocketTimeout(Duration.ofSeconds(3))</span></span><br><span class="line">                <span class="comment">//.useSsl()</span></span><br><span class="line">                <span class="comment">//.withDefaultHeaders(defaultHeaders)</span></span><br><span class="line">                <span class="comment">//.withBasicAuth(username, password)</span></span><br><span class="line">                <span class="comment">// ... other options</span></span><br><span class="line">                .build();</span><br><span class="line">        RestHighLevelClient client = RestClients.create(configuration).rest();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过继承<strong>ElasticsearchRepository</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span> ,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findAllByNameLike</span><span class="params">(String  name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/es_search_product_by_name/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">es_search_product_by_name</span><span class="params">(@PathVariable(name = <span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">    List&lt;Product&gt; allByNameLike = productRepository.findAllByNameLike(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(allByNameLike);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聊天模块"><a href="#聊天模块" class="headerlink" title="聊天模块"></a>聊天模块</h3><p>聊天模块需要配置<strong>SocketIoConfig</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.bossCount&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bossCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.workCount&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.allowCustomRequests&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowCustomRequests;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.upgradeTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> upgradeTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.pingTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pingTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.pingInterval&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下配置在上面的application.yml中已经注明</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例化socketIo的服务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SocketConfig socketConfig = <span class="keyword">new</span> SocketConfig();</span><br><span class="line">        socketConfig.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">        socketConfig.setSoLinger(<span class="number">0</span>);</span><br><span class="line">        com.corundumstudio.socketio.Configuration config = <span class="keyword">new</span> com.corundumstudio.socketio.Configuration();</span><br><span class="line">        config.setSocketConfig(socketConfig);</span><br><span class="line">        <span class="comment">//线上不能使用hostname，血坑</span></span><br><span class="line"><span class="comment">//        config.setHostname(host);</span></span><br><span class="line">        config.setPort(port);</span><br><span class="line">        config.setBossThreads(bossCount);</span><br><span class="line">        config.setWorkerThreads(workCount);</span><br><span class="line">        config.setAllowCustomRequests(allowCustomRequests);</span><br><span class="line">        config.setUpgradeTimeout(upgradeTimeout);</span><br><span class="line">        config.setPingTimeout(pingTimeout);</span><br><span class="line">        config.setPingInterval(pingInterval);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不得不再提一下，聊天记录所用的类有哪些属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"com-sodse-trade-domain-ChatRecord"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRecord</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是自己发送为1，不是自己发送为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"是自己发送为1，不是自己发送为0"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer isSend;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 聊天对象id</span></span><br><span class="line"><span class="comment">     * 每当用户发送一条信息，都会写入一次数据库，其中is_send为1表示自己发的，然后同时给被接受者反向写入id但是send值为0，表示被接收。</span></span><br><span class="line"><span class="comment">     * 第二，当用户删除自己的聊天框时，使用delete把该用户id和对象的id全部满足的记录删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"聊天对象id ,每当用户发送一条信息，都会写入一次数据库，其中is_send为1表示自己发的，然后同时给被接受者反向写入id但是send值为0，表示被接收。,第二，当用户删除自己的聊天框时，使用delete把该用户id和对象的id全部满足的记录删除"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long talkerId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最为关键的方法<strong>SocketIoService</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"socketIOService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoServiceImpl</span> <span class="keyword">implements</span> <span class="title">SocketIoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存已连接的客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketIOClient&gt; clientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * socketIo的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SocketIOServer socketIOServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：当前的service被初始化的时候执行以下的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoStartUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：当我们的系统停止的时候关闭我们的socketIo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoStop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听客户端连接</span></span><br><span class="line">        socketIOServer.addConnectListener(client -&gt; &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此处实现我们的socket的连接的用户的逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String loginUser = getParamsByClient(client).get(<span class="string">"loginUser"</span>).get(<span class="number">0</span>);</span><br><span class="line">            clientMap.put(loginUser, client);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听客户端断开连接</span></span><br><span class="line">        socketIOServer.addDisconnectListener(client -&gt; &#123;</span><br><span class="line">            String loginUser = getParamsByClient(client).get(<span class="string">"loginUser"</span>).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (loginUser != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(loginUser)) &#123;</span><br><span class="line">                clientMap.remove(loginUser);</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理自定义的事件，与连接监听类似</span></span><br><span class="line">        socketIOServer.addEventListener(PUSH_EVENT, PushMessage<span class="class">.<span class="keyword">class</span>, (<span class="title">client</span>, <span class="title">data</span>, <span class="title">ackSender</span>) -&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// TODO do something</span></span><br><span class="line">        &#125;);</span><br><span class="line">        socketIOServer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socketIOServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            socketIOServer.stop();</span><br><span class="line">            socketIOServer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：发送消息到前端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushMessage 发送消息的实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMessageToUser</span><span class="params">(PushMessage pushMessage)</span> </span>&#123;</span><br><span class="line">        clientMap.get(pushMessage.getLoginUser()).sendEvent(PUSH_EVENT, pushMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法为获取client连接中的参数，可根据需求更改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; getParamsByClient(SocketIOClient client) &#123;</span><br><span class="line">        <span class="comment">// 从请求的连接中拿出参数</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = client.getHandshakeData().getUrlParams();</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最为关键的语句我认为应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketIOClient&gt; clientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>通过建立一个<strong>ConcurrentHashMap</strong>，socket能够检测用户是否在线，在线就将用户put进ConcurrentHashMap，不在线就将其移除，若被发送消息的用户在线时，socket就会将这个消息通过ConcurrentHashMap中获得的用户信息来发送给相应的用户，这个特点在于这是后端主动发起消息给前端的，也是我在考虑到了聊天消息是怎么产生的时候，所了解的。</p><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>之前实现过一个前后端耦合的商城，那里的Security配置都比较简单，而这里用的是前后端分离的vue和springboot结合，两者甚至都不在同一个端口，所以这里的security配置也有了很大的改观，并且利用了jwt来作为两个端口的认证凭证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( AuthenticationManagerBuilder auth )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService( myUserDetailsService ).passwordEncoder( <span class="keyword">new</span> BCryptPasswordEncoder() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( HttpSecurity httpSecurity )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line"></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line"></span><br><span class="line">                <span class="comment">//关闭防护</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(<span class="string">"/"</span>).permitAll()<span class="comment">//允许/、/login的访问</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(<span class="string">"/user"</span>).hasRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/user下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin"</span>).hasRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/register"</span>).permitAll()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启跨域</span></span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line"><span class="comment">//                .exceptionHandling().accessDeniedPage("/accessDenied")</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用的是：<strong>auth.userDetailsService( myUserDetailsService ).passwordEncoder( new BCryptPasswordEncoder() );</strong>也就是myUserDetailsService所继承的UserDetails通过重写方法来进行的密码认证。</p><p>在登录阶段，使用的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServiceImpl</span> <span class="keyword">implements</span> <span class="title">AuthService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">( String username, String password )</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken upToken = <span class="keyword">new</span> UsernamePasswordAuthenticationToken( username, password );</span><br><span class="line">        <span class="keyword">final</span> Authentication authentication = authenticationManager.authenticate(upToken);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        <span class="keyword">final</span> UserDetails userDetails = userDetailsService.loadUserByUsername( username );</span><br><span class="line">        <span class="keyword">final</span> String token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">register</span><span class="params">( User userToAdd )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String username = userToAdd.getUsername();</span><br><span class="line">        <span class="keyword">if</span>( !userService.findByUsername(username).isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当用户不存在时</span></span><br><span class="line">        userToAdd=qq_register(userToAdd);</span><br><span class="line">        <span class="comment">//qq注册的处理</span></span><br><span class="line">        BCryptPasswordEncoder encoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        <span class="keyword">final</span> String rawPassword = userToAdd.getPassword();</span><br><span class="line">        userToAdd.setPassword( encoder.encode(rawPassword) );</span><br><span class="line">        <span class="keyword">return</span> userService.insert(userToAdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>jwtTokenUtil.generateToken(userDetails)</strong>，来对Security内置的UserDetails生成JWT</p><p>这里还有一个JWT的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span> <span class="params">( HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String authHeader = request.getHeader( Const.HEADER_STRING );</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith( Const.TOKEN_PREFIX )) &#123;</span><br><span class="line">            <span class="keyword">final</span> String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                        UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                                userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                        authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                                request));</span><br><span class="line">                        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这拦截器首先在<strong>WebSecurityConfig</strong>中被定义了，Security就会使用这个拦截器来作为<strong>authenticationTokenFilter</strong>的认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>在这一模块仅仅使用了eureka和ribbon，eureka作为注册中心，而ribbon作为负载均衡，当然，后续可以使用feign来进行负载均衡。并且还可在多模块的时候再继续使用Hystrix来实现服务熔断，以及和zipkin来实现分布式的链路追踪。</p><p>新建一个工程，配置eureka-server,并且在application.yml文件中配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">eureka_server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">      <span class="attr">hostname:</span> <span class="string">eureka_server_8761</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">service-url:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>同样的在原来的主体工程中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#注册服务的时候使用ip</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">service-url:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>就已经实现了注册中心，然后就是负载均衡：</p><p>在主体工程中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启发现服务功能</span></span><br></pre></td></tr></table></figure><p>并且添加RestTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span><span class="comment">//使用负载均衡机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而controller中注入RestTemplate来实现负载均衡。</p><p>后续暂无。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目–SpringBoot-Vue交易平台&quot;&gt;&lt;a href=&quot;#项目–SpringBoot-Vue交易平台&quot; class=&quot;headerlink&quot; title=&quot;项目–SpringBoot+Vue交易平台&quot;&gt;&lt;/a&gt;项目–SpringBoot+Vue交易平台&lt;/</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Docker/"/>
    
    <category term="MySQL" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/MySQL/"/>
    
    <category term="MyBatis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/MyBatis/"/>
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="ElasticSearch" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/ElasticSearch/"/>
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
    <category term="JWT" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/JWT/"/>
    
    <category term="七牛云" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
    <category term="项目" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
    <category term="Element—ui" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Element%E2%80%94ui/"/>
    
    <category term="SpringSecurity" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringSecurity/"/>
    
    <category term="REST" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker搭建Redis集群</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/02/01/redis5/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/02/01/redis5/</id>
    <published>2021-02-01T09:56:45.000Z</published>
    <updated>2022-05-09T14:21:25.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Docker搭建Redis集群"><a href="#使用Docker搭建Redis集群" class="headerlink" title="使用Docker搭建Redis集群"></a>使用Docker搭建Redis集群</h2><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先需要使用docker下载安装好redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5.0.2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span> 到 /root/workspace/</span></span><br><span class="line">mkdir -p  /docker/redis-node01/data</span><br><span class="line">mkdir -p  /docker/redis-node02/data</span><br><span class="line">mkdir -p  /docker/redis-node03/data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署Redis集群，该集群有3个节点 </span></span><br><span class="line">docker create --name redis-node01 --privileged=true -v /root/workspace/docker/redis-node01/data:/data -p 6379:6379 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-01.conf --port 6379</span><br><span class="line"></span><br><span class="line">docker create --name redis-node02 --privileged=true -v /root/workspace/docker/redis-node02/data:/data -p 6380:6380 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-02.conf --port 6380</span><br><span class="line"></span><br><span class="line">docker create --name redis-node03 --privileged=true -v /root/workspace/docker/redis-node03/data:/data -p 6381:6381 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-03.conf --port 6381</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span></span><br><span class="line">docker start redis-node01 redis-node02 redis-node03</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/1.png" alt="图"></p><p>启动完容器后查看容器IP,这一步极为关键</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器ip</span></span><br><span class="line">docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' redis-node01 redis-node02 redis-node03</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/2.png" alt="图"></p><p>接着为第一个节点搭建集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入redis-node01容器进行操作</span></span><br><span class="line">docker exec -it redis-node01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建redis集群</span></span><br><span class="line">redis-cli --cluster create 172.17.0.3:6379 172.17.0.4:6380 172.17.0.5:6381 --cluster-replicas 0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/3.png" alt="图"></p><p><strong>搭建完成，查看集群信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看集群信息</span></span><br><span class="line"> redis-cli</span><br><span class="line"> 127.0.0.1:6379&gt; cluster nodes</span><br><span class="line"> </span><br><span class="line"> 127.0.0.1:6379&gt; cluster info</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/4.png" alt="图"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>然后使用redis可视化工具测试一下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/5.png" alt="图"></p><p>为节点增加值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/6.png" alt="图"></p><p>查看值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/7.png" alt=""></p><p>搭建完成了，非常之简单</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用Docker搭建Redis集群&quot;&gt;&lt;a href=&quot;#使用Docker搭建Redis集群&quot; class=&quot;headerlink&quot; title=&quot;使用Docker搭建Redis集群&quot;&gt;&lt;/a&gt;使用Docker搭建Redis集群&lt;/h2&gt;&lt;h3 id=&quot;搭建&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>关于Elasticsearch和spring-es—Data的实战汇总</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/01/15/es1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/01/15/es1/</id>
    <published>2021-01-15T09:56:11.000Z</published>
    <updated>2021-04-26T17:01:58.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Elasticsearch和spring-es—Data的实战汇总"><a href="#关于Elasticsearch和spring-es—Data的实战汇总" class="headerlink" title="关于Elasticsearch和spring-es—Data的实战汇总"></a>关于Elasticsearch和spring-es—Data的实战汇总</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Elasticsearch是一个搜索的服务器，可以抽象为类似数据库的一样的东西。但是它本身的作用并不抽象，很大的业务作用都与数据库有着很大的重合。原理是倒排索引，这篇文章就不细说了</p><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>比如说，在我们需要使用数据库进行搜索的时候，直接模糊查询就好了 <strong>select id from item where itemName like %xxx%</strong> 但是这样的查询并不完美，比如我要找电子产品，我输入手机，那么和产品名称为手机的都会<strong>严格</strong>的被查询回来，可是这样就无法找到类似于：智能机，老人机，这样的称呼，这样很明显是不可学的，那我们是将手机再拆分为两个SQL进行查找吗？也许这样可行，但是对于手这个单词的查找可能会找到手套之类的物品，而这样已经违背的我们的初衷，明显，仅仅在数据库使用like是不明智的选择</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p><strong>性能问题</strong>。我们在进行数据库查找的时候，更多的是这样：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/uChmeeX1Fpyfns636FFuBpwcrBDBZFK9jZ5zYIZxgrD9aibzjejjMaRIXzRnnnIO3tk5I7d2UbdjVN0wCPMyZgQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt=""></p><p>这种like或者where的一行一行的查找，在对于海量的数据的时候，性能会变得非常的差劲，以致于能影响我们数据库的正常使用，<strong>使用了Elasticsearch之后，数据会在ES中有备份，而这样的查找就变成了</strong>：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/uChmeeX1Fpyfns636FFuBpwcrBDBZFK9hY8IYo9qrQe7N2hficOxvN8pWON1zeON6V3sH6zib6pm9SdxzFfmg5UA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt=""></p><p>这正是Elasticsearch的特性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。</p><p>对比关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">索引（indices）---------------------------------Databases 数据库</span><br><span class="line"></span><br><span class="line">  类型（type）----------------------------------Table 数据表</span><br><span class="line"></span><br><span class="line">     文档（Document）---------------------------Row 行</span><br><span class="line"></span><br><span class="line">   字段（Field）---------------------------Columns 列</span><br></pre></td></tr></table></figure><p>详细说明：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>索引库（indices)</td><td>indices是index的复数，代表许多的索引，</td></tr><tr><td>类型（type）</td><td>类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念</td></tr><tr><td>文档（document）</td><td>存入索引库原始的数据。比如每一条商品信息，就是一个文档</td></tr><tr><td>字段（field）</td><td>文档中的属性</td></tr><tr><td>映射配置（mappings）</td><td>字段的数据类型、属性、是否索引、是否存储等特性</td></tr></tbody></table><p>另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的：</p><ul><li>索引集（Indices，index的复数）：逻辑上的完整索引 collection1</li><li>分片（shard）：数据拆分后的各个部分</li><li>副本（replica）：每个分片的复制</li></ul><p>要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>安装好了可以直接使用你的localhost地址，加上端口访问，</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/</span></span><br></pre></td></tr></table></figure><p>首页会出现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: "c48f8b6d6494",</span><br><span class="line">    cluster_name: "docker-cluster",</span><br><span class="line">    cluster_uuid: "zJTUdR71Qya-vCLde_kaiQ",</span><br><span class="line">    version: &#123;</span><br><span class="line">    number: "7.6.2",</span><br><span class="line">    build_flavor: "default",</span><br><span class="line">    build_type: "docker",</span><br><span class="line">    build_hash: "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    build_date: "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    build_snapshot: false,</span><br><span class="line">    lucene_version: "8.4.0",</span><br><span class="line">    minimum_wire_compatibility_version: "6.8.0",</span><br><span class="line">    minimum_index_compatibility_version: "6.0.0-beta1"</span><br><span class="line">    &#125;,</span><br><span class="line">    tagline: "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些都是它的基本情况</p><h4 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>Elasticsearch采用Rest风格API，因此其API就是一次http请求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p>这样会展现出我们这个索引库的所有数据</p><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  /索引库名</span><br></pre></td></tr></table></figure><p>删除索引库</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>而当我们需要往Elasticsearch放入数据时，建议使用Elasticsearch—DATA 使用我们的外部API来放入我们的数据。</p><p>当然也有原生的API：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping/类型名称</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"字段名"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"类型"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="literal">true</span>，</span><br><span class="line">      <span class="string">"store"</span>: <span class="literal">true</span>，</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"分词器"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型名称：就是前面将的type的概念，类似于数据库中的不同表<br>字段名：任意填写 ，可以指定许多属性，例如：</li><li>type：类型，可以是text、long、short、date、integer、object等</li><li>index：是否索引，默认为true</li><li>store：是否存储，默认为false</li><li>analyzer：分词器，这里的<code>ik_max_word</code>即使用ik分词器</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_mapping</span><br></pre></td></tr></table></figure><p>而使用这个方法可以查看我们的各个字段的类型</p><p>官方文档中有对类型的具体阐述：</p><ul><li><p>String类型，又分两种：</p><ul><li>text：可分词，不可参与聚合</li><li>keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合</li></ul></li><li><p>Numerical：数值类型，分两类</p><ul><li>基本数据类型：long、interger、short、byte、double、float、half_float</li><li>浮点数的高精度类型：scaled_float<ul><li>需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。</li></ul></li></ul></li><li><p>Date：日期类型</p><p>elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间</p></li></ul><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>index影响字段的索引情况。</p><ul><li>true：字段会被索引，则可以用来进行搜索。默认值就是true</li><li>false：字段不会被索引，不能用来搜索</li></ul><p>index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。</p><p>但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。</p><p>在我们实体对Class进行操作的时候，可以进行手动标注</p><h5 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h5><p>通过POST请求，可以向一个已经存在的索引库中添加数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/类型名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"key"</span>:<span class="string">"value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并可以通过：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /索引库名/_search</span><br></pre></td></tr></table></figure><p>去查看我们的所有数据。</p><p>这些都是原生的操作方法，但是实际操作过程中，并不会使用这种方法去操作，在Spring中也提供了相应的data-es去操作</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"查询类型"</span>:&#123;</span><br><span class="line">            <span class="attr">"查询条件"</span>:<span class="string">"查询条件值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的query代表一个查询对象，里面可以有不同的查询属性</p><ul><li>查询类型：例如：<code>match_all</code>， <code>match</code>，<code>term</code> ， <code>range</code> 等等</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询所有</p><p>则会在返回的JSON头出现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    took: 7,</span><br><span class="line">    timed_out: false,</span><br><span class="line">    _shards: &#123;</span><br><span class="line">    total: 1,</span><br><span class="line">    successful: 1,</span><br><span class="line">    skipped: 0,</span><br><span class="line">    failed: 0</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>took：查询花费时间，单位是毫秒</li><li>time_out：是否超时</li><li>_shards：分片信息</li><li>hits：搜索结果总览对象<ul><li>total：搜索到的总条数</li><li>max_score：所有结果中文档得分的最高分</li><li>hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息<ul><li>_index：索引库</li><li>_type：文档类型</li><li>_id：文档id</li><li>_score：文档得分</li><li>_source：文档的源数据</li></ul></li></ul></li></ul><h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><p>使用：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/2.png" alt=""></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/product/_search</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"手机"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/3.png" alt="图3"></p><p><strong>match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系</strong></p><h5 id="and"><a href="#and" class="headerlink" title="and"></a>and</h5><p>某些情况下，我们需要更精确查找，我们希望这个关系变成<code>and</code>，可以这样做:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"手机"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/4.png" alt=""></p><h5 id="or和and"><a href="#or和and" class="headerlink" title="or和and"></a>or和and</h5><p>在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。</p><p>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。</p><p><code>match</code> 查询支持 <code>minimum_should_match</code> 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"最新小米手机"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。</p><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/5.png" alt="图五"></p><h4 id="多字段查询"><a href="#多字段查询" class="headerlink" title="多字段查询"></a>多字段查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"小米"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:   [ <span class="string">"name"</span>, <span class="string">"content"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="词条匹配"><a href="#词条匹配" class="headerlink" title="词条匹配"></a>词条匹配</h4><p><strong>term</strong> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些<strong>未分词</strong>的字符串</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"term"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:<span class="number">2699.00</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多词条精确匹配"><a href="#多词条精确匹配" class="headerlink" title="多词条精确匹配"></a>多词条精确匹配</h4><p>terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"terms"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:[<span class="number">2699.00</span>,<span class="number">2899.00</span>,<span class="number">3899.00</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">            <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">///////......</span></span><br></pre></td></tr></table></figure><h3 id="结果过滤"><a href="#结果过滤" class="headerlink" title="结果过滤"></a>结果过滤</h3><h4 id="直接指定字段"><a href="#直接指定字段" class="headerlink" title="直接指定字段"></a>直接指定字段</h4><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，我们可以添加_source的过滤:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"price"</span>],</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"_shards"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"hits"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: &#123;</span><br><span class="line"><span class="attr">"value"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"hits"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"price"</span>: <span class="number">5000</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"iPhone11"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定includes和excludes"><a href="#指定includes和excludes" class="headerlink" title="指定includes和excludes"></a>指定includes和excludes</h4><p>我们也可以通过：</p><ul><li>includes：来指定想要显示的字段</li><li>excludes：来指定不想要显示的字段</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"includes"</span>:[<span class="string">"content"</span>,<span class="string">"price"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">2999</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/6.png" alt=""></p><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="布尔组合"><a href="#布尔组合" class="headerlink" title="布尔组合"></a>布尔组合</h4><p><code>bool</code>把各种其它查询通过<code>must</code>（与）、<code>must_not</code>（非）、<code>should</code>（或）的方式进行组合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>:  <span class="string">"电视"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"手机"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/7.png" alt=""></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">                <span class="attr">"gte"</span>:  <span class="number">1000.0</span>,</span><br><span class="line">                <span class="attr">"lt"</span>:   <span class="number">2800.00</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询允许以下字符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">gt</td><td align="center">大于</td></tr><tr><td align="center">gte</td><td align="center">大于等于</td></tr><tr><td align="center">lt</td><td align="center">小于</td></tr><tr><td align="center">lte</td><td align="center">小于等于</td></tr></tbody></table><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>fuzzy查询是 <code>term</code> 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"appla"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>fuzziness</code>来指定允许的编辑距离:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>:<span class="string">"appla"</span>,</span><br><span class="line">            <span class="attr">"fuzziness"</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><h4 id="条件查询中进行过滤"><a href="#条件查询中进行过滤" class="headerlink" title="条件查询中进行过滤"></a><strong>条件查询中进行过滤</strong></h4><p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用<code>filter</code>方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米手机"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">2000.00</span>,<span class="attr">"lt"</span>:<span class="number">3800.00</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无查询条件，直接过滤"><a href="#无查询条件，直接过滤" class="headerlink" title="无查询条件，直接过滤"></a><strong>无查询条件，直接过滤</strong></h4><p>如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用<code>constant_score</code>取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">             <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">2000.00</span>,<span class="attr">"lt"</span>:<span class="number">3000.00</span>&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="单字段排序"><a href="#单字段排序" class="headerlink" title="单字段排序"></a>单字段排序</h4><p><code>sort</code> 可以让我们按照不同的字段进行排序，并且通过<code>order</code>指定排序的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小米手机"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"price"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><p>假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米手机"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">200000</span>,<span class="attr">"lt"</span>:<span class="number">300000</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">      &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"_score"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合aggregations"><a href="#聚合aggregations" class="headerlink" title="聚合aggregations"></a>聚合aggregations</h2><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫<code>桶</code>，一个叫<code>度量</code>：</p><blockquote><p><strong>桶（bucket）</strong></p></blockquote><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个<code>桶</code>，例如我们根据国籍对人划分，可以得到<code>中国桶</code>、<code>英国桶</code>，<code>日本桶</code>……或者我们按照年龄段对人进行划分：010,1020,2030,3040等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li><li>……</li></ul><p>bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><blockquote><p><strong>度量（metrics）</strong></p></blockquote><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为<code>度量</code></p><p>比较常用的一些度量聚合方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li><li>……</li></ul><h3 id="聚合为桶"><a href="#聚合为桶" class="headerlink" title="聚合为桶"></a>聚合为桶</h3><p>这里我使用了产品的category来分类，聚合为不同的桶：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"size"</span>:<span class="number">0</span>,<span class="attr">"aggs"</span>:&#123;<span class="attr">"popular_category"</span>:&#123;<span class="attr">"terms"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"category"</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率</li><li>aggs：声明这是一个聚合查询，是aggregations的缩写<ul><li>popular_category：给这次聚合起一个名字，任意。<ul><li>terms：划分桶的方式，这里是根据词条划分<ul><li>field：划分桶的字段</li></ul></li></ul></li></ul></li></ul><p>但是，这里我出现了一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata&#x3D;true on [interests] in order to load field data by uninverting the inverted index. Note that this can use significant memory.</span><br></pre></td></tr></table></figure><p>大意就是必须把我们的属性设置为：set fielddata=true。</p><p>这里时候我返回idea，使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Field</span>(type = FieldType.Text,fielddata = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>将字段变为fielddata = true，可是这样一样出现这样的错误，这是为什么呢？</p><h5 id="紧急错误"><a href="#紧急错误" class="headerlink" title="紧急错误"></a>紧急错误</h5><p>之后我通过</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/_mapping</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/0.png" alt=""></p><p>发现了这个错误的原因，原来是这个@field注解并没有生效，所以属性也没有生效。</p><p>之后在网上搜索各个文章，发现很多的做法都是使用外置一个json，也有一部分是用createindex+putindex。</p><p>使用json明显不是官方的做法，简直越来越复杂，而createindex和putindex一起使用也不正确，后来看了看官方文档，标注这两个方法都被弃用了，而且createindex其实已经集成到repository里面自动产生了，很迷惑。</p><p>但是在多次调试的情况下，我获得了两种答案：</p><h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>先使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearchRestTemplate.putMapping(Product<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>将mapping配置放入es连接中，再使用saveALL就行了</p><p>二是升级版本，把springboot升级到2.4.0</p><p>之后便是再次尝试：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/8.png" alt="图"></p><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>popular_category：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的category字段值都会形成一个桶<ul><li>key：这个桶对应的category字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul><h3 id="桶内度量"><a href="#桶内度量" class="headerlink" title="桶内度量"></a>桶内度量</h3><p>我们需要告诉Elasticsearch<code>使用哪个字段</code>，<code>使用何种度量方式</code>进行运算，这些信息要嵌套在<code>桶</code>内，<code>度量</code>的运算会基于<code>桶</code>内的文档进行</p><p>现在，我们为刚刚的聚合结果添加 求价格平均值的度量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_category"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"category"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见<code>度量</code>也是一个聚合</li><li>avg_price：聚合的名称</li><li>avg：度量的类型，这里是求平均值</li><li>field：度量运算的字段</li></ul><p>结果如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/9.png" alt=""></p><h3 id="桶内嵌套桶"><a href="#桶内嵌套桶" class="headerlink" title="桶内嵌套桶"></a>桶内嵌套桶</h3><p>刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_category"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"category"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"maker"</span>:&#123;</span><br><span class="line">                    <span class="attr">"terms"</span>:&#123;</span><br><span class="line">                        <span class="attr">"field"</span>:<span class="string">"brand"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原来的color桶和avg计算我们不变</li><li>maker：在嵌套的aggs下新添一个桶，叫做maker</li><li>terms：桶的划分类型依然是词条</li><li>filed：这里根据make字段进行划分</li></ul><h3 id="划分桶的其它方式"><a href="#划分桶的其它方式" class="headerlink" title="划分桶的其它方式"></a>划分桶的其它方式</h3><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li></ul><h4 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h4><p>histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。</p><p>举例：</p><p>比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的：</p><p>0，200，400，600，…</p><p>上面列出的是每个阶梯的key，也是区间的启点。</p><p>如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket_key = Math.floor((value - offset) / interval) * interval + offset</span><br></pre></td></tr></table></figure><p>value：就是当前数据的值，本例中是450</p><p>offset：起始偏移量，默认为0</p><p>interval：阶梯间隔，比如200</p><p>因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"price"</span>:&#123;</span><br><span class="line">      <span class="attr">"histogram"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="number">1000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图所示：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/10.png" alt=""></p><p>同样还可以指定： “min_doc_count”: 1 去表达，只有存在最小区间的才展示。</p><h2 id="spring-boot-starter-data-elasticsearch"><a href="#spring-boot-starter-data-elasticsearch" class="headerlink" title="spring-boot-starter-data-elasticsearch"></a>spring-boot-starter-data-elasticsearch</h2><p>这里使用的SpringBoot版本是2.3.7。spring-boot-starter-data-elasticsearch版本为2.4.2、</p><p>elasticsearch版本为7.6.2</p><p>首先导入pom文件，然后，新版本的elasticsearch建议使用Configuration器配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientConfiguration configuration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">"192.168.78.128:9200"</span>)</span><br><span class="line"><span class="comment">//                .connectedTo("localhost:9200")</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//.withConnectTimeout(Duration.ofSeconds(5))</span></span><br><span class="line">                <span class="comment">//.withSocketTimeout(Duration.ofSeconds(3))</span></span><br><span class="line">                <span class="comment">//.useSsl()</span></span><br><span class="line">                <span class="comment">//.withDefaultHeaders(defaultHeaders)</span></span><br><span class="line">                <span class="comment">//.withBasicAuth(username, password)</span></span><br><span class="line">                <span class="comment">// ... other options</span></span><br><span class="line">                .build();</span><br><span class="line">        RestHighLevelClient client = RestClients.create(configuration).rest();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"product"</span>, shards = <span class="number">1</span>, replicas = <span class="number">0</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"com-sodse-trade-domain-Product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = ToStringSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ApiModelProperty</span>(<span class="title">value</span> </span>= <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword, analyzer = "ik_max_word")</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>,type = FieldType.Text)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String mainImg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会有一个品牌表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"会有一个品牌表"</span>)</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会有一个分类表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text,fielddata = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"会有一个分类表"</span>)</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当库存为0时则无法购买</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"当库存为0时则无法购买"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为真</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"判断是否为真"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳在创建新商品时产生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>,type = FieldType.Long)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"时间戳在创建新商品时产生"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如手机：颜色，衣服：颜色。。。以逗号隔开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"如手机：颜色，衣服：颜色。。。以逗号隔开"</span>)</span><br><span class="line">    <span class="keyword">private</span> String properties1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如手机规格：8+128gb，衣服 S,M,L,XL,XXL 以逗号隔开。若无第二规格，则在第一个开头显示 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"如手机规格：8+128gb，衣服 S,M,L,XL,XXL 以逗号隔开。若无第二规格，则在第一个开头显示 无"</span>)</span><br><span class="line">    <span class="keyword">private</span> String properties2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快递费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"快递费"</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal courierFees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属于哪一个商家</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"属于哪一个商家"</span>)</span><br><span class="line">    <span class="keyword">private</span> String merchant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p> @ApiModelProperty和ApiModel是我自己的swagger依赖，和Elasticsearch无关。</p><p>Spring Data通过注解来声明字段的映射属性，有下面的三个注解：</p><ul><li>@Document作用在类，标记实体类为文档对象，一般有四个属性<ul><li>indexName：对应索引库名称</li><li>type：对应在索引库中的类型</li><li>shards：分片数量，默认5</li><li>replicas：副本数量，默认1</li></ul></li><li>@Id` 作用在成员变量，标记一个字段作为id主键</li><li>@Field作用在成员变量，标记为文档的字段，并指定字段映射属性：<ul><li>type：字段类型，取值是枚举：FieldType</li><li>index：是否索引，布尔类型，默认是true</li><li>store：是否存储，布尔类型，默认是false</li><li>analyzer：分词器名称：ik_max_word</li></ul></li></ul><p>值得注意的是：@Document的type在新版本被弃用了。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>这里通过继承ElasticsearchRepository来像JPA一样使用它的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span> ,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findAllByNameLike</span><span class="params">(String  name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看常规的操作</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">product_es_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product p=<span class="keyword">new</span> Product();</span><br><span class="line">        p.setId(<span class="number">2L</span>);</span><br><span class="line">        p.setName(<span class="string">"手机"</span>);</span><br><span class="line">        p.setPrice(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        p.setContent(<span class="string">"这是一件物品"</span>);</span><br><span class="line"><span class="comment">//        productRepository.index(p);</span></span><br><span class="line">        productRepository.save(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>productRepository.index() 是 过去弃用的方法，现今使用productRepository.save 去保存一个Object。</p><p>更新和保存同样都是使用save，它会根据主键是否相同来判断是更新还是保存新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">product_es_test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    productRepository.saveAll(productService.find());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>productRepository.saveAll 保存一个<strong>List<Object></strong> 数据</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">es_Delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    productRepository.deleteAll();<span class="comment">//或者是deleteById(1L);</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">product_es_test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Product&gt; products = productRepository.findAllByNameLike(<span class="string">"手机"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Product p:products) &#123;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过像JPA一样自定义方法来进行增删改查操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">"price"</span>));</span><br></pre></td></tr></table></figure><p>还可以选择降序排序等等</p><h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>Spring Data 的另一个强大功能，是根据方法名称自动实现功能。<br>比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。<br>当然，方法名称要符合一定的约定：</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>Elasticsearch Query String</th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByNameAndPrice</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Or</code></td><td><code>findByNameOrPrice</code></td><td><code>{&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Is</code></td><td><code>findByName</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Not</code></td><td><code>findByNameNot</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Between</code></td><td><code>findByPriceBetween</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByPriceLessThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByPriceGreaterThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Before</code></td><td><code>findByPriceBefore</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>After</code></td><td><code>findByPriceAfter</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Like</code></td><td><code>findByNameLike</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByNameStartingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>EndingWith</code></td><td><code>findByNameEndingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>Contains/Containing</code></td><td><code>findByNameContaining</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>In</code></td><td><code>findByNameIn(Collectionnames)</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}}</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByNameNotIn(Collectionnames)</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}}</code></td></tr><tr><td><code>Near</code></td><td><code>findByStoreNear</code></td><td><code>Not Supported Yet !</code></td></tr><tr><td><code>True</code></td><td><code>findByAvailableTrue</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr><tr><td><code>False</code></td><td><code>findByAvailableFalse</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}}</code></td></tr><tr><td><code>OrderBy</code></td><td><code>findByAvailableTrueOrderByNameDesc</code></td><td><code>{&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr></tbody></table><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><h4 id="QueryBuilders"><a href="#QueryBuilders" class="headerlink" title="QueryBuilders"></a>QueryBuilders</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBaseQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 词条查询</span></span><br><span class="line">    MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"小米"</span>);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    Iterable&lt;Product&gt; items = productRepository.search(queryBuilder);</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/11.png" alt=""></p><h4 id="NativeSearchQueryBuilder"><a href="#NativeSearchQueryBuilder" class="headerlink" title="NativeSearchQueryBuilder"></a>NativeSearchQueryBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"手机"</span>));</span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体</p><p><code>Page</code>：默认是分页查询，因此返回的是一个分页的结果对象，包含属性：</p><ul><li>totalElements：总条数</li><li>totalPages：总页数</li><li>Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据</li></ul><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/12.png" alt=""></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"手机"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分页参数</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置分页参数</span></span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    <span class="comment">// 每页大小</span></span><br><span class="line">    System.out.println(items.getSize());</span><br><span class="line">    <span class="comment">// 当前页</span></span><br><span class="line">    System.out.println(items.getNumber());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/13.png" alt=""></p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 构建查询条件</span></span><br><span class="line">       NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">       <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">       queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"书籍"</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 排序</span></span><br><span class="line">       queryBuilder.withSort(SortBuilders.fieldSort(<span class="string">"price"</span>).order(SortOrder.DESC));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">       Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">       <span class="comment">// 打印总条数</span></span><br><span class="line">       System.out.println(items.getTotalElements());</span><br><span class="line">       items.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/14.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Elasticsearch和spring-es—Data的实战汇总&quot;&gt;&lt;a href=&quot;#关于Elasticsearch和spring-es—Data的实战汇总&quot; class=&quot;headerlink&quot; title=&quot;关于Elasticsearch和spring</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="ElasticSearch" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot多环境适配</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring18/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring18/</id>
    <published>2021-01-05T10:16:54.000Z</published>
    <updated>2021-01-18T10:34:21.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Profile功能"><a href="#Profile功能" class="headerlink" title="Profile功能"></a>Profile功能</h1><p>为了方便多环境适配，springboot简化了profile功能。</p><h3 id="1、application-profile功能"><a href="#1、application-profile功能" class="headerlink" title="1、application-profile功能"></a>1、application-profile功能</h3><ul><li><p>默认配置文件  application.yaml；任何时候都会加载</p></li><li><p>指定环境配置文件  application-{env}.yaml</p></li><li><p>激活指定环境</p></li><li><ul><li>配置文件激活</li><li>命令行激活：java -jar xxx.jar –<strong>spring.profiles.active=prod  –person.name=haha</strong></li></ul></li><li><ul><li><ul><li><strong>修改配置文件的任意值，命令行优先</strong></li></ul></li></ul></li><li><p>默认配置与环境配置同时生效</p></li><li><p>同名配置项，profile配置优先</p></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//比如说再有两个的情况下，</span></span><br><span class="line"><span class="string">application-myprod.yml</span></span><br><span class="line"><span class="string">application-mytest.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.profiles.active=myprod</span></span><br></pre></td></tr></table></figure><p>通过这种方式指定一个配置文件。</p><p>在应用程序启动时默认的配置文件先生效，然后再使用指定的配置文件，当两个配置文件有重复的配置的时候，指定的优先生效。</p><h3 id="2、-Profile条件装配功能"><a href="#2、-Profile条件装配功能" class="headerlink" title="2、@Profile条件装配功能"></a>2、@Profile条件装配功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(value = &#123;<span class="string">"prod"</span>,<span class="string">"default"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name:李四&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;MAVEN_HOME&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;os.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/msg"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg+<span class="string">"==&gt;"</span>+osName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的配置可以对类和返回值产生不同的影响，但一般不这么做，因为一般的项目都比较大而复杂。</p><h3 id="3、profile分组"><a href="#3、profile分组" class="headerlink" title="3、profile分组"></a>3、profile分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.group.production[0]&#x3D;proddb</span><br><span class="line">spring.profiles.group.production[1]&#x3D;prodmq</span><br><span class="line"></span><br><span class="line">使用：--spring.profiles.active&#x3D;production  激活</span><br></pre></td></tr></table></figure><p>当我们指定的指定一个的配置文件的时候，属于它的组也会依次生效</p><h3 id="4、外部化配置"><a href="#4、外部化配置" class="headerlink" title="4、外部化配置"></a>4、外部化配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><ol><li>默认属性（通过设置指定<code>SpringApplication.setDefaultProperties</code>）。</li><li><a href="https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code></a><code>@Configuration</code>类上的注释。请注意，<code>Environment</code>在刷新应用程序上下文之前，不会将此类属性源添加到中。现在配置某些属性（如<code>logging.*</code>和<code>spring.main.*</code>在刷新开始之前先读取）为时已晚。</li><li><strong>配置数据（例如**</strong>文件）<strong>**<code>application.properties</code></strong></li><li>一<code>RandomValuePropertySource</code>，只有在拥有性能<code>random.*</code>。</li><li>操作系统环境变量。</li><li>Java系统属性（<code>System.getProperties()</code>）。</li><li>的JNDI属性<code>java:comp/env</code>。</li><li><code>ServletContext</code> 初始化参数。</li><li><code>ServletConfig</code> 初始化参数。</li><li>来自的属性<code>SPRING_APPLICATION_JSON</code>（嵌入在环境变量或系统属性中的嵌入式JSON）。</li><li>命令行参数。</li><li><code>properties</code>测试中的属性。可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">用于测试应用程序的特定部分</a><a href="https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener"><code>@SpringBootTest</code></a>的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试注释</a>和<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">注释</a>。</li><li><a href="https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener"><code>@TestPropertySource</code></a> 测试中的注释。</li><li><code>$HOME/.config/spring-boot</code>当devtools处于活动状态时，目录中的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools-globalsettings" target="_blank" rel="noopener">Devtools全局设置属性</a>。</li></ol><h3 id="5、外部配置源"><a href="#5、外部配置源" class="headerlink" title="5、外部配置源"></a>5、外部配置源</h3><p>常用：<strong>Java属性文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>、<strong>命令行参数</strong>；</p><h3 id="6、配置文件查找位置"><a href="#6、配置文件查找位置" class="headerlink" title="6、配置文件查找位置"></a>6、配置文件查找位置</h3><p>(1) classpath 根路径</p><p>(2) classpath 根路径下config目录</p><p>(3) jar包当前目录</p><p>(4) jar包当前目录的config目录</p><p>(5) /config子目录的直接子目录</p><h3 id="7、配置文件加载顺序："><a href="#7、配置文件加载顺序：" class="headerlink" title="7、配置文件加载顺序："></a>7、配置文件加载顺序：</h3><ol><li>　当前jar包内部的application.properties和application.yml</li><li>　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li><li>　引用的外部jar包的application.properties和application.yml</li><li>　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li></ol><p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Profile功能&quot;&gt;&lt;a href=&quot;#Profile功能&quot; class=&quot;headerlink&quot; title=&quot;Profile功能&quot;&gt;&lt;/a&gt;Profile功能&lt;/h1&gt;&lt;p&gt;为了方便多环境适配，springboot简化了profile功能。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="Profile" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Profile/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity+JWT结合Vue在前后端分离下的权限控制</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring17/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring17/</id>
    <published>2021-01-05T08:00:29.000Z</published>
    <updated>2021-02-06T07:41:26.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringSecurity-JWT结合Vue在前后端分离下的权限控制"><a href="#SpringSecurity-JWT结合Vue在前后端分离下的权限控制" class="headerlink" title="SpringSecurity+JWT结合Vue在前后端分离下的权限控制"></a>SpringSecurity+JWT结合Vue在前后端分离下的权限控制</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>再构建一个前后端分离项目的时候。我们之前在前后端耦合情况下使用的Security配置会和前后端分离的情况下有一些较大的区别。</p><p>就比如在前后端耦合的情况下，所有页面。都是由后端来处理，这样的权限控制较为简易。而且不会出现跨域的问题。按目前结合vue进行前后端分离是当前技术的主流。很多公司和业务都是按照着这个的标准进行的，那么以往的权限控制就不能完全适用于现在了。</p><p>这一段设计经过了我的一些思考。当我在初步的使用vue的时候。我还按照原来的配置去配置security。结果发现这样的权限控制并没有任何效果。起初以为是跨域问题，结果在解决了跨域问题之后，才真正明白了，他们启动的并不是同一个端口。那么我在后端配置的权限控制和前端不同端口的情况下怎么会生效呢？</p><p>于是在查阅了网上的各种资料之后，我找到了一种方法，使用jwt配合security权限控制来进行前后端之间的交流，这样即使是在不同端口的情况下也能实现权限的控制。并且可以将jwt所认证的信息存储在当地的cookie当中。即使用户退出的浏览器在打开浏览器时也不用再次进行登录去认证。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先必不可说的肯定是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- jwt --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--   spring security     权限管理依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 因为在进行前后端分离时，需要用到一个自定义的类型去进行交互。当然这是基本常识，在此也不多讲述：</p><p>这是一个用于交互的实体,前后端用这个类来进行交互。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">// 200是正常，非200表示异常</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">succ</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> succ(<span class="number">200</span>, <span class="string">"操作成功"</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">succ</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        Result r = <span class="keyword">new</span> Result();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fail(<span class="number">400</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(String msg, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fail(<span class="number">400</span>, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        Result r = <span class="keyword">new</span> Result();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义一个用户提交登陆信息使用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"昵称不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>后端需要解决一些跨域问题,这是一个跨域解决方案的一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始配置我们的security:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService; <span class="comment">//自行编写的持久层方法，这里我用的是mybatis </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">        <span class="comment">//需要自定义一个JWT拦截器，下面会提及</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( AuthenticationManagerBuilder auth )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService( myUserDetailsService ).passwordEncoder( <span class="keyword">new</span> BCryptPasswordEncoder() );</span><br><span class="line">    &#125;<span class="comment">//将我们的持久层方法注入到这个security里面，之前的文章说过了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( HttpSecurity httpSecurity )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity.csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/register"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.PUT).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.DELETE).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.GET).authenticated()</span><br><span class="line">                .and()<span class="comment">// 开启跨域</span></span><br><span class="line">                .cors()</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置拦截</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//自定义拦截方法</span></span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyUserDetailsService:这个不用说，就是我们自己定义的获取数据库用户信息的方法。接着使用: <strong>auth.userDetailsService( myUserDetailsService ).passwordEncoder( new BCryptPasswordEncoder() );</strong> 将他住到我们的security权限认证当中。</li><li>JwtTokenFilter：这是我们的拦截器。我们需要对验证的每一个Token.进行验证，判断它的过期时间等等。我们需要把这个拦截器一块注入到security当中。源码在下方：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里看起来复杂，实际就是获取从前端返回的信息，比如username，然后进行数据库查找，然后进行将找到的用户进行加密形成一个Token，将一个信息传递回security</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span> <span class="params">( HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String authHeader = request.getHeader( Const.HEADER_STRING );</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith( Const.TOKEN_PREFIX )) &#123;</span><br><span class="line">            <span class="keyword">final</span> String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                        UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                                userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                        authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                                request));</span><br><span class="line">                        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着这一个认证拦截器又用到了JWT的工具类：这一个工具，通常用于生成JWT，和获取各种JWT的信息，其中用到了我们spring中的依赖注的JWT源码，但我们还需要根据他所给的方法和API，进行自己的改写和判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jwt的各种方法，写法比较固定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5625635588908941275L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME = <span class="string">"sub"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED = <span class="string">"created"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreatedDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date created;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            created = <span class="keyword">new</span> Date((Long) claims.get(CLAIM_KEY_CREATED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            created = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpirationDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiration;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            expiration = claims.getExpiration();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            expiration = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey( Const.SECRET )</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            claims = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Date <span class="title">generateExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis() + Const.EXPIRATION_TIME * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date expiration = getExpirationDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isCreatedBeforeLastPasswordReset</span><span class="params">(Date created, Date lastPasswordReset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (lastPasswordReset != <span class="keyword">null</span> &amp;&amp; created.before(lastPasswordReset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, Const.SECRET )</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">canTokenBeRefreshed</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String refreshedToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            refreshedToken = generateToken(claims);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            refreshedToken = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> refreshedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        User user = (User) userDetails;</span><br><span class="line">        <span class="keyword">final</span> String username = getUsernameFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">                username.equals(user.getUsername())</span><br><span class="line">                        &amp;&amp; !isTokenExpired(token)</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，这种工作大致上就完成了，总体而言并不复杂。就是把JWT和security结合在一起。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@Validated @RequestBody LoginDto loginDto, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"登录"</span>);</span><br><span class="line">    String jwt= authService.login( loginDto.getUsername(), loginDto.getPassword() );</span><br><span class="line">    User user= userService.findByUsername(loginDto.getUsername()).get(<span class="number">0</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Authorization"</span>,jwt);<span class="comment">//放置响应头中</span></span><br><span class="line">    response.setHeader(<span class="string">"Access-control-Expose-Headers"</span>,<span class="string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(MapUtil.builder()</span><br><span class="line">            .put(<span class="string">"id"</span>, user.getId())</span><br><span class="line">            .put(<span class="string">"username"</span>, user.getUsername())</span><br><span class="line">            .map());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用postman或者是vue的axios进行测试，图床崩了暂时就不搞图了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringSecurity-JWT结合Vue在前后端分离下的权限控制&quot;&gt;&lt;a href=&quot;#SpringSecurity-JWT结合Vue在前后端分离下的权限控制&quot; class=&quot;headerlink&quot; title=&quot;SpringSecurity+JWT结合Vu</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="Security" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Security/"/>
    
    <category term="JWT" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>Element-ui组件使用和一键import功能</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/07/16/vue2/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/07/16/vue2/</id>
    <published>2020-07-16T11:51:47.000Z</published>
    <updated>2021-01-18T12:20:42.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Element-ui组件使用"><a href="#Element-ui组件使用" class="headerlink" title="Element-ui组件使用"></a>Element-ui组件使用</h3><p>element-ui首先得通过npm 安装下载，</p><p>其次通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"element-ui/lib/theme-chalk/index.css"</span></span><br></pre></td></tr></table></figure><p>导入进去，</p><p>然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Element)</span><br></pre></td></tr></table></figure><p>被Vue所使用即可了。</p><p>并且通过：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/layout</span><br></pre></td></tr></table></figure><p>访问网站，直接复制在我们components文件夹下面新建的一个Vue里面，既可以使用了。</p><h3 id="一键import"><a href="#一键import" class="headerlink" title="一键import"></a>一键import</h3><p>这个在components下面建一个js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="string">'.'</span>, <span class="literal">false</span>, /\.vue$/</span><br><span class="line">   <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentName = capitalizeFirstLetter(</span><br><span class="line">    fileName.replace(<span class="regexp">/^\.\//</span>, <span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="comment">//因为得到的filename格式是: './dataList.vue', 所以这里我们去掉头和尾，只保留真正的文件名</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果组件在components下面的文件夹里面的话。js就改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">    <span class="string">'.'</span>,<span class="literal">true</span>,/\.vue$/</span><br><span class="line">    <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">233</span>,requireComponent.keys());</span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    <span class="keyword">const</span> componetConfig = requireComponent(fileName);</span><br><span class="line">    <span class="built_in">console</span>.log(componetConfig);</span><br><span class="line">    <span class="keyword">let</span> a = fileName.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    fileName = <span class="string">'.'</span> + fileName.slice(a);</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    <span class="keyword">const</span> componetName = capitalizeFirstLetter(</span><br><span class="line">        fileName.replace(<span class="regexp">/^\.\//</span>,<span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>,<span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">    Vue.component(componetName,componetConfig.default || componetConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后在main.js进行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx.js</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Element-ui组件使用&quot;&gt;&lt;a href=&quot;#Element-ui组件使用&quot; class=&quot;headerlink&quot; title=&quot;Element-ui组件使用&quot;&gt;&lt;/a&gt;Element-ui组件使用&lt;/h3&gt;&lt;p&gt;element-ui首先得通过npm 安装下</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>利用Kurento实现一对一通信</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/20/Kurento1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/20/Kurento1/</id>
    <published>2020-06-20T12:44:01.000Z</published>
    <updated>2022-05-09T14:21:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用Kurento实现一对一通信"><a href="#利用Kurento实现一对一通信" class="headerlink" title="利用Kurento实现一对一通信"></a>利用Kurento实现一对一通信</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自己的计划是，毕业设计做一个类似于腾讯会议的视频流通信服务，发现想要实现起来并不容易，不过自己也还是慢慢的在摸索，最后找到了一个叫做Kurento的视频流服务器，打算使用这个服务器去开发程序。</p><h3 id="配置与实现"><a href="#配置与实现" class="headerlink" title="配置与实现"></a>配置与实现</h3><p>想要配置这个东西可是非常非常的坑啊，本来自己是去官网找到了一些可以直接运行的例子，然后在本地直接start，完全没有问题，然后拿到虚拟机试一试：</p><p>当然，kurento肯定是利用docker安装的，这个dockerhub也有，这里先列出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name kms -p 8888:8888 kurento/kurento-media-server:xenial-latest</span><br></pre></td></tr></table></figure><p>发现仍然可以使用，最后拿去阿里云服务器试了试，结果就……，完全没有作用，安全组什么的都开了，我之后就觉得会不会是公网ip之类的问题，但是不知道怎么下手，之后再Stack Overflow中，看到了创建者的发言，在公网中必须有turn服务器，于是乎，我便开始了配置turn服务器之路。</p><p>由于在dockerhub没有turn服务器的镜像源，turn服务器安装这块坑就大了，网上有很多的教程，非常之乱，又要什么内网ip，什么什么md5验证，什么什么必须要在Ubuntu下运行，看的我真的是一脸懵逼，怎么可能这么复杂而且又有这么多说法呢？？</p><p>我基本都试了一次，嗯，如同预期一般，非常的不靠谱。</p><p>但最后还是找到了解决方案，在github找到了可以直接使用的dockerfile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/konoui/kurento-coturn-docker.git</span><br></pre></td></tr></table></figure><p>然后去运行它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /kurento-coturn-docker/coturn/</span><br><span class="line">//使用dockerfile,记住加点</span><br><span class="line">sudo docker build --tag coturn .</span><br><span class="line">//后台运行coturn</span><br><span class="line">sudo docker run -p 3478:3478 -p 3478:3478/udp coturn</span><br><span class="line">//别忘了开完全组</span><br></pre></td></tr></table></figure><p>然后是网上博客都有讲到的有效性测试，这个大家自己看吧。</p><p>然后需要编辑Kurento：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入镜像</span></span><br><span class="line">docker exec -it kms /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta">#</span><span class="bash">进入配置文件夹</span></span><br><span class="line">cd /etc/kurento/modules/kurento/</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑配置文件</span></span><br><span class="line">vim WebRtcEndpoint.conf.ini</span><br></pre></td></tr></table></figure><p>配置打洞服务器，配置文件应该改成这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stunServerAddress=you_url</span><br><span class="line">stunServerPort=you_port</span><br><span class="line">turnURL=kurento:kurento@you_url?transport=tcp</span><br></pre></td></tr></table></figure><p>一般情况下，坑到这里应该也就完了，但是你可以在试试，还是跑不通！！！！</p><p>这又是为什么呢？？？？</p><p>最后我想了想，为什么本地配置就完全没问题呢？就算连接公网需要turn，但是代码层面却没有任何提示啊，这不应该，所以，接下来就是最坑的了，你甚至需要去打开源代码，修改并连接turn服务器！！！！</p><p>我敢说，绝大多数人都会和我一样，觉得这不应该，你特么本地的代码例子完全就是摆着看的嘛。</p><p>做法如下：</p><p>打开index.js</p><p>在函数function uiStart()里，增加一个叫iceservers的变量，格式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iceservers=&#123;</span><br><span class="line">   <span class="string">"iceServers"</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">         urls:<span class="string">"stun:139.198.123.138:3478"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         urls:[<span class="string">"turn:139.198.123.138:3478"</span>]</span><br><span class="line">           username:<span class="string">"kurento"</span>,</span><br><span class="line">           credential: <span class="string">"kurento"</span></span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再修改底下的options变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   localVideo: uiLocalVideo,</span><br><span class="line">   remoteVideo: uiRemoteVideo,</span><br><span class="line">   mediaConstraints: &#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">   onicecandidate: <span class="function">(<span class="params">candidate</span>) =&gt;</span> sendMessage(&#123;</span><br><span class="line">     id: <span class="string">'ADD_ICE_CANDIDATE'</span>,</span><br><span class="line">     candidate: candidate,</span><br><span class="line">   &#125;),</span><br><span class="line">     configuration: iceservers <span class="comment">//修改在这里，增加了一个configuration的key</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>暂时不写了。。。头痛</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用Kurento实现一对一通信&quot;&gt;&lt;a href=&quot;#利用Kurento实现一对一通信&quot; class=&quot;headerlink&quot; title=&quot;利用Kurento实现一对一通信&quot;&gt;&lt;/a&gt;利用Kurento实现一对一通信&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="Kurento" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Kurento/"/>
    
    <category term="turn" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/turn/"/>
    
    <category term="Docker" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>利用Nginx进行前后端分离项目部署-ruoyi</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/</id>
    <published>2020-06-12T06:21:51.000Z</published>
    <updated>2021-01-31T05:17:12.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用Nginx进行前后端分离项目部署"><a href="#利用Nginx进行前后端分离项目部署" class="headerlink" title="利用Nginx进行前后端分离项目部署"></a>利用Nginx进行前后端分离项目部署</h2><p>首先需要这个项目，利用git去仓库克隆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/y_project/RuoYi-Vue.git</span><br></pre></td></tr></table></figure><p>然后我们就获得了这个项目，你可以看到，这个项目分为：</p><ul><li>ruoyi</li><li>ruoyi-ui</li></ul><p>这两个文件夹，一个是后端，一个是前端。</p><p>根据正常的操作使用说明，我们先使用idea打开这个项目，更改一下项目的目标地址。一般都是在application.yml 文件上：</p><p>比如你可以改localhost，或者是其他的ip地址，我就改了ip地址。</p><p>当然，如果你仅仅需要部署到单个服务器上，其他的都别管，直接使用maven打包就行了。</p><p><strong>后端的打包和运行很简单，这里不多赘述了</strong></p><h3 id="开始准备"><a href="#开始准备" class="headerlink" title="开始准备"></a>开始准备</h3><p>我这里准备了三台虚拟机：</p><ol><li>192.168.78.128</li><li>192.168.78.129</li><li>192.168.78.130</li></ol><p>第二台和第三台虚拟机都是部署后端的jar包，我们准备使用Nginx进行负载均衡，这里我后端的数据库是连接前端的128的ip，因为只有同一个数据库才好进行负载均衡。</p><p>首先需要在128部署好docker，docker下安装好MySQL和Redis。</p><p>启动docker镜像，启动两个后端，紧接着我们来到前端进行部署。</p><h3 id="安装Nodejs和Nginx"><a href="#安装Nodejs和Nginx" class="headerlink" title="安装Nodejs和Nginx"></a>安装Nodejs和Nginx</h3><h4 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h4><p>我这⾥下载的是 node-v12.16.3-linux-x64.tar.xz 安装包，并将其直接放在了 root ⽬录下。</p><p>1、在 /usr/local/ 下创建 node ⽂件夹并进⼊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir node</span><br><span class="line">cd node</span><br></pre></td></tr></table></figure><p>2、将 Node 的安装包解压到 /usr/local/node 中即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost node]# tar -xJvf /root/node-v12.16.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>解压完之后， /usr/local/node ⽬录中会出现⼀个 node-v12.16.3-linux-x64 的⽬录</p><p><strong>配置NODE系统环境变量</strong></p><p>编辑 ~/.bash_profile ⽂件，在⽂件末尾追加如下信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Nodejs</span></span><br><span class="line">export PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATH</span><br></pre></td></tr></table></figure><p>刷新环境变量，使之⽣效即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p><strong>检查安装结果</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>这⾥下载的是 nginx-1.17.10.tar.gz 安装包，并将其直接放在了 root ⽬录下</p><p>1、在 /usr/local/ 下创建 nginx ⽂件夹并进⼊:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br></pre></td></tr></table></figure><p>2、将 Nginx 安装包解压到 /usr/local/nginx 中即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# tar zxvf /root/nginx-1.17.10.tar.gz -C ./</span><br></pre></td></tr></table></figure><p>解压完之后， /usr/local/nginx ⽬录中会出现⼀个 nginx-1.17.10 的⽬录</p><p><strong>预先安装额外的依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><p><strong>编译安装NGINX</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.17.10</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后，Nginx的可执⾏⽂件位置位于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p><strong>启动NGINX</strong></p><p>直接执⾏如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>如果想停⽌Nginx服务，可执⾏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p>如果修改了配置⽂件后想重新加载Nginx，可执⾏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>注意其配置⽂件位于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h3><p>把ruoyi-ui放在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/workspace/ruoyi-ui/</span><br></pre></td></tr></table></figure><p>文件夹下，并使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --unsafe-perm --registry=https:registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>–unsafe-perm：是为了更高的权限</p><p>–registry=https:registry.npm.taobao.org：拥有更快的镜像源</p><p>然后等待执行完毕。</p><p>执行完毕后，可以看到多了一个node模块。</p><p>接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>开始建立，建立完成后，可以看到多了一个dist文件夹，这表示我们基本完成了环境的构建。</p><h3 id="使用Nginx代理服务器完成部署"><a href="#使用Nginx代理服务器完成部署" class="headerlink" title="使用Nginx代理服务器完成部署"></a>使用Nginx代理服务器完成部署</h3><p>打开配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>把最上的user注释改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user  root;</span><br></pre></td></tr></table></figure><p>以此获得最大的权限。</p><p>接着，定位到：location /，并将其改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /root/workspace/ruoyiui/dist;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果页面发生了404错误，那么可以在这里修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root ...</span><br><span class="line">    index ...</span><br><span class="line">    try_files $uri $uri/ /index.html; ---解决页面刷新404问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这句话的意思是，当访问uri没有的时候 尝试访问 index.html 由于vue是单页模式，所以入口都是index.html 无论访问什么连接都由vue本身接管</strong></p><p>可以看到的是，这里的root路径，就是我们的前端路径。</p><p>启动nginx，然后我们可以打开节点：192.168.78.128</p><p>我们却发现，它出现了一点错误（暂时无图）</p><p>这个错误是地址引用错误，在验证码这个url错误，原因是正确的地址是：192.168.78.128/prod-api/xxxx</p><p>这表示，我们遗失了 prod-api 这个路径，那怎么办呢？</p><p>我们回到Nginx配置文件，添加一项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       location /prod-api/ &#123;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://192.168.78.129:8080/;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>/usr/local/nginx/sbin/nginx -s reload ，重启Nginx，便可以了。</p><p>这里的前四段是标准写法，不用太多思考，最后的一段才是真正后端地址</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>需要在任意一个位置加上upstream：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   upstream ruoyi&#123;</span><br><span class="line">server 192.168.78.129:8080 weight=5;</span><br><span class="line">server 192.168.78.130:8080 weight=3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>并且把location /prod-api/ ，改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   location /prod-api/ &#123;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://ruoyi/;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>/usr/local/nginx/sbin/nginx -s reload，重启Nginx，这样Nginx便会自动的实现负载均衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用Nginx进行前后端分离项目部署&quot;&gt;&lt;a href=&quot;#利用Nginx进行前后端分离项目部署&quot; class=&quot;headerlink&quot; title=&quot;利用Nginx进行前后端分离项目部署&quot;&gt;&lt;/a&gt;利用Nginx进行前后端分离项目部署&lt;/h2&gt;&lt;p&gt;首先需要这个</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="项目" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis（二）</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/09/redis4/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/09/redis4/</id>
    <published>2020-06-09T11:25:09.000Z</published>
    <updated>2020-06-12T13:52:47.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的数据库"><a href="#Redis的数据库" class="headerlink" title="Redis的数据库"></a>Redis的数据库</h2><h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>redis和mysql类似，redis也有自己不同的数据库。但是和mysql不一样的是，redis的数据库是自发产生的，redis会根据服务器状态，自行的确定数据库的数量。默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000421.jpg" alt=""></p><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line">redis&gt; SELECT <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line">(<span class="literal">nil</span>)</span><br><span class="line">redis[<span class="number">2</span>]&gt; SET msg<span class="string">"another world"</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line"><span class="string">"another world"</span></span><br></pre></td></tr></table></figure><h4 id="谨慎处理多数据库程序"><a href="#谨慎处理多数据库程序" class="headerlink" title="谨慎处理多数据库程序"></a>谨慎处理多数据库程序</h4><p>如果你在其他语言的客户端中执行Redis命令，并且该客户端没有像redis-cli那样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。</p><h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p>如我们执行一下命令：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; RPUSH alphabet <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line">(integer)<span class="number">3</span></span><br><span class="line">redis&gt; HSET book name <span class="string">"Redis in Action"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book author <span class="string">"Josiah L. Carlson"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book publisher <span class="string">"Manning"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后的模型就是这样：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000028.jpg" alt=""></p><h5 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h5><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">date</span> <span class="string">"2013.12.1"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000391.jpg" alt=""></p><h5 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h5><p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p><h5 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h5><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p><h5 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h5><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</p><h5 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h5><p>除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。</p><p>比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p><p>另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。</p><h5 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h5><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之内</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之后</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。</p><p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">1000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) <span class="number">997</span></span><br><span class="line">redis&gt; SET another_key another_value</span><br><span class="line">OK</span><br><span class="line">redis&gt; TIME</span><br><span class="line"><span class="number">1</span>)<span class="string">"1377333070"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"761687"</span></span><br><span class="line">redis&gt; EXPIREAT another_key <span class="number">1377333100</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL another_key</span><br><span class="line">(integer) <span class="number">10</span></span><br></pre></td></tr></table></figure><p>如果是：EXPIREAT another_key 1385877600000，这表示数据库键过期时间为1385877600000（2013年12月1日零时）。</p><h5 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h5><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li>EXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl秒。</li><li>PEXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl毫秒。</li><li>EXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li><li>PEXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p><h5 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h5><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h5 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h5><p>PERSIST命令可以移除一个键的过期时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PEXPIREAT message <span class="number">1391234400000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">13893281</span></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>ERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><h5 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h5><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT alphabet <span class="number">1385877600000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL alphabet</span><br><span class="line">(integer) <span class="number">8549007</span></span><br><span class="line">redis&gt; PTTL alphabet</span><br><span class="line">(integer) <span class="number">8549001011</span></span><br></pre></td></tr></table></figure><h5 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h5><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><p>1）检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</p><p>2）检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</p><h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><p>我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是：如果一个键过期了，那么它什么时候会被删除呢？</p><p>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p><p>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><p>例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。</p><p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。</p><p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p><p>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</p><p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p> 从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li><li>惰性删除浪费太多内存，有内存泄漏的危险。</li><li>定期删除策略是前两种策略的一种整合和折中：</li><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li><li>定期删除策略的难点是确定删除操作执行的时长和频率：</li><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p><h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h5 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h5><p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><h5 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h5><p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><h4 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h4><p>我们将探讨过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p><h5 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h5><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><h5 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h5><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h5 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h5><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><ul><li>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：</li><li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。</li><li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。</li><li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。</li><li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。</li><li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El。</li></ul><p>关于数据库通知功能的详细用法，以及notify-keyspace-events选项的更多设置，Redis的官方文档已经做了很详细的介绍，这里不再赘述。</p><h5 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h5><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type,<span class="keyword">char</span> *event,robj *key,<span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。</p><p>event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。</p><p>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h5 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h5><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span></span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(server.notify_keyspace_events &amp; type):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment">#内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment">#内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyevent@&#123;dbid&#125;__:&#123;event&#125;"</span>.format(dbid=dbid,event=event)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure><p>notifyKeyspaceEvent函数执行以下操作：</p><p>1）server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</p><p>2）如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</p><p>3）最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</p><h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</li><li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li><li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li><li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li><li>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</li><li>Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li><li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li></ul><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p><p>比如：一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000211.jpg" alt=""></p><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p><p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><h5 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h5><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</p><p>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000002.jpg" alt=""></p><h5 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h5><p>前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。</p><p>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p><h5 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h5><p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。</p><p>首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</p><p>其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</p><p>最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：</p><ul><li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li><li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li></ul><p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p><h5 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h5><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h5 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h5><p>在上一节，我们介绍了SAVE命令和BGSAVE的实现方法，并且说明了这两个命令在实现方面的主要区别：SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会。</p><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h5 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h5><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件。</p><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h5><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul><p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p><h5 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h5><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>我们将对RDB文件本身进行介绍，并详细说明文件各个部分的结构和意义。</p><p>图展示了一个完整RDB文件所包含的各个部分:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000011.jpg" alt=""></p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。本章只介绍第六版RDB文件的结构。</p><p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p><p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h5 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h5><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000074.jpg" alt=""></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000121.jpg" alt=""></p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p><p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h5 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h5><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p><p>带有过期时间的键值对在RDB文件中的结构：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000025.jpg" alt=""></p><p>带有过期时间的键值对中的TYPE、key、value三个部分的意义，和前面介绍的不带过期时间的键值对的TYPE、key、value三个部分的意义完全相同，至于新增的EXPIRETIME_MS和ms，它们的意义如下：</p><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h5 id="Value的编码"><a href="#Value的编码" class="headerlink" title="Value的编码"></a>Value的编码</h5><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><p><strong>1.字符串对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。</p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p><strong>2.列表对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象<img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000184.jpg" alt=""></p><p><strong>3.集合对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象.。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000320.jpg" alt=""></p><p><strong>4.哈希表对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象。</p><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000410.jpg" alt="img"></p><p><strong>5.有序集合对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000423.jpg" alt="img"></p><p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。</p><p>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><p><strong>6.INTSET编码的集合</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p><p>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><p><strong>7.ZIPLIST编码的列表、哈希表或者有序集合</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p><p>1）将压缩列表转换成一个字符串对象。</p><p>2）将转换所得的字符串对象保存到RDB文件。</p><p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><p>1）读入字符串对象，并将它转换成原来的压缩列表对象。</p><p>2）根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</p><h4 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h4><h5 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h5><p>根据之前学习的RDB文件结构知识，当一个RDB文件没有包含任何数据库数据时，这个RDB文件将由以下四个部分组成：</p><ul><li>·五个字节的”REDIS”字符串。</li><li>·四个字节的版本号（db_version）。</li><li>·一个字节的EOF常量。</li><li>·八个字节的校验和（check_sum）。</li></ul><p>从od命令的输出中可以看到，最开头的是“REDIS”字符串，之后的0006是版本号，再之后的一个字节377代表EOF常量，最后的334 263 C 360 Z 334 362 V八个字节则代表RDB文件的校验和。</p><h5 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h5><p>根据之前学习的数据库结构知识，当一个数据库被保存到RDB文件时，这个数据库将由以下三部分组成：</p><ul><li>·一个一字节长的特殊值SELECTDB。</li><li>·一个长度可能为一字节、两字节或者五字节的数据库号码（db_number）。</li><li>·一个或以上数量的键值对（key_value_pairs）。</li></ul><p>观察od命令打印的输出，RDB文件的最开始仍然是REDIS和版本号0006，之后出现的376代表SELECTDB常量，再之后的\0代表整数0，表示被保存的数据库为0号数据库。</p><h5 id="包含带有过期时间的字符串键的RDB文件"><a href="#包含带有过期时间的字符串键的RDB文件" class="headerlink" title="包含带有过期时间的字符串键的RDB文件"></a>包含带有过期时间的字符串键的RDB文件</h5><p>根据之前学习的键值对结构知识，一个带有过期时间的键值对将由以下部分组成：</p><ul><li>·一个一字节长的EXPIRETIME_MS特殊值。</li><li>·一个八字节长的过期时间（ms）。</li><li>·一个一字节长的类型（TYPE）。</li><li>·一个键（key）和一个值（value）。</li></ul><h5 id="包含一个集合键的RDB文件"><a href="#包含一个集合键的RDB文件" class="headerlink" title="包含一个集合键的RDB文件"></a>包含一个集合键的RDB文件</h5><p>以下是RDB文件各个部分的意义：</p><ul><li>·REDIS0006：RDB文件标志和版本号。</li><li>·376\0：切换到0号数据库。</li><li>·002 004 L A N G：002是常量REDIS_RDB_TYPE_SET（这个常量的实际值为整数2），表示这是一个哈希表编码的集合键，004表示键的长度，LANG是键的名字。</li><li>·003：集合的大小，说明这个集合包含三个元素。</li><li>·004 R U B Y：集合的第一个元素。</li><li>·004 J A V A：集合的第二个元素。</li><li>·001 C：集合的第三个元素。</li><li>·377：代表常量EOF。</li><li>·202 312 r 352 346 305*023：代表校验和。</li></ul><h4 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li><li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li><li>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li><li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000442.jpg" alt="img"></p><p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。</p><p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容。</p><h5 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h5><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p><h5 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h5><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p><strong>文件的写入和同步</strong></p><p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><p><strong>AOF持久化的效率和安全性</strong></p><p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li></ul><h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><p>1）创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</p><p>2）从AOF文件中分析并读取出一条写命令。</p><p>3）使用伪客户端执行被读出的写命令。</p><p>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p><p>当完成以上步骤之后，AOF文件所保存的数据库状态就会被完整地还原出来</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000420.jpg" alt=""></p><h4 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p><p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p><h4 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li><li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li><li>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li><li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li><li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li><li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h5 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h5><p>文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000316.jpg" alt=""></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p><p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><h5 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I/O多路复用程序的实现"></a>I/O多路复用程序的实现</h5><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><h5 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h5><p>I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li><li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li></ul><p>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p><p>ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p><p>ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li>·如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li><li>·如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li><li>·如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li><li>·如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li></ul><p>ae.c/aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p><p>ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p><p>ae.c/aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p><p>ae.c/aeGetApiName函数返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p><h5 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h5><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li>·为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>·为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>·为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>·当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><p><strong>1.连接应答处理器</strong></p><p>networking.c/acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p><p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000266.jpg" alt="img"></p><p><strong>2.命令请求处理器</strong></p><p>networking.c/readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。</p><p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000331.jpg" alt="img"></p><p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p><p><strong>3.命令回复处理器</strong></p><p>networking.c/sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p><p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000250.jpg" alt="img"></p><p>当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件之间的关联。</p><p><strong>4.一次完整的客户端与服务器连接事件示例</strong></p><p>让我们来追踪一次Redis客户端与服务器进行连接并发送命令的整个过程，看看在过程中会产生什么事件，而这些事件又是如何被处理的。</p><p>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p><p>如果这时有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p><p>之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p><p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000008.jpg" alt="img"></p><p>#####　时间事件</p><p>Redis的时间事件分为以下两类：</p><ul><li>·定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>·周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>·id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>·when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li><li>·timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>·如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>·如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p><p>#####　实现</p><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><p>图展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件：因为新的时间事件总是插入到链表的表头，所以三个时间事件分别按ID逆序排序，表头事件的ID为3，中间事件的ID为2，表尾事件的ID为1。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000382.jpg" alt="img"></p><p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p><p>无序链表并不影响时间事件处理器的性能</p><p>在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p><h5 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h5><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>·更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>·清理数据库中的过期键值对。</li><li>·关闭和清理连接失效的客户端。</li><li>·尝试进行AOF或RDB持久化操作。</li><li>·如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>·如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p><p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。</p><p>从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。</p><h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>从事件处理的角度来看，Redis服务器的运行流程可以用流程图：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000428.jpg" alt=""></p><p>以下是事件的调度和执行规则：</p><p>1）aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</p><p>2）因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</p><p>3）对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</p><p>4）因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</p><h4 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li><li>文件事件处理器是基于Reactor模式实现的网络通信程序。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li><li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li><li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p><p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><ol><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值（flag）。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li></ol><h4 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h4><p>客户端状态包含的属性可以分为两类：</p><p>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</p><p>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</p><h5 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h5><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符。</p><p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p><ul><li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。</li><li>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数。</li></ul><h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p><h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态</p><p>每个标志使用一个常量表示，一部分标志记录了客户端的角色：</p><p>·在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</p><p>·REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。</p><p>·REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</p><p>而另外一部分标志则记录了客户端目前所处的状态：</p><p>·REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</p><p>·REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</p><p>·REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。</p><p>·REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来，不再阻塞。REDIS_UNBLOCKED标志只能在REDIS_BLOCKED标志已经打开的情况下使用。</p><p>·REDIS_MULTI标志表示客户端正在执行事务。</p><p>·REDIS_DIRTY_CAS标志表示事务使用WATCH命令监视的数据库键已经被修改，REDIS_DIRTY_EXEC标志表示事务在命令入队时出现了错误，以上两个标志都表示事务的安全性已经被破坏，只要这两个标记中的任意一个被打开，EXEC命令必然会执行失败。这两个标志只能在客户端打开了REDIS_MULTI标志的情况下使用。</p><p>·REDIS_CLOSE_ASAP标志表示客户端的输出缓冲区大小超出了服务器允许的范围，服务器会在下一次执行serverCron函数时关闭这个客户端，以免服务器的稳定性受到这个客户端影响。积存在输出缓冲区中的所有内容会直接被释放，不会返回给客户端。</p><p>·REDIS_CLOSE_AFTER_REPLY标志表示有用户对这个客户端执行了CLIENT KILL命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端，然后关闭客户端。</p><p>·REDIS_ASKING标志表示客户端向集群节点（运行在集群模式下的服务器）发送了ASKING命令。</p><p>·REDIS_FORCE_AOF标志强制服务器将当前执行的命令写入到AOF文件里面，REDIS_FORCE_REPL标志强制主服务器将当前执行的命令复制给所有从服务器。执行PUBSUB命令会使客户端打开REDIS_FORCE_AOF标志，执行SCRIPT LOAD命令会使客户端打开REDIS_FORCE_AOF标志和REDIS_FORCE_REPL标志。</p><p>·在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送这个命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY标志，否则发送操作会被拒绝执行。</p><p>以上提到的所有标志都定义在redis.h文件里面。</p><p><strong>PUBSUB命令和SCRIPT LOAD命令的特殊性</strong></p><p>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。<br>以上规则适用于绝大部分Redis命令，但PUBSUB命令和SCRIPT LOAD命令是其中的例外。PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。因此，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。SCRIPT LOAD命令的情况与PUBSUB命令类似：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。</p><h5 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求</p><h5 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h5><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。</p><p>argc属性则负责记录argv数组的长度。</p><h5 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h5><p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p><h5 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h5><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p><p>·固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</p><p>·可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</p><h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证</p><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>最后，客户端还有几个和时间有关的属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><h4 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h4><p>服务器使用不同的方式来创建和关闭不同类型的客户端，本节将介绍服务器创建和关闭客户端的方法。</p><h5 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h5><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器（在第12章有介绍），为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p><h5 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h5><p>一个普通客户端可以因为多种原因而被关闭：</p><p>·如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</p><p>·如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</p><p>·如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</p><p>·如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS_MASTER标志），从服务器（打开了REDIS_SLAVE标志），正在被BLPOP等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</p><p>·如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</p><p>·如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</p><p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。</p><p>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><p>·硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</p><p>·软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</p><h5 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h5><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisClient *lua_client;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h5><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端.</p><h4 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li><li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li><li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li><li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li><li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li><li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li><li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li><li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li><li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li></ul><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h4 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h4><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。</p><h5 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h5><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p><h5 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h5><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p><p>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</p><p>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p>3）调用命令执行器，执行客户端指定的命令。</p><h5 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h5><p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p><p>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息，表记录了这个结构的各个主要属性的类型和作用：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000095.jpg" alt=""></p><h5 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h5><p>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：</p><p>·检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</p><p>·根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</p><p>·检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</p><p>·如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</p><p>·如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</p><p>·如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</p><p>·如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</p><p>·如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</p><p>·如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</p><p>·如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</p><h5 id="命令执行器（3）：调用命令的实现函数"><a href="#命令执行器（3）：调用命令的实现函数" class="headerlink" title="命令执行器（3）：调用命令的实现函数"></a>命令执行器（3）：调用命令的实现函数</h5><p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// client</span><br><span class="line">是指向客户端状态的指针</span><br><span class="line">client-&gt;cmd-&gt;proc(client);</span><br></pre></td></tr></table></figure><h5 id="命令执行器（4）：执行后续工作"><a href="#命令执行器（4）：执行后续工作" class="headerlink" title="命令执行器（4）：执行后续工作"></a>命令执行器（4）：执行后续工作</h5><p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p><p>·如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</p><p>·根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</p><p>·如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</p><p>·如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</p><p>当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了</p><h5 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h5><p>前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p><h5 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h5><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端）</p><h5 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h5><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h5 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h5><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p><p>·服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</p><p>·对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</p><h5 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h5><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">// 用于计算键的空转（idle）时长。</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h5><p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看</p><h5 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h5><p>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h5><p>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGTERM信号的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    redisLogFromHandler(REDIS_WARNING,<span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</span><br><span class="line">    <span class="comment">// 打开关闭标识</span></span><br><span class="line">    server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h5><p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p><p>·如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。</p><p>·如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</p><h5 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h5><p>serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</p><h5 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h5><p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p><h5 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h5><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGSAVE，</span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;                <span class="comment">/* PID of RDB saving child */</span></span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGREWRITEAOF，    </span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;                <span class="comment">/* PID if rewriting process */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p><p>·如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</p><p>·如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</p><p>另一方面，如果rdb_child_pid和aof_child_pid两个属性的值都为-1，那么表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：</p><p>1）查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作（这就是上一个小节我们说到的检查）。</p><p>2）检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了）。</p><p>3）检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000328.jpg" alt=""></p><h5 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h5><p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</p><h5 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h5><p>在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端</p><h5 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h5><p>服务器状态的cronloops属性记录了serverCron函数执行的次数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// serverCron函数的运行次数计数器</span></span><br><span class="line">    <span class="comment">// serverCron函数每执行一次，这个属性的值就增一。</span></span><br><span class="line">    <span class="keyword">int</span> cronloops;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能。</p><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h5 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h5><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置服务器的运行id </span></span><br><span class="line">    getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);</span><br><span class="line">    <span class="comment">// 为运行id加上结尾字符</span></span><br><span class="line">    server.runid[REDIS_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 设置默认配置文件路径</span></span><br><span class="line">    server.configfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器频率</span></span><br><span class="line">    server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line">    <span class="comment">// 设置服务器的运行架构</span></span><br><span class="line">    server.arch_bits = (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器端口号</span></span><br><span class="line">    server.port = REDIS_SERVERPORT;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是initServerConfig函数完成的主要工作：</p><p>·设置服务器的运行ID。</p><p>·设置服务器的默认运行频率。</p><p>·设置服务器的默认配置文件路径。</p><p>·设置服务器的运行架构。</p><p>·设置服务器的默认端口号。</p><p>·设置服务器的默认RDB持久化条件和AOF持久化条件。</p><p>·初始化服务器的LRU时钟。</p><p>·创建命令表。</p><p>initServerConfig函数设置的服务器状态属性基本都是一些整数、浮点数、或者字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象这些数据结构在之后的步骤才会被创建出来。</p><h5 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h5><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p><h5 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h5><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p><p>·server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</p><p>·server.db数组，数组中包含了服务器的所有数据库。</p><p>·用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</p><p>·用于执行Lua脚本的Lua环境server.lua。</p><p>·用于保存慢查询日志的server.slowlog属性。</p><p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p><p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p><p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p><p>·为服务器设置进程信号处理器。</p><p>·创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</p><p>·打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</p><p>·为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</p><p>·如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</p><p>·初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备。</p><h5 id="原数据库状态"><a href="#原数据库状态" class="headerlink" title="原数据库状态"></a>原数据库状态</h5><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p><p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p><p>·如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</p><p>·相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</p><h5 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h5><p>在初始化的最后一步，服务器将打印出日志。</p><h4 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h4><p>一个命令请求从发送到完成主要包括以下步骤：</p><ul><li>1）客户端将命令请求发送给服务器；</li><li>2）服务器读取命令请求，并分析出命令参数；</li><li>3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li><li>4）服务器将命令回复返回给客户端。</li></ul><p>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</p><p>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ul><li>1）初始化服务器状态；</li><li>2）载入服务器配置；</li><li>3）初始化服务器数据结构；</li><li>4）还原数据库状态；</li><li>5）执行事件循环。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的数据库&quot;&gt;&lt;a href=&quot;#Redis的数据库&quot; class=&quot;headerlink&quot; title=&quot;Redis的数据库&quot;&gt;&lt;/a&gt;Redis的数据库&lt;/h2&gt;&lt;h4 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
