<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小世界</title>
  
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/"/>
  <updated>2022-05-11T09:20:37.656Z</updated>
  <id>https://github.com/Pandalee99/pandalee99.github.io/</id>
  
  <author>
    <name>攀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【置顶】谈谈几件事</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/04/19/restart-my-blog/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/04/19/restart-my-blog/</id>
    <published>2023-04-19T12:11:40.000Z</published>
    <updated>2022-05-11T09:20:37.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谈谈几件事"><a href="#谈谈几件事" class="headerlink" title="谈谈几件事"></a>谈谈几件事</h1><p>1、考上了USTC，很多知识都要重新学习了。</p><p>2、我的图片都是放到Gitee中的，使用Gitee做的图床。由于Gitee开启了防盗链模式，所有的图片都挂了，以后可能会做图片迁移，不过反正都没人看，能拖就拖。</p><p>3、前面大多数博客都是流水账，我当日记写的，也是后面才有的一点点知识总结，总体而言都是废话连篇。</p><p>4、开始学Go了，记录一下过程。</p><h3 id="续"><a href="#续" class="headerlink" title="续"></a>续</h3><p>1、学完Go了，不知道学啥。</p><p>2、英语听力不好，润不动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;谈谈几件事&quot;&gt;&lt;a href=&quot;#谈谈几件事&quot; class=&quot;headerlink&quot; title=&quot;谈谈几件事&quot;&gt;&lt;/a&gt;谈谈几件事&lt;/h1&gt;&lt;p&gt;1、考上了USTC，很多知识都要重新学习了。&lt;/p&gt;
&lt;p&gt;2、我的图片都是放到Gitee中的，使用Gitee做的图</summary>
      
    
    
    
    
    <category term="Life" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>使用Go语言编写一个web应用</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-web-study/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-web-study/</id>
    <published>2022-04-27T15:29:13.000Z</published>
    <updated>2022-05-27T05:30:37.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Go语言编写一个web-分布式应用"><a href="#使用Go语言编写一个web-分布式应用" class="headerlink" title="使用Go语言编写一个web/分布式应用"></a>使用Go语言编写一个web/分布式应用</h1><h2 id="初始知识"><a href="#初始知识" class="headerlink" title="初始知识"></a>初始知识</h2><h3 id="go语言的学习"><a href="#go语言的学习" class="headerlink" title="go语言的学习"></a>go语言的学习</h3><p>其实很简单，就不详细写了。</p><p>可以去类似于去菜鸟教程这个网站，去初步的了解编程语言的写法。</p><p>或者是类似于哔哔哔哩这样的视频网站，直接照这视频一步一步的去学习它的写法，不过这种方法比较消耗时间。但是我觉得如果你有一定的编程基础，学这个go真的很简单，没有什么复杂地方。你仅需要注意的是，语法有些不同，你可能要花一段时间去适应它的写法。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然网上很多教程都是使用VScode去写的，但是我觉得不是很好，可能自己对于这种轻量级的工具不是很适应。</p><p>我使用的是IntelliJ IDEA ，然后安装了go的插件之后去写的，我觉得这样写起来比较轻松，这个要看个人了。</p><h3 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h3><p>这个编程语言去做一个web服务的话，有点像cpp一样复古的写法，但是相比于cpp这样语言来肯定要简单得多。不过，如果你有一定的基础的话，会比较轻松吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//初始化一个函数，让其能对web应用进行响应</span></span><br><span class="line"><span class="comment">//第一个参数是路由地址，第二个参数是函数主要功能是收到请求并响应</span></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务器，第一个参数是网络地址，第二个参数是处理方式</span></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后就可以看到结果了。</p><h2 id="正式编写"><a href="#正式编写" class="headerlink" title="正式编写"></a>正式编写</h2><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h4><p>首先要编写一个go程序，就如上面的例子一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := myHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: &amp;mh, <span class="comment">//Handler实际上是一个接口</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，所有的网址都会输出同样的信息，因为每个请求都是使用同一个Handler。而我们应该使用：DefaultServeMux 去进行处理不同的Handler，而我们就需要对每个Handler进行注册，这样才能进行出结果。</p><p>所以我们应该这么改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于我们把我们需要自定义的Handler，根据自己的需要去更改，最后注册到DefaultServeMux当中，完成对不同请求产生不同的响应。</p><h4 id="HandleFunc"><a href="#HandleFunc" class="headerlink" title="HandleFunc"></a>HandleFunc</h4><p>但前面的处理完全可以简写为一个方式，增加可读性，于是乎，我们就要用到这个函数HandleFunc：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HandleFunc</span></span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个HandleFunc本质上还是调用Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把上述代码中的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>其结果也是一样的。因为这其实是接口型函数，表示函数的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是go语言精妙的地方了。你可以面对多种不一样的处理方式，但是只用放在同一个接口当中，这就是go语言使用组成而不是继承的原因。</p><p>总结，如何注册DefaultServeHTTP</p><p>方法一、使用http.Handle（第二个参数是Handler）</p><p>方法二、使用http.HandleFunc（第二个参数是Handler函数）</p><p>方法三、http.HandlerFunc可以进行类型转换，将Handler函数转化成Handler（结构体）来使用</p><h3 id="内置Handler"><a href="#内置Handler" class="headerlink" title="内置Handler"></a>内置Handler</h3><ul><li>func NotFoundHandler() Handler<br>返回一个 handler，它给每个请求的响应都是“404 page not found”</li><li>func RedirectHandler(url string, code int) Handler<br>返回一个 handler，它把每个请求使用给定的状态码跳转到指定的 URL。<br>url，要跳转到的 URL<br>code，跳转的状态码（3xx），常见的：StatusMovedPermanently、StatusFound 或 StatusSeeOther 等</li><li>func StripPrefix(prefix string, h handler) Handler<br>返回一个 handler，它从请求 URL 中去掉指定的前缀，然后再调用另一个 handler。<br>如果请求的 URL 与提供的前缀不符，那么 404<br>略像中间件<br>prefix，URL 将要被移除的字符串前缀<br>h，是一个 handler，在移除字符串前缀之后，这个 handler 将会接收到请求<br>修饰了另一个 Handler </li><li>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler<br>返回一个 handler，它用来在指定时间内运行传入的 h。<br>也相当于是一个修饰器<br>h，将要被修饰的 handler<br>dt，第一个 handler 允许的处理时间<br>msg，如果超时，那么就把 msg 返回给请求，表示响应时间过长</li><li>func FileServer(root FileSystem) Handler<br>返回一个 handler，使用基于 root 的文件系统来响应请求<br>type FileSystem interface {<pre><code>Open(name string) (File, error)</code></pre>  }<br>使用时需要用到操作系统的文件系统，所以还需要委托给：<br>type Dir string<br>func (d Dir) Open(name string) (File, error)</li></ul><h4 id="代码演示：FileServer"><a href="#代码演示：FileServer" class="headerlink" title="代码演示：FileServer"></a>代码演示：FileServer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8888"</span>, http.FileServer(http.Dir(<span class="string">"root"</span>)))</span><br></pre></td></tr></table></figure><p>可以通过这个方法指定root这个根路径，这样打开文件的时候直接去root，直接找到需要的url路径，加载文件</p><h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p> 最基本的肯定是：</p><ul><li><p>HTTP Request 和 HTTP Response（请求和响应）</p></li><li><p>它们具有相同的结构：</p><ul><li><p>​    请求（响应）行</p></li><li><p>​    0 个或多个 Header</p></li><li><p>​    空行</p></li><li><p>​    可选的消息体（Body）</p></li></ul></li></ul><p>而 <strong>net/http</strong> 包提供了用于表示 HTTP 消息的结构，其中Reqeust（是个 struct），代表了客户端发送的 HTTP 请求消息</p><h4 id="URL类型"><a href="#URL类型" class="headerlink" title="URL类型"></a>URL类型</h4><h5 id="URL-Query"><a href="#URL-Query" class="headerlink" title="URL Query"></a>URL Query</h5><p>RawQuery 会提供实际查询的字符串。</p><p>例如： <a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>它的 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>还有一个简便方法可以得到 Key-Value 对：通过 Request 的 Form 字段（以后再说）</p><h5 id="URL-Fragment"><a href="#URL-Fragment" class="headerlink" title="URL Fragment"></a>URL Fragment</h5><p>如果从浏览器发出的请求，那么你无法提取出 Fragment 字段的值</p><p>浏览器在发送请求时会把 fragment 部分去掉</p><p>但不是所有的请求都是从浏览器发出的（例如从 HTTP 客户端包）。</p><h5 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h5><p>请求和响应（Request、Response）的 headers 是通过 Header 类型来描述的，它是一个 map，用来表述 HTTP Header 里的 Key-Value 对。</p><p>Header map 的 key 是 string 类型，value 是 []string</p><p>设置 key 的时候会创建一个空的 []string 作为 value，value 里面第一个元素就是新 header 的值；</p><p>为指定的 key 添加一个新的 header 值，执行 append 操作即可</p><h5 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h5><p>请求和响应的 bodies 都是使用 Body 字段来表示的</p><p>Body 是一个 io.ReadCloser 接口</p><p>一个 Reader 接口</p><p>一个 Closer 接口</p><p>Reader 接口定义了一个 Open 方法：</p><p>参数：[]byte</p><p>返回：byte 的数量、可选的错误</p><p>Closer 接口定义了一个 Close 方法：</p><p>没有参数，返回可选的错误</p><h5 id="代码演示-Fragment"><a href="#代码演示-Fragment" class="headerlink" title="代码演示:Fragment"></a>代码演示:Fragment</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/url"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.URL.Fragment)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过这种方式，看看自己请求有没有Fragment</p><h5 id="代码演示-Header"><a href="#代码演示-Header" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/header"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.Header)</span><br><span class="line">fmt.Fprintln(writer, request.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">fmt.Fprintln(writer, request.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman测试：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/header</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[Accept:[*&#x2F;*] Accept-Encoding:[gzip, deflate, br] Connection:[keep-alive] Postman-Token:[9ddda678-d6f8-42d2-aea5-67816a86c3d7] User-Agent:[PostmanRuntime&#x2F;7.28.3]]</span><br><span class="line">[gzip, deflate, br]</span><br><span class="line">gzip, deflate, br</span><br></pre></td></tr></table></figure><h5 id="代码演示-Header-1"><a href="#代码演示-Header-1" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/post"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">length := request.ContentLength</span><br><span class="line">body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">request.Body.Read(body)</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个方式去展现出body的内容</p><h4 id="URL-Query-1"><a href="#URL-Query-1" class="headerlink" title="URL Query"></a>URL Query</h4><p>例如：<a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>r.URL.RawQuery 会提供实际查询的原始字符串，因为 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>r.URL.Query()，会提供查询字符串对应的 map string string</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">url := request.URL</span><br><span class="line">query := url.Query() <span class="comment">//得到一个map</span></span><br><span class="line"></span><br><span class="line">id := query[<span class="string">"id"</span>]</span><br><span class="line">log.Println(id)</span><br><span class="line"></span><br><span class="line">name := query.Get(<span class="string">"name"</span>)</span><br><span class="line">log.Println(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/home?id=123&amp;name=panda&amp;id=456&amp;name=fox</span><br></pre></td></tr></table></figure><p>控制台显示结果为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[123 456]</span><br><span class="line">panda</span><br></pre></td></tr></table></figure><p>这表明 query[“id”] 是获取所有的值，而query.Get(“name”) 只会获取第一个值</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><h4 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a>enctype</h4><p>接下来看看，如何处理表单类的数据。</p><p>HTML 表单里面的数据会以 name-value 对的形式，通过 POST 请求发送出去，它的数据内容会放在 POST 请求的 Body 里面。</p><p>通过 POST 发送的 name-value 数据对的格式可以通过表单的 Content Type 来指定，也就是 enctype 属性。</p><p>默认值是：application/x-www-form-urlencoded<br>浏览器被要求至少要支持： application/x-www-form-urlencoded 、multipart/form-data。HTML 5 的话，还需要支持 text/plain</p><p>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：    first_name=sau%20sheong&amp;last_name=chang</p><p>如果 enctype 是 multipart/form-data，那么：每一个 name-value 对都会被转换为一个MIME消息部分，每一个部分都有自己的 Content Type 和 Content Disposition</p><p>那么，改如何选择enctype呢？</p><ol><li>简单文本：表单 URL 编码</li><li>大量数据，例如上传文件：multipart-MIME，甚至可以把二进制数据通过选择 Base64 编码，来当作文本进行发送</li></ol><h4 id="Form字段"><a href="#Form字段" class="headerlink" title="Form字段"></a>Form字段</h4><p>Request 上的函数允许我们从 URL 或/和 Body 中提取数据，通过这些字段：    </p><ul><li>Form</li><li>PostForm</li><li>MultipartForm</li></ul><p>Form 里面的数据是 key-value 对。通常的做法是：先调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.Form)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会打印出一个map，包含传入的所有的值。包括url的值和表单的值。</p><p>如果只想要表单的 key-value 对，不要 URL 的，可以使用 PostForm 字段。<br>PostForm 只支持 application/x-www-form-urlencoded</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就只有一个字段</p><p>而想要得到 multipart key-value 对，必须使用 MultipartForm 字段。</p><p>想要使用 MultipartForm 这个字段的话，首先需要调用ParseMultipartForm 这个方法，该方法会在必要时调用 ParseForm 方法<br>，参数是需要读取数据的长度<br>MultipartForm 只包含表单的 key-value 对，返回类型是一个 struct 而不是 map。这个 struct 里有两个 map：1、key 是 string，value 是 []string 。2、空的（key 是 string，value 是文件）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="FormValue-和-PostFormValue-方法"><a href="#FormValue-和-PostFormValue-方法" class="headerlink" title="FormValue 和 PostFormValue 方法"></a>FormValue 和 PostFormValue 方法</h5><ul><li>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用 ParseForm 或 ParseMultipartForm</li><li>PostFormValue 方法也一样，但只能读取 PostForm</li><li>FormValue 和 PostFormValue 都会调用 ParseMultipartForm 方法</li><li>但如果表单的 enctype 设为 multipart/form-data，那么即使你调用ParseMultipartForm 方法，也无法通过 FormValue 获得想要的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.FormValue(<span class="string">"name"</span>))</span><br><span class="line">fmt.Fprintln(writer, request.PostFormValue(<span class="string">"name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>multipart/form-data 最常见的应用场景就是上传文件（例子）：</p><ol><li>首先调用 ParseMultipartForm 方法</li><li>从 File 字段获得 FileHeader，调用其 Open 方法来获得文件</li><li>可以使用 ioutil.ReadAll 函数把文件内容读取到 byte 切片里</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)                      <span class="comment">//1024表示一次性加载到内存的最大字节数</span></span><br><span class="line">fileHeader := request.MultipartForm.File[<span class="string">"upload"</span>][<span class="number">0</span>] <span class="comment">//表示从upload字段获取值</span></span><br><span class="line">file, err := fileHeader.Open()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字如其意，非常简单。但是这部分代码仍然有改进的空间，比如使用FormFile</p><h5 id="FormFile"><a href="#FormFile" class="headerlink" title="FormFile()"></a>FormFile()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//request.ParseMultipartForm(1024)                      //1024表示一次性加载到内存的最大字节数</span></span><br><span class="line"><span class="comment">//fileHeader := request.MultipartForm.File["upload"][0] //表示从upload字段获取值</span></span><br><span class="line"><span class="comment">//file, err := fileHeader.Open()</span></span><br><span class="line"></span><br><span class="line">file, _, err := request.FormFile(<span class="string">"uploader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MultipartReader"><a href="#MultipartReader" class="headerlink" title="MultipartReader()"></a>MultipartReader()</h5><p>方法签名：func (r <em>Request) MultipartReader() (</em>multipart.Reader, error)<br>如果是 multipart/form-data 或 multipart 混合的 POST 请求：1、MultipartReader 返回一个 MIME multipart reader 2、否则返回 nil 和一个错误<br>可以使用该函数代替 ParseMultipartForm 来把请求的 body 作为 stream 进行处理。1、不是把表单作为一个对象来处理的，不是一次性获得整个 map。2、逐个检查来自表单的值，然后每次处理一个</p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h4><p>从服务器向客户端返回响应需要使用 ResponseWriter。ResponseWriter 是一个接口，handler 用它来返回响应。而真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response。</p><p>但是，为什么request是指针，而writer不用是呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(writer http.ResponseWriter, request *http.Request)</span><br></pre></td></tr></table></figure><p>其实，这两个都是按引用进行传递的，ResponseWriter是具有Header、Write、WriteHeader三种方法的接口，response指针实现了以上三种方法，故response是一种特殊的ResponseWriter。</p><p>并且，ResponseWriter还能使用writer.Write([]byte(str))方法，把字符串写入到body里面。</p><h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接收一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回<br>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader(http.StatusOK)，所以 WriteHeader 主要用来发送错误类的 HTTP 状态码<br>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p><h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改<br>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p><h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，包装一个 404 状态码和一个额外的信息<br>ServeFile 函数，从文件系统提供文件，返回给请求者<br>ServeContent 函数，它可以把实现了 io.ReadSeeker 接口的任何东西里面的内容返回给请求者，并且，还可以处理 Range 请求（范围请求），如果只请求了资源的一部分内容，那么 ServeContent 就可以如此响应。而 ServeFile 或 io.Copy 则不行。<br>Redirect 函数，告诉客户端重定向到另一个 URL</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>Web 模板就是预先设计好的 HTML 页面，它可以被模板引擎反复的使用，来产生 HTML 页面<br>Go 的标准库提供了 text/template，html/template 两个模板库，大多数 Go 的 Web 框架都使用这些库作为 默认的模板引擎</p><h4 id="Go-的模板和模板引擎"><a href="#Go-的模板和模板引擎" class="headerlink" title="Go 的模板和模板引擎"></a>Go 的模板和模板引擎</h4><p>go主要使用的是 text/template，HTML 相关的部分使用了 html/template，是个混合体。go模板可以完全无逻辑，但又具有足够的嵌入特性。和大多数模板引擎一样，Go Web 的模板位于无逻辑和嵌入逻辑之间的某个地方</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在 Web 应用中，通产是由 handler 来触发模板引擎。handler 调用模板引擎，并将使用的模板传递给引擎，通常是一组模板文件和动态数据。<br>模板引擎生成 HTML，并将其写入到 ResponseWriter，ResponseWriter 再将它加入到 HTTP 响应中，返回给客户端。</p><h5 id="模板的例子"><a href="#模板的例子" class="headerlink" title="模板的例子"></a>模板的例子</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go Web Programming<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模板必须是可读的文本格式，扩展名任意。对于 Web 应用通常就是 HTML，里面会内嵌一些命令（叫做 action）</span><br><span class="line">text/template 是通用模板引擎，html/template 是 HTML 模板引擎</span><br><span class="line">action 位于双层花括号之间：&#123;&#123; . &#125;&#125;。这里的 . 就是一个 action。它可以命令模板引擎将其替换成一个值。</span><br></pre></td></tr></table></figure><p>是不是有点像jsp</p><h5 id="使用模板引擎"><a href="#使用模板引擎" class="headerlink" title="使用模板引擎"></a>使用模板引擎</h5><ol><li>解析模板源（可以是字符串或模板文件），从而创建一个解析好的 模板的 struct</li><li>执行解析好的模板，并传入 ResponseWriter 和 数据。这会触发模板引擎组合解析好的模板和数据，来产生最终的 HTML，并将它传递给 ResponseWriter </li></ol><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">t, _ := template.ParseFiles(<span class="string">"mytest.html"</span>) <span class="comment">//去解析一个模板文件，一个也在这个包下的html文件，</span></span><br><span class="line">t.Execute(writer, <span class="string">"hello,my friends"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是鉴于现今几乎都是前后端分离的项目了，模板引擎已经几乎要绝迹了，随便学学吧。</p><h4 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h4><h5 id="ParseFiles"><a href="#ParseFiles" class="headerlink" title="ParseFiles"></a>ParseFiles</h5><p>解析模板文件，并创建一个解析好的模板 struct，后续可以被执行<br>ParseFiles 函数是 Template struct 上 ParseFiles 方法的简便调用<br>调用 ParseFiles 后，会创建一个新的模板，模板的名字是文件名<br>ParseFiles 的参数数量可变，但只返回一个模板，当解析多个文件时，第一个文件作为返回的模板（名、内容），其余的作为 map，供后续执行使用</p><h5 id="ParseGlob"><a href="#ParseGlob" class="headerlink" title="ParseGlob"></a>ParseGlob</h5><p>使用模式匹配来解析特定的文件</p><h5 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h5><p>可以解析字符串模板，其它方式最终都会调用 Parse</p><h5 id="Lookup-方法"><a href="#Lookup-方法" class="headerlink" title="Lookup 方法"></a>Lookup 方法</h5><p>通过模板名来寻找模板，如果没找到就返回 nil</p><h5 id="Must-函数"><a href="#Must-函数" class="headerlink" title="Must 函数"></a>Must 函数</h5><p>可以包裹一个函数，返回到一个模板的指针 和 一个错误。如果错误不为 nil，那么就 panic</p><h4 id="模板的Action"><a href="#模板的Action" class="headerlink" title="模板的Action"></a>模板的Action</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action 就是 Go 模板中嵌入的命令，位于两组花括号之间 &#123;&#123; xxx &#125;&#125;，就是一个 Action，而且是最重要的一个。它代表了传入模板的数据</span><br></pre></td></tr></table></figure><p>Action 主要可以分为五类：条件类，迭代/遍历类，设置类，包含类，定义类</p><h5 id="条件Action"><a href="#条件Action" class="headerlink" title="条件Action"></a>条件Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">  other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代-遍历-Action"><a href="#迭代-遍历-Action" class="headerlink" title="迭代/遍历 Action"></a>迭代/遍历 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">  Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>这类 Action 用来遍历数组、slice、map 或 channel 等数据结构，“.”用来表示每次迭代循环中的元素</p><h5 id="设置Action"><a href="#设置Action" class="headerlink" title="设置Action"></a>设置Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>它允许在指定范围内，让“.”来表示其它指定的值（arg）</p><h5 id="包含-Action"><a href="#包含-Action" class="headerlink" title="包含 Action"></a>包含 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template "name" &#125;&#125;</span><br><span class="line">它允许你在模板中包含其它的模板</span><br><span class="line">&#123;&#123; template "name" arg &#125;&#125;</span><br><span class="line">给被包含模板传递参数</span><br></pre></td></tr></table></figure><h4 id="函数与管道"><a href="#函数与管道" class="headerlink" title="函数与管道"></a>函数与管道</h4><h5 id="参数（argument）"><a href="#参数（argument）" class="headerlink" title="参数（argument）"></a>参数（argument）</h5><p>参数就是模板里面用到的值。可以是 bool、整数、string … ，也可以是 struct、struct 的字段、数组的 key 等等<br>参数可以是变量、方法（返回单个值或返回一个值和一个错误）或函数<br>参数可以是一个点“.”，也就是传入模板引擎的那个值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">这里的 arg 就是参数</span><br></pre></td></tr></table></figure><h5 id="在-Action-中设置变量"><a href="#在-Action-中设置变量" class="headerlink" title="在 Action 中设置变量"></a>在 Action 中设置变量</h5><p>可以在 action 中设置变量，变量以 $ 开头：$variable := value<br>一个迭代 action 的例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">  The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="管道（pipeline）"><a href="#管道（pipeline）" class="headerlink" title="管道（pipeline）"></a>管道（pipeline）</h5><p>管道是按顺序连接到一起的参数、函数和方法。和 Unix 的管道类似:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：&#123;&#123; p1 | p2 | p3 &#125;&#125;  ，p1、p2、p3 要么是参数，要么是函数</span><br><span class="line">管道允许我们把参数的输出发给下一个参数，下一个参数由管道（|）分隔开。</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>参数可以是一个函数，Go 模板引擎提供了一些基本的内置函数，功能比较有限。例如 fmt.Sprint 的各类变体等<br>开发者可以自定义函数，可以接收任意数量的输入参数<br>返回：一个值     或       一个值+一个错误</p><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define、template、block</span><br><span class="line">html、js、urlquery。对字符串进行转义，防止安全问题</span><br><span class="line">如果是 Web 模板，那么不会需要经常使用这些函数。</span><br><span class="line">index</span><br><span class="line">print/printf/println</span><br><span class="line">len</span><br><span class="line">with</span><br><span class="line">这些都是内置的函数</span><br></pre></td></tr></table></figure><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template.Funcs(funcMap FuncMap) *Template</span><br><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//value 是函数</span></span><br><span class="line"><span class="comment">//可以有任意数量的参数</span></span><br><span class="line"><span class="comment">//返回单个值的函数或返回一个值+一个错误的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个 FuncMap（map 类型）。</span></span><br><span class="line"><span class="comment">key 是函数名</span></span><br><span class="line"><span class="comment">value 就是函数</span></span><br><span class="line"><span class="comment">把 FuncMap 附加到模板</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>常见用法：template.New(“”).Funcs(funcMap).Parse(…)，调用顺序非常重要。可以在管道中使用，也可以作为正常函数使用。</p><h4 id="模板组合"><a href="#模板组合" class="headerlink" title="模板组合"></a>模板组合</h4><h5 id="Layout-模板"><a href="#Layout-模板" class="headerlink" title="Layout 模板"></a>Layout 模板</h5><p>Layout 模板就是网页中固定的部分，它可以被多个网页重复使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Include（包含）action 的形式：&#123;&#123; template "name" . &#125;，</span><br></pre></td></tr></table></figure><p>以这种方式做 layout 模板是不可行的。而正确的做法是在模板文件里面使用 define action 再定义一个模板。这种形式特别像thymeleaf，就是单纯的将HTML页面强行模块化，使其具有公共部分的属性，总体而言还是比较简单的。而也可以在多个模板文件里，定义同名的模板。</p><h5 id="使用-block-action-定义默认模板"><a href="#使用-block-action-定义默认模板" class="headerlink" title="使用 block action 定义默认模板"></a>使用 block action 定义默认模板</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">block action 可以定义模板，并同时就使用它</span><br><span class="line">template：模板必须可用</span><br><span class="line">block：模板可以不存在</span><br></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eq/ne</span><br><span class="line">lt/gt</span><br><span class="line">le/ge</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><p>字如其意。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>接下来看看如何使用golang去连接数据库，并进行基本的CRUD。</p><h4 id="https-www-jianshu-com-p-7e745fefb8af"><a href="#https-www-jianshu-com-p-7e745fefb8af" class="headerlink" title="https://www.jianshu.com/p/7e745fefb8af"></a><strong><a href="https://www.jianshu.com/p/7e745fefb8af" target="_blank" rel="noopener">https://www.jianshu.com/p/7e745fefb8af</a></strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//"用户名:密码@[连接方式](主机名:端口号)/数据库名"</span></span><br><span class="line">    db,_:=sql.Open(<span class="string">"mysql"</span>,<span class="string">"root:root@(127.0.0.1:3306)/testdatabases"</span>) <span class="comment">// 设置连接数据库的参数</span></span><br><span class="line">    <span class="keyword">defer</span> db.Close()    <span class="comment">//关闭数据库</span></span><br><span class="line">    err:=db.Ping()      <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"数据库连接失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作一：执行数据操作语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sql:="insert into stu values (2,'berry')"</span></span><br><span class="line"><span class="comment">    result,_:=db.Exec(sql)      //执行SQL语句</span></span><br><span class="line"><span class="comment">    n,_:=result.RowsAffected(); //获取受影响的记录数</span></span><br><span class="line"><span class="comment">    fmt.Println("受影响的记录数是",n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作二：执行预处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    stu:=[2][2] string&#123;&#123;"3","ketty"&#125;,&#123;"4","rose"&#125;&#125;</span></span><br><span class="line"><span class="comment">    stmt,_:=db.Prepare("insert into stu values (?,?)")      //获取预处理语句对象</span></span><br><span class="line"><span class="comment">    for _,s:=range stu&#123;</span></span><br><span class="line"><span class="comment">        stmt.Exec(s[0],s[1])            //调用预处理语句</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作三：单行查询</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    var id,name string</span></span><br><span class="line"><span class="comment">    rows:=db.QueryRow("select * from stu where id=4")   //获取一行数据</span></span><br><span class="line"><span class="comment">    rows.Scan(&amp;id,&amp;name)        //将rows中的数据存到id,name中</span></span><br><span class="line"><span class="comment">    fmt.Println(id,"--",name)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作四：多行查询</span></span><br><span class="line">    rows,_:=db.Query(<span class="string">"select * from stu"</span>)       <span class="comment">//获取所有数据</span></span><br><span class="line">    <span class="keyword">var</span> id,name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next()&#123;        <span class="comment">//循环显示所有的数据</span></span><br><span class="line">        rows.Scan(&amp;id,&amp;name)</span><br><span class="line">        fmt.Println(id,<span class="string">"--"</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>前面很多时候，都是使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>HandleFunc这种方式去进行路由控制，但是其实还有更为方便的写法。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>main()：设置类工作<br>controller：1、静态资源 。2、把不同的请求送到不同的 controller 进行处理</p><p>我们实际上应该这么设置才是最为正确的写法。</p><p>例子，先制作出两个页面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerWelcomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">_, err := writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将两个函数进行注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="comment">//RegisterRoutes 用于注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//这里还可以使用静态资源</span></span><br><span class="line">registerHomeRoutes()</span><br><span class="line">registerWelcomeRoutes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在主函数中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">server :&#x3D; http.Server&#123;</span><br><span class="line">Addr:    &quot;localhost:8888&quot;,</span><br><span class="line">Handler: nil,</span><br><span class="line">&#125;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">err :&#x3D; server.ListenAndServe()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是一种代码层面的解耦合，将我们的函数进一步模块化。</p><h4 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h4><p>静态路由：一个路径对应一个页面：</p><p>/home           或       /about</p><p>带参数的路由：根据路由参数，创建出一族不同的页面：</p><p>/companies/123               或            /companies/Google</p><p>这里使用HandlerFunc就可以了，将字符串传入URL，效果是相同的，与Spring+thymeleaf可以说是一模一样。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>现在讲究前后端分离，大多数数据都是使用JSON去传递数据，接下来看看如何在go中使用JSON对象。</p><h4 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h4><p>Go bool：JSON boolean<br>Go float64：JSON 数值<br>Go string：JSON strings<br>Go nil：JSON null.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于未知结构的-JSON"><a href="#对于未知结构的-JSON" class="headerlink" title="对于未知结构的 JSON"></a>对于未知结构的 JSON</h4><p>map[string]interface{} 可以存储任意 JSON 对象<br>[]interface{} 可以存储任意的 JSON 数组</p><h4 id="读取-JSON"><a href="#读取-JSON" class="headerlink" title="读取 JSON"></a>读取 JSON</h4><p>需要一个解码器：dec := json.NewDecoder(r.Body) ，参数需实现 Reader 接口<br>解码器上进行解码：dec.Decode(&amp;query)</p><h4 id="写入-JSON"><a href="#写入-JSON" class="headerlink" title="写入 JSON"></a>写入 JSON</h4><p>需要一个编码器：enc := json.NewEncoder(w)，参数需实现 Writer 接口<br>编码是：enc.Encode(results)</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//首先看看请求的类型</span></span><br><span class="line">dec := json.NewDecoder(request.Body) <span class="comment">//现在JSON就在这个body里边了，并且需要进行解码</span></span><br><span class="line">company := Company&#123;&#125;</span><br><span class="line">err := dec.Decode(&amp;company) <span class="comment">//将密码解码到company这个变量里边</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;             <span class="comment">//如果它不为空</span></span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则将客户端传过来的数据转化为json重新返回给客户端</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">err = enc.Encode(company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := server.ListenAndServe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman进行测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/companies</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">&#123;</span></span><br><span class="line">    "id": 123,</span><br><span class="line">    "name": "google",</span><br><span class="line">    "country": "USA"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码的类型：Marshal-和-Unmarshal"><a href="#编码的类型：Marshal-和-Unmarshal" class="headerlink" title="编码的类型：Marshal 和 Unmarshal"></a>编码的类型：Marshal 和 Unmarshal</h4><p>Marshal（编码）: 把 go struct 转化为 json 格式。MarshalIndent，带缩进<br>Unmarshal（解码）: 把 json 转化为 go struct</p><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "id": 123,</span></span><br><span class="line"><span class="string">    "name": "google",</span></span><br><span class="line"><span class="string">    "country": "USA"</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c := Company&#123;&#125;</span><br><span class="line">_ = json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;c)</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line">bytes, _ := json.Marshal(c)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">bytes2, _ := json.MarshalIndent(c, <span class="string">","</span>, <span class="string">"     "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果为：</span></span><br><span class="line">&#123;<span class="number">123</span> google USA&#125;</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">123</span>,<span class="string">"name"</span>:<span class="string">"google"</span>,<span class="string">"country"</span>:<span class="string">"USA"</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">,     <span class="string">"id"</span>: <span class="number">123</span>,</span><br><span class="line">,     <span class="string">"name"</span>: <span class="string">"google"</span>,</span><br><span class="line">,     <span class="string">"country"</span>: <span class="string">"USA"</span></span><br><span class="line">,&#125;</span><br></pre></td></tr></table></figure><p>区别：</p><p>针对 string 或 bytes：</p><ul><li>Marshal =&gt; String</li><li>Unmarshal &lt;= String</li></ul><p>针对 stream:</p><ul><li>Encode =&gt; Stream，把数据写入到 io.Writer</li><li>Decode &lt;= Stream，从 io.Reader 读取数据</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件大家都懂的，像消息队列，缓存，也是中间件。当然也可以自己捏一个中间件的处理逻辑。</p><h4 id="创建中间件"><a href="#创建中间件" class="headerlink" title="创建中间件"></a>创建中间件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//handler 如果是 nil：DefaultServeMux</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>像这个Handler接口，并可以支持中间件的处理。</p><p>首先创建一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m MyMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 在 next handler 之前做一些事情</span></span><br><span class="line">m.Next.ServeHTTP(w, r)</span><br><span class="line"><span class="comment">// 在 next handler 之后做一些事情</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>途中可以定义中间件需要做的事情。</p><h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ol><li>Logging，日志</li><li>安全，身份认证</li><li>请求超时，减少资源消耗</li><li>响应压缩，提升效率 </li></ol><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间件</span></span><br><span class="line"><span class="keyword">type</span> AuthMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *AuthMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> am.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">am.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//如果什么都没有，执行默认页面</span></span><br><span class="line">auth := request.Header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line"><span class="keyword">if</span> auth != <span class="string">""</span> &#123; <span class="comment">//说明存在身份，则执行逻辑</span></span><br><span class="line">am.Next.ServeHTTP(writer, request)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//否则报异常</span></span><br><span class="line">writer.WriteHeader(http.StatusUnauthorized) <span class="comment">//401未授权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是自定义的中间件类型，接着是主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="built_in">new</span>(middleware.AuthMiddleware))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该中间件注册过后，便可以执行逻辑。</p><p>使用Postman进行测试，一个带Authorization，而另一个不带,测试略。</p><h3 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h3><p>从请求的上下文中获取信息，以用于处理</p><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">Context</span><span class="params">()</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//返回当前请求的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//基于 Context 进行“修改”，（实际上）创建一个新的 Context</span></span><br></pre></td></tr></table></figure><p>有这么两种方式去处理上下文</p><p>看看里面实际上是什么：</p><h4 id="context-Context"><a href="#context-Context" class="headerlink" title="context.Context"></a>context.Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这些方法都是用于读取，不能进行设置</span></span><br></pre></td></tr></table></figure><p>这就是上下文接口里面的方法</p><p>context这个包，也有一些方法，可以返回新的context</p><h4 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h4><ul><li>WithCancel()，它有一个 CancelFunc</li><li>WithDeadline()，带有一个时间戳（time.Time）</li><li>WithTimeout()，带有一个具体的时间段（time.Duration）</li><li>WithValue()，在里面可以添加一些值</li></ul><h4 id="一个超时的例子"><a href="#一个超时的例子" class="headerlink" title="一个超时的例子"></a>一个超时的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeoutMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeoutMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tm.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">tm.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//处理和中间件的一般方式一样</span></span><br><span class="line"></span><br><span class="line">ctx := request.Context()                         <span class="comment">//获取上下文</span></span><br><span class="line">ctx, _ = context.WithTimeout(ctx, <span class="number">3</span>*time.Second) <span class="comment">//修改context的超时判断</span></span><br><span class="line">request.WithContext(ctx)                         <span class="comment">//用我们自定义的context去代替</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)                        <span class="comment">//意图在于，如果我们请求能够在3秒内完成的话，这个chan就会收到一个信号</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                                      <span class="comment">//使用goroutine</span></span><br><span class="line">tm.Next.ServeHTTP(writer, request) <span class="comment">//执行完这个方法后，发送一个信号</span></span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;                   <span class="comment">//发送信号</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//一个竞争的状态</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch: <span class="comment">//正常处理完，得到信号，返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//否则返回错误</span></span><br><span class="line">writer.WriteHeader(http.StatusRequestTimeout)</span><br><span class="line">&#125;</span><br><span class="line">ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先新造好这个中间件，然后注册到main函数里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/middleware"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//time.Sleep(4*time.Second)</span></span><br><span class="line"><span class="comment">//测试用</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, &amp;middleware.TimeoutMiddleware&#123;Next: <span class="built_in">new</span>(middleware.AuthMiddleware)&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后像之前一样去测试，即可。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>这是HTTP的流程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> HTTP/1.1</span><br><span class="line">…</span><br><span class="line">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure><p>都是明文传输的，所以我们有时候就需要HTTPS</p><h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><ul><li>http.ListenAndServe 函数</li><li>http.ListenAndServeTLS 函数</li></ul><p>可以使用ListenAndServeTLS去使其页面变为HTTPS类型，看看接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServeTLS(certFile, keyFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现需要安全证书，而我们的go就可以自己生成安全证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -h</span><br><span class="line">//看看帮助</span><br><span class="line"> -ca</span><br><span class="line">        whether this cert should be its own Certificate Authority</span><br><span class="line">  -duration duration</span><br><span class="line">        Duration that certificate is valid <span class="keyword">for</span> (default <span class="number">8760</span>h0m0s)</span><br><span class="line">  -ecdsa-curve string</span><br><span class="line">        ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521</span><br><span class="line">  -ed25519</span><br><span class="line">        Generate an Ed25519 key</span><br><span class="line">  -host string</span><br><span class="line">        Comma-separated hostnames and IPs to generate a certificate <span class="keyword">for</span></span><br><span class="line">  -rsa-bits int</span><br><span class="line">        Size of RSA key to generate. Ignored <span class="keyword">if</span> --ecdsa-curve is <span class="built_in">set</span> (default <span class="number">2048</span>)</span><br><span class="line">  -<span class="built_in">start</span>-<span class="built_in">date</span> string</span><br><span class="line">        Creation <span class="built_in">date</span> formatted as Jan <span class="number">1</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span> <span class="number">2011</span></span><br></pre></td></tr></table></figure><p>于是乎，便生成证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -host localhost</span><br><span class="line"> //wrote cert.pem</span><br><span class="line"> //wrote key.pem</span><br></pre></td></tr></table></figure><p>之后再测试，发现只有使用HTTPS的前缀，才能打开网页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go_web/controller"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">http.ListenAndServeTLS(<span class="string">"localhost:8888"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们使用的HTTP1.1协议就会自动升级到HTTP2.0协议</p><h3 id="HTTP的协议"><a href="#HTTP的协议" class="headerlink" title="HTTP的协议"></a>HTTP的协议</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>在HTTP/1.1的情况下：</p><ol><li>请求 header+body</li><li>响应 header+body</li></ol><p>这样请求和响应，他们的信息都无法被压缩，会导致传输效率低，但是HTTP2.0使得他们能够压缩加密</p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><p>在这个协议下，请求和响应都是使用Stream来进行的，把消息拆成多个Frame进行发送，每个Frame都可以单独的进行优化。</p><p>Frame类型：Headers、Continuation、Data等等，把请求和响应分成多个Frame，每个数据类型都可以单独优化。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><p>请求多路复用</p></li><li><p>Header 压缩</p></li><li><p>默认安全</p><p>​    HTTP ，但很多决定不支持 HTTP</p><p>​    HTTPS</p></li><li><p>Server Push</p></li></ul><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>在没有Server Push的情况下，每个页面的素材例如：css、html等都是必须发送一个单独的请求来进行的。</p><p>在有了Server Push的情况下，但我们的html页面包含css文件的时候，Server Push会自动传输css文件，即使这个html文件还没有进行对css的引用。这样一来，当html文件需要使用的时候，就不用再次发送请求了。节省了一些加载时间。</p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pusher, ok := writer.(http.Pusher); ok &#123; <span class="comment">//先做类型断言，看看存不存在push</span></span><br><span class="line">pusher.Push(<span class="string">"/css/app.css"</span>, &amp;http.PushOptions&#123; <span class="comment">//如果为真，则说明支持server push</span></span><br><span class="line">Header: http.Header&#123;<span class="string">"Content-Type"</span>: []<span class="keyword">string</span>&#123;<span class="string">"text/css"</span>&#125;&#125;, <span class="comment">//使其自加载这个文件</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后启动服务，进入页面，打开F12看看，结果就清晰明了了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来学习，如何对go web应用进行测试：</p><h4 id="测试-Model-层"><a href="#测试-Model-层" class="headerlink" title="测试 Model 层"></a>测试 Model 层</h4><p>可以编写一个单独的go程序进行测试，然后编写测试函数，并且应该注重命名：</p><ul><li><p>user_test.go</p><p>​    测试代码所在文件的名称以 _test 结尾</p><p>​    对于生产编译，不会包含以 _test 结尾的文件</p><p>​    对于测试编译，会包含以 _test 结尾的文件</p></li><li><p>func TestUpdatesModifiedTime(t *testing.T) { … }</p><p>​    测试函数名应以 Test 开头（需要导出）</p><p>​    函数名需要表达出被验证的特性</p><p>​    测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Company)</span> <span class="title">GetCompanyType</span><span class="params">()</span> <span class="params">(result <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(c.Name, <span class="string">".LTD"</span>) &#123;</span><br><span class="line">result = <span class="string">"Limited Liability Company"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = <span class="string">"Others"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用一个极为简易的例子去测试，判断公司的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCompany_GetCompanyType</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google.LTD"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">companyType := c.GetCompanyType() <span class="comment">//获取类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> companyType != <span class="string">"Limited Liability Company"</span> &#123; <span class="comment">//判断</span></span><br><span class="line">t.Error(<span class="string">"this is others!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果测试通过，则会直接显示PASS</span></span><br><span class="line"><span class="comment">//如果测试不通过。结果如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UN   TestCompany_GetCompanyType</span></span><br><span class="line"><span class="comment">    company_test.go:15: this is others!</span></span><br><span class="line"><span class="comment">--- FAIL: TestCompany_GetCompanyType (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这便是测试的结果。</p><h4 id="测试-Controller-层"><a href="#测试-Controller-层" class="headerlink" title="测试 Controller 层"></a>测试 Controller 层</h4><ol><li>为了尽量保证单元测试的隔离性，测试不要使用例如数据库、外部API、文件系统等外部资源。</li><li>模拟请求和响应</li><li>需要使用 net/http/httptest 提供的功能</li></ol><p>这里有几个函数值得关注：</p><h5 id="NewRequest-函数"><a href="#NewRequest-函数" class="headerlink" title="NewRequest 函数"></a>NewRequest 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//method：HTTP Method</span></span><br><span class="line"><span class="comment">//url：请求的 URL</span></span><br><span class="line"><span class="comment">//body：请求的 Body</span></span><br><span class="line"><span class="comment">//返回的 *Request 可以传递给 handler 函数</span></span><br></pre></td></tr></table></figure><h5 id="ResponseRecorder"><a href="#ResponseRecorder" class="headerlink" title="ResponseRecorder"></a>ResponseRecorder</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseRecorder &#123;</span><br><span class="line">  Code <span class="keyword">int</span> <span class="comment">// 状态码  200、500…</span></span><br><span class="line">HeaderMap http.Header <span class="comment">// 响应的 header</span></span><br><span class="line">Body *bytes.Buffer <span class="comment">// 响应的 body</span></span><br><span class="line">Flushed <span class="keyword">bool</span> <span class="comment">// 缓存是否被 flush 了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来捕获从 handler 返回的响应，只是做记录</span></span><br><span class="line"><span class="comment">//可以用于测试断言</span></span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutesController</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, handlerCompany)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerCompany</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := model.Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收到请求后使用JSON编码，并写到响应里面，并返回回去</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着写一个测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httptest"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandleCompanyCorrect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">r := httptest.NewRequest(http.MethodGet, <span class="string">"/companies"</span>, <span class="literal">nil</span>) <span class="comment">//模拟一个请求</span></span><br><span class="line">w := httptest.NewRecorder()                                 <span class="comment">//用于捕获和记录响应</span></span><br><span class="line">handlerCompany(w, r)                                        <span class="comment">//传入Handler</span></span><br><span class="line"></span><br><span class="line">result, _ := ioutil.ReadAll(w.Result().Body) <span class="comment">//获取响应，提取body</span></span><br><span class="line"></span><br><span class="line">c := model.Company&#123;&#125;</span><br><span class="line">json.Unmarshal(result, &amp;c) <span class="comment">//解码并重新放入c这个变量里边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.ID != <span class="number">123</span> &#123; <span class="comment">//然后判断</span></span><br><span class="line">t.Error(<span class="string">"this is a failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过就显示PASS</span></span><br><span class="line"><span class="comment">//否则显示：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">=== RUN   TestHandleCompanyCorrect</span></span><br><span class="line"><span class="comment">    company_test.go:23: this is a failed</span></span><br><span class="line"><span class="comment">--- FAIL: TestHandleCompanyCorrect (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这还是比较方便的</p><h3 id="Profiling-性能分析"><a href="#Profiling-性能分析" class="headerlink" title="Profiling 性能分析"></a>Profiling 性能分析</h3><h4 id="分析的对象"><a href="#分析的对象" class="headerlink" title="分析的对象"></a>分析的对象</h4><ul><li><p>内存消耗</p></li><li><p>CPU 使用</p></li><li><p>阻塞的 goroutine</p></li><li><p>执行追踪</p></li></ul><p>还有一个 Web 界面：应用的实时数据</p><h4 id="如何分析"><a href="#如何分析" class="headerlink" title="如何分析"></a>如何分析</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import _ “<span class="built_in">net</span>/http/pprof”</span><br><span class="line">引入一个包，设置一些监听的 URL，它们会提供各类诊断信息</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/heap   // 内存</span><br><span class="line">从应用获取内存 dump：应用在使用哪些内存，它们会去哪</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/profile    // CPU</span><br><span class="line">CPU 的快照，可以看到谁在用 CPU</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/block // goroutine</span><br><span class="line">看到阻塞的 goroutine</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/trace?seconds=<span class="number">5</span>  // trace</span><br><span class="line">监控这段时间内，什么在执行，什么在调用什么…</span><br><span class="line"></span><br><span class="line"><span class="function">http:// <span class="title">localhost</span>:8000/<span class="title">debug</span>/<span class="title">pprof</span> // 网页</span></span><br></pre></td></tr></table></figure><p>未完待续…….</p><h1 id="使用Go语言编写一个简易的分布式系统"><a href="#使用Go语言编写一个简易的分布式系统" class="headerlink" title="使用Go语言编写一个简易的分布式系统"></a>使用Go语言编写一个简易的分布式系统</h1><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>在一开始我要去学习用go语言编写一个分布式系统的时候。我会在想什么是分布式系统，分布式系统又跟以往的系统有什么很大的差异，或者说区别嘛。带着这个好奇，我去搜索一下什么才是真正的分布式系统，我以为是非常高深，又难以明白的一门学科，但是我仔细了解分布式系统的原理后。我发现我好像学过？！</p><p>以下资料是来源于我在网上搜索得出的信息：</p><blockquote><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h3><p>​            集  群: 同一个业务,部署在多个服务器上</p><p>​            分布式: 同一个业务,拆分成多个子业务,部署在不同的服务器上</p><p>​            微服务: 同一个业务,按照功能模块拆分,每一个服务只对应一个功能模块</p><h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二.区别"></a>二.区别</h3><p>​     <strong>集群</strong>是多台服务器一起处理同一个业务,可以使用负载均衡使得每一个服务器的负载相对平衡,集群中的一台服务器出现问题,该服务器所负责的业务可以由其他的服务器代为处理.集群是一种物理形态.</p><p>​     <strong>分布式</strong>是把一个业务拆分成多个子业务,给不同的服务器去处理,这里的服务器可以是单个的服务器,也可以是多个服务器集群,一旦处理该业务的服务器出现问题,那么该业务就无法实现了.分布式是一种工作方式.</p><p>​     <strong>微服务</strong>是把一个业务中的各种功能模块进行拆分,给不同的服务去处理,每个服务只处理一个功能模块,该服务可以是单个服务器也可以是多个服务器集群,每个服务之间都是低耦合的.微服务是一种架构风格.</p><p>​    <strong>为什么说分布式不一定是微服务:</strong></p><p>​    假设有一个很大应用,拆分成几个小应用,但还是很庞大,即便使用了分布式,但其依旧不算是微服务,因为微服务的核心要素是微小,简单来说就是这个应用还不够小(嗯..没错就是这样!)</p><p>​            所以我们可以理解为:微服务是分布式的一个子集</p><h3 id="三-应用场景"><a href="#三-应用场景" class="headerlink" title="三.应用场景"></a>三.应用场景</h3><p>假设有一个业务,该业务有5个功能,每个功能单独处理需要1个小时.</p><p>此时,如果只部署一台服务器,则需要5个小时才能处理完该业务,若采用集群或者分布式来处理,结果如下:</p><p>​            1.采用集群处理:提供5台服务器一起处理该业务,则处理每个功能只需12分钟,即处理整个业务只需1个小时</p><p>​    2.采用分布式处理:提供5台服务器,每个服务器处理不同的功能,则一共也只需要一个小时.</p><p>​            该情况下,微服务和分布式的工作原理和最终结果是一样的.</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>​            分布式中的每一个节点,都可以做集群.而集群并不一定就是分布式的.</p><p>​            微服务肯定是分布式的,但分布式不一定是微服务的.</p><p>作者：晔歌歌<br>链接：<a href="https://www.jianshu.com/p/5f157ac8efcf" target="_blank" rel="noopener">https://www.jianshu.com/p/5f157ac8efcf</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>所以说分布式系统其实是一个非常广泛的概念，很多的应用都可以是一个分布式系统，所以我想以我曾经学过的知识微服务，这一方面去了解，或者说是使用：<strong>如何用go编写一个微服务</strong>，也就是分布式系统。</p><p>注：我觉得写go还用前后端耦合，并且还用模板，是非常愚蠢的行为。而微服务是天生前后端分离的（战术后仰）。</p><p>总体分为三个部分：服务注册，服务发现，状态监控。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="创建自定义的日志服务"><a href="#创建自定义的日志服务" class="headerlink" title="创建自定义的日志服务"></a>创建自定义的日志服务</h3><h4 id="实现基本逻辑"><a href="#实现基本逻辑" class="headerlink" title="实现基本逻辑"></a>实现基本逻辑</h4><p>目的在于接受请求，并把请求写入到log里面，是很多应用必备的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为标准库也有一个log，所以可以起一个别名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log *stlog.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的在于把日志写入文件系统</span></span><br><span class="line"><span class="keyword">type</span> fileLog <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fl fileLog)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//首先要打开文件，才能写入</span></span><br><span class="line"><span class="comment">//fl文件路径，os...表示没有则创造，只写，只附加，</span></span><br><span class="line">f, err := os.OpenFile(<span class="keyword">string</span>(fl), os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//defer表示程序最后一定会执行的，这句的意思是必须把文件关闭</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">return</span> f.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把log指向某个文件地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(destination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log = stlog.New(fileLog(destination), <span class="string">"go"</span>, stlog.LstdFlags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/log"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//如果请求是post</span></span><br><span class="line">msg, err := ioutil.ReadAll(request.Body) <span class="comment">//先读取内容</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(msg) == <span class="number">0</span> &#123;         <span class="comment">//如果有错误</span></span><br><span class="line">writer.WriteHeader(http.StatusBadRequest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有错误则写入日志</span></span><br><span class="line">write(<span class="keyword">string</span>(msg))</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//对于其他情况，方法就不进行，直接返回</span></span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%v\n"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写好一个基本的日志服务的逻辑，逻辑较为简单。但还需要完善，接下来就要实现能够运行的日志服务。也就是说，还需要把web服务集中化管理，使其能够正常的运行。</p><p>接着创立一个service，去完善服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, serviceName, host, port <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, serviceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完善了服务启动的逻辑，接着还需要去使这个服务能够正常的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line"><span class="string">"Log service"</span>,</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>接着启动服务，并使用postman进行测试:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:4000/log</span></span><br></pre></td></tr></table></figure><p>输入任意文字，就会看到在根目录下，有一个日志文件生成了。</p><h3 id="服务注册的基本逻辑"><a href="#服务注册的基本逻辑" class="headerlink" title="服务注册的基本逻辑"></a>服务注册的基本逻辑</h3><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>首先需要去尝试编写一下，一个可以将服务都注册进去的注册中心。</p><p>先写一个数据结构，注册中心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注册中心包含了各个服务的名字的地址，紧接着，编写服务注册进去之后的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之后，需要让服务独立运行</p><h4 id="独立服务"><a href="#独立服务" class="headerlink" title="独立服务"></a>独立服务</h4><p>接着就需要将之前的服务，注册到服务中心中。</p><p>这就需要创建一个服务中心主要运行逻辑了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将之前的处理逻辑注册进去</span></span><br><span class="line">http.Handle(<span class="string">"/services"</span>, registry.RegistryService&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的逻辑一样，需要有取消功能，当然其实你在ide中能直接打断，但在大型服务中，每秒都要运行。还是需要自定义取消功能的</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">//一样是定义服务的地址</span></span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = registry.ServerPort</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"注册中心 的服务开始。按任意键停止. \n"</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"结束服务注册"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和日志服务的注册类似，没什么特别的,接着测试：</p><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:3000/services</span></span><br></pre></td></tr></table></figure><p>接着输入json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">     <span class="attr">"serviceName"</span>: <span class="string">"study service"</span>,</span><br><span class="line">    <span class="attr">"serviceURL"</span> : <span class="string">" http://localhost/5000/study"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着显示服务注册成功：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">接受请求：</span><br><span class="line">增加服务：study service ，该服务的//localhost/<span class="number">5000</span>/study</span><br></pre></td></tr></table></figure><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><h4 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h4><p>首先微服务的基本含义是：注册中心是一个服务，然后其他的服务注册到注册中心，然后由主要控制台相互控制和调用。</p><p>那么现在会需要一个客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着需要去改一下日志服务的逻辑，使得日志服务会主动去注册自己：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的<strong>registry.RegisterService(reg)</strong>实际上会去调用client的<strong>func RegisterService(r Registration)</strong>，这样会向注册中心发送一个post请求，去注册自己。</p><p>接着，要去改动日志服务的main函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: <span class="string">"log service"</span>,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是增加了<strong>serviceAddress</strong> ，也就是说所有服务都会使用这同一个逻辑。</p><h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>紧接着两个服务连续启动，先启动注册中心，后启动日志逻辑，结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:4000</span><br></pre></td></tr></table></figure><p>很简单对吧，和Spring cloud的微服务简直一模一样。</p><h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h3><p>那么我们把微服务注册进去了，自然能够调用，但是怎么主动去取消微服务呢？它肯定不是说我自己把自己的微服务关了就行了，同时也需要通知注册中心。</p><h4 id="修改注册中心"><a href="#修改注册中心" class="headerlink" title="修改注册中心"></a>修改注册中心</h4><p>直接在注册中心加上一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[i+<span class="number">1</span>:]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后直接在Switch里面增加一个情况Delete：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清晰，就是一模一样的移除服务，总体代码改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心取消服务的方法定义好了，那么也就需要在其他可注册服务的函数体中定义方法。为了进一步的解除耦合度，取消服务的方法和建立服务的方法一样，需要在client里面编写。</p><h4 id="修改客户端"><a href="#修改客户端" class="headerlink" title="修改客户端"></a>修改客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了ShutdownService去结束这个服务。</p><p>紧接着，去开始服务注册的函数里边，进行取消注册的修改：</p><h4 id="修改服务的注册功能"><a href="#修改服务的注册功能" class="headerlink" title="修改服务的注册功能"></a>修改服务的注册功能</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//启动服务，一旦发生可错误，就取消</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是两个goroutine的修改，使其具有取消服务的功能。</p><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>那么注册中心和服务的逻辑都修改好了，然后和上面的步骤一样，先启动注册中心，后启动日志逻辑，结果为:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止.</span><br><span class="line">q</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">移除服务： <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function"><span class="title">http</span>: <span class="title">Server</span> <span class="title">closed</span></span></span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>前面的服务注册都是一对一的，还体现不了分布式的特点。接下来进行多服务注册，使得一个学生成绩的服务既要使用日志服务，也要注册到注册中心</p><h3 id="业务服务"><a href="#业务服务" class="headerlink" title="业务服务"></a>业务服务</h3><h4 id="基本的数据结构与方法"><a href="#基本的数据结构与方法" class="headerlink" title="基本的数据结构与方法"></a>基本的数据结构与方法</h4><p>首先要编写一个学生的基础信息的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生信息</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">int</span></span><br><span class="line">FirstName <span class="keyword">string</span></span><br><span class="line">LastName  <span class="keyword">string</span></span><br><span class="line">Grades    []Grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分数</span></span><br><span class="line"><span class="keyword">type</span> Grade <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Type  GradeType</span><br><span class="line">Score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GradeType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">//考试类型</span></span><br><span class="line">GradeQuiz = GradeType(<span class="string">"Quiz"</span>)</span><br><span class="line">GradeTest = GradeType(<span class="string">"Test"</span>)</span><br><span class="line">GradeExam = GradeType(<span class="string">"Exam"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的平均成绩</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">Average</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">for</span> _, grade := <span class="keyword">range</span> s.Grades &#123;</span><br><span class="line">result += grade.Score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="keyword">float32</span>(<span class="built_in">len</span>(s.Grades))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找学生 by ID</span></span><br><span class="line"><span class="keyword">type</span> Students []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ss Students)</span> <span class="title">GetByID</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*Student, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ss &#123;</span><br><span class="line"><span class="keyword">if</span> ss[i].ID == id &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ss[i], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生的ID：  %d  未找到"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于外部的访问</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">students      Students</span><br><span class="line">studentsMutex sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着肯定得有一些学生的数据，来做测试，这些数据一开始就会被加载进数据结构中，这暂时是用来代替数据库的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">students = []Student&#123;</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">1</span>,</span><br><span class="line">FirstName: <span class="string">"Nick"</span>,</span><br><span class="line">LastName:  <span class="string">"Carter"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">85</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">82</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">2</span>,</span><br><span class="line">FirstName: <span class="string">"Roberto"</span>,</span><br><span class="line">LastName:  <span class="string">"Baggio"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">81</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">3</span>,</span><br><span class="line">FirstName: <span class="string">"Emma"</span>,</span><br><span class="line">LastName:  <span class="string">"Stone"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">67</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">75</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">4</span>,</span><br><span class="line">FirstName: <span class="string">"Rachel"</span>,</span><br><span class="line">LastName:  <span class="string">"McAdams"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">98</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">99</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">5</span>,</span><br><span class="line">FirstName: <span class="string">"Kelly"</span>,</span><br><span class="line">LastName:  <span class="string">"Clarkson"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">95</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">97</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，也肯定要有server，才能正常的启动服务，需要去编写基本的逻辑，比如获取全部学生信息，根据ID进行信息搜索，增加学生信息等功能：</p><h4 id="服务的逻辑"><a href="#服务的逻辑" class="headerlink" title="服务的逻辑"></a>服务的逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="built_in">new</span>(studentsHandler)</span><br><span class="line"><span class="comment">//这个两个地址是不同的，一个是单个页面</span></span><br><span class="line">http.Handle(<span class="string">"/students"</span>, handler)</span><br><span class="line"><span class="comment">//另一个是必须传入参数的页面</span></span><br><span class="line">http.Handle(<span class="string">"/students/"</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以一个链接需要处理很多情况</span></span><br><span class="line"><span class="comment">// /students 分割后长度是2</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125; 分割后长度是3</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125;/grades  分割后长度是4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//简单对字符进行处理：</span></span><br><span class="line">pathSegments := strings.Split(r.URL.Path, <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(pathSegments) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//获取全部信息</span></span><br><span class="line">sh.getAll(w, r)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//查询</span></span><br><span class="line"><span class="comment">//提取id</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.getOne(w, r, id)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//新增</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.addGrade(w, r, id)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取全部学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getAll</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将学生信息全部转为JSON，返回给data，最后写入</span></span><br><span class="line">data, err := sh.toJSON(students)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据ID，搜索学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getOne</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑与获取全部信息几乎一致</span></span><br><span class="line">data, err := sh.toJSON(student)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Printf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加学生成绩信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">addGrade</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的逻辑一样的，没什么好说</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着要从URL中获取到要传达的学生成绩信息</span></span><br><span class="line"><span class="keyword">var</span> g Grade</span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line">err = dec.Decode(&amp;g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这部分逻辑是获取成绩信息</span></span><br><span class="line"><span class="comment">//如果学生成绩获取正确，就附加信息</span></span><br><span class="line">student.Grades = <span class="built_in">append</span>(student.Grades, g)</span><br><span class="line">w.WriteHeader(http.StatusCreated) <span class="comment">//201</span></span><br><span class="line"></span><br><span class="line">data, err := sh.toJSON(g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"applicaiton/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化为JSON</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">toJSON</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">enc := json.NewEncoder(&amp;b)</span><br><span class="line">err := enc.Encode(obj)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，基础逻辑也已经完善了，接着就是在注册中心里增加服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后，得让web服务可以运行，在cmd文件夹下创建一个新的main函数，写入一样的逻辑代码：</p><h4 id="服务启动器"><a href="#服务启动器" class="headerlink" title="服务启动器"></a>服务启动器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么下来，这个业务服务也就完成了，他们可以互相不干扰的进行服务注册，但是现在grade服务还不能去调用日志服务。所以我们还需要服务发现。</p><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现作用能让grade服务可以请求log服务</p><h4 id="去引用日志服务"><a href="#去引用日志服务" class="headerlink" title="去引用日志服务"></a>去引用日志服务</h4><p>首先肯定是要给服务的数据结构增加一些基本信息，这样才能使得服务有这些基本的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该服务所依赖的其他服务。用slice去保存</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line"><span class="comment">//向外暴露的服务端口</span></span><br><span class="line">ServiceUpdateURL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一条目</span></span><br><span class="line"><span class="keyword">type</span> patchEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Name ServiceName</span><br><span class="line">URL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务变化</span></span><br><span class="line"><span class="keyword">type</span> patch <span class="keyword">struct</span> &#123;</span><br><span class="line">Added   []patchEntry</span><br><span class="line">Removed []patchEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以想想，一个服务如果还依赖着其他的服务。那么，当这个服务正要注册的时候，或者说要加入服务群体的时候。就会在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span></span></span><br></pre></td></tr></table></figure><p>进行服务注册，那么这个时候如果服务还依赖其他服务，比如正要注册的grade服务还依赖log服务，这时候就正好可以去获取依赖。</p><p>修改后代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个找到所需要服务并将其注册的过程。</p><p>接着，grade服务会向注册中心请求这些服务，但是注册中心也需要地方去存储这些请求的服务。</p><p>log服务就会向grade服务提供服务，那么会需要一些数据结构去存储：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去实现它的逻辑，总体修改后代码如下：</p><h4 id="服务的提供者"><a href="#服务的提供者" class="headerlink" title="服务的提供者"></a>服务的提供者</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务注册中心要向URL更新一些信息</span></span><br><span class="line">serviceUpdateURL, err := url.Parse(r.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(serviceUpdateURL.Path, &amp;serviceUpdateHandler&#123;&#125;)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err = enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新服务的处理</span></span><br><span class="line"><span class="keyword">type</span> serviceUpdateHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suh serviceUpdateHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先进行解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line">err := dec.Decode(&amp;p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf("收到更新： %v\n", p)</span></span><br><span class="line">prov.Update(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受到patch的时候，需要进行更新，</span></span><br><span class="line"><span class="keyword">var</span> prov = providers&#123;</span><br><span class="line">services: <span class="built_in">make</span>(<span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span>),</span><br><span class="line">mutex:    <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span> <span class="title">Update</span><span class="params">(pat patch)</span></span> &#123;</span><br><span class="line"><span class="comment">//对传进来的patch更新provider</span></span><br><span class="line">p.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增的情况</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Added &#123;</span><br><span class="line"><span class="comment">//如果这个服务名目前还不存在，就创建新的slice</span></span><br><span class="line"><span class="keyword">if</span> _, ok := p.services[patchEntry.Name]; !ok &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在的话，就在值后边附加URL</span></span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(p.services[patchEntry.Name],</span><br><span class="line">patchEntry.URL)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少的情况</span></span><br><span class="line"><span class="comment">//遍历，对比，移除</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Removed &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs, ok := p.services[patchEntry.Name]; ok &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> providerURLs &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs[i] == patchEntry.URL &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(providerURLs[:i],</span><br><span class="line">providerURLs[i+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后还需要，根据服务的名称来找到它所依赖服务的url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span> <span class="title">get</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">providers, ok := p.services[name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"没有可提供服务的提供商： %v"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机数</span></span><br><span class="line">idx := <span class="keyword">int</span>(rand.Float32() * <span class="keyword">float32</span>(<span class="built_in">len</span>(providers)))</span><br><span class="line"><span class="keyword">return</span> providers[idx], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于这个get方法是私有的，对外再套一个函数：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvider</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> prov.get(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端的client"><a href="#客户端的client" class="headerlink" title="客户端的client"></a>客户端的client</h4><p>log服务现在有服务端的逻辑，但是客户端的服务想使用这个client还是比较麻烦的，所以还需要对log服务有一个自己的client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写日志，把日志写到server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetClientLogger</span><span class="params">(serviceURL <span class="keyword">string</span>, clientService registry.ServiceName)</span></span> &#123;</span><br><span class="line">stlog.SetPrefix(fmt.Sprintf(<span class="string">"[%v] - "</span>, clientService))</span><br><span class="line">stlog.SetFlags(<span class="number">0</span>)</span><br><span class="line">stlog.SetOutput(&amp;clientLogger&#123;url: serviceURL&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> clientLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">url <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl clientLogger)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">b := bytes.NewBuffer([]<span class="keyword">byte</span>(data))</span><br><span class="line"><span class="comment">//写到服务端</span></span><br><span class="line">res, err := http.Post(cl.url+<span class="string">"/log"</span>, <span class="string">"text/plain"</span>, b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to send log message. Service responded with %d - %s"</span>, res.StatusCode, res.Status)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果都没有问题，返回数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以让本地的日志服务写好日志后发送到服务器端保存</p><h4 id="使main函数具有服务发现的功能"><a href="#使main函数具有服务发现的功能" class="headerlink" title="使main函数具有服务发现的功能"></a>使main函数具有服务发现的功能</h4><p>主要是使得两个启动器拥有新的功能：</p><h5 id="grading-service"><a href="#grading-service" class="headerlink" title="grading service"></a>grading service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: []registry.ServiceName&#123;registry.LogService&#125;,</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在服务启动之后使用log服务</span></span><br><span class="line"><span class="keyword">if</span> logProvider, err := registry.GetProvider(registry.LogService); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"发现日志服务: %s\n"</span>, logProvider)</span><br><span class="line">log.SetClientLogger(logProvider, r.ServiceName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="log-service"><a href="#log-service" class="headerlink" title="log service"></a>log service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.LogService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: <span class="built_in">make</span>([]registry.ServiceName, <span class="number">0</span>),</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来便可以测试了。</p><h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><p>按照：registryservice，logservice，gradingservice的顺序启动，测试结果如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span> </span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">GradingService 服务开始。按任意键停止.</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br></pre></td></tr></table></figure><p>这么一来就完成了。</p><h3 id="依赖变化"><a href="#依赖变化" class="headerlink" title="依赖变化"></a>依赖变化</h3><h4 id="重新发现服务"><a href="#重新发现服务" class="headerlink" title="重新发现服务"></a>重新发现服务</h4><p>可以从上述的情况下看到一些不那么方便的点，一是：启动必须按照顺序来，不能随意。二是：当log服务下线后，再上线的话不会被再次发现。这都是服务极为脆弱的表现。那么解决这个问题的最好方法是：使服务具有依赖变化时进行通知的功能。</p><p>可以在服务中更改，使其具备通知的功能,主要是有notify函数，总体修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务通知，当服务上线，而这个服务又被依赖时，告知依赖服务自己上线了</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Added: []patchEntry&#123;</span><br><span class="line">patchEntry&#123;</span><br><span class="line">Name: reg.ServiceName,</span><br><span class="line">URL:  reg.ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">notify</span><span class="params">(fullPatch patch)</span></span> &#123;</span><br><span class="line">r.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> r.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//看看服务的依赖在patch里面存不存在</span></span><br><span class="line"><span class="comment">//对已经注册的服务循环遍历</span></span><br><span class="line"><span class="keyword">for</span> _, reg := <span class="keyword">range</span> r.registrations &#123;</span><br><span class="line"><span class="comment">//并发的发出通知</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reg Registration)</span></span> &#123;</span><br><span class="line"><span class="comment">//对服务所需要的服务进行循环</span></span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line">p := patch&#123;Added: []patchEntry&#123;&#125;, Removed: []patchEntry&#123;&#125;&#125;</span><br><span class="line"><span class="comment">//标志位，为TRUE表示有需要更新的地方</span></span><br><span class="line">sendUpdate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, added := <span class="keyword">range</span> fullPatch.Added &#123;</span><br><span class="line"><span class="comment">//如果添加的服务正好是某个服务的依赖项</span></span><br><span class="line"><span class="keyword">if</span> added.Name == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, added)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看有哪些服务停止了</span></span><br><span class="line"><span class="keyword">for</span> _, removed := <span class="keyword">range</span> fullPatch.Removed &#123;</span><br><span class="line"><span class="comment">///如果停掉的服务正好是所被依赖的服务</span></span><br><span class="line"><span class="keyword">if</span> removed.Name == reqService &#123;</span><br><span class="line">p.Removed = <span class="built_in">append</span>(p.Removed, removed)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后判断标志位，把更新发送到对应的服务</span></span><br><span class="line"><span class="keyword">if</span> sendUpdate &#123;</span><br><span class="line">err := r.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(reg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><p>接着再进行测试，可以看到，当log服务下线后，重新上线时，grading 服务就能够发现log服务了。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125; &#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br></pre></td></tr></table></figure><h4 id="服务下线告知"><a href="#服务下线告知" class="headerlink" title="服务下线告知"></a>服务下线告知</h4><p>接着也容易，把remove方法里面添加下线告知的功能就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下线也告知</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Removed: []patchEntry&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: registry.registrations[i].ServiceName,</span><br><span class="line">URL:  registry.registrations[i].ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//下线告知</span></span><br><span class="line"></span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这部分逻辑就完成了。接下来测试代码。</p><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><p>测试的步骤是先开启注册中心，再开启日志服务，后开始grade服务。然后使得日志服务停止，再重启。可以看到一系列的结果。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span></span><br><span class="line">移除服务： http://localhost:<span class="number">4000</span></span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line">收到更新： &#123;[] []&#125;</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"><span class="title">LogService</span> 服务开始。按任意键停止</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">GradingService</span> 服务开始。按任意键停止.</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br><span class="line"><span class="function">发现日志服务: <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function">收到更新： &#123;[] [&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;]&#125;</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br></pre></td></tr></table></figure><p>使用解除了耦合的网络接口，这也是Spring Cloud的微服务思想，同时也是分布式的一种类型。所以说分布式也没什么神奇之处，最核心的一处在于：<strong>把本地接口转化为了网络接口</strong>。能够理解这一过程，也就理解了分布式的思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Go语言编写一个web-分布式应用&quot;&gt;&lt;a href=&quot;#使用Go语言编写一个web-分布式应用&quot; class=&quot;headerlink&quot; title=&quot;使用Go语言编写一个web/分布式应用&quot;&gt;&lt;/a&gt;使用Go语言编写一个web/分布式应用&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="Golang" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>go语言学习遇到的问题</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-language-error-problem/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-language-error-problem/</id>
    <published>2022-04-27T12:54:36.000Z</published>
    <updated>2022-05-09T05:57:34.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go语言学习遇到的问题"><a href="#go语言学习遇到的问题" class="headerlink" title="go语言学习遇到的问题"></a>go语言学习遇到的问题</h1><p>最近在努力学习go，这个编程语言语法和写法的都和其他的编程语言有着比较大的差异。所以特地记录一下学习go遇到的问题。</p><h2 id="GOPATH和go-module"><a href="#GOPATH和go-module" class="headerlink" title="GOPATH和go module"></a>GOPATH和go module</h2><p>这个问题比较神奇，也是我学习这个编程语言中遇到的比较拧巴的问题。网上的绝大多数的教程都会让你配置GOPATH，然后go程序都必须在GOPATH的SRC这个文件下运行，而这个GOPATH是你windows的环境变量。</p><p><strong>在以前GOPATH下会对go程序的编写严格进行，必须在src下，并且在很多包，或者git下其他的程序之后，整个项目就会变得非常混乱</strong>。</p><p>这样听起来很奇怪不是吗？身为一个比较新鲜的编程语言，既然会有这么愚蠢的方法。</p><p>而网上的教程绝大多数度是让你去配置环境，最后用vscode去编写go程序，但是我自己在用IDEA去写的时候却不会遇到要配置GOPATH这个问题，这是为什么呢？然后我去网上进行了一番搜索之后，了解了一个新鲜的事物，叫做go module。</p><p>而go 1.13版本之后就支持了go module，这使得程序的编写不用在指定的文件夹进行，而是用模块化的方式去编写程序。</p><p>而现在，在有了MODULE之后，GOPATH现在常用于存放第三方API，不进行程序编写了。go module允许go在任意地方进行编写，非常人性化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当你在GOPATH下使用go module时</span><br><span class="line">用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</span><br><span class="line"></span><br><span class="line">GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</span><br><span class="line">GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</span><br><span class="line">GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。</span><br><span class="line">但是我建议新开别的文件夹去写go程序，不要在GoPATH下</span><br></pre></td></tr></table></figure><p>所以，我们应该<strong>使用 go mod init your_project_name</strong></p><p>去实现go的模块化编写</p><p>未完待续。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go语言学习遇到的问题&quot;&gt;&lt;a href=&quot;#go语言学习遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;go语言学习遇到的问题&quot;&gt;&lt;/a&gt;go语言学习遇到的问题&lt;/h1&gt;&lt;p&gt;最近在努力学习go，这个编程语言语法和写法的都和其他的编程语言有着比</summary>
      
    
    
    
    
    <category term="Golang" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>个人项目--SpringBoot+Vue商城</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/02/06/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C3/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/02/06/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C3/</id>
    <published>2021-02-06T10:02:24.000Z</published>
    <updated>2022-04-27T11:40:51.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人项目–SpringBoot-Vue电商平台"><a href="#个人项目–SpringBoot-Vue电商平台" class="headerlink" title="个人项目–SpringBoot+Vue电商平台"></a>个人项目–SpringBoot+Vue电商平台</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人做了一个交易平台，后端是SpringBoot，前端是Vue。这个电商平台有分<strong>商家页面</strong>和<strong>普通用户页面</strong>，后续还会增加一个独属于<strong>管理员的页面</strong>。这个电商平台通过<strong>QQ登录进行注册</strong>，并且为每一个注册的的用户分配一个默认好友，可以进行聊天，每一个普通的用户都可以通过申请提交成为一名商家，成为商家之后才可以进行增加自家的商品。</p><p>其实本人之前也做过一个前后的耦合的thymeleaf和SpringBoot的商城，后续也曾想过下一个项目是不是该做一个博客，音乐平台，或者是视频网站，最后考虑到，用工具的方法有千千万万，重要的是对工具的了解程度如何，你能不能更加深入的对单个方面有较为深刻的理解，于是这个项目也是一个电商平台，但在实现了前后端分离的同时，还加入了很多新的技术，并且在一些方面有了更为优秀的解决方案。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>看文章有时候就和看别人家的注释一样，不一定能快速分清楚对方的注释是关键语句还是在水代码行数，所以前面先列出本人做的项目的特点，节约一下阅读的时间，后面会有较为详细的描述。</p><p><strong>实现的模板</strong>：基本CRUD和购物车，秒杀商品，搜索，Socket通信，security安全拦截，微服务等。</p><p><strong>一些特点</strong>：</p><ul><li>使用了redis，在用户访问商品时候会把商品放入redis缓存器，减少数据库的频繁访问，并且使用redis集群实现数据的安全</li><li>使用了redis实现了商品的秒杀，对突然间大量的请求会将其放入redis而不放入数据库，等秒杀活动过了一定时间再使用定时任务，慢慢写入数据库，由于redis的单线程保证了秒杀的安全，也减少了数据库的访问压力，后续的云服务还可以通过将商品放入消息队列的方式，进一步提高性能。</li><li>图片的类型是String，而不是流文件，这里结合了七牛云做图床，实现图片数据库和本地数据库的分离</li><li>每一个用户会有一个默认的好友，以用来测试socket模块，socket模块实现了用户的实时在线聊天，并且还会保存用户的聊天信息。</li><li>申请了QQ互联的功能，只需要QQ扫码便可以进行登录，QQ互联是和VUE 进行结合的，会产生一个全局的JWT来保证用户的权限认证，后端的security也是用JWT来和前端进行权限认证</li><li>搜索模块结合了Elasticsearch，以便于用户进行模糊类型的搜索</li><li>商品平台里面的数据是使用Jsoup爬虫从京东爬取而来的，并且使用雪花算法为每一个商品生成了一个全局唯一的UID</li><li>结合eureka和ribbon实现注册中心和负载均衡，降低访问压力</li></ul><h2 id="项目讲述"><a href="#项目讲述" class="headerlink" title="项目讲述"></a>项目讲述</h2><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><ol><li>SpringBoot （后端）</li><li>MySQL （数据库）</li><li>MyBatis （访问数据库）</li><li>swagger （集成文档）</li><li>SpringSecurity （登录与权限控制）</li><li>JWT （单点登录）</li><li>Jsoup （爬虫，用于补充数据库的数据）</li><li>fastjson （转JSON工具，用于前后端数据交互）</li><li>七牛云 （图床）</li><li>netty-socketio （用于用户之间的通信）</li><li>qq互联 （实现QQ登录）</li><li>redis （中间件，用于数据的缓存）</li><li>elasticsearch （搜索引擎）</li><li>spring-boot-admin （管理后台）</li><li>eureka （微服务的注册中心）</li><li>ribbon （负载均衡）</li><li>docker （容器化）</li><li>Nginx （反向代理）</li><li>aliyunEcs （服务器）</li><li>vue （前端）</li><li>axios （前端api） </li><li>Element-ui （前端UI）</li></ol><h3 id="基本CRUD"><a href="#基本CRUD" class="headerlink" title="基本CRUD"></a>基本CRUD</h3><p>无聊的操作总是千篇一律，有意思的源码也可能涉及跨域。</p><p>一个基本的CRUD，是由mybatis来操作mysql数据库来实现的，mybatis其实也很讲究，有一级缓存二级缓存等等很多原理，mysql也有innodb等等知识，然而这东西在讲系统时讲出来比较麻烦，所以在这篇展示项目的文章中，我仅仅根据我的所写的代码去讲述为什么需要这么写，暂时不写这些工具的原理。</p><p>这个是mybatis中mapper的规范，所有的命名都是根据以下来确定的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">countByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * delete by primary key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id primaryKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deleteCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert record to table</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> insert count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrUpdate</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrUpdateSelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert record to table selective</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> insert count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">selectByExample</span><span class="params">(ProductExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * select by primary key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id primary key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object by primary key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Product <span class="title">selectByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleSelective</span><span class="params">(@Param(<span class="string">"record"</span>)</span> Product record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> ProductExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExample</span><span class="params">(@Param(<span class="string">"record"</span>)</span> Product record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> ProductExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update record selective</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the updated record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update record</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the updated record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(Product record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBatch</span><span class="params">(List&lt;Product&gt; list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">batchInsert</span><span class="params">(@Param(<span class="string">"list"</span>)</span> List&lt;Product&gt; list)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中运用到了插件mybatiscodehelper</p><p>在控制层中有一个 <strong>BaseController</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而全部的控制器都是通过继承来实现依赖注入的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span>  <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样继承省去了很多代码量</p><p>在后端中，购物车模块的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/add_all_cart_order"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">add_all_cart_order</span><span class="params">(@Validated @RequestBody List&lt;OrderSheet&gt; orderSheets , HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    BigDecimal sum=<span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (OrderSheet o:orderSheets) &#123;<span class="comment">//List&lt;OrderSheet&gt; orderSheets</span></span><br><span class="line">        sum.add(o.getSumMoney());</span><br><span class="line">    &#125;</span><br><span class="line">    String state=<span class="string">"余额不足"</span>;</span><br><span class="line">    User user=userService.selectById(orderSheets.get(<span class="number">0</span>).getUserId());</span><br><span class="line">    BigDecimal money=user</span><br><span class="line">            .getMoney()</span><br><span class="line">            .subtract(sum);</span><br><span class="line">    <span class="keyword">if</span> (money.compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">0</span>))==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (OrderSheet o:orderSheets) &#123;<span class="comment">//List&lt;OrderSheet&gt; orderSheets</span></span><br><span class="line">        o.setState(<span class="string">"未收货"</span>);</span><br><span class="line">        orderSheetService.insert(o);</span><br><span class="line">        shoppingCartService.deleteByPrimaryKey(o.getId());</span><br><span class="line">        user.setMoney(user.getMoney().subtract(sum));</span><br><span class="line">        userService.updateByPrimaryKey(user);</span><br><span class="line">        state=<span class="string">"支付成功"</span>;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(state);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数支付方面的代码都与其类似。</p><h3 id="秒杀商品"><a href="#秒杀商品" class="headerlink" title="秒杀商品"></a>秒杀商品</h3><p>首先我先举例一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addorder"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">add_order</span><span class="params">(@Validated @RequestBody OrderSheet orderSheet, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        orderSheet.setId(<span class="keyword">new</span> RandomId().nextId());</span><br><span class="line">        orderSheet.setTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        Product product=productService.selectOneById(orderSheet.getProductId());</span><br><span class="line">        orderSheet.setSumMoney(product.getPrice().multiply(<span class="keyword">new</span> BigDecimal(orderSheet.getAmount())));</span><br><span class="line"><span class="comment">//        redis缓存放入</span></span><br><span class="line">        Boolean success=orderRedis.addOrderByRedis(orderSheet);</span><br><span class="line">        String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(message, <span class="string">"抢购失败"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.succ(message);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        redis缓存放入</span></span><br><span class="line">        orderSheetService.insert(orderSheet);</span><br><span class="line">        <span class="keyword">return</span> Result.succ(JSONObject.toJSONString(orderSheet.getId(),<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>orderSheetService</strong>就是可以被替换为秒杀模块，通过<strong>orderRedis.addOrderByRedis</strong>来实现将商品放入redis，而不涉及数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRedisImpl</span> <span class="keyword">implements</span> <span class="title">OrderRedis</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">addOrderByRedis</span><span class="params">(OrderSheet orderSheet)</span> </span>&#123;</span><br><span class="line">        Long productId = orderSheet.getProductId();</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!jedis.exists(<span class="string">"product_stock_"</span>+productId))&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = jedis.get((<span class="string">"get_product_"</span>+productId).getBytes());</span><br><span class="line">                Product p =(Product) SerializeUtil.unserialize(bytes);</span><br><span class="line">                jedis.set(<span class="string">"product_stock_"</span>+productId,p.getStock()+<span class="string">""</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis.get(<span class="string">"product_stock_"</span>+productId).equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                jedis.decrBy(<span class="string">"product_stock_"</span>+productId , <span class="number">1</span>);</span><br><span class="line">                jedis.lpush((<span class="string">"order_product_"</span>+productId).getBytes() ,SerializeUtil.serialize(orderSheet));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.destroy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法比较简易，这里使用的是Jedis，通过从线程池里获取Jedis的方式保证了Jedis的线程安全，然后由于redis是单线程的，所以Jedis的API的所有操作都具有着原子性。以此实现线程安全的同时能够把数据放入redis 当中，然后通过<strong>TaskService</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 每天半夜1点钟开始执行任务</span></span><br><span class="line"><span class="comment">//    @Scheduled(cron = "0 0 1 * * ?")</span></span><br><span class="line">    <span class="comment">// 下面是用于测试的配置，每分钟执行一次任务</span></span><br><span class="line">     <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"localhost"</span>);</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"定时任务开始......"</span>);</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; bytes=jedis.lrange(<span class="string">"order_product_885036"</span>.getBytes(), <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span>[] b:bytes) &#123;</span><br><span class="line">            OrderSheet orderSheet =(OrderSheet) SerializeUtil.unserialize(b);</span><br><span class="line">            System.out.println(JSON.toJSONString(orderSheet));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"定时任务结束......"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/// ... 当关闭应用程序时:</span></span><br><span class="line">        pool.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后半夜时分，再将任务写入数据库。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索模块用的是Elasticsearch，这里不得不吐槽一下Elasticsearch的Api更新速度飞快，版本更新也很快，动不动就方法废弃，部署起来真的是不容易：</p><p>现在版本，根据官方文档来看，需要配置  <strong>RestHighLevelClient</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientConfiguration configuration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">"192.168.78.128:9200"</span>)</span><br><span class="line"><span class="comment">//                .connectedTo("localhost:9200")</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//.withConnectTimeout(Duration.ofSeconds(5))</span></span><br><span class="line">                <span class="comment">//.withSocketTimeout(Duration.ofSeconds(3))</span></span><br><span class="line">                <span class="comment">//.useSsl()</span></span><br><span class="line">                <span class="comment">//.withDefaultHeaders(defaultHeaders)</span></span><br><span class="line">                <span class="comment">//.withBasicAuth(username, password)</span></span><br><span class="line">                <span class="comment">// ... other options</span></span><br><span class="line">                .build();</span><br><span class="line">        RestHighLevelClient client = RestClients.create(configuration).rest();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过继承<strong>ElasticsearchRepository</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span> ,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findAllByNameLike</span><span class="params">(String  name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/es_search_product_by_name/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">es_search_product_by_name</span><span class="params">(@PathVariable(name = <span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">    List&lt;Product&gt; allByNameLike = productRepository.findAllByNameLike(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(allByNameLike);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聊天模块"><a href="#聊天模块" class="headerlink" title="聊天模块"></a>聊天模块</h3><p>聊天模块需要配置<strong>SocketIoConfig</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.bossCount&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bossCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.workCount&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.allowCustomRequests&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowCustomRequests;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.upgradeTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> upgradeTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.pingTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pingTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;socketio.pingInterval&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下配置在上面的application.yml中已经注明</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例化socketIo的服务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SocketConfig socketConfig = <span class="keyword">new</span> SocketConfig();</span><br><span class="line">        socketConfig.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">        socketConfig.setSoLinger(<span class="number">0</span>);</span><br><span class="line">        com.corundumstudio.socketio.Configuration config = <span class="keyword">new</span> com.corundumstudio.socketio.Configuration();</span><br><span class="line">        config.setSocketConfig(socketConfig);</span><br><span class="line">        <span class="comment">//线上不能使用hostname，血坑</span></span><br><span class="line"><span class="comment">//        config.setHostname(host);</span></span><br><span class="line">        config.setPort(port);</span><br><span class="line">        config.setBossThreads(bossCount);</span><br><span class="line">        config.setWorkerThreads(workCount);</span><br><span class="line">        config.setAllowCustomRequests(allowCustomRequests);</span><br><span class="line">        config.setUpgradeTimeout(upgradeTimeout);</span><br><span class="line">        config.setPingTimeout(pingTimeout);</span><br><span class="line">        config.setPingInterval(pingInterval);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不得不再提一下，聊天记录所用的类有哪些属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"com-sodse-trade-domain-ChatRecord"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRecord</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是自己发送为1，不是自己发送为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"是自己发送为1，不是自己发送为0"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer isSend;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 聊天对象id</span></span><br><span class="line"><span class="comment">     * 每当用户发送一条信息，都会写入一次数据库，其中is_send为1表示自己发的，然后同时给被接受者反向写入id但是send值为0，表示被接收。</span></span><br><span class="line"><span class="comment">     * 第二，当用户删除自己的聊天框时，使用delete把该用户id和对象的id全部满足的记录删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"聊天对象id ,每当用户发送一条信息，都会写入一次数据库，其中is_send为1表示自己发的，然后同时给被接受者反向写入id但是send值为0，表示被接收。,第二，当用户删除自己的聊天框时，使用delete把该用户id和对象的id全部满足的记录删除"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long talkerId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最为关键的方法<strong>SocketIoService</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"socketIOService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoServiceImpl</span> <span class="keyword">implements</span> <span class="title">SocketIoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存已连接的客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketIOClient&gt; clientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * socketIo的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SocketIOServer socketIOServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：当前的service被初始化的时候执行以下的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoStartUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：当我们的系统停止的时候关闭我们的socketIo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">autoStop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听客户端连接</span></span><br><span class="line">        socketIOServer.addConnectListener(client -&gt; &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此处实现我们的socket的连接的用户的逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String loginUser = getParamsByClient(client).get(<span class="string">"loginUser"</span>).get(<span class="number">0</span>);</span><br><span class="line">            clientMap.put(loginUser, client);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听客户端断开连接</span></span><br><span class="line">        socketIOServer.addDisconnectListener(client -&gt; &#123;</span><br><span class="line">            String loginUser = getParamsByClient(client).get(<span class="string">"loginUser"</span>).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (loginUser != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(loginUser)) &#123;</span><br><span class="line">                clientMap.remove(loginUser);</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理自定义的事件，与连接监听类似</span></span><br><span class="line">        socketIOServer.addEventListener(PUSH_EVENT, PushMessage<span class="class">.<span class="keyword">class</span>, (<span class="title">client</span>, <span class="title">data</span>, <span class="title">ackSender</span>) -&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// TODO do something</span></span><br><span class="line">        &#125;);</span><br><span class="line">        socketIOServer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socketIOServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            socketIOServer.stop();</span><br><span class="line">            socketIOServer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：发送消息到前端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushMessage 发送消息的实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMessageToUser</span><span class="params">(PushMessage pushMessage)</span> </span>&#123;</span><br><span class="line">        clientMap.get(pushMessage.getLoginUser()).sendEvent(PUSH_EVENT, pushMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法为获取client连接中的参数，可根据需求更改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; getParamsByClient(SocketIOClient client) &#123;</span><br><span class="line">        <span class="comment">// 从请求的连接中拿出参数</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = client.getHandshakeData().getUrlParams();</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最为关键的语句我认为应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketIOClient&gt; clientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>通过建立一个<strong>ConcurrentHashMap</strong>，socket能够检测用户是否在线，在线就将用户put进ConcurrentHashMap，不在线就将其移除，若被发送消息的用户在线时，socket就会将这个消息通过ConcurrentHashMap中获得的用户信息来发送给相应的用户，这个特点在于这是后端主动发起消息给前端的，也是我在考虑到了聊天消息是怎么产生的时候，所了解的。</p><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>之前实现过一个前后端耦合的商城，那里的Security配置都比较简单，而这里用的是前后端分离的vue和springboot结合，两者甚至都不在同一个端口，所以这里的security配置也有了很大的改观，并且利用了jwt来作为两个端口的认证凭证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( AuthenticationManagerBuilder auth )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService( myUserDetailsService ).passwordEncoder( <span class="keyword">new</span> BCryptPasswordEncoder() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( HttpSecurity httpSecurity )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line"></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line"></span><br><span class="line">                <span class="comment">//关闭防护</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(<span class="string">"/"</span>).permitAll()<span class="comment">//允许/、/login的访问</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(<span class="string">"/user"</span>).hasRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/user下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin"</span>).hasRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/register"</span>).permitAll()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启跨域</span></span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line"><span class="comment">//                .exceptionHandling().accessDeniedPage("/accessDenied")</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用的是：<strong>auth.userDetailsService( myUserDetailsService ).passwordEncoder( new BCryptPasswordEncoder() );</strong>也就是myUserDetailsService所继承的UserDetails通过重写方法来进行的密码认证。</p><p>在登录阶段，使用的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServiceImpl</span> <span class="keyword">implements</span> <span class="title">AuthService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">( String username, String password )</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken upToken = <span class="keyword">new</span> UsernamePasswordAuthenticationToken( username, password );</span><br><span class="line">        <span class="keyword">final</span> Authentication authentication = authenticationManager.authenticate(upToken);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        <span class="keyword">final</span> UserDetails userDetails = userDetailsService.loadUserByUsername( username );</span><br><span class="line">        <span class="keyword">final</span> String token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">register</span><span class="params">( User userToAdd )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String username = userToAdd.getUsername();</span><br><span class="line">        <span class="keyword">if</span>( !userService.findByUsername(username).isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当用户不存在时</span></span><br><span class="line">        userToAdd=qq_register(userToAdd);</span><br><span class="line">        <span class="comment">//qq注册的处理</span></span><br><span class="line">        BCryptPasswordEncoder encoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        <span class="keyword">final</span> String rawPassword = userToAdd.getPassword();</span><br><span class="line">        userToAdd.setPassword( encoder.encode(rawPassword) );</span><br><span class="line">        <span class="keyword">return</span> userService.insert(userToAdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>jwtTokenUtil.generateToken(userDetails)</strong>，来对Security内置的UserDetails生成JWT</p><p>这里还有一个JWT的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span> <span class="params">( HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String authHeader = request.getHeader( Const.HEADER_STRING );</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith( Const.TOKEN_PREFIX )) &#123;</span><br><span class="line">            <span class="keyword">final</span> String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                        UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                                userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                        authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                                request));</span><br><span class="line">                        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这拦截器首先在<strong>WebSecurityConfig</strong>中被定义了，Security就会使用这个拦截器来作为<strong>authenticationTokenFilter</strong>的认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>在这一模块仅仅使用了eureka和ribbon，eureka作为注册中心，而ribbon作为负载均衡，当然，后续可以使用feign来进行负载均衡。并且还可在多模块的时候再继续使用Hystrix来实现服务熔断，以及和zipkin来实现分布式的链路追踪。</p><p>新建一个工程，配置eureka-server,并且在application.yml文件中配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">eureka_server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">      <span class="attr">hostname:</span> <span class="string">eureka_server_8761</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">service-url:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>同样的在原来的主体工程中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#注册服务的时候使用ip</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">service-url:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>就已经实现了注册中心，然后就是负载均衡：</p><p>在主体工程中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启发现服务功能</span></span><br></pre></td></tr></table></figure><p>并且添加RestTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span><span class="comment">//使用负载均衡机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而controller中注入RestTemplate来实现负载均衡。</p><p>后续暂无。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;个人项目–SpringBoot-Vue电商平台&quot;&gt;&lt;a href=&quot;#个人项目–SpringBoot-Vue电商平台&quot; class=&quot;headerlink&quot; title=&quot;个人项目–SpringBoot+Vue电商平台&quot;&gt;&lt;/a&gt;个人项目–SpringBoot+V</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Docker/"/>
    
    <category term="MyBatis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/MyBatis/"/>
    
    <category term="MySQL" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/MySQL/"/>
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="ElasticSearch" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/ElasticSearch/"/>
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
    <category term="七牛云" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
    <category term="JWT" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/JWT/"/>
    
    <category term="项目" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
    <category term="Element—ui" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Element%E2%80%94ui/"/>
    
    <category term="SpringSecurity" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringSecurity/"/>
    
    <category term="REST" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker搭建Redis集群</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/02/01/redis5/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/02/01/redis5/</id>
    <published>2021-02-01T09:56:45.000Z</published>
    <updated>2022-05-09T14:21:25.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Docker搭建Redis集群"><a href="#使用Docker搭建Redis集群" class="headerlink" title="使用Docker搭建Redis集群"></a>使用Docker搭建Redis集群</h2><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先需要使用docker下载安装好redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5.0.2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span> 到 /root/workspace/</span></span><br><span class="line">mkdir -p  /docker/redis-node01/data</span><br><span class="line">mkdir -p  /docker/redis-node02/data</span><br><span class="line">mkdir -p  /docker/redis-node03/data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署Redis集群，该集群有3个节点 </span></span><br><span class="line">docker create --name redis-node01 --privileged=true -v /root/workspace/docker/redis-node01/data:/data -p 6379:6379 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-01.conf --port 6379</span><br><span class="line"></span><br><span class="line">docker create --name redis-node02 --privileged=true -v /root/workspace/docker/redis-node02/data:/data -p 6380:6380 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-02.conf --port 6380</span><br><span class="line"></span><br><span class="line">docker create --name redis-node03 --privileged=true -v /root/workspace/docker/redis-node03/data:/data -p 6381:6381 redis:5.0.2 --cluster-enabled yes --cluster-config-file nodes-node-03.conf --port 6381</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span></span><br><span class="line">docker start redis-node01 redis-node02 redis-node03</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/1.png" alt="图"></p><p>启动完容器后查看容器IP,这一步极为关键</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器ip</span></span><br><span class="line">docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' redis-node01 redis-node02 redis-node03</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/2.png" alt="图"></p><p>接着为第一个节点搭建集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入redis-node01容器进行操作</span></span><br><span class="line">docker exec -it redis-node01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建redis集群</span></span><br><span class="line">redis-cli --cluster create 172.17.0.3:6379 172.17.0.4:6380 172.17.0.5:6381 --cluster-replicas 0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/3.png" alt="图"></p><p><strong>搭建完成，查看集群信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看集群信息</span></span><br><span class="line"> redis-cli</span><br><span class="line"> 127.0.0.1:6379&gt; cluster nodes</span><br><span class="line"> </span><br><span class="line"> 127.0.0.1:6379&gt; cluster info</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/4.png" alt="图"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>然后使用redis可视化工具测试一下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/5.png" alt="图"></p><p>为节点增加值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/6.png" alt="图"></p><p>查看值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2021%E5%B9%B42%E6%9C%8817/7.png" alt=""></p><p>搭建完成了，非常之简单</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用Docker搭建Redis集群&quot;&gt;&lt;a href=&quot;#使用Docker搭建Redis集群&quot; class=&quot;headerlink&quot; title=&quot;使用Docker搭建Redis集群&quot;&gt;&lt;/a&gt;使用Docker搭建Redis集群&lt;/h2&gt;&lt;h3 id=&quot;搭建&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>关于Elasticsearch和spring-es—Data的实战汇总</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/01/15/es1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/01/15/es1/</id>
    <published>2021-01-15T09:56:11.000Z</published>
    <updated>2021-04-26T17:01:58.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Elasticsearch和spring-es—Data的实战汇总"><a href="#关于Elasticsearch和spring-es—Data的实战汇总" class="headerlink" title="关于Elasticsearch和spring-es—Data的实战汇总"></a>关于Elasticsearch和spring-es—Data的实战汇总</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Elasticsearch是一个搜索的服务器，可以抽象为类似数据库的一样的东西。但是它本身的作用并不抽象，很大的业务作用都与数据库有着很大的重合。原理是倒排索引，这篇文章就不细说了</p><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>比如说，在我们需要使用数据库进行搜索的时候，直接模糊查询就好了 <strong>select id from item where itemName like %xxx%</strong> 但是这样的查询并不完美，比如我要找电子产品，我输入手机，那么和产品名称为手机的都会<strong>严格</strong>的被查询回来，可是这样就无法找到类似于：智能机，老人机，这样的称呼，这样很明显是不可学的，那我们是将手机再拆分为两个SQL进行查找吗？也许这样可行，但是对于手这个单词的查找可能会找到手套之类的物品，而这样已经违背的我们的初衷，明显，仅仅在数据库使用like是不明智的选择</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p><strong>性能问题</strong>。我们在进行数据库查找的时候，更多的是这样：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/uChmeeX1Fpyfns636FFuBpwcrBDBZFK9jZ5zYIZxgrD9aibzjejjMaRIXzRnnnIO3tk5I7d2UbdjVN0wCPMyZgQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt=""></p><p>这种like或者where的一行一行的查找，在对于海量的数据的时候，性能会变得非常的差劲，以致于能影响我们数据库的正常使用，<strong>使用了Elasticsearch之后，数据会在ES中有备份，而这样的查找就变成了</strong>：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/uChmeeX1Fpyfns636FFuBpwcrBDBZFK9hY8IYo9qrQe7N2hficOxvN8pWON1zeON6V3sH6zib6pm9SdxzFfmg5UA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt=""></p><p>这正是Elasticsearch的特性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。</p><p>对比关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">索引（indices）---------------------------------Databases 数据库</span><br><span class="line"></span><br><span class="line">  类型（type）----------------------------------Table 数据表</span><br><span class="line"></span><br><span class="line">     文档（Document）---------------------------Row 行</span><br><span class="line"></span><br><span class="line">   字段（Field）---------------------------Columns 列</span><br></pre></td></tr></table></figure><p>详细说明：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>索引库（indices)</td><td>indices是index的复数，代表许多的索引，</td></tr><tr><td>类型（type）</td><td>类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念</td></tr><tr><td>文档（document）</td><td>存入索引库原始的数据。比如每一条商品信息，就是一个文档</td></tr><tr><td>字段（field）</td><td>文档中的属性</td></tr><tr><td>映射配置（mappings）</td><td>字段的数据类型、属性、是否索引、是否存储等特性</td></tr></tbody></table><p>另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的：</p><ul><li>索引集（Indices，index的复数）：逻辑上的完整索引 collection1</li><li>分片（shard）：数据拆分后的各个部分</li><li>副本（replica）：每个分片的复制</li></ul><p>要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>安装好了可以直接使用你的localhost地址，加上端口访问，</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/</span></span><br></pre></td></tr></table></figure><p>首页会出现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: "c48f8b6d6494",</span><br><span class="line">    cluster_name: "docker-cluster",</span><br><span class="line">    cluster_uuid: "zJTUdR71Qya-vCLde_kaiQ",</span><br><span class="line">    version: &#123;</span><br><span class="line">    number: "7.6.2",</span><br><span class="line">    build_flavor: "default",</span><br><span class="line">    build_type: "docker",</span><br><span class="line">    build_hash: "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    build_date: "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    build_snapshot: false,</span><br><span class="line">    lucene_version: "8.4.0",</span><br><span class="line">    minimum_wire_compatibility_version: "6.8.0",</span><br><span class="line">    minimum_index_compatibility_version: "6.0.0-beta1"</span><br><span class="line">    &#125;,</span><br><span class="line">    tagline: "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些都是它的基本情况</p><h4 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>Elasticsearch采用Rest风格API，因此其API就是一次http请求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p>这样会展现出我们这个索引库的所有数据</p><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  /索引库名</span><br></pre></td></tr></table></figure><p>删除索引库</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>而当我们需要往Elasticsearch放入数据时，建议使用Elasticsearch—DATA 使用我们的外部API来放入我们的数据。</p><p>当然也有原生的API：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping/类型名称</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"字段名"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"类型"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="literal">true</span>，</span><br><span class="line">      <span class="string">"store"</span>: <span class="literal">true</span>，</span><br><span class="line">      <span class="string">"analyzer"</span>: <span class="string">"分词器"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型名称：就是前面将的type的概念，类似于数据库中的不同表<br>字段名：任意填写 ，可以指定许多属性，例如：</li><li>type：类型，可以是text、long、short、date、integer、object等</li><li>index：是否索引，默认为true</li><li>store：是否存储，默认为false</li><li>analyzer：分词器，这里的<code>ik_max_word</code>即使用ik分词器</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_mapping</span><br></pre></td></tr></table></figure><p>而使用这个方法可以查看我们的各个字段的类型</p><p>官方文档中有对类型的具体阐述：</p><ul><li><p>String类型，又分两种：</p><ul><li>text：可分词，不可参与聚合</li><li>keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合</li></ul></li><li><p>Numerical：数值类型，分两类</p><ul><li>基本数据类型：long、interger、short、byte、double、float、half_float</li><li>浮点数的高精度类型：scaled_float<ul><li>需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。</li></ul></li></ul></li><li><p>Date：日期类型</p><p>elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间</p></li></ul><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>index影响字段的索引情况。</p><ul><li>true：字段会被索引，则可以用来进行搜索。默认值就是true</li><li>false：字段不会被索引，不能用来搜索</li></ul><p>index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。</p><p>但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。</p><p>在我们实体对Class进行操作的时候，可以进行手动标注</p><h5 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h5><p>通过POST请求，可以向一个已经存在的索引库中添加数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/类型名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"key"</span>:<span class="string">"value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并可以通过：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /索引库名/_search</span><br></pre></td></tr></table></figure><p>去查看我们的所有数据。</p><p>这些都是原生的操作方法，但是实际操作过程中，并不会使用这种方法去操作，在Spring中也提供了相应的data-es去操作</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"查询类型"</span>:&#123;</span><br><span class="line">            <span class="attr">"查询条件"</span>:<span class="string">"查询条件值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的query代表一个查询对象，里面可以有不同的查询属性</p><ul><li>查询类型：例如：<code>match_all</code>， <code>match</code>，<code>term</code> ， <code>range</code> 等等</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询所有</p><p>则会在返回的JSON头出现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    took: 7,</span><br><span class="line">    timed_out: false,</span><br><span class="line">    _shards: &#123;</span><br><span class="line">    total: 1,</span><br><span class="line">    successful: 1,</span><br><span class="line">    skipped: 0,</span><br><span class="line">    failed: 0</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>took：查询花费时间，单位是毫秒</li><li>time_out：是否超时</li><li>_shards：分片信息</li><li>hits：搜索结果总览对象<ul><li>total：搜索到的总条数</li><li>max_score：所有结果中文档得分的最高分</li><li>hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息<ul><li>_index：索引库</li><li>_type：文档类型</li><li>_id：文档id</li><li>_score：文档得分</li><li>_source：文档的源数据</li></ul></li></ul></li></ul><h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><p>使用：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/2.png" alt=""></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/product/_search</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"手机"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/3.png" alt="图3"></p><p><strong>match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系</strong></p><h5 id="and"><a href="#and" class="headerlink" title="and"></a>and</h5><p>某些情况下，我们需要更精确查找，我们希望这个关系变成<code>and</code>，可以这样做:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"手机"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/4.png" alt=""></p><h5 id="or和and"><a href="#or和and" class="headerlink" title="or和and"></a>or和and</h5><p>在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。</p><p>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。</p><p><code>match</code> 查询支持 <code>minimum_should_match</code> 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"最新小米手机"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。</p><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/5.png" alt="图五"></p><h4 id="多字段查询"><a href="#多字段查询" class="headerlink" title="多字段查询"></a>多字段查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"小米"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:   [ <span class="string">"name"</span>, <span class="string">"content"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="词条匹配"><a href="#词条匹配" class="headerlink" title="词条匹配"></a>词条匹配</h4><p><strong>term</strong> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些<strong>未分词</strong>的字符串</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"term"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:<span class="number">2699.00</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多词条精确匹配"><a href="#多词条精确匹配" class="headerlink" title="多词条精确匹配"></a>多词条精确匹配</h4><p>terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"terms"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:[<span class="number">2699.00</span>,<span class="number">2899.00</span>,<span class="number">3899.00</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">            <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: &#123;</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">///////......</span></span><br></pre></td></tr></table></figure><h3 id="结果过滤"><a href="#结果过滤" class="headerlink" title="结果过滤"></a>结果过滤</h3><h4 id="直接指定字段"><a href="#直接指定字段" class="headerlink" title="直接指定字段"></a>直接指定字段</h4><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，我们可以添加_source的过滤:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"price"</span>],</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"took"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"_shards"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"hits"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: &#123;</span><br><span class="line"><span class="attr">"value"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"hits"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"price"</span>: <span class="number">5000</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"iPhone11"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定includes和excludes"><a href="#指定includes和excludes" class="headerlink" title="指定includes和excludes"></a>指定includes和excludes</h4><p>我们也可以通过：</p><ul><li>includes：来指定想要显示的字段</li><li>excludes：来指定不想要显示的字段</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"includes"</span>:[<span class="string">"content"</span>,<span class="string">"price"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">2999</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/6.png" alt=""></p><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="布尔组合"><a href="#布尔组合" class="headerlink" title="布尔组合"></a>布尔组合</h4><p><code>bool</code>把各种其它查询通过<code>must</code>（与）、<code>must_not</code>（非）、<code>should</code>（或）的方式进行组合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>:  <span class="string">"电视"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"手机"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/7.png" alt=""></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">                <span class="attr">"gte"</span>:  <span class="number">1000.0</span>,</span><br><span class="line">                <span class="attr">"lt"</span>:   <span class="number">2800.00</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询允许以下字符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">gt</td><td align="center">大于</td></tr><tr><td align="center">gte</td><td align="center">大于等于</td></tr><tr><td align="center">lt</td><td align="center">小于</td></tr><tr><td align="center">lte</td><td align="center">小于等于</td></tr></tbody></table><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>fuzzy查询是 <code>term</code> 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"appla"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>fuzziness</code>来指定允许的编辑距离:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>:<span class="string">"appla"</span>,</span><br><span class="line">            <span class="attr">"fuzziness"</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><h4 id="条件查询中进行过滤"><a href="#条件查询中进行过滤" class="headerlink" title="条件查询中进行过滤"></a><strong>条件查询中进行过滤</strong></h4><p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用<code>filter</code>方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米手机"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">2000.00</span>,<span class="attr">"lt"</span>:<span class="number">3800.00</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无查询条件，直接过滤"><a href="#无查询条件，直接过滤" class="headerlink" title="无查询条件，直接过滤"></a><strong>无查询条件，直接过滤</strong></h4><p>如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用<code>constant_score</code>取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">             <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">2000.00</span>,<span class="attr">"lt"</span>:<span class="number">3000.00</span>&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="单字段排序"><a href="#单字段排序" class="headerlink" title="单字段排序"></a>单字段排序</h4><p><code>sort</code> 可以让我们按照不同的字段进行排序，并且通过<code>order</code>指定排序的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小米手机"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"price"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><p>假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"小米手机"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">200000</span>,<span class="attr">"lt"</span>:<span class="number">300000</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">      &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"_score"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合aggregations"><a href="#聚合aggregations" class="headerlink" title="聚合aggregations"></a>聚合aggregations</h2><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫<code>桶</code>，一个叫<code>度量</code>：</p><blockquote><p><strong>桶（bucket）</strong></p></blockquote><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个<code>桶</code>，例如我们根据国籍对人划分，可以得到<code>中国桶</code>、<code>英国桶</code>，<code>日本桶</code>……或者我们按照年龄段对人进行划分：010,1020,2030,3040等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li><li>……</li></ul><p>bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><blockquote><p><strong>度量（metrics）</strong></p></blockquote><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为<code>度量</code></p><p>比较常用的一些度量聚合方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li><li>……</li></ul><h3 id="聚合为桶"><a href="#聚合为桶" class="headerlink" title="聚合为桶"></a>聚合为桶</h3><p>这里我使用了产品的category来分类，聚合为不同的桶：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"size"</span>:<span class="number">0</span>,<span class="attr">"aggs"</span>:&#123;<span class="attr">"popular_category"</span>:&#123;<span class="attr">"terms"</span>:&#123;<span class="attr">"field"</span>:<span class="string">"category"</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率</li><li>aggs：声明这是一个聚合查询，是aggregations的缩写<ul><li>popular_category：给这次聚合起一个名字，任意。<ul><li>terms：划分桶的方式，这里是根据词条划分<ul><li>field：划分桶的字段</li></ul></li></ul></li></ul></li></ul><p>但是，这里我出现了一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata&#x3D;true on [interests] in order to load field data by uninverting the inverted index. Note that this can use significant memory.</span><br></pre></td></tr></table></figure><p>大意就是必须把我们的属性设置为：set fielddata=true。</p><p>这里时候我返回idea，使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Field</span>(type = FieldType.Text,fielddata = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>将字段变为fielddata = true，可是这样一样出现这样的错误，这是为什么呢？</p><h5 id="紧急错误"><a href="#紧急错误" class="headerlink" title="紧急错误"></a>紧急错误</h5><p>之后我通过</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.78.128:9200/_mapping</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/0.png" alt=""></p><p>发现了这个错误的原因，原来是这个@field注解并没有生效，所以属性也没有生效。</p><p>之后在网上搜索各个文章，发现很多的做法都是使用外置一个json，也有一部分是用createindex+putindex。</p><p>使用json明显不是官方的做法，简直越来越复杂，而createindex和putindex一起使用也不正确，后来看了看官方文档，标注这两个方法都被弃用了，而且createindex其实已经集成到repository里面自动产生了，很迷惑。</p><p>但是在多次调试的情况下，我获得了两种答案：</p><h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>先使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearchRestTemplate.putMapping(Product<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>将mapping配置放入es连接中，再使用saveALL就行了</p><p>二是升级版本，把springboot升级到2.4.0</p><p>之后便是再次尝试：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/8.png" alt="图"></p><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>popular_category：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的category字段值都会形成一个桶<ul><li>key：这个桶对应的category字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul><h3 id="桶内度量"><a href="#桶内度量" class="headerlink" title="桶内度量"></a>桶内度量</h3><p>我们需要告诉Elasticsearch<code>使用哪个字段</code>，<code>使用何种度量方式</code>进行运算，这些信息要嵌套在<code>桶</code>内，<code>度量</code>的运算会基于<code>桶</code>内的文档进行</p><p>现在，我们为刚刚的聚合结果添加 求价格平均值的度量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_category"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"category"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见<code>度量</code>也是一个聚合</li><li>avg_price：聚合的名称</li><li>avg：度量的类型，这里是求平均值</li><li>field：度量运算的字段</li></ul><p>结果如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/9.png" alt=""></p><h3 id="桶内嵌套桶"><a href="#桶内嵌套桶" class="headerlink" title="桶内嵌套桶"></a>桶内嵌套桶</h3><p>刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_category"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"category"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"maker"</span>:&#123;</span><br><span class="line">                    <span class="attr">"terms"</span>:&#123;</span><br><span class="line">                        <span class="attr">"field"</span>:<span class="string">"brand"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原来的color桶和avg计算我们不变</li><li>maker：在嵌套的aggs下新添一个桶，叫做maker</li><li>terms：桶的划分类型依然是词条</li><li>filed：这里根据make字段进行划分</li></ul><h3 id="划分桶的其它方式"><a href="#划分桶的其它方式" class="headerlink" title="划分桶的其它方式"></a>划分桶的其它方式</h3><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li></ul><h4 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h4><p>histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。</p><p>举例：</p><p>比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的：</p><p>0，200，400，600，…</p><p>上面列出的是每个阶梯的key，也是区间的启点。</p><p>如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket_key = Math.floor((value - offset) / interval) * interval + offset</span><br></pre></td></tr></table></figure><p>value：就是当前数据的值，本例中是450</p><p>offset：起始偏移量，默认为0</p><p>interval：阶梯间隔，比如200</p><p>因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"price"</span>:&#123;</span><br><span class="line">      <span class="attr">"histogram"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="number">1000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图所示：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/10.png" alt=""></p><p>同样还可以指定： “min_doc_count”: 1 去表达，只有存在最小区间的才展示。</p><h2 id="spring-boot-starter-data-elasticsearch"><a href="#spring-boot-starter-data-elasticsearch" class="headerlink" title="spring-boot-starter-data-elasticsearch"></a>spring-boot-starter-data-elasticsearch</h2><p>这里使用的SpringBoot版本是2.3.7。spring-boot-starter-data-elasticsearch版本为2.4.2、</p><p>elasticsearch版本为7.6.2</p><p>首先导入pom文件，然后，新版本的elasticsearch建议使用Configuration器配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClientConfiguration configuration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(<span class="string">"192.168.78.128:9200"</span>)</span><br><span class="line"><span class="comment">//                .connectedTo("localhost:9200")</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//.withConnectTimeout(Duration.ofSeconds(5))</span></span><br><span class="line">                <span class="comment">//.withSocketTimeout(Duration.ofSeconds(3))</span></span><br><span class="line">                <span class="comment">//.useSsl()</span></span><br><span class="line">                <span class="comment">//.withDefaultHeaders(defaultHeaders)</span></span><br><span class="line">                <span class="comment">//.withBasicAuth(username, password)</span></span><br><span class="line">                <span class="comment">// ... other options</span></span><br><span class="line">                .build();</span><br><span class="line">        RestHighLevelClient client = RestClients.create(configuration).rest();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"product"</span>, shards = <span class="number">1</span>, replicas = <span class="number">0</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"com-sodse-trade-domain-Product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = ToStringSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ApiModelProperty</span>(<span class="title">value</span> </span>= <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword, analyzer = "ik_max_word")</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>,type = FieldType.Text)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String mainImg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会有一个品牌表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"会有一个品牌表"</span>)</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会有一个分类表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text,fielddata = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"会有一个分类表"</span>)</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当库存为0时则无法购买</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"当库存为0时则无法购买"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为真</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"判断是否为真"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳在创建新商品时产生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>,type = FieldType.Long)</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"时间戳在创建新商品时产生"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如手机：颜色，衣服：颜色。。。以逗号隔开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"如手机：颜色，衣服：颜色。。。以逗号隔开"</span>)</span><br><span class="line">    <span class="keyword">private</span> String properties1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如手机规格：8+128gb，衣服 S,M,L,XL,XXL 以逗号隔开。若无第二规格，则在第一个开头显示 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"如手机规格：8+128gb，衣服 S,M,L,XL,XXL 以逗号隔开。若无第二规格，则在第一个开头显示 无"</span>)</span><br><span class="line">    <span class="keyword">private</span> String properties2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快递费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"快递费"</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal courierFees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属于哪一个商家</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"属于哪一个商家"</span>)</span><br><span class="line">    <span class="keyword">private</span> String merchant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p> @ApiModelProperty和ApiModel是我自己的swagger依赖，和Elasticsearch无关。</p><p>Spring Data通过注解来声明字段的映射属性，有下面的三个注解：</p><ul><li>@Document作用在类，标记实体类为文档对象，一般有四个属性<ul><li>indexName：对应索引库名称</li><li>type：对应在索引库中的类型</li><li>shards：分片数量，默认5</li><li>replicas：副本数量，默认1</li></ul></li><li>@Id` 作用在成员变量，标记一个字段作为id主键</li><li>@Field作用在成员变量，标记为文档的字段，并指定字段映射属性：<ul><li>type：字段类型，取值是枚举：FieldType</li><li>index：是否索引，布尔类型，默认是true</li><li>store：是否存储，布尔类型，默认是false</li><li>analyzer：分词器名称：ik_max_word</li></ul></li></ul><p>值得注意的是：@Document的type在新版本被弃用了。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>这里通过继承ElasticsearchRepository来像JPA一样使用它的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span> ,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">findAllByNameLike</span><span class="params">(String  name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看常规的操作</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">product_es_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product p=<span class="keyword">new</span> Product();</span><br><span class="line">        p.setId(<span class="number">2L</span>);</span><br><span class="line">        p.setName(<span class="string">"手机"</span>);</span><br><span class="line">        p.setPrice(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        p.setContent(<span class="string">"这是一件物品"</span>);</span><br><span class="line"><span class="comment">//        productRepository.index(p);</span></span><br><span class="line">        productRepository.save(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>productRepository.index() 是 过去弃用的方法，现今使用productRepository.save 去保存一个Object。</p><p>更新和保存同样都是使用save，它会根据主键是否相同来判断是更新还是保存新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">product_es_test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    productRepository.saveAll(productService.find());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>productRepository.saveAll 保存一个<strong>List<Object></strong> 数据</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">es_Delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    productRepository.deleteAll();<span class="comment">//或者是deleteById(1L);</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">product_es_test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Product&gt; products = productRepository.findAllByNameLike(<span class="string">"手机"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Product p:products) &#123;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过像JPA一样自定义方法来进行增删改查操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">"price"</span>));</span><br></pre></td></tr></table></figure><p>还可以选择降序排序等等</p><h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>Spring Data 的另一个强大功能，是根据方法名称自动实现功能。<br>比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。<br>当然，方法名称要符合一定的约定：</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>Elasticsearch Query String</th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByNameAndPrice</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Or</code></td><td><code>findByNameOrPrice</code></td><td><code>{&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Is</code></td><td><code>findByName</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Not</code></td><td><code>findByNameNot</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Between</code></td><td><code>findByPriceBetween</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByPriceLessThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByPriceGreaterThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Before</code></td><td><code>findByPriceBefore</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>After</code></td><td><code>findByPriceAfter</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Like</code></td><td><code>findByNameLike</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByNameStartingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>EndingWith</code></td><td><code>findByNameEndingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>Contains/Containing</code></td><td><code>findByNameContaining</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>In</code></td><td><code>findByNameIn(Collectionnames)</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}}</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByNameNotIn(Collectionnames)</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}}</code></td></tr><tr><td><code>Near</code></td><td><code>findByStoreNear</code></td><td><code>Not Supported Yet !</code></td></tr><tr><td><code>True</code></td><td><code>findByAvailableTrue</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr><tr><td><code>False</code></td><td><code>findByAvailableFalse</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}}</code></td></tr><tr><td><code>OrderBy</code></td><td><code>findByAvailableTrueOrderByNameDesc</code></td><td><code>{&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr></tbody></table><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><h4 id="QueryBuilders"><a href="#QueryBuilders" class="headerlink" title="QueryBuilders"></a>QueryBuilders</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBaseQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 词条查询</span></span><br><span class="line">    MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"小米"</span>);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    Iterable&lt;Product&gt; items = productRepository.search(queryBuilder);</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/11.png" alt=""></p><h4 id="NativeSearchQueryBuilder"><a href="#NativeSearchQueryBuilder" class="headerlink" title="NativeSearchQueryBuilder"></a>NativeSearchQueryBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"手机"</span>));</span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体</p><p><code>Page</code>：默认是分页查询，因此返回的是一个分页的结果对象，包含属性：</p><ul><li>totalElements：总条数</li><li>totalPages：总页数</li><li>Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据</li></ul><p>如图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/12.png" alt=""></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"手机"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分页参数</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置分页参数</span></span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    <span class="comment">// 每页大小</span></span><br><span class="line">    System.out.println(items.getSize());</span><br><span class="line">    <span class="comment">// 当前页</span></span><br><span class="line">    System.out.println(items.getNumber());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/13.png" alt=""></p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 构建查询条件</span></span><br><span class="line">       NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">       <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">       queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"书籍"</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 排序</span></span><br><span class="line">       queryBuilder.withSort(SortBuilders.fieldSort(<span class="string">"price"</span>).order(SortOrder.DESC));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">       Page&lt;Product&gt; items = productRepository.search(queryBuilder.build());</span><br><span class="line">       <span class="comment">// 打印总条数</span></span><br><span class="line">       System.out.println(items.getTotalElements());</span><br><span class="line">       items.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/14.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Elasticsearch和spring-es—Data的实战汇总&quot;&gt;&lt;a href=&quot;#关于Elasticsearch和spring-es—Data的实战汇总&quot; class=&quot;headerlink&quot; title=&quot;关于Elasticsearch和spring</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="ElasticSearch" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot多环境适配</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring18/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring18/</id>
    <published>2021-01-05T10:16:54.000Z</published>
    <updated>2021-01-18T10:34:21.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Profile功能"><a href="#Profile功能" class="headerlink" title="Profile功能"></a>Profile功能</h1><p>为了方便多环境适配，springboot简化了profile功能。</p><h3 id="1、application-profile功能"><a href="#1、application-profile功能" class="headerlink" title="1、application-profile功能"></a>1、application-profile功能</h3><ul><li><p>默认配置文件  application.yaml；任何时候都会加载</p></li><li><p>指定环境配置文件  application-{env}.yaml</p></li><li><p>激活指定环境</p></li><li><ul><li>配置文件激活</li><li>命令行激活：java -jar xxx.jar –<strong>spring.profiles.active=prod  –person.name=haha</strong></li></ul></li><li><ul><li><ul><li><strong>修改配置文件的任意值，命令行优先</strong></li></ul></li></ul></li><li><p>默认配置与环境配置同时生效</p></li><li><p>同名配置项，profile配置优先</p></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//比如说再有两个的情况下，</span></span><br><span class="line"><span class="string">application-myprod.yml</span></span><br><span class="line"><span class="string">application-mytest.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.profiles.active=myprod</span></span><br></pre></td></tr></table></figure><p>通过这种方式指定一个配置文件。</p><p>在应用程序启动时默认的配置文件先生效，然后再使用指定的配置文件，当两个配置文件有重复的配置的时候，指定的优先生效。</p><h3 id="2、-Profile条件装配功能"><a href="#2、-Profile条件装配功能" class="headerlink" title="2、@Profile条件装配功能"></a>2、@Profile条件装配功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile</span>(value = &#123;<span class="string">"prod"</span>,<span class="string">"default"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name:李四&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;MAVEN_HOME&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;os.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/msg"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg+<span class="string">"==&gt;"</span>+osName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的配置可以对类和返回值产生不同的影响，但一般不这么做，因为一般的项目都比较大而复杂。</p><h3 id="3、profile分组"><a href="#3、profile分组" class="headerlink" title="3、profile分组"></a>3、profile分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.group.production[0]&#x3D;proddb</span><br><span class="line">spring.profiles.group.production[1]&#x3D;prodmq</span><br><span class="line"></span><br><span class="line">使用：--spring.profiles.active&#x3D;production  激活</span><br></pre></td></tr></table></figure><p>当我们指定的指定一个的配置文件的时候，属于它的组也会依次生效</p><h3 id="4、外部化配置"><a href="#4、外部化配置" class="headerlink" title="4、外部化配置"></a>4、外部化配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><ol><li>默认属性（通过设置指定<code>SpringApplication.setDefaultProperties</code>）。</li><li><a href="https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code></a><code>@Configuration</code>类上的注释。请注意，<code>Environment</code>在刷新应用程序上下文之前，不会将此类属性源添加到中。现在配置某些属性（如<code>logging.*</code>和<code>spring.main.*</code>在刷新开始之前先读取）为时已晚。</li><li><strong>配置数据（例如**</strong>文件）<strong>**<code>application.properties</code></strong></li><li>一<code>RandomValuePropertySource</code>，只有在拥有性能<code>random.*</code>。</li><li>操作系统环境变量。</li><li>Java系统属性（<code>System.getProperties()</code>）。</li><li>的JNDI属性<code>java:comp/env</code>。</li><li><code>ServletContext</code> 初始化参数。</li><li><code>ServletConfig</code> 初始化参数。</li><li>来自的属性<code>SPRING_APPLICATION_JSON</code>（嵌入在环境变量或系统属性中的嵌入式JSON）。</li><li>命令行参数。</li><li><code>properties</code>测试中的属性。可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">用于测试应用程序的特定部分</a><a href="https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener"><code>@SpringBootTest</code></a>的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试注释</a>和<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">注释</a>。</li><li><a href="https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener"><code>@TestPropertySource</code></a> 测试中的注释。</li><li><code>$HOME/.config/spring-boot</code>当devtools处于活动状态时，目录中的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools-globalsettings" target="_blank" rel="noopener">Devtools全局设置属性</a>。</li></ol><h3 id="5、外部配置源"><a href="#5、外部配置源" class="headerlink" title="5、外部配置源"></a>5、外部配置源</h3><p>常用：<strong>Java属性文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>、<strong>命令行参数</strong>；</p><h3 id="6、配置文件查找位置"><a href="#6、配置文件查找位置" class="headerlink" title="6、配置文件查找位置"></a>6、配置文件查找位置</h3><p>(1) classpath 根路径</p><p>(2) classpath 根路径下config目录</p><p>(3) jar包当前目录</p><p>(4) jar包当前目录的config目录</p><p>(5) /config子目录的直接子目录</p><h3 id="7、配置文件加载顺序："><a href="#7、配置文件加载顺序：" class="headerlink" title="7、配置文件加载顺序："></a>7、配置文件加载顺序：</h3><ol><li>　当前jar包内部的application.properties和application.yml</li><li>　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li><li>　引用的外部jar包的application.properties和application.yml</li><li>　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li></ol><p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Profile功能&quot;&gt;&lt;a href=&quot;#Profile功能&quot; class=&quot;headerlink&quot; title=&quot;Profile功能&quot;&gt;&lt;/a&gt;Profile功能&lt;/h1&gt;&lt;p&gt;为了方便多环境适配，springboot简化了profile功能。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="Profile" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Profile/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity+JWT结合Vue在前后端分离下的权限控制</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring17/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2021/01/05/spring17/</id>
    <published>2021-01-05T08:00:29.000Z</published>
    <updated>2021-02-06T07:41:26.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringSecurity-JWT结合Vue在前后端分离下的权限控制"><a href="#SpringSecurity-JWT结合Vue在前后端分离下的权限控制" class="headerlink" title="SpringSecurity+JWT结合Vue在前后端分离下的权限控制"></a>SpringSecurity+JWT结合Vue在前后端分离下的权限控制</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>再构建一个前后端分离项目的时候。我们之前在前后端耦合情况下使用的Security配置会和前后端分离的情况下有一些较大的区别。</p><p>就比如在前后端耦合的情况下，所有页面。都是由后端来处理，这样的权限控制较为简易。而且不会出现跨域的问题。按目前结合vue进行前后端分离是当前技术的主流。很多公司和业务都是按照着这个的标准进行的，那么以往的权限控制就不能完全适用于现在了。</p><p>这一段设计经过了我的一些思考。当我在初步的使用vue的时候。我还按照原来的配置去配置security。结果发现这样的权限控制并没有任何效果。起初以为是跨域问题，结果在解决了跨域问题之后，才真正明白了，他们启动的并不是同一个端口。那么我在后端配置的权限控制和前端不同端口的情况下怎么会生效呢？</p><p>于是在查阅了网上的各种资料之后，我找到了一种方法，使用jwt配合security权限控制来进行前后端之间的交流，这样即使是在不同端口的情况下也能实现权限的控制。并且可以将jwt所认证的信息存储在当地的cookie当中。即使用户退出的浏览器在打开浏览器时也不用再次进行登录去认证。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先必不可说的肯定是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- jwt --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--   spring security     权限管理依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 因为在进行前后端分离时，需要用到一个自定义的类型去进行交互。当然这是基本常识，在此也不多讲述：</p><p>这是一个用于交互的实体,前后端用这个类来进行交互。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">// 200是正常，非200表示异常</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">succ</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> succ(<span class="number">200</span>, <span class="string">"操作成功"</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">succ</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        Result r = <span class="keyword">new</span> Result();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fail(<span class="number">400</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(String msg, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fail(<span class="number">400</span>, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        Result r = <span class="keyword">new</span> Result();</span><br><span class="line">        r.setCode(code);</span><br><span class="line">        r.setMsg(msg);</span><br><span class="line">        r.setData(data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义一个用户提交登陆信息使用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"昵称不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>后端需要解决一些跨域问题,这是一个跨域解决方案的一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始配置我们的security:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService; <span class="comment">//自行编写的持久层方法，这里我用的是mybatis </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenFilter();</span><br><span class="line">        <span class="comment">//需要自定义一个JWT拦截器，下面会提及</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( AuthenticationManagerBuilder auth )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService( myUserDetailsService ).passwordEncoder( <span class="keyword">new</span> BCryptPasswordEncoder() );</span><br><span class="line">    &#125;<span class="comment">//将我们的持久层方法注入到这个security里面，之前的文章说过了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">( HttpSecurity httpSecurity )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        httpSecurity.csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="string">"/register"</span>).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.PUT).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.DELETE).authenticated()</span><br><span class="line">                .antMatchers(HttpMethod.GET).authenticated()</span><br><span class="line">                .and()<span class="comment">// 开启跨域</span></span><br><span class="line">                .cors()</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置拦截</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//自定义拦截方法</span></span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyUserDetailsService:这个不用说，就是我们自己定义的获取数据库用户信息的方法。接着使用: <strong>auth.userDetailsService( myUserDetailsService ).passwordEncoder( new BCryptPasswordEncoder() );</strong> 将他住到我们的security权限认证当中。</li><li>JwtTokenFilter：这是我们的拦截器。我们需要对验证的每一个Token.进行验证，判断它的过期时间等等。我们需要把这个拦截器一块注入到security当中。源码在下方：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里看起来复杂，实际就是获取从前端返回的信息，比如username，然后进行数据库查找，然后进行将找到的用户进行加密形成一个Token，将一个信息传递回security</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span> <span class="params">( HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String authHeader = request.getHeader( Const.HEADER_STRING );</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="keyword">null</span> &amp;&amp; authHeader.startsWith( Const.TOKEN_PREFIX )) &#123;</span><br><span class="line">            <span class="keyword">final</span> String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                        UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                                userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                        authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                                request));</span><br><span class="line">                        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着这一个认证拦截器又用到了JWT的工具类：这一个工具，通常用于生成JWT，和获取各种JWT的信息，其中用到了我们spring中的依赖注的JWT源码，但我们还需要根据他所给的方法和API，进行自己的改写和判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jwt的各种方法，写法比较固定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5625635588908941275L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME = <span class="string">"sub"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED = <span class="string">"created"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreatedDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date created;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            created = <span class="keyword">new</span> Date((Long) claims.get(CLAIM_KEY_CREATED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            created = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpirationDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiration;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            expiration = claims.getExpiration();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            expiration = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey( Const.SECRET )</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            claims = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Date <span class="title">generateExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis() + Const.EXPIRATION_TIME * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date expiration = getExpirationDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isCreatedBeforeLastPasswordReset</span><span class="params">(Date created, Date lastPasswordReset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (lastPasswordReset != <span class="keyword">null</span> &amp;&amp; created.before(lastPasswordReset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, Const.SECRET )</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">canTokenBeRefreshed</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String refreshedToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token);</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            refreshedToken = generateToken(claims);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            refreshedToken = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> refreshedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        User user = (User) userDetails;</span><br><span class="line">        <span class="keyword">final</span> String username = getUsernameFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">                username.equals(user.getUsername())</span><br><span class="line">                        &amp;&amp; !isTokenExpired(token)</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，这种工作大致上就完成了，总体而言并不复杂。就是把JWT和security结合在一起。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@Validated @RequestBody LoginDto loginDto, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"登录"</span>);</span><br><span class="line">    String jwt= authService.login( loginDto.getUsername(), loginDto.getPassword() );</span><br><span class="line">    User user= userService.findByUsername(loginDto.getUsername()).get(<span class="number">0</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Authorization"</span>,jwt);<span class="comment">//放置响应头中</span></span><br><span class="line">    response.setHeader(<span class="string">"Access-control-Expose-Headers"</span>,<span class="string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.succ(MapUtil.builder()</span><br><span class="line">            .put(<span class="string">"id"</span>, user.getId())</span><br><span class="line">            .put(<span class="string">"username"</span>, user.getUsername())</span><br><span class="line">            .map());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用postman或者是vue的axios进行测试，图床崩了暂时就不搞图了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringSecurity-JWT结合Vue在前后端分离下的权限控制&quot;&gt;&lt;a href=&quot;#SpringSecurity-JWT结合Vue在前后端分离下的权限控制&quot; class=&quot;headerlink&quot; title=&quot;SpringSecurity+JWT结合Vu</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="Security" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Security/"/>
    
    <category term="JWT" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>Element-ui组件使用和一键import功能</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/07/16/vue2/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/07/16/vue2/</id>
    <published>2020-07-16T11:51:47.000Z</published>
    <updated>2021-01-18T12:20:42.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Element-ui组件使用"><a href="#Element-ui组件使用" class="headerlink" title="Element-ui组件使用"></a>Element-ui组件使用</h3><p>element-ui首先得通过npm 安装下载，</p><p>其次通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"element-ui/lib/theme-chalk/index.css"</span></span><br></pre></td></tr></table></figure><p>导入进去，</p><p>然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Element)</span><br></pre></td></tr></table></figure><p>被Vue所使用即可了。</p><p>并且通过：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/layout</span><br></pre></td></tr></table></figure><p>访问网站，直接复制在我们components文件夹下面新建的一个Vue里面，既可以使用了。</p><h3 id="一键import"><a href="#一键import" class="headerlink" title="一键import"></a>一键import</h3><p>这个在components下面建一个js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="string">'.'</span>, <span class="literal">false</span>, /\.vue$/</span><br><span class="line">   <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentName = capitalizeFirstLetter(</span><br><span class="line">    fileName.replace(<span class="regexp">/^\.\//</span>, <span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="comment">//因为得到的filename格式是: './dataList.vue', 所以这里我们去掉头和尾，只保留真正的文件名</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果组件在components下面的文件夹里面的话。js就改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">    <span class="string">'.'</span>,<span class="literal">true</span>,/\.vue$/</span><br><span class="line">    <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">233</span>,requireComponent.keys());</span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    <span class="keyword">const</span> componetConfig = requireComponent(fileName);</span><br><span class="line">    <span class="built_in">console</span>.log(componetConfig);</span><br><span class="line">    <span class="keyword">let</span> a = fileName.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    fileName = <span class="string">'.'</span> + fileName.slice(a);</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    <span class="keyword">const</span> componetName = capitalizeFirstLetter(</span><br><span class="line">        fileName.replace(<span class="regexp">/^\.\//</span>,<span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>,<span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">    Vue.component(componetName,componetConfig.default || componetConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后在main.js进行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx.js</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Element-ui组件使用&quot;&gt;&lt;a href=&quot;#Element-ui组件使用&quot; class=&quot;headerlink&quot; title=&quot;Element-ui组件使用&quot;&gt;&lt;/a&gt;Element-ui组件使用&lt;/h3&gt;&lt;p&gt;element-ui首先得通过npm 安装下</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>利用Kurento实现一对一通信</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/20/Kurento1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/20/Kurento1/</id>
    <published>2020-06-20T12:44:01.000Z</published>
    <updated>2022-05-09T14:21:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用Kurento实现一对一通信"><a href="#利用Kurento实现一对一通信" class="headerlink" title="利用Kurento实现一对一通信"></a>利用Kurento实现一对一通信</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自己的计划是，毕业设计做一个类似于腾讯会议的视频流通信服务，发现想要实现起来并不容易，不过自己也还是慢慢的在摸索，最后找到了一个叫做Kurento的视频流服务器，打算使用这个服务器去开发程序。</p><h3 id="配置与实现"><a href="#配置与实现" class="headerlink" title="配置与实现"></a>配置与实现</h3><p>想要配置这个东西可是非常非常的坑啊，本来自己是去官网找到了一些可以直接运行的例子，然后在本地直接start，完全没有问题，然后拿到虚拟机试一试：</p><p>当然，kurento肯定是利用docker安装的，这个dockerhub也有，这里先列出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name kms -p 8888:8888 kurento/kurento-media-server:xenial-latest</span><br></pre></td></tr></table></figure><p>发现仍然可以使用，最后拿去阿里云服务器试了试，结果就……，完全没有作用，安全组什么的都开了，我之后就觉得会不会是公网ip之类的问题，但是不知道怎么下手，之后再Stack Overflow中，看到了创建者的发言，在公网中必须有turn服务器，于是乎，我便开始了配置turn服务器之路。</p><p>由于在dockerhub没有turn服务器的镜像源，turn服务器安装这块坑就大了，网上有很多的教程，非常之乱，又要什么内网ip，什么什么md5验证，什么什么必须要在Ubuntu下运行，看的我真的是一脸懵逼，怎么可能这么复杂而且又有这么多说法呢？？</p><p>我基本都试了一次，嗯，如同预期一般，非常的不靠谱。</p><p>但最后还是找到了解决方案，在github找到了可以直接使用的dockerfile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/konoui/kurento-coturn-docker.git</span><br></pre></td></tr></table></figure><p>然后去运行它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /kurento-coturn-docker/coturn/</span><br><span class="line">//使用dockerfile,记住加点</span><br><span class="line">sudo docker build --tag coturn .</span><br><span class="line">//后台运行coturn</span><br><span class="line">sudo docker run -p 3478:3478 -p 3478:3478/udp coturn</span><br><span class="line">//别忘了开完全组</span><br></pre></td></tr></table></figure><p>然后是网上博客都有讲到的有效性测试，这个大家自己看吧。</p><p>然后需要编辑Kurento：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入镜像</span></span><br><span class="line">docker exec -it kms /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta">#</span><span class="bash">进入配置文件夹</span></span><br><span class="line">cd /etc/kurento/modules/kurento/</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑配置文件</span></span><br><span class="line">vim WebRtcEndpoint.conf.ini</span><br></pre></td></tr></table></figure><p>配置打洞服务器，配置文件应该改成这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stunServerAddress=you_url</span><br><span class="line">stunServerPort=you_port</span><br><span class="line">turnURL=kurento:kurento@you_url?transport=tcp</span><br></pre></td></tr></table></figure><p>一般情况下，坑到这里应该也就完了，但是你可以在试试，还是跑不通！！！！</p><p>这又是为什么呢？？？？</p><p>最后我想了想，为什么本地配置就完全没问题呢？就算连接公网需要turn，但是代码层面却没有任何提示啊，这不应该，所以，接下来就是最坑的了，你甚至需要去打开源代码，修改并连接turn服务器！！！！</p><p>我敢说，绝大多数人都会和我一样，觉得这不应该，你特么本地的代码例子完全就是摆着看的嘛。</p><p>做法如下：</p><p>打开index.js</p><p>在函数function uiStart()里，增加一个叫iceservers的变量，格式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iceservers=&#123;</span><br><span class="line">   <span class="string">"iceServers"</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">         urls:<span class="string">"stun:139.198.123.138:3478"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         urls:[<span class="string">"turn:139.198.123.138:3478"</span>]</span><br><span class="line">           username:<span class="string">"kurento"</span>,</span><br><span class="line">           credential: <span class="string">"kurento"</span></span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再修改底下的options变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   localVideo: uiLocalVideo,</span><br><span class="line">   remoteVideo: uiRemoteVideo,</span><br><span class="line">   mediaConstraints: &#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">   onicecandidate: <span class="function">(<span class="params">candidate</span>) =&gt;</span> sendMessage(&#123;</span><br><span class="line">     id: <span class="string">'ADD_ICE_CANDIDATE'</span>,</span><br><span class="line">     candidate: candidate,</span><br><span class="line">   &#125;),</span><br><span class="line">     configuration: iceservers <span class="comment">//修改在这里，增加了一个configuration的key</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>暂时不写了。。。头痛</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用Kurento实现一对一通信&quot;&gt;&lt;a href=&quot;#利用Kurento实现一对一通信&quot; class=&quot;headerlink&quot; title=&quot;利用Kurento实现一对一通信&quot;&gt;&lt;/a&gt;利用Kurento实现一对一通信&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="Kurento" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Kurento/"/>
    
    <category term="turn" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/turn/"/>
    
    <category term="Docker" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>利用Nginx进行前后端分离项目部署-ruoyi</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/12/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21/</id>
    <published>2020-06-12T06:21:51.000Z</published>
    <updated>2021-01-31T05:17:12.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用Nginx进行前后端分离项目部署"><a href="#利用Nginx进行前后端分离项目部署" class="headerlink" title="利用Nginx进行前后端分离项目部署"></a>利用Nginx进行前后端分离项目部署</h2><p>首先需要这个项目，利用git去仓库克隆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/y_project/RuoYi-Vue.git</span><br></pre></td></tr></table></figure><p>然后我们就获得了这个项目，你可以看到，这个项目分为：</p><ul><li>ruoyi</li><li>ruoyi-ui</li></ul><p>这两个文件夹，一个是后端，一个是前端。</p><p>根据正常的操作使用说明，我们先使用idea打开这个项目，更改一下项目的目标地址。一般都是在application.yml 文件上：</p><p>比如你可以改localhost，或者是其他的ip地址，我就改了ip地址。</p><p>当然，如果你仅仅需要部署到单个服务器上，其他的都别管，直接使用maven打包就行了。</p><p><strong>后端的打包和运行很简单，这里不多赘述了</strong></p><h3 id="开始准备"><a href="#开始准备" class="headerlink" title="开始准备"></a>开始准备</h3><p>我这里准备了三台虚拟机：</p><ol><li>192.168.78.128</li><li>192.168.78.129</li><li>192.168.78.130</li></ol><p>第二台和第三台虚拟机都是部署后端的jar包，我们准备使用Nginx进行负载均衡，这里我后端的数据库是连接前端的128的ip，因为只有同一个数据库才好进行负载均衡。</p><p>首先需要在128部署好docker，docker下安装好MySQL和Redis。</p><p>启动docker镜像，启动两个后端，紧接着我们来到前端进行部署。</p><h3 id="安装Nodejs和Nginx"><a href="#安装Nodejs和Nginx" class="headerlink" title="安装Nodejs和Nginx"></a>安装Nodejs和Nginx</h3><h4 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h4><p>我这⾥下载的是 node-v12.16.3-linux-x64.tar.xz 安装包，并将其直接放在了 root ⽬录下。</p><p>1、在 /usr/local/ 下创建 node ⽂件夹并进⼊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir node</span><br><span class="line">cd node</span><br></pre></td></tr></table></figure><p>2、将 Node 的安装包解压到 /usr/local/node 中即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost node]# tar -xJvf /root/node-v12.16.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>解压完之后， /usr/local/node ⽬录中会出现⼀个 node-v12.16.3-linux-x64 的⽬录</p><p><strong>配置NODE系统环境变量</strong></p><p>编辑 ~/.bash_profile ⽂件，在⽂件末尾追加如下信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Nodejs</span></span><br><span class="line">export PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATH</span><br></pre></td></tr></table></figure><p>刷新环境变量，使之⽣效即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p><strong>检查安装结果</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>这⾥下载的是 nginx-1.17.10.tar.gz 安装包，并将其直接放在了 root ⽬录下</p><p>1、在 /usr/local/ 下创建 nginx ⽂件夹并进⼊:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br></pre></td></tr></table></figure><p>2、将 Nginx 安装包解压到 /usr/local/nginx 中即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# tar zxvf /root/nginx-1.17.10.tar.gz -C ./</span><br></pre></td></tr></table></figure><p>解压完之后， /usr/local/nginx ⽬录中会出现⼀个 nginx-1.17.10 的⽬录</p><p><strong>预先安装额外的依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><p><strong>编译安装NGINX</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.17.10</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后，Nginx的可执⾏⽂件位置位于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p><strong>启动NGINX</strong></p><p>直接执⾏如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>如果想停⽌Nginx服务，可执⾏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p>如果修改了配置⽂件后想重新加载Nginx，可执⾏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>注意其配置⽂件位于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h3><p>把ruoyi-ui放在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/workspace/ruoyi-ui/</span><br></pre></td></tr></table></figure><p>文件夹下，并使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --unsafe-perm --registry=https:registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>–unsafe-perm：是为了更高的权限</p><p>–registry=https:registry.npm.taobao.org：拥有更快的镜像源</p><p>然后等待执行完毕。</p><p>执行完毕后，可以看到多了一个node模块。</p><p>接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>开始建立，建立完成后，可以看到多了一个dist文件夹，这表示我们基本完成了环境的构建。</p><h3 id="使用Nginx代理服务器完成部署"><a href="#使用Nginx代理服务器完成部署" class="headerlink" title="使用Nginx代理服务器完成部署"></a>使用Nginx代理服务器完成部署</h3><p>打开配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>把最上的user注释改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user  root;</span><br></pre></td></tr></table></figure><p>以此获得最大的权限。</p><p>接着，定位到：location /，并将其改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /root/workspace/ruoyiui/dist;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果页面发生了404错误，那么可以在这里修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root ...</span><br><span class="line">    index ...</span><br><span class="line">    try_files $uri $uri/ /index.html; ---解决页面刷新404问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这句话的意思是，当访问uri没有的时候 尝试访问 index.html 由于vue是单页模式，所以入口都是index.html 无论访问什么连接都由vue本身接管</strong></p><p>可以看到的是，这里的root路径，就是我们的前端路径。</p><p>启动nginx，然后我们可以打开节点：192.168.78.128</p><p>我们却发现，它出现了一点错误（暂时无图）</p><p>这个错误是地址引用错误，在验证码这个url错误，原因是正确的地址是：192.168.78.128/prod-api/xxxx</p><p>这表示，我们遗失了 prod-api 这个路径，那怎么办呢？</p><p>我们回到Nginx配置文件，添加一项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       location /prod-api/ &#123;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://192.168.78.129:8080/;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>/usr/local/nginx/sbin/nginx -s reload ，重启Nginx，便可以了。</p><p>这里的前四段是标准写法，不用太多思考，最后的一段才是真正后端地址</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>需要在任意一个位置加上upstream：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   upstream ruoyi&#123;</span><br><span class="line">server 192.168.78.129:8080 weight=5;</span><br><span class="line">server 192.168.78.130:8080 weight=3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>并且把location /prod-api/ ，改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   location /prod-api/ &#123;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http://ruoyi/;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>/usr/local/nginx/sbin/nginx -s reload，重启Nginx，这样Nginx便会自动的实现负载均衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用Nginx进行前后端分离项目部署&quot;&gt;&lt;a href=&quot;#利用Nginx进行前后端分离项目部署&quot; class=&quot;headerlink&quot; title=&quot;利用Nginx进行前后端分离项目部署&quot;&gt;&lt;/a&gt;利用Nginx进行前后端分离项目部署&lt;/h2&gt;&lt;p&gt;首先需要这个</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="项目" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis（二）</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/09/redis4/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/09/redis4/</id>
    <published>2020-06-09T11:25:09.000Z</published>
    <updated>2020-06-12T13:52:47.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的数据库"><a href="#Redis的数据库" class="headerlink" title="Redis的数据库"></a>Redis的数据库</h2><h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>redis和mysql类似，redis也有自己不同的数据库。但是和mysql不一样的是，redis的数据库是自发产生的，redis会根据服务器状态，自行的确定数据库的数量。默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000421.jpg" alt=""></p><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line">redis&gt; SELECT <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line">(<span class="literal">nil</span>)</span><br><span class="line">redis[<span class="number">2</span>]&gt; SET msg<span class="string">"another world"</span></span><br><span class="line">OK</span><br><span class="line">redis[<span class="number">2</span>]&gt; GET msg</span><br><span class="line"><span class="string">"another world"</span></span><br></pre></td></tr></table></figure><h4 id="谨慎处理多数据库程序"><a href="#谨慎处理多数据库程序" class="headerlink" title="谨慎处理多数据库程序"></a>谨慎处理多数据库程序</h4><p>如果你在其他语言的客户端中执行Redis命令，并且该客户端没有像redis-cli那样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。</p><h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p>如我们执行一下命令：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; RPUSH alphabet <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line">(integer)<span class="number">3</span></span><br><span class="line">redis&gt; HSET book name <span class="string">"Redis in Action"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book author <span class="string">"Josiah L. Carlson"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; HSET book publisher <span class="string">"Manning"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后的模型就是这样：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000028.jpg" alt=""></p><h5 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h5><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">date</span> <span class="string">"2013.12.1"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000391.jpg" alt=""></p><h5 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h5><p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p><h5 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h5><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p><h5 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h5><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</p><h5 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h5><p>除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。</p><p>比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p><p>另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。</p><h5 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h5><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之内</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line">redis&gt; GET key  // <span class="number">5</span>秒之后</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。</p><p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE key <span class="number">1000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(integer) <span class="number">997</span></span><br><span class="line">redis&gt; SET another_key another_value</span><br><span class="line">OK</span><br><span class="line">redis&gt; TIME</span><br><span class="line"><span class="number">1</span>)<span class="string">"1377333070"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"761687"</span></span><br><span class="line">redis&gt; EXPIREAT another_key <span class="number">1377333100</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL another_key</span><br><span class="line">(integer) <span class="number">10</span></span><br></pre></td></tr></table></figure><p>如果是：EXPIREAT another_key 1385877600000，这表示数据库键过期时间为1385877600000（2013年12月1日零时）。</p><h5 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h5><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li>EXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl秒。</li><li>PEXPIRE<key><ttl>命令用于将键key的生存时间设置为ttl毫秒。</li><li>EXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li><li>PEXPIREAT<key><timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p><h5 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h5><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h5 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h5><p>PERSIST命令可以移除一个键的过期时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PEXPIREAT message <span class="number">1391234400000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">13893281</span></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL message</span><br><span class="line">(integer) <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>ERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><h5 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h5><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT alphabet <span class="number">1385877600000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL alphabet</span><br><span class="line">(integer) <span class="number">8549007</span></span><br><span class="line">redis&gt; PTTL alphabet</span><br><span class="line">(integer) <span class="number">8549001011</span></span><br></pre></td></tr></table></figure><h5 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h5><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><p>1）检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</p><p>2）检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</p><h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><p>我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是：如果一个键过期了，那么它什么时候会被删除呢？</p><p>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p><p>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</p><p>例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。</p><p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。</p><p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p><p>惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</p><p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p> 从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li><li>惰性删除浪费太多内存，有内存泄漏的危险。</li><li>定期删除策略是前两种策略的一种整合和折中：</li><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li><li>定期删除策略的难点是确定删除操作执行的时长和频率：</li><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p><h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h5 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h5><p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><h5 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h5><p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><h4 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h4><p>我们将探讨过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p><h5 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h5><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><h5 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h5><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h5 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h5><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><ul><li>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：</li><li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。</li><li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。</li><li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。</li><li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。</li><li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El。</li></ul><p>关于数据库通知功能的详细用法，以及notify-keyspace-events选项的更多设置，Redis的官方文档已经做了很详细的介绍，这里不再赘述。</p><h5 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h5><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type,<span class="keyword">char</span> *event,robj *key,<span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。</p><p>event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。</p><p>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h5 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h5><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span></span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许发送的通知，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(server.notify_keyspace_events &amp; type):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment">#内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment">#将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment">#内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"__keyevent@&#123;dbid&#125;__:&#123;event&#125;"</span>.format(dbid=dbid,event=event)</span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure><p>notifyKeyspaceEvent函数执行以下操作：</p><p>1）server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</p><p>2）如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</p><p>3）最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</p><h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</li><li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li><li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li><li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li><li>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</li><li>Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li><li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li></ul><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p><p>比如：一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000211.jpg" alt=""></p><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p><p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><h5 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h5><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</p><p>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000002.jpg" alt=""></p><h5 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h5><p>前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。</p><p>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p><h5 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h5><p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。</p><p>首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</p><p>其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</p><p>最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：</p><ul><li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li><li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li></ul><p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p><h5 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h5><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h5 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h5><p>在上一节，我们介绍了SAVE命令和BGSAVE的实现方法，并且说明了这两个命令在实现方面的主要区别：SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会。</p><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h5 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h5><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件。</p><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h5><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul><p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。</p><h5 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h5><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>我们将对RDB文件本身进行介绍，并详细说明文件各个部分的结构和意义。</p><p>图展示了一个完整RDB文件所包含的各个部分:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000011.jpg" alt=""></p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。本章只介绍第六版RDB文件的结构。</p><p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p><p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h5 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h5><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000074.jpg" alt=""></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000121.jpg" alt=""></p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p><p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h5 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h5><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p><p>带有过期时间的键值对在RDB文件中的结构：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000025.jpg" alt=""></p><p>带有过期时间的键值对中的TYPE、key、value三个部分的意义，和前面介绍的不带过期时间的键值对的TYPE、key、value三个部分的意义完全相同，至于新增的EXPIRETIME_MS和ms，它们的意义如下：</p><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h5 id="Value的编码"><a href="#Value的编码" class="headerlink" title="Value的编码"></a>Value的编码</h5><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><p><strong>1.字符串对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。</p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p><strong>2.列表对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象<img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000184.jpg" alt=""></p><p><strong>3.集合对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象.。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000320.jpg" alt=""></p><p><strong>4.哈希表对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象。</p><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000410.jpg" alt="img"></p><p><strong>5.有序集合对象</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000423.jpg" alt="img"></p><p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。</p><p>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><p><strong>6.INTSET编码的集合</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p><p>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><p><strong>7.ZIPLIST编码的列表、哈希表或者有序集合</strong></p><p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，RDB文件保存这种对象的方法是：</p><p>1）将压缩列表转换成一个字符串对象。</p><p>2）将转换所得的字符串对象保存到RDB文件。</p><p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><p>1）读入字符串对象，并将它转换成原来的压缩列表对象。</p><p>2）根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</p><h4 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h4><h5 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h5><p>根据之前学习的RDB文件结构知识，当一个RDB文件没有包含任何数据库数据时，这个RDB文件将由以下四个部分组成：</p><ul><li>·五个字节的”REDIS”字符串。</li><li>·四个字节的版本号（db_version）。</li><li>·一个字节的EOF常量。</li><li>·八个字节的校验和（check_sum）。</li></ul><p>从od命令的输出中可以看到，最开头的是“REDIS”字符串，之后的0006是版本号，再之后的一个字节377代表EOF常量，最后的334 263 C 360 Z 334 362 V八个字节则代表RDB文件的校验和。</p><h5 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h5><p>根据之前学习的数据库结构知识，当一个数据库被保存到RDB文件时，这个数据库将由以下三部分组成：</p><ul><li>·一个一字节长的特殊值SELECTDB。</li><li>·一个长度可能为一字节、两字节或者五字节的数据库号码（db_number）。</li><li>·一个或以上数量的键值对（key_value_pairs）。</li></ul><p>观察od命令打印的输出，RDB文件的最开始仍然是REDIS和版本号0006，之后出现的376代表SELECTDB常量，再之后的\0代表整数0，表示被保存的数据库为0号数据库。</p><h5 id="包含带有过期时间的字符串键的RDB文件"><a href="#包含带有过期时间的字符串键的RDB文件" class="headerlink" title="包含带有过期时间的字符串键的RDB文件"></a>包含带有过期时间的字符串键的RDB文件</h5><p>根据之前学习的键值对结构知识，一个带有过期时间的键值对将由以下部分组成：</p><ul><li>·一个一字节长的EXPIRETIME_MS特殊值。</li><li>·一个八字节长的过期时间（ms）。</li><li>·一个一字节长的类型（TYPE）。</li><li>·一个键（key）和一个值（value）。</li></ul><h5 id="包含一个集合键的RDB文件"><a href="#包含一个集合键的RDB文件" class="headerlink" title="包含一个集合键的RDB文件"></a>包含一个集合键的RDB文件</h5><p>以下是RDB文件各个部分的意义：</p><ul><li>·REDIS0006：RDB文件标志和版本号。</li><li>·376\0：切换到0号数据库。</li><li>·002 004 L A N G：002是常量REDIS_RDB_TYPE_SET（这个常量的实际值为整数2），表示这是一个哈希表编码的集合键，004表示键的长度，LANG是键的名字。</li><li>·003：集合的大小，说明这个集合包含三个元素。</li><li>·004 R U B Y：集合的第一个元素。</li><li>·004 J A V A：集合的第二个元素。</li><li>·001 C：集合的第三个元素。</li><li>·377：代表常量EOF。</li><li>·202 312 r 352 346 305*023：代表校验和。</li></ul><h4 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li><li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li><li>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li><li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000442.jpg" alt="img"></p><p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。</p><p>被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF文件，观察里面的内容。</p><h5 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h5><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p><h5 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h5><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line">        <span class="comment"># 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line">        <span class="comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p><strong>文件的写入和同步</strong></p><p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><p><strong>AOF持久化的效率和安全性</strong></p><p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</li></ul><h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><p>1）创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</p><p>2）从AOF文件中分析并读取出一条写命令。</p><p>3）使用伪客户端执行被读出的写命令。</p><p>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p><p>当完成以上步骤之后，AOF文件所保存的数据库状态就会被完整地还原出来</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000420.jpg" alt=""></p><h4 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p><p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p><h4 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li><li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li><li>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</li><li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li><li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li><li>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h5 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h5><p>文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000316.jpg" alt=""></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</p><p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><h5 id="I-O多路复用程序的实现"><a href="#I-O多路复用程序的实现" class="headerlink" title="I/O多路复用程序的实现"></a>I/O多路复用程序的实现</h5><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><h5 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h5><p>I/O多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件。</li><li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li></ul><p>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p><p>ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p><p>ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li>·如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li><li>·如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li><li>·如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li><li>·如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE|AE_WRITABLE。</li></ul><p>ae.c/aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p><p>ae.c/aeApiPoll函数接受一个sys/time.h/struct timeval结构为参数，并在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p><p>ae.c/aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p><p>ae.c/aeGetApiName函数返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p><h5 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h5><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li>·为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>·为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>·为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>·当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><p><strong>1.连接应答处理器</strong></p><p>networking.c/acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p><p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000266.jpg" alt="img"></p><p><strong>2.命令请求处理器</strong></p><p>networking.c/readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。</p><p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000331.jpg" alt="img"></p><p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p><p><strong>3.命令回复处理器</strong></p><p>networking.c/sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p><p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作，如图。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000250.jpg" alt="img"></p><p>当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件之间的关联。</p><p><strong>4.一次完整的客户端与服务器连接事件示例</strong></p><p>让我们来追踪一次Redis客户端与服务器进行连接并发送命令的整个过程，看看在过程中会产生什么事件，而这些事件又是如何被处理的。</p><p>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p><p>如果这时有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p><p>之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p><p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000008.jpg" alt="img"></p><p>#####　时间事件</p><p>Redis的时间事件分为以下两类：</p><ul><li>·定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>·周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>·id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>·when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li><li>·timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>·如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>·如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p><p>#####　实现</p><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><p>图展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件：因为新的时间事件总是插入到链表的表头，所以三个时间事件分别按ID逆序排序，表头事件的ID为3，中间事件的ID为2，表尾事件的ID为1。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000382.jpg" alt="img"></p><p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p><p>无序链表并不影响时间事件处理器的性能</p><p>在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><p>ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。</p><h5 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h5><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>·更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>·清理数据库中的过期键值对。</li><li>·关闭和清理连接失效的客户端。</li><li>·尝试进行AOF或RDB持久化操作。</li><li>·如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>·如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p><p>在Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。</p><p>从Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。</p><h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>从事件处理的角度来看，Redis服务器的运行流程可以用流程图：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000428.jpg" alt=""></p><p>以下是事件的调度和执行规则：</p><p>1）aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</p><p>2）因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</p><p>3）对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</p><p>4）因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</p><h4 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li><li>文件事件处理器是基于Reactor模式实现的网络通信程序。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li><li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li><li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p><p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><ol><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值（flag）。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li></ol><h4 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h4><p>客户端状态包含的属性可以分为两类：</p><p>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</p><p>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</p><h5 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h5><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符。</p><p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p><ul><li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。</li><li>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数。</li></ul><h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p><h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态</p><p>每个标志使用一个常量表示，一部分标志记录了客户端的角色：</p><p>·在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</p><p>·REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。</p><p>·REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</p><p>而另外一部分标志则记录了客户端目前所处的状态：</p><p>·REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</p><p>·REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</p><p>·REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。</p><p>·REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来，不再阻塞。REDIS_UNBLOCKED标志只能在REDIS_BLOCKED标志已经打开的情况下使用。</p><p>·REDIS_MULTI标志表示客户端正在执行事务。</p><p>·REDIS_DIRTY_CAS标志表示事务使用WATCH命令监视的数据库键已经被修改，REDIS_DIRTY_EXEC标志表示事务在命令入队时出现了错误，以上两个标志都表示事务的安全性已经被破坏，只要这两个标记中的任意一个被打开，EXEC命令必然会执行失败。这两个标志只能在客户端打开了REDIS_MULTI标志的情况下使用。</p><p>·REDIS_CLOSE_ASAP标志表示客户端的输出缓冲区大小超出了服务器允许的范围，服务器会在下一次执行serverCron函数时关闭这个客户端，以免服务器的稳定性受到这个客户端影响。积存在输出缓冲区中的所有内容会直接被释放，不会返回给客户端。</p><p>·REDIS_CLOSE_AFTER_REPLY标志表示有用户对这个客户端执行了CLIENT KILL命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端，然后关闭客户端。</p><p>·REDIS_ASKING标志表示客户端向集群节点（运行在集群模式下的服务器）发送了ASKING命令。</p><p>·REDIS_FORCE_AOF标志强制服务器将当前执行的命令写入到AOF文件里面，REDIS_FORCE_REPL标志强制主服务器将当前执行的命令复制给所有从服务器。执行PUBSUB命令会使客户端打开REDIS_FORCE_AOF标志，执行SCRIPT LOAD命令会使客户端打开REDIS_FORCE_AOF标志和REDIS_FORCE_REPL标志。</p><p>·在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送这个命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY标志，否则发送操作会被拒绝执行。</p><p>以上提到的所有标志都定义在redis.h文件里面。</p><p><strong>PUBSUB命令和SCRIPT LOAD命令的特殊性</strong></p><p>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。<br>以上规则适用于绝大部分Redis命令，但PUBSUB命令和SCRIPT LOAD命令是其中的例外。PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。因此，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。SCRIPT LOAD命令的情况与PUBSUB命令类似：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。</p><h5 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求</p><h5 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h5><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。</p><p>argc属性则负责记录argv数组的长度。</p><h5 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h5><p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p><h5 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h5><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p><p>·固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</p><p>·可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</p><h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证</p><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>最后，客户端还有几个和时间有关的属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><h4 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h4><p>服务器使用不同的方式来创建和关闭不同类型的客户端，本节将介绍服务器创建和关闭客户端的方法。</p><h5 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h5><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器（在第12章有介绍），为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p><h5 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h5><p>一个普通客户端可以因为多种原因而被关闭：</p><p>·如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</p><p>·如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</p><p>·如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</p><p>·如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS_MASTER标志），从服务器（打开了REDIS_SLAVE标志），正在被BLPOP等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</p><p>·如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</p><p>·如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</p><p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。</p><p>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><p>·硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</p><p>·软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</p><h5 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h5><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisClient *lua_client;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h5><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端.</p><h4 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li><li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li><li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li><li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li><li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li><li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li><li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li><li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li><li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li></ul><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h4 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h4><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。</p><h5 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h5><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p><h5 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h5><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p><p>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</p><p>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p>3）调用命令执行器，执行客户端指定的命令。</p><h5 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h5><p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p><p>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息，表记录了这个结构的各个主要属性的类型和作用：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000095.jpg" alt=""></p><h5 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h5><p>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：</p><p>·检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</p><p>·根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</p><p>·检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</p><p>·如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</p><p>·如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</p><p>·如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</p><p>·如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</p><p>·如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</p><p>·如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</p><p>·如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</p><h5 id="命令执行器（3）：调用命令的实现函数"><a href="#命令执行器（3）：调用命令的实现函数" class="headerlink" title="命令执行器（3）：调用命令的实现函数"></a>命令执行器（3）：调用命令的实现函数</h5><p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// client</span><br><span class="line">是指向客户端状态的指针</span><br><span class="line">client-&gt;cmd-&gt;proc(client);</span><br></pre></td></tr></table></figure><h5 id="命令执行器（4）：执行后续工作"><a href="#命令执行器（4）：执行后续工作" class="headerlink" title="命令执行器（4）：执行后续工作"></a>命令执行器（4）：执行后续工作</h5><p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p><p>·如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</p><p>·根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</p><p>·如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</p><p>·如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</p><p>当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了</p><h5 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h5><p>前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p><h5 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h5><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端）</p><h5 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h5><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h5 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h5><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p><p>·服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</p><p>·对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</p><h5 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h5><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">// 用于计算键的空转（idle）时长。</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h5><p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过INFO status命令的instantaneous_ops_per_sec域查看</p><h5 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h5><p>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h5><p>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGTERM信号的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    redisLogFromHandler(REDIS_WARNING,<span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</span><br><span class="line">    <span class="comment">// 打开关闭标识</span></span><br><span class="line">    server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h5><p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p><p>·如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。</p><p>·如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</p><h5 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h5><p>serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</p><h5 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h5><p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p><h5 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h5><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGSAVE，</span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;                <span class="comment">/* PID of RDB saving child */</span></span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID：</span></span><br><span class="line">    <span class="comment">// 如果服务器没有在执行BGREWRITEAOF，    </span></span><br><span class="line">    <span class="comment">// 那么这个属性的值为-1。</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;                <span class="comment">/* PID if rewriting process */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p><p>·如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</p><p>·如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</p><p>另一方面，如果rdb_child_pid和aof_child_pid两个属性的值都为-1，那么表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：</p><p>1）查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作（这就是上一个小节我们说到的检查）。</p><p>2）检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了）。</p><p>3）检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000328.jpg" alt=""></p><h5 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h5><p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</p><h5 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h5><p>在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端</p><h5 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h5><p>服务器状态的cronloops属性记录了serverCron函数执行的次数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// serverCron函数的运行次数计数器</span></span><br><span class="line">    <span class="comment">// serverCron函数每执行一次，这个属性的值就增一。</span></span><br><span class="line">    <span class="keyword">int</span> cronloops;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能。</p><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h5 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h5><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置服务器的运行id </span></span><br><span class="line">    getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);</span><br><span class="line">    <span class="comment">// 为运行id加上结尾字符</span></span><br><span class="line">    server.runid[REDIS_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 设置默认配置文件路径</span></span><br><span class="line">    server.configfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器频率</span></span><br><span class="line">    server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line">    <span class="comment">// 设置服务器的运行架构</span></span><br><span class="line">    server.arch_bits = (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器端口号</span></span><br><span class="line">    server.port = REDIS_SERVERPORT;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是initServerConfig函数完成的主要工作：</p><p>·设置服务器的运行ID。</p><p>·设置服务器的默认运行频率。</p><p>·设置服务器的默认配置文件路径。</p><p>·设置服务器的运行架构。</p><p>·设置服务器的默认端口号。</p><p>·设置服务器的默认RDB持久化条件和AOF持久化条件。</p><p>·初始化服务器的LRU时钟。</p><p>·创建命令表。</p><p>initServerConfig函数设置的服务器状态属性基本都是一些整数、浮点数、或者字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象这些数据结构在之后的步骤才会被创建出来。</p><h5 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h5><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p><h5 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h5><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p><p>·server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisClient结构实例。</p><p>·server.db数组，数组中包含了服务器的所有数据库。</p><p>·用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</p><p>·用于执行Lua脚本的Lua环境server.lua。</p><p>·用于保存慢查询日志的server.slowlog属性。</p><p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p><p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p><p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p><p>·为服务器设置进程信号处理器。</p><p>·创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</p><p>·打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</p><p>·为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</p><p>·如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</p><p>·初始化服务器的后台I/O模块（bio），为将来的I/O操作做好准备。</p><h5 id="原数据库状态"><a href="#原数据库状态" class="headerlink" title="原数据库状态"></a>原数据库状态</h5><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p><p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p><p>·如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</p><p>·相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</p><h5 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h5><p>在初始化的最后一步，服务器将打印出日志。</p><h4 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h4><p>一个命令请求从发送到完成主要包括以下步骤：</p><ul><li>1）客户端将命令请求发送给服务器；</li><li>2）服务器读取命令请求，并分析出命令参数；</li><li>3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li><li>4）服务器将命令回复返回给客户端。</li></ul><p>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</p><p>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ul><li>1）初始化服务器状态；</li><li>2）载入服务器配置；</li><li>3）初始化服务器数据结构；</li><li>4）还原数据库状态；</li><li>5）执行事件循环。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的数据库&quot;&gt;&lt;a href=&quot;#Redis的数据库&quot; class=&quot;headerlink&quot; title=&quot;Redis的数据库&quot;&gt;&lt;/a&gt;Redis的数据库&lt;/h2&gt;&lt;h4 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis（一）</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/06/02/redis3/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/06/02/redis3/</id>
    <published>2020-06-02T11:25:03.000Z</published>
    <updated>2020-06-12T13:52:34.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>在深入学习Springboot之后，我想，对于各个部件的使用，不应该仅仅局限于它的外部API，如果可以深入的去了解它的构造，想必以后也会有很多收获吧。</p><p>首先，我们来阐述一下Redis的概念，我们一般使用Redis，都是把它作为一个缓存来用，那么这是一个用于什么类型的缓存呢，是图片？视频？还是什么？答案是字符串。其实Redis可以从狭义上来理解，Redis就是用来存储字符串的。你可不要小看这样的字符串，字符串可是信息的基本组成，也是数据的基石。</p><p>而Redis，则是由C语言来编写的，一个高速缓存器。</p><p>Redis自己构建了一种名为简单动态字符串的抽象类型，名为SDS。当我们加入一个字符串缓存时，Redis会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS。</p></li><li><p>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。</p></li></ul><p>如果客户端执行命令:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fruits <span class="string">"apple"</span> <span class="string">"banana"</span> <span class="string">"cherry"</span></span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串“fruits”的SDS。</li><li>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串“apple”，第二个SDS保存着字符串“banana”，第三个SDS保存着字符串“cherry”。</li></ul><h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><p>SDS是一个由C语言写成的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000134.jpg" alt=""></p><ul><li><p>free属性的值为0，表示这个SDS没有分配任何未使用空间。</p></li><li><p>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</p></li><li><p>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、’e’、’d’、’i’、’s’五个字符，而最后一个字节则保存了空字符’\0’。</p></li></ul><h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h4><p>根据传统，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000112.jpg" alt=""></p><h5 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h5><p>因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000075.jpg" alt=""></p><p>和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000014.jpg" alt=""></p><h5 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h5><p>除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p><p>如已经存在：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000041.jpg" alt=""></p><p>将s1的内容修改为”Redis Cluster”，但粗心的他却忘了在执行strcat之前为s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2保存的内容被意外地修改：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000051.jpg" alt=""></p><p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p><p>sdscat将在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接”Cluster”之后，sdscat就会先扩展s的空间，然后才执行拼接”Cluster”的操作：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000065.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000149.jpg" alt=""></p><p>sdscat不仅对这个SDS进行了拼接操作，它还为SDS分配了13字节的未使用空间，并且拼接之后的字符串也正好是13字节长，这种现象既不是bug也不是巧合，它和SDS的空间分配策略有关。</p><h5 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h5><p>C字符串并不记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。</li></ul><p>但是Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响。</p><p>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。</p><p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><p><strong>1.空间预分配</strong></p><p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。</p><ul><li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。</li><li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</li></ul><p>比如说：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000158.jpg" alt=""></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, <span class="string">" Cluster"</span>);</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000178.jpg" alt=""></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, <span class="string">" Tutorial"</span>)</span><br></pre></td></tr></table></figure><p>那么这次sdscat将不需要执行内存重分配，因为未使用空间里面的13字节足以保存9字节的”Tutorial”，执行sdscat之后的SDS。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000411.jpg" alt=""></p><p><strong>2.惰性空间释放</strong></p><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p><h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><p>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p><p>如果有一种使用空字符来分割多个单词的特殊数据格式，那么这种格式就不能使用C字符串来保存，因为C字符串所用的函数只会识别出其中的”Redis”，而忽略之后的”Cluster”。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000018.jpg" alt=""></p><p>使用SDS来保存之前提到的特殊数据格式就没有任何问题，因为SDS使用len属性的值而不是空字符来判断字符串是否结束。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000127.jpg" alt=""></p><h5 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h5><p>虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000119.jpg" alt=""></p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><p>比如说：以下展示的integers列表键包含了从1到1024共一千零二十四个整数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; LLEN integers</span><br><span class="line">(integer) <span class="number">1024</span></span><br><span class="line">redis&gt; LRANGE integers <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>)<span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"3"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"4"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"5"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"6"</span></span><br><span class="line"><span class="number">7</span>)<span class="string">"7"</span></span><br><span class="line"><span class="number">8</span>)<span class="string">"8"</span></span><br><span class="line"><span class="number">9</span>)<span class="string">"9"</span></span><br><span class="line"><span class="number">10</span>)<span class="string">"10"</span></span><br><span class="line"><span class="number">11</span>)<span class="string">"11"</span></span><br></pre></td></tr></table></figure><p>integers列表键的底层实现就是一个链表，链表中的每个节点都保存了一个整数值。</p><h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="　链表和链表节点的实现"></a>　链表和链表节点的实现</h4><p>使用了一个数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000312.jpg" alt=""></p><p>并且为了方便进行管理，使用了一个list的结构去持有链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode * tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li></ul><p>于是乎，图形如下：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000235.jpg" alt=""></p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。</p><p>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p><p>举个例子，website是一个包含10086个键值对的哈希键，这个哈希键的键都是一些数据库的名字，而键的值就是数据库的主页网址：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HLEN website</span><br><span class="line">(integer) <span class="number">10086</span></span><br><span class="line">redis&gt; HGETALL website</span><br><span class="line"><span class="number">1</span>)<span class="string">"Redis"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"Redis.io"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"MariaDB"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"MariaDB.org"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"MongoDB"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"MongoDB.org"</span></span><br></pre></td></tr></table></figure><h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>哈希表的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000397.jpg" alt=""></p><h5 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h5><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><ul><li>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</li><li>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000345.jpg" alt=""></p><h5 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h5><p>Redis中的字典的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    in trehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>以此，根据上面的结构，我们可以推出一个完整的字典：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000368.jpg" alt=""></p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>比如这是一个空的字典：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000087.jpg" alt=""></p><p>然后我们会计算出kv0的哈希值，在使用哈希值去计算索引值，索引值所指的就是我们这个数据列的索引。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000096.jpg" alt=""></p><h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。</p><p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p>这里和Java中HashMap的处理方法非常的一致。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000221.jpg" alt=""></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><p>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：</p><p>·如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）；</p><p>·如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。</p><p>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p><p>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p><h5 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h5><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><p>1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</p><p>2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</p><p>对于一个大小为512，包含256个键值对的哈希表来说，这个哈希表的负载因子为：load_factor = ht[0].used / ht[0].size＝0.5</p><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。这样做的原因在于，一次性将这些键值对全部rehash的话，庞大的计算量可能会导致服务器在一段时间内停止服务。</p><p>因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p><p>以下是哈希表渐进式rehash的详细步骤：</p><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</p><p>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p><p>3）在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</p><p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</p><p>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p><h5 id="渐进式rehash执行期间的哈希表操作"><a href="#渐进式rehash执行期间的哈希表操作" class="headerlink" title="渐进式rehash执行期间的哈希表操作"></a>渐进式rehash执行期间的哈希表操作</h5><p>因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE fruit-price <span class="number">0</span> <span class="number">2</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>)<span class="string">"banana"</span></span><br><span class="line"><span class="number">2</span>)<span class="string">"5"</span></span><br><span class="line"><span class="number">3</span>)<span class="string">"cherry"</span></span><br><span class="line"><span class="number">4</span>)<span class="string">"6.5"</span></span><br><span class="line"><span class="number">5</span>)<span class="string">"apple"</span></span><br><span class="line"><span class="number">6</span>)<span class="string">"8"</span></span><br><span class="line">redis&gt; ZCARD fruit-price</span><br><span class="line">(integer)<span class="number">130</span></span><br></pre></td></tr></table></figure><h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000365.jpg" alt=""></p><ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>ength：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p>位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><ul><li>层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><h5 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h5><p>节点的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><strong>1.层</strong></p><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000126.jpg" alt=""></p><p><strong>2.前进指针</strong></p><p>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000188.jpg" alt=""></p><p>1）迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</p><p>2）在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</p><p>3）在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</p><p>4）当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p><p><strong>3.跨度</strong></p><p>层的跨度（level[i].span属性）用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p><strong>4.后退指针</strong></p><p>节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p><strong>5.分值和成员</strong></p><p>节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000207.jpg" alt=""></p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><p>举个例子，如果我们创建一个只包含五个元素的集合键，并且集合中的所有元素都是整数值，那么这个集合键的底层实现就会是整数集合：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line"><span class="string">"intset"</span></span><br></pre></td></tr></table></figure><h4 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h4><p>就好似如intset这个数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p><p>length属性记录了整数集合包含的元素数量，也即是contents数组的长度。</p><p>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：</p><ul><li>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767）。</li><li>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647）。</li><li>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000181.jpg" alt=""></p><ul><li>encoding属性的值为INTSET_ENC_INT16，表示整数集合的底层实现为int16_t类型的数组，而集合保存的都是int16_t类型的整数值。</li><li>length属性的值为5，表示整数集合包含五个元素。</li><li>contents数组按从小到大的顺序保存着集合中的五个元素。</li><li>因为每个集合元素都是int16_t类型的整数值，所以contents数组的大小等于sizeof（int16_t）<em>5=16</em>5=80位。</li></ul><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><p>1）根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</p><p>2）将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</p><p>3）将新元素添加到底层数组里面。</p><h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4><p>整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。</p><h5 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h5><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。</p><p>例如，我们一般只使用int16_t类型的数组来保存int16_t类型的值，只使用int32_t类型的数组来保存int32_t类型的值，诸如此类。</p><p>但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活。</p><h5 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h5><p>当然，要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值，最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。不过这样一来，即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值，数组都需要使用int64_t类型的空间去保存它们，从而出现浪费内存的情况。</p><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH lst <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">10086</span> <span class="string">"hello"</span> <span class="string">"world"</span></span><br><span class="line">(integer)<span class="number">6</span></span><br><span class="line">redis&gt; OBJECT ENCODING lst</span><br><span class="line"><span class="string">"ziplist"</span></span><br></pre></td></tr></table></figure><p><strong>注意：3.2版本的listTypePush会根据不同的编码调用不同数据结构的API，而4.0直接调用了quicklist的API，以前的编码转换的机制已经不存在了。</strong></p><h4 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h4><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000044.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000059.jpg" alt=""></p><h4 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h4><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种：</p><ul><li>长度小于等于63（2 6–1）字节的字节数组；</li><li>长度小于等于16383（2 14–1）字节的字节数组；</li><li>长度小于等于4294967295（2 32–1）字节的字节数组；</li></ul><p>而整数值则可以是以下六种长度的其中一种：</p><ul><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长的有符号整数；</li><li>3字节长的有符号整数；</li><li>nt16_t类型整数；</li><li>int32_t类型整数；</li><li>int64_t类型整数。</li></ul><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p><h5 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h5><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><h5 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h5><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度：</p><ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；</li></ul><h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000274.jpg" alt=""></p><ul><li>编码的最高两位00表示节点保存的是一个字节数组；</li><li>编码的后六位001011记录了字节数组的长度11；</li><li>content属性保存着节点的值”hello world”。</li></ul><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000305.jpg" alt=""></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N 2）。</p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O（N），在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p><p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p><h4 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>对象的type属性记录了对象的类型，这个属性的值可以是表列出的常量的其中一个。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000182.jpg" alt=""></p><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>TYPE命令在面对不同类型的值对象时所产生的输出。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000197.jpg" alt=""></p><h5 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h5><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表列出的常量的其中一个。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000377.jpg" alt=""></p><p>每种类型的对象都至少使用了两种不同的编码:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000128.jpg" alt=""></p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello wrold"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line"><span class="string">"embstr"</span></span><br><span class="line">redis&gt; SET story <span class="string">"long long long long long long ago ..."</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line">redis&gt; SADD numbers <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line"><span class="string">"intset"</span></span><br><span class="line">redis&gt; SADD numbers <span class="string">"seven"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure><p>不同编码的对象所对应的OBJECT ENCODING命令输出:</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000419.jpg" alt=""></p><p>在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li></ul><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000396.jpg" alt=""></p><ul><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li><li>可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。</li></ul><p>在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。</p><h5 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。</p><p>因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。</p><h5 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h5><p>因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的:<img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000151.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000099.jpg" alt=""></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</p><h5 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h5><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</li></ul><h5 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h5><p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000093.jpg" alt=""></p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><h5 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h5><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</li></ul><h5 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h5><p>因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000436.jpg" alt=""></p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p><h5 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码。</p><h5 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h5><p>因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000437.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000009.jpg" alt=""></p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p><p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p><h4 id="为什么有序集合需要同时使用跳跃表和字典来实现？"><a href="#为什么有序集合需要同时使用跳跃表和字典来实现？" class="headerlink" title="为什么有序集合需要同时使用跳跃表和字典来实现？"></a>为什么有序集合需要同时使用跳跃表和字典来实现？</h4><p>在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。</p><p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000216.jpg" alt=""></p><h5 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><p>有序集合保存的元素数量小于128个；</p><p>有序集合保存的所有元素成员的长度都小于64字节；</p><p>不能满足以上两个条件的有序集合对象将使用skiplist编码。</p><h5 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h5><p>因为有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的：</p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000329.jpg" alt=""></p><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000332.jpg" alt=""></p><h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。</p><p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p><h5 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h5><p>从上面发生类型错误的代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。</p><p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li><li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li></ul><h5 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h5><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1；</li><li>当对象被一个新程序使用时，它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放。</li></ul><p><img src="http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000194.jpg" alt=""></p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象，如图8-20所示。</p><p>如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有以下两种做法：</p><p>1）为键B新创建一个包含整数值100的字符串对象；</p><p>2）让键A和键B共享同一个字符串对象；</p><p>以上两种方法很明显是第二种方法更节约内存。</p><p>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p><p>1）将数据库键的值指针指向一个现有的值对象；</p><p>2）将被共享的值对象的引用计数增一。</p><h4 id="为什么Redis不共享包含字符串的对象？"><a href="#为什么Redis不共享包含字符串的对象？" class="headerlink" title="为什么Redis不共享包含字符串的对象？"></a>为什么Redis不共享包含字符串的对象？</h4><p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：</p><ul><li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）；</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N 2）。</li></ul><p>因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p><h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p>redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"># </span><br><span class="line">等待一小段时间</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">20</span></span><br><span class="line"># </span><br><span class="line">等待一阵子</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">180</span></span><br><span class="line">#</span><br><span class="line">访问msg</span><br><span class="line">键的值</span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line"># </span><br><span class="line">键处于活跃状态，空转时长为<span class="number">0</span> </span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。</p><p>除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Redis数据库中的每个键值对的键和值都是一个对象。</p><p>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</p><p>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</p><p>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</p><p>Redis会共享值为0到9999的字符串对象。</p><p>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的数据结构&quot;&gt;&lt;a href=&quot;#Redis的数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis的数据结构&quot;&gt;&lt;/a&gt;Redis的数据结构&lt;/h2&gt;&lt;p&gt;在深入学习Springboot之后，我想，对于各个部件的使用，不应该仅仅局限</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>利用tess4j实现简单图像识别</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB1/</id>
    <published>2020-05-25T09:40:10.000Z</published>
    <updated>2020-05-14T10:58:16.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用tess4j把PDF转化为文字"><a href="#利用tess4j把PDF转化为文字" class="headerlink" title="利用tess4j把PDF转化为文字"></a>利用tess4j把PDF转化为文字</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="Java运行环境"><a href="#Java运行环境" class="headerlink" title="Java运行环境"></a>Java运行环境</h4><p>在cmd输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -v</span><br></pre></td></tr></table></figure><p>JDK最好为8。</p><h4 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h4><p>利用tess4j需要训练集和资源库，在这里我把资源库地址给写死了。</p><p>请把tessdata这个文件夹放在：E：/temp/ </p><p>这个文件夹下面，没有则创建一个，仅仅手动操作这个便可以。</p><h4 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h4><p>在拿出Jar包，放在任意位置都可以，然后使用cmd 切换到目标地址下输入指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar to.jar</span><br></pre></td></tr></table></figure><p>便可以运行了，然后打开：localhost：8888。访问或者使用。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="PDF操作"><a href="#PDF操作" class="headerlink" title="PDF操作"></a>PDF操作</h4><p>这里运用了maven，在pom文件下加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.tess4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tess4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便引入了对PDF的依赖，然后在后端的控制层加入：@RequestParam(“file”) MultipartFile file 去绑定所提交的PDF文件。</p><p>然后通过将pdf分解为图片，在使用tess4j去识别图片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PDDocument doc = PDDocument.load(multipartFileToFile(file));</span><br><span class="line">PDFRenderer renderer = <span class="keyword">new</span> PDFRenderer(doc);</span><br><span class="line"><span class="keyword">int</span> pageCount = doc.getNumberOfPages();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pageCount; i++) &#123;</span><br><span class="line">    BufferedImage image = renderer.renderImageWithDPI(i, <span class="number">144</span>); </span><br><span class="line">    String fn[];</span><br><span class="line">    fn=fileName.split(<span class="string">"\\."</span>);</span><br><span class="line">    File my=<span class="keyword">new</span> File(filePath + <span class="string">"\\"</span> + fn + <span class="string">"_"</span> + (i + <span class="number">1</span>) + <span class="string">"."</span> + <span class="string">"jpg"</span>);</span><br><span class="line">    ImageIO.write(image, <span class="string">"jpg"</span>, my);</span><br><span class="line">    tesspdf(my,i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的tesspdf方法便是将图片转化为文字。</p><h4 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h4><p>在通过路劲获得了图片文件后，主要的操作方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tessreact.doOCR(imageFile);</span><br></pre></td></tr></table></figure><p>它会读取相应的图片文件，然后进行转化，它的流程是：</p><p>1、先使用：public StringBuilder() {    super(16);}，对字符串进行构建和识别，防止空串。</p><p>2、再使用：AbstractStringBuilder(int capacity) {    value = new char[capacity];}，进行构建。</p><blockquote><p>3、再对识别出的字符串进行拼串，为什么要这么做呢？那是因为有着:<code>\\</code>，这样的特殊的转义字符。具体方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、它会向tessOCR返回一个字符串表示收到，并开始构建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doOCR</span><span class="params">(File var1)</span> <span class="keyword">throws</span> TesseractException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doOCR((File)var1, (Rectangle)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、从字符串的路径中找到图片：ImageIOHelper.getImageFile(var1);</p><p>6、然后通过一个方法获取到图像的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getImageFileFormat</span><span class="params">(File var0)</span> </span>&#123;</span><br><span class="line">    String var1 = var0.getName();</span><br><span class="line">    String var2 = var1.substring(var1.lastIndexOf(<span class="number">46</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (var2.matches(<span class="string">"(pbm|pgm|ppm)"</span>)) &#123;</span><br><span class="line">        var2 = <span class="string">"pnm"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2.matches(<span class="string">"(jp2|j2k|jpf|jpx|jpm)"</span>)) &#123;</span><br><span class="line">        var2 = <span class="string">"jpeg2000"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、借助ImageIO这个类，对图像进行读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Iterator&lt;ImageReader&gt;</span><br><span class="line">        getImageReadersByFormatName(String formatName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (formatName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"formatName == null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator iter;</span><br><span class="line">        <span class="comment">// Ensure category is present</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            iter = theRegistry.getServiceProviders(ImageReaderSpi<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">new</span> <span class="title">ContainsFilter</span>(<span class="title">readerFormatNamesMethod</span>,</span></span><br><span class="line"><span class="class">                                                       <span class="title">formatName</span>),</span></span><br><span class="line"><span class="class">                                                <span class="title">true</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImageReaderIterator(iter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>8、可以从7看到，它返回的是迭代器，然后把这个迭代器的值转化为ImageReader</p><p>9、而这个ImageReader，已经拥有了对图片进行处理的能力，它会调用：readAll方法进行读取，主要方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IIOImage <span class="title">readAll</span><span class="params">(<span class="keyword">int</span> imageIndex, ImageReadParam param)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageIndex &lt; getMinIndex()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"imageIndex &lt; getMinIndex()!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BufferedImage im = read(imageIndex, param);</span><br><span class="line"></span><br><span class="line">        ArrayList thumbnails = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> numThumbnails = getNumThumbnails(imageIndex);</span><br><span class="line">        <span class="keyword">if</span> (numThumbnails &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            thumbnails = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numThumbnails; j++) &#123;</span><br><span class="line">                thumbnails.add(readThumbnail(imageIndex, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IIOMetadata metadata = getImageMetadata(imageIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IIOImage(im, thumbnails, metadata);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法隐藏了很多细节，可以看到它返回的是IIOImage，而这个IIOImage，就是我们最终要得到的数据了。</p><p>10、然后使用doOCR方法进行字符串转化，也可看到这里填入的正是IIOImage类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doOCR</span><span class="params">(IIOImage var1, String var2, Rectangle var3, <span class="keyword">int</span> var4)</span> <span class="keyword">throws</span> TesseractException </span>&#123;</span><br><span class="line">    String var5 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setImage(var1.getRenderedImage(), var3);</span><br><span class="line">        var5 = <span class="keyword">this</span>.getOCRText(var2, var4);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">        logger.warn(var7.getMessage(), var7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用tess4j把PDF转化为文字&quot;&gt;&lt;a href=&quot;#利用tess4j把PDF转化为文字&quot; class=&quot;headerlink&quot; title=&quot;利用tess4j把PDF转化为文字&quot;&gt;&lt;/a&gt;利用tess4j把PDF转化为文字&lt;/h2&gt;&lt;h3 id=&quot;前期准备&quot;</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="tess4j" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/tess4j/"/>
    
  </entry>
  
  <entry>
    <title>分析项目：微人事</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/22/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C2/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/22/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C2/</id>
    <published>2020-05-22T09:39:56.000Z</published>
    <updated>2020-05-14T11:23:21.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析项目：微人事"><a href="#分析项目：微人事" class="headerlink" title="分析项目：微人事"></a>分析项目：微人事</h2><p>这次我们来分析一下这个名为：”微人事“ 的项目的功能以及各个模块的实现。</p><p>这个项目分为两个大模块，分别是server模块和mail模块，这个项目的作者也已经很久没有更新了，我们先忽略掉mail这个模块，来看看server这个模块有着什么。</p><p>点击进入到server模块内，可以得知这个server模块又被切分为了四个小的模块，分别是mapper、model、service和web。</p><p>显然，这个web模块，就是我们主要学习的内容了。</p><p>之后根据经验之谈，一般在config这个包内的，基本上都是security的配置相关。</p><h3 id="Security配置"><a href="#Security配置" class="headerlink" title="Security配置"></a>Security配置</h3><p>配置中有一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O object)</span> </span>&#123;</span><br><span class="line">    object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">    object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来决定security的设置，而这两个设置，是被自定义的构造了出来。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>这个配置主要设置了两个选择，一个是在登录的时候，根据用户名去搜索数据库，根据用户名来得到用户的权限，从而跳转到该角色所能访问的页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomUrlDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute configAttribute : configAttributes) &#123;</span><br><span class="line">            String needRole = configAttribute.getAttribute();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"ROLE_LOGIN"</span>.equals(needRole)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"尚未登录，请登录!"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">                <span class="keyword">if</span> (authority.getAuthority().equals(needRole)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"权限不足，请联系管理员!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求分析"><a href="#请求分析" class="headerlink" title="请求分析"></a>请求分析</h4><p>这个类的作用，主要是根据用户传来的请求地址，分析出请求需要的角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilterInvocationSecurityMetadataSource</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuService menuService;</span><br><span class="line">    AntPathMatcher antPathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        String requestUrl = ((FilterInvocation) object).getRequestUrl();</span><br><span class="line">        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();</span><br><span class="line">        <span class="keyword">for</span> (Menu menu : menus) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(menu.getUrl(), requestUrl)) &#123;</span><br><span class="line">                List&lt;Role&gt; roles = menu.getRoles();</span><br><span class="line">                String[] str = <span class="keyword">new</span> String[roles.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roles.size(); i++) &#123;</span><br><span class="line">                    str[i] = roles.get(i).getName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> SecurityConfig.createList(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SecurityConfig.createList(<span class="string">"ROLE_LOGIN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有可以值得思考的地方是，作者的security为每一个成功或者失败的Handler，都做了自己处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        Hr hr = (Hr) authentication.getPrincipal();</span><br><span class="line">        hr.setPassword(<span class="keyword">null</span>);</span><br><span class="line">        RespBean ok = RespBean.ok(<span class="string">"登录成功!"</span>, hr);</span><br><span class="line">        String s = <span class="keyword">new</span> ObjectMapper().writeValueAsString(ok);</span><br><span class="line">        out.write(s);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">                    .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        RespBean respBean = RespBean.error(<span class="string">"登录失败!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            respBean.setMsg(<span class="string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="层次的结合"><a href="#层次的结合" class="headerlink" title="层次的结合"></a>层次的结合</h3><p>如果说单单security的设置的话，可能很多人自认为自己可以耐心一点，慢慢写，也可以做到很详细的配置。但是我还看到了别的地方。</p><p>我们来看到Controller层，这里有着：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/system/config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuService menuService;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/menu"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getMenusByHrId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuService.getMenusByHrId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出一点不太符合逻辑的东西，这里的方法明显是在展示一个菜单，为什么service的方法名有一个ByHrId？我们却没有在任何一点地方看到传入Hr的信息啊？</p><p>我们点进去看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getMenusByHrId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现是获取到security的权限表的一个ID，也就是说，它的菜单栏会根据Hr的ID在展现。</p><p>为什么要这么做呢？那是因为为了方便以后更方便扩展，可以拥有更高的权限去解锁更多的选项栏，从现在这样的一对多关系延伸到多对多关系。</p><h4 id="规范的写法"><a href="#规范的写法" class="headerlink" title="规范的写法"></a>规范的写法</h4><p>我们还可以从Controller层看到，这里返回的是自定义的类RespBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RespBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">ok</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">200</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">ok</span><span class="params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">200</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">error</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">500</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title">error</span><span class="params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="number">500</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以更规范的去使用，便于让前端明白是什么类型，而不是非常粗暴的使用HashMap，使用HashMap有很多不好的地方。这里暂时不说明</p><h4 id="自定义处理"><a href="#自定义处理" class="headerlink" title="自定义处理"></a>自定义处理</h4><p>还有，自己定义对时间的类型的处理，时间类型的绑定往往会是前后端解耦比较麻烦的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运用缓存"><a href="#运用缓存" class="headerlink" title="运用缓存"></a>运用缓存</h4><p>在service层上也运用了缓存的功能，我们可以使用缓存区缓解压力，就例如像菜单这样的设置，完全可以使用CacheConfig去设置一个缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"menus_cache"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuMapper menuMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuRoleMapper menuRoleMapper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getMenusByHrId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getAllMenusWithRole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getAllMenusWithRole();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title">getAllMenus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getAllMenus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getMidsByRid</span><span class="params">(Integer rid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuMapper.getMidsByRid(rid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateMenuRole</span><span class="params">(Integer rid, Integer[] mids)</span> </span>&#123;</span><br><span class="line">        menuRoleMapper.deleteByRid(rid);</span><br><span class="line">        <span class="keyword">if</span> (mids == <span class="keyword">null</span> || mids.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer result = menuRoleMapper.insertRecord(rid, mids);</span><br><span class="line">        <span class="keyword">return</span> result==mids.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追溯到底层，我们可以看到GetALlMenusWithRole这样的方法的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="getAllMenusWithRole" resultMap="MenuWithRole"&gt;</span><br><span class="line">  <span class="keyword">select</span> m.*,r.<span class="string">`id`</span> <span class="keyword">as</span> rid,r.<span class="string">`name`</span> <span class="keyword">as</span> rname,r.<span class="string">`nameZh`</span> <span class="keyword">as</span> rnameZh <span class="keyword">from</span> menu m,menu_role mr,<span class="keyword">role</span> r <span class="keyword">where</span> m.<span class="string">`id`</span>=mr.<span class="string">`mid`</span> <span class="keyword">and</span> mr.<span class="string">`rid`</span>=r.<span class="string">`id`</span> <span class="keyword">order</span> <span class="keyword">by</span> m.<span class="string">`id`</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>像类似于这样的SQL语句完全可以进行一定的缓存封装，从而减少压力。</p><h3 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h3><p>这样项目就这么完美，没有差错吗？也不尽然，从以往的眼光来看，我们看这个项目就算是一个SSM项目的经典类型。这个项目不涉及云服务也不涉及应用监控相关的内容，但仅仅是用于自己的毕业设计的话，也就是足够了。</p><p>当然，我本身在测试这个项目的时候还发现一些这个项目错误的地方，现今指出来：</p><p>比如在使用Search功能的时候出现的keyword错误，需要把Mapper的SQL修改一下，改为 name</p><p>其次就是在使用导出数据的时候，作者还没有配置相关数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/export"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; exportData() &#123;</span><br><span class="line">    List&lt;Employee&gt; list = (List&lt;Employee&gt;) employeeService.getEmployeeByPage(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,<span class="keyword">null</span>).getData();</span><br><span class="line">    <span class="keyword">return</span> POIUtils.employee2Excel(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，这个项目非常适合一些学了知识却又不知道怎么运用的初学者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析项目：微人事&quot;&gt;&lt;a href=&quot;#分析项目：微人事&quot; class=&quot;headerlink&quot; title=&quot;分析项目：微人事&quot;&gt;&lt;/a&gt;分析项目：微人事&lt;/h2&gt;&lt;p&gt;这次我们来分析一下这个名为：”微人事“ 的项目的功能以及各个模块的实现。&lt;/p&gt;
&lt;p&gt;这个</summary>
      
    
    
    
    
    <category term="项目" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="SpringBoot+" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用ElasticSearch搜索服务器做全文检索</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/18/spring16/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/18/spring16/</id>
    <published>2020-05-18T08:24:37.000Z</published>
    <updated>2021-02-08T11:39:40.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用ElasticSearch做全文检索"><a href="#使用ElasticSearch做全文检索" class="headerlink" title="使用ElasticSearch做全文检索"></a>使用ElasticSearch做全文检索</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于ElasticSearch网络上有很多的教程。但是这些教程，讲的都不是很好，大多数都仅讲了，它是一个搜索服务器，一个搜索引擎，这种比较抽象的话，并没有解释他的是一个什么样的结构，这让我在当初学习的时候，有中无从下手的感觉。但如今对他有了一定的了解，于是乎，我打算把这些功能比较形象的写出来。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>这个概念比较关键，如果你能理解它的概念，那么你也能理解他的大部分逻辑了。</p><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>首先你要明白搜索引擎这个概念。我们平常用的搜索引擎如，百度，谷歌等等。他们是怎么样在这上亿的数据量中快速的搜索到我们需要的内容呢？如果仅仅依靠数据库。，那么，会给数据库造成很大的压力，而且曾经上万的人可能在同一时间使用搜索引擎去搜索内容。数据库怎么可能承担了如此之多的数据量的访问呢？</p><p>那么我们根据之前所学的概念。我们可以尝试用的缓存去解决这个问题。对！把需要读取的需要读取的东西放入缓存中。如果需要再从缓存当中去读取。那么就不会给数据库造成很大压力了。但之前的缓存像Redis，它是一种类似于key- value的类型。那么对于千奇百怪的搜索内容，不同编码的字符串，redis是怎么能够能中搜索到呢？就算他能够实现。但是缓存这种东西。一般来说是不会把它设置为永久存在的。缓存一般有他的存活时间，他也没有像数据库那么稳定。所以单单是使用缓存去解决这个问题，明显不是最优的选择。</p><p>另外一个比较重要的一点就是，在一个商城中。我们一般都会实现搜索这种功能。但搜索功能是直接去访问数据库的。如果很多人进行搜索，那么海量的请求会给我们数据库造成极大的压力。所以我们也需要把这种东西拆分成两部分。用别的东西去代替搜索，或者说不直接从数据库访问数据。但是仅仅是Redis缓存明显不能够承担这种任务。</p><p>于是乎便诞生了ElasticSearch，这种NoSQL类型特殊的数据库型缓存。对，<strong>就是数据库类型的缓存。</strong></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>他的工作流程主要是：当用户需要某一个数据时，先从数据库里读取，再把这个数据加入到这个特殊的缓存当中。然后当我们需要某些内容的，他们就能够去这个特殊的缓存中读取数据。这种读取速度的方法跟一般的缓存不同的是，会根据内容关键词去进行搜索，只会的搜索出所需要的内容。</p><p>之后如若遇到有相同的关键词，就会去这个搜索服务器中搜索。将它的值或数据类型，返回给用户。而当我们这关键词在这搜索服务器中所显示数据量太少，或者说没有这个数据时，才会去数据库中再次读取数据。再补充到到搜索服务器当中。这个工作流程和Redis缓存非常的类似。但主要的区别在于，它是一个能够搜索和存储的数据库型缓存。</p><h4 id="和Redis的主要区别"><a href="#和Redis的主要区别" class="headerlink" title="和Redis的主要区别"></a>和Redis的主要区别</h4><p>那这是不是代表了这个搜索服务器完全可以取代Redis这个缓存呢？其实这是不一样的。因为我们的这个搜索服务器，他虽然能对关键是进行搜索，但这搜索的效率相对缓存那样的key-value直接取值而言，并不是特别高，虽然说比数据库要快，但是单单论缓存的速度而言，是远远的比不上Redis的。</p><p>所以，当我们需要搜索的时候才会用这个搜索服务器。我们一般仅仅是使用缓存的话还是Redis比较快速。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>就一个商城项目而言，当我们需要去搜索的时候，就用这个搜索服务器，快速的将关键词拆分进搜索，然后返回出相应的内容，但是这些内容并不包含所有的信息。他只包含了一些比较关键的信息，就例如它的头标题或者是特定的图片等等。</p><p>然后等用户点进的这个链接。我们才会去从数据库中另外读取数据，或者说去Redis中读取数据。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>接下来我们就来进行一个实验，来尝试的使用这个搜索服务器。</p><p>但是这个东西操作有点困难，所以你必须先掌握docker的使用</p><p>譬如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">要求熟练掌握</span></span><br><span class="line">ip addr</span><br><span class="line">service network restart</span><br><span class="line">service docker start</span><br><span class="line">docker pull xxx</span><br><span class="line">docker images</span><br><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br><span class="line">docker run xxx</span><br><span class="line">docker kill xxx</span><br><span class="line">docker rm xxx</span><br><span class="line">docker rename xxx yyy</span><br><span class="line">docker image rm xxx</span><br><span class="line">docker restart xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">了解</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim xxx</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:xxx </span><br><span class="line"><span class="meta">#</span><span class="bash">必须带版本号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动</span></span></span><br><span class="line">docker run -d -e ES_JAVA_POTS="-Xms256m -Xmx256m"  -e "discovery.type=single-node" -p 9200:9200 -p 9300:9300 --name es01 f29a1ee41030</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>如果你的云服务器内存不足1G的话，则使用</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find / -name jvm.options</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#使用此指令找到es的jvm设置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#使用</span></span></span><br><span class="line">vim /var/lib/docker/overlay2/973a5c6a4450ab59e64d6ba7e78ed6622512c142e0a2f8164653b11e8b66baa9/diff/usr/share/elasticsearch/config/jvm.options</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">进入，将-xms和-xmx参数，改为256m</span></span><br></pre></td></tr></table></figure><p>否则可能会出现：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/20210208/0-1.png" alt=""></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.searchbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个依赖还包括其他东西。我们一般是用这个jest方法去使用elasticsearch。</p><h5 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">jest:</span></span><br><span class="line">      <span class="attr">uris:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">http://192.168.78.128:9200</span>  <span class="comment"># ES服务器的地址！</span></span><br><span class="line">      <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">763638353551774166L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_NAME = <span class="string">"index_entity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE = <span class="string">"tstype"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(Entity entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(List&lt;Entity&gt; entityList)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Entity&gt; <span class="title">searchEntity</span><span class="params">(String searchContent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JestClient jestClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(Entity entity)</span> </span>&#123;</span><br><span class="line">        Index index = <span class="keyword">new</span> Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jestClient.execute(index);</span><br><span class="line">            LOGGER.info(<span class="string">"ES 插入完成"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量保存内容到ES</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(List&lt;Entity&gt; entityList)</span> </span>&#123;</span><br><span class="line">        Bulk.Builder bulk = <span class="keyword">new</span> Bulk.Builder();</span><br><span class="line">        <span class="keyword">for</span>(Entity entity : entityList) &#123;</span><br><span class="line">            Index index = <span class="keyword">new</span> Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br><span class="line">            bulk.addAction(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jestClient.execute(bulk.build());</span><br><span class="line">            LOGGER.info(<span class="string">"ES 插入完成"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在ES中搜索内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Entity&gt; <span class="title">searchEntity</span><span class="params">(String searchContent)</span></span>&#123;</span><br><span class="line">        SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//searchSourceBuilder.query(QueryBuilders.queryStringQuery(searchContent));</span></span><br><span class="line">        <span class="comment">//searchSourceBuilder.field("name");</span></span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"name"</span>,searchContent));</span><br><span class="line">        Search search = <span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                .addIndex(Entity.INDEX_NAME).addType(Entity.TYPE).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JestResult result = jestClient.execute(search);</span><br><span class="line">            System.out.println(result.toString());</span><br><span class="line">            <span class="keyword">return</span> result.getSourceAsObjectList(Entity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来到了重点，详细说一说。</p><p>先说saveEntity方法，这里要注意的就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index index = <span class="keyword">new</span> Index.Builder(entity).index(Entity.INDEX_NAME).type(Entity.TYPE).build();</span><br></pre></td></tr></table></figure><p>他到底做了什么呢？我们可以从index和type这两个，看到它是在为一个entity类实例建立一个索引名和索引类型，将两者绑定在一起，作为一个索引类型被执行。调用的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.source = source;</span><br><span class="line">    <span class="keyword">this</span>.id(AbstractAction.getIdFromSource(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它没有对Entity做改动，而仅仅是加上一部分属于他的内容。</p><p>我们还可以从中获取到，这个index 类型还附带一个url：uri=index_entity/tstype,method=POST</p><p>将这个索引类型发送到我们的ES服务器当中。</p><p>接着，我们来看到下面的Search方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"name"</span>,searchContent));</span><br></pre></td></tr></table></figure><p>这个方法一开始就建立了一个对象，我们可以看到：QueryBuilders.matchQuery(“name”,searchContent)是对要搜索的内容，进行了一定程度的转换，那么转换成什么样子了呢？</p><p>我们使用一个例子：entityController/search?name=北京 为例。进行搜索，我们来看看这个searchSourceBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span> : &#123;</span><br><span class="line">    <span class="string">"match"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : &#123;</span><br><span class="line">        <span class="string">"query"</span> : <span class="string">"北京"</span>,</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"boolean"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变为了一个Json型对象，记住，他将要搜索的内容：北京，变为了一个Json对象。然后通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Search search = <span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                .addIndex(Entity.INDEX_NAME).addType(Entity.TYPE).build();</span><br></pre></td></tr></table></figure><p>封装成一个Url，发送到ES服务器。它里面的内容是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri=index_entity/tstype/_search,method=POST</span><br></pre></td></tr></table></figure><p>和添加类似，返回进了服务器当中。</p><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/entityController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService cityESService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/save"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(<span class="keyword">long</span> id, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save 接口"</span>);</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">0</span> &amp;&amp; StringUtils.isNotEmpty(name)) &#123;</span><br><span class="line">            Entity newEntity = <span class="keyword">new</span> Entity(id,name);</span><br><span class="line">            List&lt;Entity&gt; addList = <span class="keyword">new</span> ArrayList&lt;Entity&gt;();</span><br><span class="line">            addList.add(newEntity);</span><br><span class="line">            cityESService.saveEntity(addList);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Bad input value"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/search"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Entity&gt; <span class="title">save</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        List&lt;Entity&gt; entityList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(name)) &#123;</span><br><span class="line">            entityList = cityESService.searchEntity(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层比较随意，接收参数，调用接口便可。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们可以安装ES-Head可视化插件，帮助我们查看里面的内容。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-123940.jpg" alt=""></p><p>我们打开PostMan，输入 localhost:8888/entityController/save?id=1&amp;name=北京长城，为其添加内容。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-124151.jpg" alt=""></p><p>想这样子，添加很多内容</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-124505.jpg" alt=""></p><p>之后，可以使用方法进行搜索操作，搜到到的值，会以JSON形式，返回给我们，方便我们绑定对象实例。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/elasticsearch/2020429-150806.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用ElasticSearch做全文检索&quot;&gt;&lt;a href=&quot;#使用ElasticSearch做全文检索&quot; class=&quot;headerlink&quot; title=&quot;使用ElasticSearch做全文检索&quot;&gt;&lt;/a&gt;使用ElasticSearch做全文检索&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="ElasticSearch" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Vue和Element-UI的基本使用</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/09/vue1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/09/vue1/</id>
    <published>2020-05-09T06:39:27.000Z</published>
    <updated>2020-05-14T11:28:04.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue和Element-UI的基本使用"><a href="#Vue和Element-UI的基本使用" class="headerlink" title="Vue和Element-UI的基本使用"></a>Vue和Element-UI的基本使用</h2><p>现在的前端项目都是使用vue去写的，因为vue构成的前端项目可和后端实现完全的解耦。虽然本人并非专攻于前端，但还是需要去了解他们的基本使用的。</p><p>在学习vue之前，还需要了解几个步骤，这些步骤可能有点繁杂。</p><h3 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h3><p>首先你必须要安装Nodejs，我在此先介绍一下什么是nodejs：</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Node.js 是能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。Node.js 由 Node.js Foundation持有和维护，亦为 Linux 基金会的项目。</p><p>Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。</p><p>Node.js大部分基本模块都用JavaScript语言编写。在Node.js出现之前，JavaScript通常作为客户端程序设计语言使用，以JavaScript写出的程序常在用户的浏览器上运行。Node.js的出现使JavaScript也能用于服务端编程。Node.js含有一系列内置模块，使得程序可以脱离Apache HTTP Server或IIS，作为独立服务器运行。</p><p>但我们并不注重于Nodejs本身，安装Node之后，会自动安装npm。这个npm才是我们最经常使用的工具。</p><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>npm是Node.js默认的、用JavaScript编写的软件包管理系统，需要安装Node.js才能使用npm。</p><p>npm会随着Node.js自动安装。npm模块仓库提供了一个名为“registry”的查询服务，用户可通过本地的npm命令下载并安装指定模块。此外用户也可以通过npm把自己设计的模块分发到registry上面。</p><p>之后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>查看的到npm版本，就代表安装成功了。</p><p>但是这里之所以提一下，是因为国外的镜像源速度都很慢，所以可以去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\nodejs\node_modules\npm\lib\config\defaults.js</span><br></pre></td></tr></table></figure><p>更改你的镜像源，增加速度。</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>要安装vue，还需要先安装webpack</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p>Webpack 是一个开源的前端打包工具。Webpack 提供了前端开发缺乏的模块化开发方式，将各种静态资源视为模块，并从它生成优化过的代码。[1]</p><p>Webpack可以从终端、或是更改 webpack.config.js 来设置各项功能。</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure><p>全局安装webpack。</p><h4 id="安装vue"><a href="#安装vue" class="headerlink" title="安装vue"></a>安装vue</h4><p>然后再使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><p>全局安装vue框架，概念之后再提。</p><h4 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h4><p>Yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码， 或者分享自己的代码。</p><p>代码通过 包（package） (或者称为 模块（module）) 的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。</p><p>通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g -verbose</span><br></pre></td></tr></table></figure><p>安装yarn，之后再使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set XXXXX</span><br></pre></td></tr></table></figure><p>设置你的快速镜像源。</p><p>之后，就可以使用 vue -v，查看vue版本，表示成功。</p><h3 id="Vue概念"><a href="#Vue概念" class="headerlink" title="Vue概念"></a>Vue概念</h3><p>vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>组件是Vue最为强大的特性之一。为了更好地管理一个大型的应用程序，往往需要将应用切割为小而独立、具有复用性的组件。在Vue中，组件是基础HTML元素的拓展，可方便地自定义其数据与行为。下方的代码是Vue组件的一个示例，渲染为一个能计算鼠标点击次数的按钮。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>Vue使用基于HTML的模板语法，允许开发者将DOM元素与底层Vue实例中的数据相绑定。所有Vue的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析。在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应式系统，在应用状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。[12]</p><p>此外，Vue允许开发者直接使用JSX语言作为组件的渲染函数，以代替模板语法。 以下为可计算点击次数的按钮的JSX渲染版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'buttonclicked'</span>, &#123;</span><br><span class="line">  props: [<span class="string">"initial_count"</span>],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> q = &#123;<span class="string">"count"</span>: <span class="number">0</span>&#125;; <span class="keyword">return</span> q;&#125; ,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">'button'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          click: <span class="keyword">this</span>.onclick</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'Clicked '</span> + <span class="keyword">this</span>.count + <span class="string">' times'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="string">"onclick"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.count = <span class="keyword">this</span>.initial_count;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><p>响应式是指MVC模型中的视图随着模型变化而变化。在Vue中，开发者只需将视图与对应的模型进行绑定，Vue便能自动观测模型的变动，并重绘视图。这一特性使得Vue的状态管理变得相当简单直观。</p><h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4><p>Vue在插入、更新或者移除DOM时，提供多种不同方式的应用过渡效果。 包括以下工具:</p><ul><li>在CSS过渡和动画中自动应用class</li><li>可以配合使用第三方CSS动画库，如Animate.css</li><li>在过渡钩子函数中使用JavaScript直接操作DOM</li><li>可以配合使用第三方JavaScript动画库，如Velocity.js</li></ul><h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h4><p>为了更好地适应复杂的项目，Vue支持以.vue为扩展名的文件来定义一个完整组件，用以替代使用Vue.component注册组件的方式。开发者可以使用 Webpack或Browserify等构建工具来打包单文件组件。</p><h4 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h4><p>在你存放信息的文件夹内，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack</span><br><span class="line">vue init webpack xxx</span><br></pre></td></tr></table></figure><p>注意，最好先使用第一个命令，我看网上很多都是直接使用第二个命令的，虽然直接搭建vue项目这个命令没有错，但是你会发现下载速度非常的慢，所以建议使用我的方法来。</p><p>然后继续：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd xxx</span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>安装包的依赖，在使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>就可以在localhost：8888查看vue项目了。</p><h3 id="vue结合Element-UI"><a href="#vue结合Element-UI" class="headerlink" title="vue结合Element-UI"></a>vue结合Element-UI</h3><p>Element-UI是国内的一套开源项目，可以非常快捷的开发项目。</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>我们在项目内，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add element-ui</span><br></pre></td></tr></table></figure><p>安装框架，之后打开项目，你可以使用vscode去打开，也可以使用webstorm去打开。在main.js改为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>增加ElementUI的使用。</p><h4 id="使用Element-ui"><a href="#使用Element-ui" class="headerlink" title="使用Element-ui"></a>使用Element-ui</h4><p>我们打开helloworld.vue，加入一个element按钮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;primary&quot;&gt;主要按钮&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure><p>再重启vue项目查看，就有一个vue按钮了</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-154904.jpg" alt=""></p><h4 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h4><h5 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h5><p>新建一个vue项目：Login.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page&quot; &gt;</span><br><span class="line">      &lt;h2&gt;Login Page&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;Login&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h5><p>打开index.js，添加三个路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/views/Login'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/views/Home'</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">'@/views/404'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   path: '/',</span></span><br><span class="line">    <span class="comment">//   name: 'HelloWorld',</span></span><br><span class="line">    <span class="comment">//   component: HelloWorld</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/404'</span>,</span><br><span class="line">      name: <span class="string">'notFound'</span>,</span><br><span class="line">      component: NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再打开localhost：8080，就可以在URL尝试访问这三个页面。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-161014.jpg" alt=""></p><h3 id="安装SCSS"><a href="#安装SCSS" class="headerlink" title="安装SCSS"></a>安装SCSS</h3><p>Sass是一个将脚本解析成CSS的脚本语言，即SassScript。Sass包括两套语法。最开始的语法叫做“缩进语法”，与Haml类似，使用缩进来区分代码块，并且用回车将不同规则分隔开。而较新的语法叫做“SCSS”，使用和CSS一样的块语法，即使用大括号将不同的规则分开，使用分号将具体的样式分开。</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">第一步</span></span><br><span class="line">yarn add css-loader style-loader sass-loader -D</span><br><span class="line">yarn config set sass-binary-site http://npm.taobao.org/mirrors/node-sass</span><br><span class="line">yarn add node-sass -D</span><br></pre></td></tr></table></figure><p>然后在：\build\webpack.base.conf.js 中，写入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,   </span><br><span class="line">    loaders: [<span class="string">'style'</span>, <span class="string">'css'</span>, <span class="string">'sass'</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以在style标签上更改了，比如404：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;site-wrapper site-page--not-found&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;site-content__wrapper&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;site-content&quot;&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&quot;not-found-title&quot;&gt;404&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p class&#x3D;&quot;not-found-desc&quot;&gt;抱歉！您访问的页面&lt;em&gt;失联&lt;&#x2F;em&gt;啦 ...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;$router.go(-1)&quot;&gt;返回上一页&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; class&#x3D;&quot;not-found-btn-gohome&quot; @click&#x3D;&quot;$router.push(&#39;&#x2F;&#39;)&quot;&gt;进入首页&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    &#x2F;&#x2F; name: &#39;404&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">.site-wrapper.site-page--not-found &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 60px;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    .site-content__wrapper &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">      background-color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .site-content &#123;</span><br><span class="line">      position: fixed;</span><br><span class="line">      top: 15%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      z-index: 2;</span><br><span class="line">      padding: 30px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      transform: translate(-50%, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    .not-found-title &#123;</span><br><span class="line">      margin: 20px 0 15px;</span><br><span class="line">      font-size: 8em;</span><br><span class="line">      font-weight: 500;</span><br><span class="line">      color: rgb(55, 71, 79);</span><br><span class="line">    &#125;</span><br><span class="line">    .not-found-desc &#123;</span><br><span class="line">      margin: 0 0 30px;</span><br><span class="line">      font-size: 26px;</span><br><span class="line">      text-transform: uppercase;</span><br><span class="line">      color: rgb(118, 131, 143);</span><br><span class="line">      &gt; em &#123;</span><br><span class="line">        font-style: normal;</span><br><span class="line">        color: #ee8145;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .not-found-btn-gohome &#123;</span><br><span class="line">      margin-left: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>此刻可以重新运行一遍，来看看结果。</p><p>这里填一个坑，我运行的时候报错了，需要更改sass-loader的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader@7.3.1</span><br></pre></td></tr></table></figure><p>最后，查看结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-171719.jpg" alt=""></p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。这和ajax非常的类似，我们来看看区别：</p><h4 id="ajax和axios的区别"><a href="#ajax和axios的区别" class="headerlink" title="ajax和axios的区别"></a>ajax和axios的区别</h4><h5 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h5><p>ajax：</p><p>1.本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>2.基于原生的XHR开发，XHR本身的架构不清晰。<br>3.JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）<br>4.不符合关注分离（Separation of Concerns）的原则<br>5.配置和调用方式非常混乱，而且基于事件的异步模型不友好。<br>PS:MVVM(Model-View-ViewModel), 源自于经典的 Model–View–Controller（MVC）模式。MVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。</p><h5 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a>axios</h5><p>1.从浏览器中创建 XMLHttpRequest<br>2.支持 Promise API<br>3.客户端支持防止CSRF<br>4.提供了一些并发请求的接口（重要，方便了很多的操作）<br>5.从 node.js 创建 http 请求<br>6.拦截请求和响应<br>7.转换请求和响应数据<br>8.取消请求<br>9.自动转换JSON数据<br>PS:防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p><h4 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h4><p>执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><p>然后修改Home.vue:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Home Page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;testAxios()&quot;&gt;测试Axios调用&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Home&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    testAxios() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#39;).then(res &#x3D;&gt; &#123; alert(res.data) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-172615.jpg" alt=""></p><h3 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Mock.js是一个模拟数据生成器，帮助前端开发和原型与后端进度分离，减少一些单调，特别是在编写自动化测试时。</p><p>提供了以下模拟功能：</p><ol><li><p>根据数据模板生成模拟数据</p></li><li><p>模拟 Ajax 请求，生成并返回模拟数据</p></li></ol><p>为什么我们要用Mock.js?</p><ol><li>开发时，后端还没完成数据输出，前端也能根据模拟的数据开发。</li><li>想要尽可能还原真实的数据。</li><li>图片,url格式数据难以模拟。</li></ol><h4 id="安装与使用-1"><a href="#安装与使用-1" class="headerlink" title="安装与使用"></a>安装与使用</h4><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add mockjs</span><br></pre></td></tr></table></figure><p>然后，我们可以在src目录下新建一个mock目录，创建mock.js，在里面模拟两个接口，分别拦截用户和菜单的请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span></span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">'http://localhost:8080/user'</span>, &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'@name'</span>, <span class="comment">// 随机生成姓名</span></span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'@email'</span>, <span class="comment">// 随机生成邮箱</span></span><br><span class="line">    <span class="string">'age|1-10'</span>: <span class="number">5</span>, <span class="comment">// 年龄1-10之间</span></span><br><span class="line">&#125;)</span><br><span class="line">Mock.mock(<span class="string">'http://localhost:8080/menu'</span>, &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'@increment'</span>, <span class="comment">// id自增</span></span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'menu'</span>, <span class="comment">// 名称为menu</span></span><br><span class="line">    <span class="string">'order|1-20'</span>: <span class="number">5</span>, <span class="comment">// 排序1-20之间</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回到Home页面，添加两个按钮，修改页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Home Page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;testAxios()&quot;&gt;测试Axios调用&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getUser()&quot;&gt;获取用户信息&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getMenu()&quot;&gt;获取菜单信息&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import mock from &#39;@&#x2F;mock&#x2F;mock.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Home&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    testAxios() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#39;).then(res &#x3D;&gt; &#123; alert(res.data) &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getUser() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#39;).then(res &#x3D;&gt; &#123; alert(JSON.stringify(res.data)) &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getMenu() &#123;</span><br><span class="line">      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;menu&#39;).then(res &#x3D;&gt; &#123; alert(JSON.stringify(res.data)) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在测试一下，获取用户信息，便可以看到结果了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/vue/2020430-173554.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue和Element-UI的基本使用&quot;&gt;&lt;a href=&quot;#Vue和Element-UI的基本使用&quot; class=&quot;headerlink&quot; title=&quot;Vue和Element-UI的基本使用&quot;&gt;&lt;/a&gt;Vue和Element-UI的基本使用&lt;/h2&gt;&lt;p&gt;现在</summary>
      
    
    
    
    
    <category term="前端" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Vue/"/>
    
    <category term="Element-UI" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Element-UI/"/>
    
    <category term="SCSS" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SCSS/"/>
    
    <category term="axios" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/axios/"/>
    
    <category term="Mock.js" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Mock-js/"/>
    
  </entry>
  
  <entry>
    <title>自定义spring-boot-starter</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/07/spring19/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/07/spring19/</id>
    <published>2020-05-07T10:17:00.000Z</published>
    <updated>2021-02-05T16:58:52.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h3 id="1、starter启动原理"><a href="#1、starter启动原理" class="headerlink" title="1、starter启动原理"></a>1、starter启动原理</h3><ul><li>starter-pom引入 autoconfigurer 包</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1354552/1606995919308-b2c7ccaa-e720-4cc5-9801-2e170b3102e1.png" alt="img"></p><ul><li><p>autoconfigure包中配置使用 <strong>META-INF/spring.factories</strong> 中 <strong>EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类</strong></p></li><li><p><strong>可以编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</strong></p></li><li><ul><li><strong>@Configuration</strong></li><li><strong>@Conditional</strong></li><li><strong>@EnableConfigurationProperties</strong></li><li><strong>@Bean</strong></li><li>……</li></ul></li></ul><p><strong>然后，引入starter</strong> <strong>— xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —-</strong> <strong>配置项</strong></p><h3 id="自定义starter-1"><a href="#自定义starter-1" class="headerlink" title="自定义starter"></a>自定义starter</h3><p>首先需要准备好两个项目</p><p>空工程：</p><p><strong>hello-spring-boot-starter（启动器）</strong></p><p>空SpringBoot工程</p><p><strong>hello-spring-boot-starter-autoconfigure（自动配置包）</strong></p><p>其中自动配置包里面有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认不要放在容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix() + <span class="string">"："</span>+userName+<span class="string">"》"</span>+helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有加入组件，没有任何注解</p><p>然后再写一个自动配置的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)  //默认<span class="title">HelloProperties</span>放在容器中</span></span><br><span class="line"><span class="class">//@<span class="title">ConditionalOnMissingBean</span>(<span class="title">HelloProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloServiceAutoConfiguration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HelloService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">HelloService</span> <span class="title">helloService</span>()</span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ConditionalOnMissingBean(HelloProperties.class)</strong>是当容器中没有HelloProperties.class这个类的时候，这个类才会生效，起到防止覆盖的作用。</p><p><strong>@EnableConfigurationProperties(HelloProperties.class)</strong>的作用是自动配置我们的hello组件</p><p>这个配置主要的作用就是将其保存入我们的组件</p><h4 id="使用启动器"><a href="#使用启动器" class="headerlink" title="使用启动器"></a>使用启动器</h4><p>之后便是使用启动器,先配置xml，然后使用maven的clean和install进打入我们的本地仓库当中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.my<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>然后再创建一个测试的springboot组件：</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.my<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就会引入这个自定义。但是发现不能像spring引入其他依赖一样，被自动注入生效</p><p>然后，在autoconfigure包中配置引用 <strong>META-INF/spring.factories</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">com.atguigu.hello.auto.HelloServiceAutoConfiguration</span><br></pre></td></tr></table></figure><p>然后再重新打包clean 和install</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>我们在新项目中写一个controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String s = helloService.sayHello(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现自动注入成功了，</p><p>但是我们的helloservice是有前后缀的，如果需要使用，则需要在配置文件当中写入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hello.prefix=my</span></span><br><span class="line"><span class="string">hello.suffix=88888</span></span><br></pre></td></tr></table></figure><p>接着再继续测试，发现输出结果正好是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my：张三 88888</span><br></pre></td></tr></table></figure><p>.</p><p>.</p><p>.</p><p>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自定义starter&quot;&gt;&lt;a href=&quot;#自定义starter&quot; class=&quot;headerlink&quot; title=&quot;自定义starter&quot;&gt;&lt;/a&gt;自定义starter&lt;/h2&gt;&lt;h3 id=&quot;1、starter启动原理&quot;&gt;&lt;a href=&quot;#1、starte</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="原理" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用Guava Cache作为本地缓存</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/05/spring15/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/05/spring15/</id>
    <published>2020-05-05T07:47:09.000Z</published>
    <updated>2020-04-26T17:19:59.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用Guava-Cache作为本地缓存"><a href="#利用Guava-Cache作为本地缓存" class="headerlink" title="利用Guava Cache作为本地缓存"></a>利用Guava Cache作为本地缓存</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然我们一般都用Redis缓存但是，在一些小的项目中可以不使用Redis，而是利用Guava Cache来做本地缓存，这么做本地缓存的速度会比Redis要快一点。</p><p>虽然Spring Boot默认使用的是 SimpleCacheConfiguration。但是这个Guava Cache在其基础上，有了不同程度的优化。所以在做一些小项目的时候呢，可以用这个来做缓存。</p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>Guava Cache使用 ConcurrentMapCacheManager来实现的缓存</p><p>Guava Cache 与 ConcurrentMap二者很相似,但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素,直到显式地移除。相对地,Guava Cache 为了限制内存占用,通常都设定为自动回收元素。在某些场景下,尽管 LoadingCache 不回收元素,它也是很有用的,因为它会自动加载缓存。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>Redis自不用说，是一个在多个服务器之间能够实现集群和哨兵的缓存，相比之下，Guava Cache就稍稍弱了些。</p><p>如果数据量不大，且多个服务之间没有相互同步数据的需要，则使用Guava Cache是非常理想的，它使用简单且性能很好。如果需要缓存的数据量很大或者多个服务之间需要共享缓存数据，则redis是理想的选择，虽然读取性能对比Guava Cache满了很多，但是绝对值并不大，大多数情况下满足我们的需要。</p><p>还有一点比较大区别就是他们的拷贝程度不同。</p><h5 id="Redis-缓存是深拷贝"><a href="#Redis-缓存是深拷贝" class="headerlink" title="Redis 缓存是深拷贝"></a>Redis 缓存是深拷贝</h5><p>从 Redis 中获取缓存时，系统中的数据对象是 Redis 缓存的副本。对该对象的任何操作都不会影响 Redis 中的缓存，后续再次获取还是修改之前的数据。除非执行Redis的更新操作。</p><h5 id="Guava本地缓存直接获取则是浅拷贝"><a href="#Guava本地缓存直接获取则是浅拷贝" class="headerlink" title="Guava本地缓存直接获取则是浅拷贝"></a>Guava本地缓存直接获取则是浅拷贝</h5><p>以获取一个MAP为例：如果直接从缓存中取，则是浅拷贝。<br>对缓存数据的任何操作都会同时修改缓存中的数据，下次从缓存中获取则是修改之后的数据。一般不会修改从缓存中获取到的数据，但如果要修改，则需注意Redis和Guava的不同。</p><p>所以如果只是做一个比较小的项目。就不用特地去连接redis。还是使用我们本地的缓存更为快速。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>27.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.24.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuavaCacheManager cacheManager = <span class="keyword">new</span> GuavaCacheManager();</span><br><span class="line">        cacheManager.setCacheBuilder(</span><br><span class="line">                CacheBuilder.newBuilder().</span><br><span class="line">                        expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS).</span><br><span class="line">                        maximumSize(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化一个对象并设置它的存活时间等等。我们把这个方法注入到spring的上下文当中。而每当我们需要去数据库读取数据时，spring就会先返回这个缓存的实体，将数据先存入到本地缓存当中。</p><p>这里我们设置它的存活时间是十秒。</p><h4 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h4><p>首先需要一个实体类和与其对应的数据表。这也就只列出实体类，大家可以自己对应一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然。还有配置文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*Mapper.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.guavacache.pojo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springtest?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><p>然后就是服务层，要实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">(String userName )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">( User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>, key = <span class="string">"#userName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsersByName</span><span class="params">( String userName )</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.getUsersByName( userName );</span><br><span class="line">        System.out.println( <span class="string">"从数据库读取，而非读取缓存！"</span> );</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>( value = <span class="string">"/getusersbyname"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">geUsersByName</span><span class="params">(@RequestBody User user )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"-------------------------------------------"</span> );</span><br><span class="line">        System.out.println(<span class="string">"call /getusersbyname"</span>);</span><br><span class="line">        System.out.println(cacheManager.toString());</span><br><span class="line">        List&lt;User&gt; users = userService.getUsersByName( user.getUserName() );</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层使用这个方法去调用，以便用于测试。</p><p>最后还有在主类上加上一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.guavacache.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavacacheApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GuavacacheApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样子就完成了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们可以打开这个PostMan，使用 localhost:8888/getusersbyname 发起POST请求，就可以测试出结果了。</p><p>但由于比较简单，这里就不放图了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用Guava-Cache作为本地缓存&quot;&gt;&lt;a href=&quot;#利用Guava-Cache作为本地缓存&quot; class=&quot;headerlink&quot; title=&quot;利用Guava Cache作为本地缓存&quot;&gt;&lt;/a&gt;利用Guava Cache作为本地缓存&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringBoot/"/>
    
    <category term="GuavaCache" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/GuavaCache/"/>
    
  </entry>
  
  <entry>
    <title>路由网关——Zuul</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2020/05/02/cloud4/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2020/05/02/cloud4/</id>
    <published>2020-05-02T07:56:50.000Z</published>
    <updated>2020-04-20T12:59:42.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由网关——Zuul"><a href="#路由网关——Zuul" class="headerlink" title="路由网关——Zuul"></a>路由网关——Zuul</h2><p>Springloud中API网关是Zuul。对于网关而言，存在两个作用：第一个作用将请求的地址映射为真实服务器的地址。</p><p>例如，用户请求<a href="http://localhost/user/1获取用户id为1的信息，而真实的服务是http://localhost:800l/user/I和http://localhost:8002/user/1都可以获取用户的信息，这时就可以通过网关使得localhost/user映射为对应真实服务器的地址。" target="_blank" rel="noopener">http://localhost/user/1获取用户id为1的信息，而真实的服务是http://localhost:800l/user/I和http://localhost:8002/user/1都可以获取用户的信息，这时就可以通过网关使得localhost/user映射为对应真实服务器的地址。</a></p><p>然这个作用就起到路由分发的作用，从而降低单个节点的负载。从这点来说，可以把称为服务端负载均衡。从高可用的角度来说，则一个请求地址可以映射到多台服务上，如果单点出现障，则其他节点也能提供服务，这样这就是一个高可用的服务了。</p><p>Zuul网关的第二个作用是过滤服务，在互联网中，服务器可能面临各种攻击，Zuul提供了过滤器，通过它过那些恶意或者无效的请求，把它们排除在服务网站之外，这样就可以降低网站服务的风险。</p><h3 id="构建Zuul网关"><a href="#构建Zuul网关" class="headerlink" title="构建Zuul网关"></a>构建Zuul网关</h3><p>首先，有引入依赖是必要的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着就是在主要执行的程序上加一个注解：@EnableZuulProxy。</p><p>这个注解会启动Zuul网关。</p><p>我们来看一看这个注解的构成吧:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(&#123;ZuulProxyMarkerConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableZuulProxy</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看其实有点不清晰，其实以下的注解包含了两种类型的过滤器。</p><h4 id="pre类型过滤器"><a href="#pre类型过滤器" class="headerlink" title="pre类型过滤器"></a>pre类型过滤器</h4><p>PreDecorationFilter：该过滤器根据提供的RouteLocator确定路由到的地址，以及怎样去路由。该路由器也可为后端请求设置各种代理相关的header。</p><h4 id="route类型过滤器"><a href="#route类型过滤器" class="headerlink" title="route类型过滤器"></a>route类型过滤器</h4><p>(1) RibbonRoutingFilter：该过滤器使用Ribbon，Hystrix和可插拔的HTTP客户端发送请求。serviceId在RequestContext.getCurrentContext().get(“serviceId”)中。该过滤器可使用不同的HTTP客户端，例如</p><p>Apache HttpClient：默认的HTTP客户端</p><p>SquareupOkHttpClient v3：如需使用该客户端，需保证com.squareup.okhttp3的依赖在classpath中，并设置ribbon.okhttp.enabled = true。</p><p>Netflix Ribbon HTTP client：设置ribbon.restclient.enabled = true即可启用该HTTP客户端。需要注意的是，该客户端有一定限制，例如不支持PATCH方法，另外，它有内置的重试机制。</p><p>(2) SimpleHostRoutingFilter：该过滤器通过Apache HttpClient向指定的URL发送请求。URL在RequestContext.getRouteHost()中。</p><p>并且，他已经引入了断路机制。之所以引入断路机制，是因为在请求不到的时候会进行断路，以避免网关发生球无法释放的场景，导致微服务瘫痪。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/,http://localhost:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/u/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://localhsot:9002/</span></span><br><span class="line">    <span class="attr">product-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/p/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">product</span></span><br></pre></td></tr></table></figure><p>这个配置是将Zuul网关注册给服务治理中心，这样它就能够获取各个微服务的服务ID了看到用户微服务映射的配置，这里采用  zuul.routes.<key>.path  和zuul.routes.&lt;key＞url  配置，其中path是请求路径，这里使用了ANT风格的通配  “/u/**” ，而旧l代表转发地址，也就是满足path通配的时候，请求就会转发给端口为9002的用户微服务。</p><p>但是，这样配置有一个弊端，因为我们的用户微服务有两个节点，一个是9002端口，另一个是9003端口，这里只能映射到9002端口的微服务，而映射不到9003端口的微服务。</p><p>为了解决这个问题，Zuul还提供了面向服务的配置。再看到代码中的产品微服务映射配置，这里使用了zuul.routes.<key>.path和zuul.routes.<key>.serviceld进行配置，其中path的配置可参考用户微服务，而serviceld这里配置为“product”，这是一个产品微服务的名称，由产品微服务的属性spring.application.name配置。</p><p>这样配置后，Zuul会自动实现负载均衡，也就是会将请求转发到某个服务的节点上。</p><p>这里可以打开:<a href="http://localhost/p/product/ribbon。查看结果。" target="_blank" rel="noopener">http://localhost/p/product/ribbon。查看结果。</a></p><h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p>上面只是将请求转发到具体的服务器或者具体的微服务上，但是有时候还希望网关功能更强大一些。</p><p>例如，监测用户登录、黑名单用户、购物验证码、恶意刷请求攻击等场景。如果这些在过滤器内判断失，那么就不再把请求转发到其他微服务上，以保护微服务的稳定。下面模拟这样的一个场景。</p><p>假设当前需要提交一个表单，而每一个表单都存在一个序列号(seria!Number），并且这个序列对应个验证码（verficationCode），在提交表单的时候，这两个参数都会一并提交到Zuul网关。</p><p>对于Redis服务器会以序列（seriaNumber）为键（key），而以验证码（verificationCode）为值（value）进行存储。</p><p>当路由网关过滤器判用户提交的验证码与Redis服务器保存不一致的时候，则不再转发请求到微服务。</p><h4 id="测试过滤器"><a href="#测试过滤器" class="headerlink" title="测试过滤器"></a>测试过滤器</h4><p>这里验证码使用Redis进行存储，所以会比使用数据库快得多，这有助于性能的提高，避免造成瓶颈。由于使用了Redis，因此需要在Zuul网关中引入Redis的依赖：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/,http://localhost:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/u/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://localhsot:9002/</span></span><br><span class="line">    <span class="attr">product-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/p/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">product</span></span><br></pre></td></tr></table></figure><p>Zuul存在一个抽象类，那就是ZuulFilter。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringCloud/Zuul/1.jpg" alt=""></p><p>这里需要注意的是，只是画出了抽象类ZuulFilter自定义的抽象方法和接口ZuulFilter定义的抽类，也就是说，当需要定义一个非抽象的Zuul过滤器的时候，需要实现这4个抽象方法，在重写这4个抽象方法前，我们很有必要知道它们的作用。</p><ol><li><p>shouldFilter：返回boolean值，如果为true，则执行这个过滤器的run方法。</p></li><li><p>run：运行过滤逻辑，这是过滤器的核心方法。</p></li><li><p>filterType：过滤器类型，它是一字符串，可以配置为以下4种。</p><p>pre：请求行之前filter。</p><p>route：处理请求，进行路由。</p><p>post：请求处理完成后执行的filter。</p><p>error：出现错误时执行的filter。</p></li><li><p>filterOrder：指定过滤器顺序，值越小则越优先。</p></li></ol><h4 id="使用过滤器判定验证码"><a href="#使用过滤器判定验证码" class="headerlink" title="使用过滤器判定验证码"></a>使用过滤器判定验证码</h4><p>我们可以在Reddit中生成一个验证码。当用户提交的验证码与Redis不一致时，就会被Zuul网关给拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyZuulFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入StringRedisTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate residTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否过滤</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 请求上下文</span></span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line"><span class="comment">// 获取HttpServletRequest对象</span></span><br><span class="line">HttpServletRequest req = ctx.getRequest();</span><br><span class="line"><span class="comment">// 取出表单序列号</span></span><br><span class="line">String serialNumber = req.getParameter(<span class="string">"serialNumber"</span>);</span><br><span class="line"><span class="comment">// 如果存在验证码返回为true，启用过滤器</span></span><br><span class="line"><span class="keyword">return</span> !StringUtils.isEmpty(serialNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器逻辑方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest req = ctx.getRequest();</span><br><span class="line"><span class="comment">// 取出表单序列号和请求验证码</span></span><br><span class="line">String serialNumber = req.getParameter(<span class="string">"serialNumber"</span>);</span><br><span class="line">String reqCode = req.getParameter(<span class="string">"verificationCode"</span>);</span><br><span class="line"><span class="comment">// 从Redis中取出验证码</span></span><br><span class="line">String verifCode = residTemplate.opsForValue().get(serialNumber);</span><br><span class="line"><span class="comment">// Redis验证码为空或者与请求不一致，拦截请求报出错误</span></span><br><span class="line"><span class="keyword">if</span> (verifCode == <span class="keyword">null</span> || !verifCode.equals(reqCode)) &#123;</span><br><span class="line"><span class="comment">// 不再转发请求</span></span><br><span class="line">ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置HTTP响应码为401（未授权）</span></span><br><span class="line">ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line"><span class="comment">// 设置响应类型为JSON数据集</span></span><br><span class="line">ctx.getResponse().setContentType(MediaType.APPLICATION_JSON_UTF8.getType());</span><br><span class="line"><span class="comment">// 设置响应体</span></span><br><span class="line">ctx.setResponseBody(<span class="string">"&#123;'success': false, "</span> + <span class="string">"'message':'Verification Code Error'&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一致放过</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器类型为请求前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器排序，数字越小优先级越高</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>述代码中在类上标注了＠Component，这样Spring就会扫描它，将其装配到IoC容器中。为继承了抽象类ZuulFilter，所以Zuul自动将它识别为过滤器。filterType方法返回了“pre，则过滤器会在路由之前执行。</p><p>filterOrder返回为0，这个方法在指定多个过滤器顺序才有意义，数字越小，则越优先，这里只有一个过滤器，所以就返回0。</p><p>然后在shouldFilter中判断是否存在序列号参数，如果存在，则返回住时，这就意味着将启用这个过滤器，否则就不再启用这个过滤器。run方法是过滤器的核心，它首先获取请求中的序列号和验证码，跟着使用StringRedisTemplate通过序列号获取Redis服务器上的验证码。</p><p>然后将Redis的验证码与请求的验证码进行比较，如果匹配不一致，则设置再转发请求到微服系统，并且将晌应码设置为401，响应类型为JSON数据集，最后还会设置响应体的内容；如果一致，则返回null，放行服务。</p><p>这样用户提交的验证码与Redis保存的不一致时，请求就会在Zuul网关中被过滤器拦截，而不会转发到微服务中</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里可以举一个例子：用户服务提供一个登录接口，用户名密码正确后返回一个Token，此Token作为用户服务的通行证，那么用户登录成功后返回的Token就需要进行加密或者防止篡改处理。在到达用户服务其他接口前，就需要对Token进行校验，非法的Token就不需要转发到用户服务中了，直接在网关层返回信息即可。</p><p>那么，我们再来看一张图：</p><p><img src="https://cdn.jdon.com/simgs/springcloud/zuulfilter.png" alt=""></p><p>上图显示这几种过滤器的前后调用顺序，第一个是pre过滤器然后是Route过滤器，最后响应是post过滤器。</p><p>这样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;路由网关——Zuul&quot;&gt;&lt;a href=&quot;#路由网关——Zuul&quot; class=&quot;headerlink&quot; title=&quot;路由网关——Zuul&quot;&gt;&lt;/a&gt;路由网关——Zuul&lt;/h2&gt;&lt;p&gt;Springloud中API网关是Zuul。对于网关而言，存在两个作用：第一</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/SpringCloud/"/>
    
    <category term="Zuul" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Zuul/"/>
    
  </entry>
  
</feed>
