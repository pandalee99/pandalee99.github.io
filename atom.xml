<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小世界</title>
  
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/"/>
  <updated>2024-08-29T12:56:43.416Z</updated>
  <id>https://github.com/Pandalee99/pandalee99.github.io/</id>
  
  <author>
    <name>攀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信搜索引擎中索引的分布式演进</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/08/29/ref1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/08/29/ref1/</id>
    <published>2024-08-29T12:51:32.000Z</published>
    <updated>2024-08-29T12:56:43.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>ref: <a href="https://cloud.tencent.com/developer/news/836333" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/836333</a></p><p>提起分布式，不少人能很清晰的阐述 paxos、CAP 等理论，但我们在遇到一个具体的分布式问题时，很少有人能知道如何做出一个“好”的设计。对于当前的很多分布式数据系统，包括开源的 HBase、ElasticSearch 等，我们一般只知其然，很少能够知其所以然。因为几乎所有的分布式数据系统，都会根据自身情况，对实际场景做一些假设，有所舍取，这种多样性也增加了我们的理解难度。</p><p>笔者从业八年，先后从事过<a href="https://cloud.tencent.com/product/cos?from=20067&from_column=20067" target="_blank" rel="noopener">分布式存储</a>系统、搜索系统的开发和设计。本文将通过搜一搜场景下的搜索引擎的分布式演化，阐述分布式数据系统在设计中的权衡，希望能给各位读者带来一点启发和帮助。这里假设读者已了解常用的分布式以及搜索的基本理论，具体细节不再冗述。</p><h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>先来看一下维基对搜索引擎的定义：搜索引擎是一种信息检索系统，旨在协助搜索存储在计算机系统中的信息。大家最熟悉的商业搜索系统莫过于 baidu、google，而 ElasticSearch （ES）是迄今为止最为成功的开源搜索引擎。在搜索引擎中，通常会采用倒排索引，用以提升检索性能。</p><p>相比商业系统，ES 更注重易用性，采用了对等架构，每个数据节点既处理写入请求，又处理检索请求。所以 ES 更适用于对搜索性能并不敏感的业务，在最经典 ELK 中，ES 就用于日志搜索分析。在成熟的商业系统中，对检索性能稳定性要求比较苛刻，数据写入时需要尽可能少的影响搜索性能，所以更多情况下会将资源消耗比较大的建索引部分拆分到离线来做。</p><p><strong>笔者所在的微信搜一搜中，搜索引擎也分为在线离线两部分，离线用于创建索引，在线用于检索</strong>。事实上，包括百度在内的大多数企业级搜索系统都采用了这类分离的架构。下图为项目初期的搜一搜索引管理架构：</p><p><img src="https://static001.geekbang.org/infoq/3d/3d2ece61a5ba223fc13e433144baad7e.png" alt="img"></p><p>如上图所示，文档在写入 Indexer 后，由 Indexer 离线创建并管理索引。Searcher 从 Indexer 拉取已建完索引，提供在线检索服务，Searcher 模块中不同节点的索引数据完全一致，互为镜像。Indexer 同步承担了索引管理功能，为无法扩容的单点。对于千万级文档中小业务来说，如果对数据流可靠性要求不苛刻，这里尚能运行良好。但随着文档量越来越大，Indexer 和 searcher 在性能、可扩展性和容错等方面的问题凸显，这种简单架构已经无法满足需求，亟需引入分布式管理。</p><h2 id="三、数据分片"><a href="#三、数据分片" class="headerlink" title="三、数据分片"></a>三、数据分片</h2><p>分布式解决问题的核心方式是将大任务分解成小任务，分别运行在不同节点上，以加速任务处理。对数据来说也类似，我们可以对数据进行切分，切分后的数据称为分片，不同分片分散到各个节点各自处理。业界对分片的叫法五花八门，在 ES 和 MongoDB 中叫 shard，在 HBase 中叫 region，在 Bigtable 中叫 tablet，另外还有 vnode，vbucket 等称呼。本文将沿用 ES 的叫法，如无特别提示，shard 即指分片。<strong>这里需要区分的一个概念是分片和副本，分片是对数据的切分，副本是对分片的拷贝</strong>。如果要求更高的读取性能，通常需要增加副本数，如果数据量快速上涨，则可能需要更多的分片。另外一个非常容易与分片（shard）混淆的概念是分区（partition），二者有时甚至会直接混用。不过一般来说分片是横向切分，多数按 key 划分；而分区通常更像是一种纵向切分，比如按时间划分。key 相同的文档先后进入系统，一定会属于一个分片，但可能被划分到多个分区中。</p><p>在对数据进行分片时，一个关键点是不同分片间需要尽量避免数据倾斜。分片的拆分方式大致有两种，一种是按 key 的字母序划分，另一种是通过对 key 进行 hash 后取余的方式来划分。Hash 的方式用的更多一些，只要 hash 算法足够均匀，就可以避免数据倾斜问题，在 MongoDB 中用的 MD5 和 Redis 中用的 CRC16 都是分散性非常好的算法。通常情况下，分片都会作为数据管理和迁移的最小单位，分片和副本要求能均匀并分散的划分到不同的节点。在扩容或缩容节点时，数据需要在节点间的重新再分配，即再均衡过程。<strong>再均衡过程中，多数系统都要求尽可能少的影响读写性能，再均衡后也需要分片在节点间尽量均匀和分散</strong>。</p><p>应对再均衡需求，分布式中常见做法有三类：</p><ol><li><strong>固定分片个数</strong>：分片数在系统初始时选定，数据量增加时，单个分片的数据量相应增加。新扩容节点时，迁移部分分片到新节点，缩容时，反向迁移。这种方式简单，易操作，ES 就采用了该方式。但其也有相应的缺点：对数据量涨幅或降幅比较大的系统，初始搭建时很难确定合适的分片数。</li><li><strong>动态分片数</strong>：当分片中的数据的增长到一定值时，就会拆分分片；如果分片中数据量过少，则会进行分片合并。在 Hbase 中，单个 region 的大小默认是 10G，过大则会触发拆分。相比上述固定分片的方式，这种方式主要优点是分片数可以自动适配数据量，不再有初始选择分片数的烦恼。但在系统初始导入数据时，会由于分区的多次拆分而严重影响读写性能。所以在 Hbase 和 MongoDB 中，均允许配置一组初始分区，来规避该问题。由于这种分片方式更复杂，部分系统还会提供人工干预的措施。</li><li><strong>按节点数分片</strong>：上述两种分片方式，均与节点无关，扩容时通过迁移分片来均衡。还有一种分片方式比上述两种更广为人知——一致性哈希：每个节点对应固定数量的分片，如果需要扩容节点，则同时增加相应的分区数，通过数据在分区之间的迁移来达到均衡。实际使用中，一致性哈希常常需要会引入 vnode，来避免数据倾斜。由于对迁移不如上述两种方式友好，所以该方式在数据系统中的应用不广泛。</li></ol><p><strong>固定分片的方式相比是最为常用的，但如上所述，在系统初始搭建时，需要选择远大于节点数的分片数，为后续扩容预留空间</strong>。在 ES 中，每个分片都是一个依赖 Lucene 的独立引擎，负责数据的存储和检索。这限制了其在初始搭建时的分片数选择，因为过多的分片数会使得请求量放大，从而导致性能的急剧下降。针对该问题，存储系统 Ceph 有个很好的解决方案：其分片为逻辑概念，每台数据节点都可以承载多个逻辑分片，所以可以在初始阶段就选择较大的分片数。相比 ES，Ceph 可以这么做的主要秘诀是：存储系统的数据分片并不需要一个独立的引擎做支撑。</p><p><img src="https://static001.geekbang.org/infoq/08/0872a548e7e65ee2834220d4acda838e.png" alt="img"></p><p>在微信搜一搜中，数据写入与在线检索分离，写入更类似 Ceph，可以按逻辑分区进行划分。这就允许我们在系统初始就选定一个较大的分区数，解决分片数难以确定问题。上图展示了分片与节点的映射关系，当文档写入时，通过 hash 取余的方式，打散到各分片中。新扩容节点 3 时，分片 5 从原来所属的节点 2 迁移至节点 3，通过分片迁移使得其在节点中的分布依旧均衡。</p><h2 id="四、分布式系统设计中的考量"><a href="#四、分布式系统设计中的考量" class="headerlink" title="四、分布式系统设计中的考量"></a>四、分布式系统设计中的考量</h2><p>在需要划分分片的数据系统中，一般都需要选出一个 Leader 来管理各个分片，这就涉及到选主问题。在数据的读写过程中，需要查找相应的分片，所以要管理路由信息。当节点故障时，需要通过迁移分片来重新分配数据，这就要求 Leader 能实时监控节点状态。主分片与副分片之间通常需要复制数据，这又涉及一致性等问题。下面将会详细阐述微信搜一搜中应对上述问题所作出的选型和考量。</p><h3 id="1-选主问题"><a href="#1-选主问题" class="headerlink" title="1. 选主问题"></a>1. 选主问题</h3><p>对于比较复杂的协调或者事务场景，分布式系统中通常会选出一个 Leader 来进行管理，<strong>这主要是因为单机的处理，远比分布式处理要简单</strong>。分布式中必须需要考虑的可靠、可信、乱序、延迟等问题，在单机中几乎不存在。比如大名鼎鼎的共识算法 Paxos，通常用来解决选主问题，这如果放到单机，将是不值一提的任务。</p><p>Leader 的选举通常有两类方式：</p><ol><li>依赖 ZK 或 etcd 等协调服务系统：这是最为常见的方式，其缺点就是需要多维护一套 ZK 系统。但相比带来的复杂度，多数情况下，这个维护成本通常更愿意被接受。</li><li>自行选主：在无共享架构（shared nothing）系统中，为了易用和维护性，系统会自行在节点间利用多数派来选主。这种方式常见于开源系统，比如 ES、MongoDB 和 Ceph 等。另外，在部分网络系统（InfiniBand）中，为了在网络分区后，仍然能在两个分区分别提供服务，也会自行实现选主。显然，这种方式更为复杂，在不同系统中自行选主的实现方式各有差异，异常和容错方面的考量点也不尽相同，各有取舍。</li></ol><p>在微信有相对成熟的自研 chubby，维护成本比较低，所以在搜一搜中，我们选择了更为简单的方式 1。依赖 chubby 选出 Leader 后，由 Leader 来管理分片到节点的映射，尤其是上述再均衡的过程中的分片重分配。分片映射关系通过 chubby 进行持久化，只有在扩缩容时才会进行变更。如果 Leader 故障，follower 通过 chubby 抢锁重新选主，新 Leader 接管分片映射后提供服务。</p><h3 id="2-在线检索"><a href="#2-在线检索" class="headerlink" title="2. 在线检索"></a>2. 在线检索</h3><p>在检索时，用户请求需发送给全部的分片，分别进行召回，召回的结果在合并后返回。为了提升在线吞吐，每个分片需要增加多个副本，所有副本均提供检索服务。在分片和副本的管理中，一个常见的做法是将不同主分片和副分片均匀且分散的分到不同节点，通过多机并发提升在线性能，在 ES、Ceph、Redis 等系统中，均采用该方式。但在商业场景下，用户请求量变化波动会非常大，比如表情搜索在节假日的请求量往往会上涨好几倍。在上述分片划分方式下，这种请求量大幅波动的场景会导致一个问题：<em>当请求量突然上涨时，需要同比增加副分片数，但这时扩容节点后，如果还需要做到主副分片均匀且分散的分布的话，就需要迁移相应分片到新节点，而迁移本身对资源消耗比较大，又会影响到在线性能</em>。</p><p>应对上述的请求大幅波动，微信内普遍采用了 Svrkit 框架。Svrkit 框架是一种非常经典的微服务架构，系统按模块来划分，每个模块都是一个服务。同一模块会在多个节点部署进程，不同节点互为镜像。请求量上涨时，迅速扩容节点，通过部署更多镜像来应对。如果节点异常导致请求失败，上游通过换机重试来避免最终失败，从而保证可用性。但对 Searcher 来说，索引量比较大时，单个镜像中不能装载全部索引，这就需要将索引拆分到不同节点。在 Svrkit 中提供了一种 byset 模式，允许同一模块划分多个分组（Set），各自加载一部分索引。每个分组都有各自的多个镜像提供服务，上游在下发请求时，需要从所有分组进行召回，合并返回。如果遇到上述的请求量上涨时，每个分组各自扩容镜像即可。</p><p><img src="https://static001.geekbang.org/infoq/da/da2be4bf2c7798b4b894eacd498894eb.png" alt="img"></p><p>如图所示，在线检索的 Searcher 模块，采用了 byset 模式，划分成多个分组。<strong>上述分片到节点的映射，也相应的变成了分片到分组的映射，映射的管理由 Leader 来负责</strong>。当文档量上涨时，通过扩容分组来容纳；请求量上涨时，各组分别扩容，增加节点数来应对。得益于离线建索引的架构，新扩容的节点只需要从离线拉取数据，整个过程不影响现有服务。在扩缩分组时，部分分片要迁移到新分组中，这时需要注意的是只有在新分组上线提供服务后，才能下线旧分组中的已迁移分片。</p><p>在 ES 中，主分片会均匀分散到各节点，这时 Leader 还需要同时管理请求路由。<strong>而在 byset 中，路由按分组划分，整个检索过程中，Leader 并不参与</strong>，是什么原因使得这里可以做到如此简洁呢？天下没有免费的午餐，这里的简化也不例外。ES 中，如果有 Searcher 的节点数据无法同步时，会通过 Leader 从路由中剔除该节点，所以不会造成数据缺失。但在 Svrkit 的 byset 路由中，Leader 并未参与，如果有 Searcher 节点的数据异常，则无法通过路由的方式及时剔除异常节点。这类数据缺失的代价可谓不菲，能否有其他方式减少该问题的发生呢？如果异常节点与 Leader 之间的通信正常，Leader 可以通知该异常 Searcher 拒绝服务，由上游重试到其他节点来保证正确召回。但如果网络异常导致通信失败，Searcher 无法知道自己数据不完整时，这里就会出现上述数据缺失问题了。所以这里的简化其实隐含的一个假设：如果 Leader 与某 Searcher 通信中断，则客户端也无法访问该 Searcher 节点。在同一数据中心的局域网内，通过交换机堆叠等措施，可以做到全链路无网络单点设备，减少这种网络分区风险。这种场景下，该假设不成立的概率其实非常低，远小于人工操作失误和软件 bug 带来的问题。其实 Svrkit 框架下的 byset 路由模块都隐含了该假设，最常用的 KV 系统就依赖 byset 路由，其稳定性已经过了实践检验，所以当前场景下做出该假设是可行的。</p><h3 id="3-文档写入"><a href="#3-文档写入" class="headerlink" title="3. 文档写入"></a>3. 文档写入</h3><p>文档写入后，首先需要存储，就涉及用<a href="https://cloud.tencent.com/product/cfs?from=20067&from_column=20067" target="_blank" rel="noopener">共享存储</a>（shared disk）架构，还是无共享架构（shared nothing）的问题。这个决定不难做出，在微信中已经有自研的 WFS（类似 HDFS）、WBT（类似 Hbase）和 WQ（类似 Kafka）已被广泛使用。显然，用共享存储能极大简化工作，实际上在商业搜索中，几乎都依赖了其他存储组件。</p><p><img src="https://static001.geekbang.org/infoq/5a/5ad638345c8b9ab711f078c067a5e776.png" alt="img"></p><p><strong>由于分片数固定，哈希方式已约定，所以文档在写入时，可以提前计算出其所在的分片，按分片写入依赖 WBT 和 WQ 的数据平台</strong>。在建索引时，Processor 模块从数据平台扫描文档，在预处理完成后返回给 Indexer，Indexer 负责索引建立，并落地到 WFS。</p><h3 id="4-节点管理"><a href="#4-节点管理" class="headerlink" title="4. 节点管理"></a>4. 节点管理</h3><p>在线 Searcher 模块中不同的分组，需要加载不同分片的数据及控制上线顺序；Indexer 的不同的节点，需分别负责不同分片的索引建立；在实时流中，Processor 会提前按分组聚合分片，所以也需要感知分片到分组的映射。基于以上原因，<strong>Leader 需要感知各个模块中节点的详细状态，在扩缩容或节点故障时，及时作出调整</strong>。</p><p>常用的节点发现方式是依赖 ZK，通过目录监听来实现，这也是 ZK 作为服务协调者主要用法之一。如果在搜索引擎中采用 ZK 的方案，在监控和与其他模块交互等方面的工作要多很多，所以并不可取。微信的 SvrKit 框架中，会在所有节点部署相同的路由配置文件来实现模块路由，路由变更由运维人员操作，需全局更新配置文件。这里，Leader 可以从路由配置中查找到所有正在提供服务的工作节点信息，如果能依赖路由配置，Leader 发现节点的过程就变的很简单了，新节点加入时通过路由文件就可以找到对应的 Leader。但单纯依赖路由配置还有两个问题：</p><ol><li>工作节点当前的状态无法被及时感知，比如节点正在启动，磁盘故障等。</li><li>在扩缩容时，新扩 Searcher 节点只有正常提供服务后，配置才能被重新下发给 Leader，但新节点在提供服务前就需要知道分片信息，以便进行数据同步。</li></ol><p>Leader 如果需要感知工作节点的当前状态，一个常见的做法就是通过心跳。工作节点定期通过心跳给 Leader 上报自身的情况，Leader 将工作节点所需的分片映射、索引任务等信息带回给工作节点。如果结合路由配置和心跳，这里是否能解决上面的问题呢？针对问题 1，心跳可以携带节点信息，包括启动、异常等状态供 Leader 决策。针对问题 2，即使节点不在路由中，Leader 也可以在心跳中将加载索引任务带回给 Searcher 节点，新节点完成数据加载后，提供在线服务。所以，<strong>这里结合路由配置和心跳的方式是可行的</strong>。不过心跳也有失效的可能，利用心跳来检测节点状态本身并不完全可靠。比如在工作节点的心跳处理线程有死锁、挂死、CPU 繁忙等异常时，可能会有误检；在异常网络时，比如大包比小包更易丢失的场景下，会导致漏检，利用心跳的方式来收集信息，也就意味着需要能容忍上述各类异常。</p><p><img src="https://static001.geekbang.org/infoq/2e/2e4aa022e816558c7ce5252603eba894.webp" alt="img"></p><p>上图展示了 Leader 利用路由和心跳来收集 Searcher 和 Indexer 中各进程状态的过程。通过心跳，Leader 能感知各进程当前状态，并利用路由配置来判断是否为新扩容节点等信息。Leader 在心跳包的回执中，同步给 Indexer 下发创建索引任务，给 Searcher 下发相应的加载索引任务。感知节点状态还允许 Leader 及时处理节点故障，比如在 Indexer 故障时，Leader 会通过心跳超时检测到，这时需回收给其分配的索引任务，换 Indexer 重做。</p><h3 id="5-事务、一致性和数据复制"><a href="#5-事务、一致性和数据复制" class="headerlink" title="5. 事务、一致性和数据复制"></a>5. 事务、一致性和数据复制</h3><p>事务是数据库中的概念，通常称作符合 ACID 要求。由于 ACID 过于苛刻，在单机场景下利用锁等方式尚可实现，但在分布式场景下就非常难了。目前各数据库的分布式实现都是弱化后的 ACDI。搜索系统中的数据流，一般都不涉及事务，但各类操控类的操作，比如扩容、缩容、回滚等都有一定的事务要求。不过控制类的操作，几乎都是非常低频的操作，其本身不涉及性能问题，所以经常在 Leader 或 Master 中以单机的方式执行。</p><p>存储界的一位架构师大牛曾经总结过一条非常实用的经验：<strong>控制流一定要跟数据流分离</strong>。这里的主要原因是二者的需求不同：控制操作通常由运维人员发起，非常低频，允许失败后重试，但对事务性有一定的要求；而数据流往往对性能或可靠性的要求更高，但相应会在其他方面做一些折让，通常是在一致性及可用性上有条件的降低要求。在部分要求强一致性的系统中，会在节点故障时临时牺牲可用性，Leader 变更路由后才恢复。<strong>将复杂控制逻辑剥离的做法通常使得数据流更可靠，比如 Chubby 或 Leader 故障导致短期无 Leader 的情况下，并不影响数据流的正常执行</strong>。ClickHouse 是控制流分离的一个反例，其写操作需要经过 ZK 传递，大大限制写性能。不过作为 OLAP 中的佼佼者，其更关注在线查询性能，而对写操作有更高的容忍度。</p><p>在分布式中，另一个经常被提及的问题是数据复制。在单数据中心，业界普遍采用的是单主节点复制，比如 ES、Ceph、Redis 等都是该方式。在主分片和副分片的数据同步时，多数系统采用了同步复制的方式来保证一致性。不同业务在一致性方面的需求不同，这就衍生出很多让人眼花缭乱的名词：最终一致性、因果一致性、读写一致性、会话一致性、单调一致性等等。这种折让虽然为业务带来灵活性，但也加剧了分布式系统的难度。在一致性上折让最大的系统莫过于 Redis 集群了，其为了性能直接采用了异步复制，相当于放弃了一致性保证，这是使用者所诟病的一个点。与单主复制对应的是多主复制，主要用于超大型、跨数据中心时的复制，通常采用异步的方式。多主复制只在几个有超大型数据的商业帝国才会用到，多数业务并不涉及，这里暂不讨论。最后一种复制方式是无主复制，该方式用的相对较少，最经典的是 DynamoDB。无主复制中，多由客户端对所有数据节点发起读写请求，根据 Quorum 多数派，来决定最新的值。这种方式在节点异常时，其实很难判断数据顺序，而且读放大比较严重，所以并不流行。在搜一搜中，Searcher 模块同一分组内并无主节点，不同节点之间不会进行数据同步，而是从 WFS 中拉取。这种做法更接近无主复制，其索引上线（相当于写入）由 Leader 控制，为较低频操作。<strong>搜索业务通常对一致性的要求都非常宽松，一般只要求尽可能达到单调读的一致性，这里通过将同一用户的请求路由到同一节点上来实现</strong>。</p><h3 id="6-搜索引擎系统架构"><a href="#6-搜索引擎系统架构" class="headerlink" title="6. 搜索引擎系统架构"></a>6. 搜索引擎系统架构</h3><p>通过对上述问题的权衡，搜一搜的分布式架构演变为如下模样：</p><p><img src="https://static001.geekbang.org/infoq/df/df6b640eaa35a10e900f5d0b0f01c9cd.png" alt="img"></p><p>Leader 依赖 Chubby 选举，为整个搜索引擎的大脑，负责管理分片映射、节点状态及路由。Searcher 模块提供了在线的召回服务，用户在发起搜索时，通过 broker 将请求下发至 Searcher 的全部分组，对结果 Merge 后返回。整个搜索过程 Leader 并不参与，实现控制流和搜索数据流的分离。Leader 通过心跳与 Searcher 中各节点进行交互，收集各个节点状态，通知各节点加载相应索引数据，并利用路由配置识别非集群节点和正在扩容中的节点。</p><p>文档数据写入时，先通过 hash 取余的方式确定所属分片，按分片写入数据平台中的 WBT（类似 HBase）和 WQ（类似 Kafka）。这里所选的分片数，一般远大于 Searcher 的分组数，确保在扩容分组时依旧能均匀分布。索引的创建、上线和退场的管理由 Leader 负责，Indexer 依据 Leader 的指示，从 Processor 拉取文档，创建索引，落地到 wfs。由于搜索业务对一致性的要求比较宽松，Searcher 中同分组的不同节点之间，并不进行索引同步，各节点各自从 WFS 拉取对应分组的索引进行加载。</p><h2 id="五、索引管理"><a href="#五、索引管理" class="headerlink" title="五、索引管理"></a>五、索引管理</h2><p><strong>在**</strong>大数据<strong>**处理中，常见的架构有两种：Lambda 和 Kappa</strong>；在 Lambda 架构中，数据处理分为两部分：批处理和流式处理。而在 Kappa 架构中，只有流式处理，避免了在实时数据处理系统上再“粘”一个离线数据处理系统。这两种架构其实各有优缺点，Lamda 架构更稳定，但需要维护两套系统，批处理和实时处理要保证一致比较困难。Kappa 架构更易维护，但其数据边界不明确，需要复杂的异常处理，有数据丢失风险。</p><p>在搜一搜场景中，我们对文档的可靠性要求比较苛刻，尤其是账号系统（公众号等），数据丢失很容易引发相应产商的投诉。另外，部分特征需要<a href="https://cloud.tencent.com/product/batch?from=20067&from_column=20067" target="_blank" rel="noopener">批量计算</a>产出，这就有定期批量更新的需求，<strong>所以这里自然选用了 Lamda 架构</strong>。当新数据进来时，经由实时流进入搜索系统；当特征定期更新时，则需等待批量索引重建才能更新到线上。</p><p><img src="https://static001.geekbang.org/infoq/5f/5f37ec2f0ce4a130e7565d16b78a6bcb.png" alt="img"></p><p>上图为剔除处理逻辑后的数据流示意图，文档通过 WQ（类似 Kafka）接入后，分别进入用于批量处理的 WBT（类似 HBase）和用于实时流的 WQ。批量计算出的特征，直接写入 WBT，通过定期全量重建索引的方式上线；新增、删除或更新的文档，流经实时流 WQ，直接进入搜索系统。由于文档异步接入且索引在离线建立，所以准确的讲这里应该叫近实时流。在 ES 中，作为存储系统，读写操作是实时的，但其提供的搜索服务也需要提前建索引，也属于近实时的。</p><h3 id="1-全量索引更新"><a href="#1-全量索引更新" class="headerlink" title="1. 全量索引更新"></a>1. 全量索引更新</h3><p>全量索引重建为定期任务，indexer 从 WBT 扫描全部文档重建索引，通过 WFS 推送至 Searcher。由于 Searcher 提前划分了分组，所以 Indexer 也需要按分组建索引，每次扫描时，只扫描对应分组的分片即可。对 Searcher 中的每个节点来说，每次召回相当于在索引中查找 TopK 的过程，如果每个节点只有一个索引，其检索资源利用率是最高的，实际上多数商业搜索中也是这么做的。但是，这也带来一个问题：在索引更新时需要预留一倍的资源进行热替换。为了避免这种资源浪费，一种常用的方式是在对节点进行索引更新时，先停止服务，索引更新完成后重新上线该节点。如果业务数据足够大，近实时流和全量索引属于不同的 Searcher 模块，再加上仔细选择上线时机的话，停服对在线的影响其实可控，是较好的选择。</p><p>在微信搜一搜场景中，引擎需要支持几十上百业务，尤其是对文档数较少的账号系统来说，同时维护两个 Searcher 模块的运维成本比较高，所以依旧选择了不停服的方案。但不停服的时候，如何避免索引替换时新旧两份数据带来的资源占用呢？针对该问题，一个很自然的解决方案是<strong>对节点内的索引数据进行切分，即 Searcher 节点内的索引切分为多个库，每个库依次替换，这样只需多预留一个库的资源即可</strong>。为了与实时流区分，这里姑且称作全量库。这里的一个难点是全量库替换时，要求新库能覆盖旧库的全部数据，以保证数据完整性。如果新旧库包含相同的分片，则可解决该问题，所以<strong>分片到分组的映射，又演化为分片到全量库的映射</strong>。</p><p><img src="https://static001.geekbang.org/infoq/1a/1ac904cdf0d5e6cf561bc418b086b3d1.png" alt="img"></p><p>如上图，分片会映射到不同全量库中，新扩容分组时，全量库的个数也相应增加。全量索引重建的请求由运维人员或定时器发起，作为控制操作发送给 Leader。Leader 负责生成管理全量库的建库、加载、退场等任务，Indexer 收到建库任务后，拉取对应的分片数据，建库完成后在 WFS 保存。Leader 收到 Indexer 的建库任务完成后，通知 Searcher 中对应分组的节点进行库数据加载及下线对应的旧库。</p><p><strong>索引的每次全量重建完都会形成一轮完整的索引，这类似于存储系统中的快照</strong>。不过这里并不“快”，建库过程中的拉取数据并不是一个瞬时操作，所以在判断其覆盖的近实时流范围时，只能按起始拉取时间来判断。已完成的索引数据，会在 WFS 中保存多个轮次，这为索引回滚提供了条件。如果当前轮次的数据异常，Leader 支持运维人员选择一轮已上过线的索引，进行快速回滚，来消除错误数据带来的影响。</p><h3 id="2-近实时流更新"><a href="#2-近实时流更新" class="headerlink" title="2. 近实时流更新"></a>2. 近实时流更新</h3><p>近实时流的实现，通常要求对写友好，所以这里需要从大名鼎鼎的 LSM（Log-Structured Merge-Tree）说起。犹如其名，<strong>LSM 最初确实是用于**</strong>日志文件<strong>**系统的，其主要思想是：增量数据在内存中先排序，超过阈值时落地文件，文件是不可修改的，新的增量重新生成新文件，这就将数据随机写入变成了顺序写</strong>。但这同时也导致数据在多次更新时，会在不同文件中有一定的冗余，这种冗余在随后的文件逐级合并时清除。LevelDB 是最为经典的 LSM 范例，其提供了按 Key 查询的能力，鉴于其简洁和优雅的代码设计，已经成为 LSM 学习标杆。在搜索引擎中，Lucene 也符合 LSM 思想，与 LevelDB 不同的是，其在内存中的索引更复杂，并不是简单按 key 排序，而是按倒排建立索引。另一个不同点是文件合并时的策略，LevelDB 是按 Level 由小到大合并，而 Lucene 中是按文件大小合并。按文件大小合并策略相比更为灵活、高效，采用该策略的另一个经典系统是 HBase。</p><p>LSM 其实是通过牺牲部分读性能，换取最大化的写。这种方式也有相应的缺点：出于资源的限制，往往无法将数据合并到 1 个文件中，这也使得部分冗余数据无法被消除。另外，在文件合并时，需要大量的 IO 和 CPU 资源，这会抢占在线读写资源，带来一定的性能波动。不过，以上问题在离线创建索引的搜索系统中并不存在：</p><ol><li>索引在离线创建，在建索引时并不太关注资源抢占问题；</li><li>由于有全量索引更新流程，这相当于数据重整过程。过旧的近实时流的文件会被覆盖而下线，所以并不需要担心数据冗余问题。</li></ol><p>然而，这里还有一个问题没有解决：LSM 主要是为单节点准备的，但 Indexer 为无状态模块，不同的合并任务可能属于不同节点，这里还能适用么？其实 Indexer 建完索引后，会在 WFS 中持久化，这里只是将本地的 IO 变换成 WFS 的 IO 操作。<strong>由于没有读操作，多节点分布并无不妥，建库任务由 Leader 统一管理，也免除了多机之间同步的烦恼</strong>。</p><p><img src="https://static001.geekbang.org/infoq/0d/0d12d5ee152ad358f7cd1bcf7c2511af.webp" alt="img"></p><p>上图为某分组中近实时流库的快照示意图，其中下面的 Refresh 库相当于 LSM 内存中累积的数据，Level 库类似 LSM 中落地后的文件。新增数据，首先会进入 Refresh 库，只有 Refresh 库的数据到达一定阈值，才会转换成 Level_0 的库。如果数据写入速度较低，Refresh 库在时间阈值（5 秒）到期后也会落地上线，以便新数据能被及时检索到；上图中“库 91” 为已上线（绿色表示）的 Refresh 库，新的数据会进入“库 92”，”库 92”可以完全覆盖“库 91”的数据，如果“库 92”中的数据达到阈值后，会转换为 Level_0 的“库 9”。</p><p>在 Level 库中，由低向高合并，高 Level 的库一旦上线（绿色表示），则会同步下线掉其已覆盖的低 Level 库（灰色表示）。如果忽略删除操作带来的波动，这里每个 Level 中，不同的库中文档数几乎一致，其大小也接近，所以不存在按大小还是按 Level 合并策略的选择。整个近实时流是按照时间顺序排列的，当全量索引重建完成并上线后，会同步下线其覆盖的近实时流库（红色表示）。图中黄色部分，表示正在建索引中的库，比如近实时流“库 7|8”，正在对“库 7”和“库 8”进行合并重建。</p><p>通常情况下，LSM 的合并都在每个分片中各自进行，比如 Lucene 就属于 ES 的一个分片。但我们的场景下，分片数往往设置一个比较大的值，按分片管理将会给在线带来非常多的库，同时也给 Leader 带来较大的压力。<strong>由于在线 Searcher 按分组来加载索引，这就为分片聚合提供了可能</strong>。这里采用了按分组管理的方式，即 Indexer 会拉取归属于某个分组的全部分片的增量数据来创建索引。索引完成后，由 Leader 通知对应分组的 Searcher 进行加载，完成上线。不过这里也相应有一个缺点是，近实时流只能按分组被全量索引覆盖下线时，不能按分片来进行，造成少量的数据冗余。在系统开启近实时流后，Leader 会自动生成相应的任务，下发给 Indexer，数据流并不经过 Leader，整个过程也无需人工参与。</p><p>由于 lambda 架构有效的平衡了数据可靠性和时效性，为多数商业系统所采用。但在搜一搜中，引擎需要支持几十上百业务，这也放大了 lamda 架构的问题：每个业务都需要维护一个全量索引和近实时流两套系统，维护成本比较高。即便有 Leader 来做任务管理，文档预处理、模块维护等仍需要各业务各自参与开发。<strong>再加上 Svrkit 本身微服务的特性，更适用于 RPC 模式的流式处理，所以这里在实现时更偏向于 Kappa 架构</strong>。默认情况下，用于预处理的 Processor 和 负责索引建立的 Indexer 模块并未区分全量和近实时流。</p><p><strong>在超大型搜索业务中，上述混合架构往往无法支撑，全量索引处理需要从流式处理中真正拆分，独自进行批处理</strong>。在百亿到千亿文档的大型 Web 搜索系统中，往往还需要进行冷热数据分离。包括时新数据在内的热数据，要求每次都能正常检索，但冷数据由于排序靠后而得不到曝光，对响应时长和召回率的容忍度都要更高。与上述按文档分片后的 DAAT（document at a time）检索模式不同，冷数据通常会采用成本更低的 TAAT（term at a time）模式。</p><p>另外，冷热分离后，数据的冷热迁移也是一个需要关注的点，往往根据业务需求来订制。这类超大业务目前只在几个商业巨头中用到，已经超出本文的范围和笔者的经验，如有读者对这部分感兴趣，可以一起交流。</p><h3 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h3><p>本文详细阐述了微信搜一搜中索引管理的分布式设计中的选型和取舍。其中涉及的多个分布式经典问题，都是在数据系统的设计中要仔细权衡的。许多非常好的知名开源系统都可以给我们提供很多思路和经验。另外，本文还阐述了在离线建索引架构下，索引管理过程中的选型和设计，这部分对采用读写分离架构的数据系统有较多的参考意义。由于选题比较大，限于笔者能力，错误在所难免，还望各位读者不吝指出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h2&gt;&lt;p&gt;ref: &lt;a href=&quot;https://cloud.tencent.com/developer/news/836333&quot;</summary>
      
    
    
    
    
    <category term="ref" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/ref/"/>
    
  </entry>
  
  <entry>
    <title>分片传输和流量控制</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/04/04/slice-transmit/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/04/04/slice-transmit/</id>
    <published>2024-04-04T12:58:59.000Z</published>
    <updated>2024-05-06T11:01:53.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分片传输和流量控制"><a href="#分片传输和流量控制" class="headerlink" title="分片传输和流量控制"></a>分片传输和流量控制</h1><p>这其实是一个小功能，准备拆开来细谈一下，原来的功能是，整块数据进行上传到网关，然后由网关上传到HDFS，但是现在需要做一个新的解法。</p><p>因为原来的功能碰到了上传一个文件，第一个是文件太大了，一次性上传往往会占用太多的时间和空间，如果出现网络抖动，或者文件实在太大了挤满了，都会出现问题。第二个是，没有对网关进行流量控制，如果可能存在一个消息队列，在网络发送数据的时候进行分批次导流，就不会出现流量太大使得网关不能正常工作。</p><p>其次就是，网关这里是复数台机器，如果进行升级的时候，一般都是灰度发布，这样会使得大部分流量向一个网关倾斜，所以进行分片传输和导流，还是非常有必要的。</p><p>现在的需求是：</p><p>将一个大文件，进行切分，比如说切分为每个大小25MB，而且需要通过一个队列进行导流，分批次导流进入网关，再由网关缓存，等数据全部到达后，合并数据块，最后上传HDFS</p><h2 id="分片传输功能"><a href="#分片传输功能" class="headerlink" title="分片传输功能"></a>分片传输功能</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">upload_py_fd</span><span class="params">(dst_dir_name, dst_basename, f, mode=<span class="number">0o640</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    Base_Url = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split_file</span><span class="params">(file, chunk_size=<span class="number">1024</span>)</span>:</span></span><br><span class="line">        print(f.getbuffer().nbytes)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = file.read(chunk_size)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成一个随机的 UUID</span></span><br><span class="line">    random_uuid = uuid.uuid4()</span><br><span class="line">    <span class="comment"># 如果传过来的是bytes，则需要转为file</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(f, bytes):</span><br><span class="line">        f = BytesIO(f)</span><br><span class="line">    total_size = f.getbuffer().nbytes</span><br><span class="line">    logger.info(<span class="string">"the file byte total size is  %s "</span> % total_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># md5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_md5</span><span class="params">(file_object)</span>:</span></span><br><span class="line">        hash_object = hashlib.md5()</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: file_object.read(<span class="number">4096</span>), <span class="string">b""</span>):</span><br><span class="line">            hash_object.update(chunk)</span><br><span class="line">        file_object.seek(<span class="number">0</span>)  <span class="comment"># 将文件指针重置到文件的开始位置</span></span><br><span class="line">        <span class="keyword">return</span> hash_object.hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 假设你已经有了文件对象 f</span></span><br><span class="line">    md5 = calculate_md5(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分片大小，可自定义</span></span><br><span class="line">    <span class="comment"># 表示1kb</span></span><br><span class="line">    chunk_size = <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 表示  25MB</span></span><br><span class="line">    chunk_size = chunk_size * <span class="number">25</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># resp</span></span><br><span class="line">    resp_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割文件</span></span><br><span class="line">    <span class="keyword">for</span> i, chunk <span class="keyword">in</span> enumerate(split_file(f, chunk_size=chunk_size)):</span><br><span class="line">        logger.info(<span class="string">f"Chunk index is : <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>,  the chunk is : <span class="subst">&#123;chunk&#125;</span>"</span>)</span><br><span class="line">        f = BytesIO(chunk)</span><br><span class="line"></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"dzuuid"</span>: str(random_uuid),</span><br><span class="line">            <span class="string">"dzchunkindex"</span>: str(i),</span><br><span class="line">            <span class="string">"dztotalfilesize:"</span>: str(len(chunk)),</span><br><span class="line">            <span class="string">"dzchunksize:"</span>: str(chunk_size),</span><br><span class="line">            <span class="string">"dztotalchunkcount"</span>: str((total_size - <span class="number">1</span>) // chunk_size + <span class="number">1</span>),</span><br><span class="line">            <span class="string">"dzchunkbyteoffset"</span>: str(i * chunk_size),</span><br><span class="line">            <span class="string">"md5"</span>: str(md5),</span><br><span class="line">            <span class="string">"file"</span>: f,</span><br><span class="line">            <span class="string">"file_name"</span>: dst_basename,</span><br><span class="line">            <span class="string">"upload_type"</span>: str(<span class="number">1</span>)  <span class="comment"># 分类型 0代表使用 time.time()_file_name ，1 代表只使用file_name</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"post data info : %s"</span> % data)</span><br><span class="line"></span><br><span class="line">        http_code, resp_buff = <span class="keyword">await</span> apost(setting.DOMAIN + Base_Url + dst_dir_name, data=data)</span><br><span class="line">        logger.info(<span class="string">"http code info  %s"</span> % http_code)</span><br><span class="line">        logger.info(<span class="string">"resp is  about wfs url  %s"</span> % resp_buff)</span><br><span class="line">        <span class="keyword">if</span> http_code != <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">raise</span> ErrMsgError(<span class="string">"upload version code:%s"</span> % http_code)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            resp_dict.update(resp_buff)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp_dict</span><br></pre></td></tr></table></figure><p>这里的做法是：</p><p>客户端会去将一个大的文件首先进行进行分片处理，然后初始化一些变量和参数，包括基本的URL路径、文件的UUID、文件的总大小等。计算文件的MD5哈希值，以确保文件的完整性，这里最后会到服务端去验证整个文件是否完整。</p><p>然后，设置分片大小，即将文件分割成多个较小的块。循环处理每个分片，将分片数据和相关信息构建成一个数据字典。</p><p>发起异步POST请求，将数据字典作为参数传递给apost函数，用于上传分片数据。</p><p>检查HTTP响应的状态码，如果不是200，则抛出异常。如果HTTP响应状态码为200，则将响应结果添加到结果字典中。</p><p>循环结束后，返回结果字典，其中包含了每个分片的上传结果</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>然后，接收到信息后的做法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">slice_upload_wfs</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="comment"># 鉴权等功能省略</span></span><br><span class="line">    </span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    req_body = <span class="keyword">await</span> request.form</span><br><span class="line">    files = <span class="keyword">await</span> request.files</span><br><span class="line">    logger.info(<span class="string">"show json req_body:%s, file:%s"</span> % (req_body, files))</span><br><span class="line">    file = files.get(<span class="string">"file"</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file:</span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">"not file"</span>, <span class="number">400</span>, content_type=<span class="string">"text/html; charset=UTF-8"</span>)</span><br><span class="line">    offset = int(req_body.get(<span class="string">"dzchunkbyteoffset"</span>, <span class="number">0</span>))</span><br><span class="line">    md5 = req_body.get(<span class="string">"md5"</span>, <span class="string">""</span>)</span><br><span class="line">    idx = int(req_body.get(<span class="string">"dzchunkindex"</span>, <span class="number">0</span>))</span><br><span class="line">    block_num = int(req_body.get(<span class="string">"dztotalchunkcount"</span>, <span class="number">0</span>))</span><br><span class="line">    uuid = req_body.get(<span class="string">"dzuuid"</span>, <span class="string">""</span>)</span><br><span class="line">    name = file.filename</span><br><span class="line">    logger.info(<span class="string">"origin file name info %s "</span> % name)</span><br><span class="line">    logger.info(<span class="string">" info : %s"</span> % req_body)</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"file"</span>:</span><br><span class="line">        <span class="comment"># 如果传有别名，就使用别名，接口适配</span></span><br><span class="line">        name = req_body.get(<span class="string">"file_name"</span>, <span class="string">"file"</span>)</span><br><span class="line">        logger.info(<span class="string">"now , the file name is %s "</span> % name)</span><br><span class="line"></span><br><span class="line">    tmp_full_path = os.path.join(UPLOAD_TEMP_PATH, <span class="string">"%s_%s"</span> % (str(uuid), name))</span><br><span class="line">    logger.info(<span class="string">f' slice_upload_wfs Processing <span class="subst">&#123;name&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span> <span class="keyword">and</span> os.path.exists(tmp_full_path):</span><br><span class="line">        <span class="comment"># 文件传输失败后重新上传，清空前面失败的</span></span><br><span class="line">        os.remove(tmp_full_path)</span><br><span class="line">    <span class="keyword">with</span> open(tmp_full_path, <span class="string">"ab"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(offset)</span><br><span class="line">        f.write(file.stream.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx + <span class="number">1</span> == block_num:</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        local_md5 = <span class="keyword">await</span> get_file_md5(tmp_full_path)</span><br><span class="line">        logger.info(<span class="string">"calc md5! cost:%s"</span> % (time.time() - t1,))</span><br><span class="line">        <span class="keyword">if</span> md5 == local_md5:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                upload_type = int(req_body.get(<span class="string">"upload_type"</span>, <span class="number">0</span>))  <span class="comment"># 分类型 0代表使用 time.time()_file_name ，1 代表只使用file_name</span></span><br><span class="line">                <span class="keyword">if</span> upload_type == <span class="number">1</span>:</span><br><span class="line">                    wfs_target_path = os.path.join(WFS_BASE_PATH, path, <span class="string">"%s"</span> % (str(name)))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    wfs_target_path = os.path.join(WFS_BASE_PATH, path, <span class="string">"%s_%s"</span> % (str(int(time.time() * <span class="number">1000</span>)), name))</span><br><span class="line">                t1 = time.time()</span><br><span class="line">                <span class="keyword">await</span> wfs_upload(client, tmp_full_path, wfs_target_path, overwrite=<span class="literal">True</span>)</span><br><span class="line">                logger.info(<span class="string">"end upload! cost:%s"</span> % (time.time()-t1, ))</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logger.info(<span class="string">"slice_upload_wfs Traceback:%s"</span> % e)</span><br><span class="line">                <span class="keyword">return</span> Response(e.args[<span class="number">0</span>], <span class="number">400</span>, content_type=<span class="string">"text/html; charset=UTF-8"</span>)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                os.remove(tmp_full_path)</span><br><span class="line">            res[name] = wfs_target_path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(tmp_full_path):</span><br><span class="line">                <span class="comment"># 清理失败的文件</span></span><br><span class="line">                os.remove(tmp_full_path)</span><br><span class="line">            logger.info(<span class="string">"Traceback md5 is not equal :%s  %s"</span> % (md5, local_md5))</span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">" %s md5:%s check fail!"</span> % (tmp_full_path, md5), <span class="number">500</span>,</span><br><span class="line">                            content_type=<span class="string">"text/html; charset=UTF-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(json.dumps(res), <span class="number">200</span>, content_type=<span class="string">"application/json; charset=UTF-8"</span>)</span><br></pre></td></tr></table></figure><p>这段代码是一个异步函数，用于处理分片上传文件到指定路径的功能。下面是代码的详细解释：</p><p>首先是通过await request.form获取请求的表单数据，通过await request.files获取上传的文件对象。检查是否存在名为”file”的文件对象，如果不存在则返回一个400状态码的响应。</p><p>之后从请求的表单数据中获取偏移量offset、MD5哈希值md5、分片索引idx、总块数block_num和UUIDuuid等信息。这些信息必然不是只有一次的，这里会接受到多次这种信息，每次都用来写入到文件当中</p><p>然后，构建临时文件的完整路径tmp_full_path，格式为UUID和文件名的组合。这里需要将每次传输到的信息分片存入。</p><p>如果是第一个分片（索引为0）并且临时文件已存在，则删除之前的临时文件。说明这个很可能是失效的。</p><p>打开临时文件，将文件指针定位到指定的偏移量，并将分片数据写入文件。</p><p>如果是最后一个分片（索引加1等于总块数），则进行以下操作：</p><ul><li>计算临时文件的MD5哈希值local_md5。</li><li>比较计算得到的MD5哈希值和请求中的MD5哈希值，如果相等则进行上传操作。</li><li>根据上传类型upload_type的值，构建目标路径wfs_target_path。</li><li>调用wfs_upload函数，将临时文件上传到目标路径。</li><li>如果上传成功，则将上传后的文件路径添加到结果字典res中，并删除临时文件。</li><li>如果上传失败，则返回一个400状态码的响应。</li></ul><p>最后，返回一个200状态码的响应，其中包含了上传结果的JSON格式数据。</p><p>这段代码实现了分片上传文件的功能，它通过处理每个分片的数据和相关信息，将分片数据写入临时文件，并在最后一个分片完成时进行上传操作。它还包括了对上传结果的处理和错误处理逻辑。</p><p>总体而言还是比较简单的，有些技术看起来比较唬人，其实也很简单。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分片传输和流量控制&quot;&gt;&lt;a href=&quot;#分片传输和流量控制&quot; class=&quot;headerlink&quot; title=&quot;分片传输和流量控制&quot;&gt;&lt;/a&gt;分片传输和流量控制&lt;/h1&gt;&lt;p&gt;这其实是一个小功能，准备拆开来细谈一下，原来的功能是，整块数据进行上传到网关，然后由</summary>
      
    
    
    
    
    <category term="Python" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/03/19/jvm-opt/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/03/19/jvm-opt/</id>
    <published>2024-03-19T15:46:00.000Z</published>
    <updated>2024-04-19T15:47:26.762Z</updated>
    
    <content type="html"><![CDATA[<p>这个文章会依次表述本人经过的实践</p><p>首先是如何去发现问题，为什么要去调优？</p><p>我之前在做开源项目的时候，碰到了需要优化字节码大小问题的需求，所以，这里就用到了虚拟机优化的知识：<br>在VM option里面增加参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+PrintInlining</span><br></pre></td></tr></table></figure><p>这样执行代码后，命令行会打印出运行时的内存大小</p><p>等我更新。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个文章会依次表述本人经过的实践&lt;/p&gt;
&lt;p&gt;首先是如何去发现问题，为什么要去调优？&lt;/p&gt;
&lt;p&gt;我之前在做开源项目的时候，碰到了需要优化字节码大小问题的需求，所以，这里就用到了虚拟机优化的知识：&lt;br&gt;在VM option里面增加参数&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Flink和Pulsar实践</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/03/14/bigdata/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/03/14/bigdata/</id>
    <published>2024-03-14T15:45:38.000Z</published>
    <updated>2024-07-09T15:50:46.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flink和Pulsar实践"><a href="#Flink和Pulsar实践" class="headerlink" title="Flink和Pulsar实践"></a>Flink和Pulsar实践</h1><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><ul><li><strong>搭建环境</strong>：确保你的环境中已经安装并配置好 Apache Pulsar 和 Apache Flink。</li><li><strong>创建 Pulsar 主题</strong>：在 Pulsar 中创建用于存储搜索日志和分析结果的主题。</li></ul><h3 id="2-数据流设计"><a href="#2-数据流设计" class="headerlink" title="2. 数据流设计"></a>2. 数据流设计</h3><p>设计一个 Flink 作业，从 Pulsar 读取数据，进行分析，并将结果写回 Pulsar。以下是详细步骤：</p><h3 id="3-Flink-读取-Pulsar-数据"><a href="#3-Flink-读取-Pulsar-数据" class="headerlink" title="3. Flink 读取 Pulsar 数据"></a>3. Flink 读取 Pulsar 数据</h3><ol><li><strong>依赖配置</strong>： 在 Flink 项目中添加 Pulsar 连接器的依赖。可以在 pom.xml 中添加以下依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-pulsar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>你的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>配置 Pulsar 客户端</strong>： 在 Flink 程序中配置 Pulsar 客户端以读取数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.FlinkPulsarSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.config.StartupMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PulsarToFlink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        String serviceUrl = <span class="string">"pulsar://localhost:6650"</span>;</span><br><span class="line">        String adminUrl = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">        String topic = <span class="string">"persistent://public/default/search-logs"</span>;</span><br><span class="line"></span><br><span class="line">        FlinkPulsarSource&lt;String&gt; pulsarSource = <span class="keyword">new</span> FlinkPulsarSource&lt;&gt;(</span><br><span class="line">                serviceUrl,</span><br><span class="line">                adminUrl,</span><br><span class="line">                topic,</span><br><span class="line">                <span class="keyword">new</span> SimpleStringSchema()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        pulsarSource.setStartFromEarliest();</span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; searchLogs = env.addSource(pulsarSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4. 数据分析"></a>4. 数据分析</h3><p>根据具体的分析需求，实现搜索词与用户地理位置的相关性分析。可以使用 Flink 的 DataStream API 进行流数据处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchLogAnalyzer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置省略</span></span><br><span class="line"></span><br><span class="line">        searchLogs.flatMap(<span class="keyword">new</span> ExtractSearchTerms())</span><br><span class="line">                  .keyBy(<span class="number">0</span>)</span><br><span class="line">                  .sum(<span class="number">1</span>)</span><br><span class="line">                  .flatMap(<span class="keyword">new</span> AnalyzeCorrelation())</span><br><span class="line">                  .addSink(<span class="keyword">new</span> FlinkPulsarSink&lt;&gt;(serviceUrl, adminUrl, resultTopic, <span class="keyword">new</span> SimpleStringSchema()));</span><br><span class="line">        </span><br><span class="line">        env.execute(<span class="string">"Search Log Analyzer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractSearchTerms</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String log, Collector&lt;Tuple2&lt;String, String&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 解析日志，提取搜索词和地理位置信息</span></span><br><span class="line">            String searchTerm = ...; <span class="comment">// 提取搜索词</span></span><br><span class="line">            String userLocation = ...; <span class="comment">// 提取用户位置</span></span><br><span class="line">            out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(searchTerm, userLocation));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnalyzeCorrelation</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Tuple2&lt;String, String&gt; value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 实现搜索词与用户地理位置相关性分析逻辑</span></span><br><span class="line">            <span class="comment">// 这里简单地示例计算每个搜索词的出现次数</span></span><br><span class="line">            out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(value.f0, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将结果写回-Pulsar"><a href="#5-将结果写回-Pulsar" class="headerlink" title="5. 将结果写回 Pulsar"></a>5. 将结果写回 Pulsar</h3><p>在 Flink 程序中，将分析结果写回 Pulsar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.FlinkPulsarSink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultToPulsar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置省略</span></span><br><span class="line"></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; analysisResult = ... <span class="comment">// 分析结果流</span></span><br><span class="line"></span><br><span class="line">        analysisResult.addSink(<span class="keyword">new</span> FlinkPulsarSink&lt;&gt;(</span><br><span class="line">            serviceUrl,</span><br><span class="line">            adminUrl,</span><br><span class="line">            <span class="string">"persistent://public/default/analysis-results"</span>,</span><br><span class="line">            <span class="keyword">new</span> Tuple2Schema()</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2Schema</span> <span class="keyword">implements</span> <span class="title">SerializationSchema</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;, <span class="title">DeserializationSchema</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化和反序列化方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-部署与运行"><a href="#6-部署与运行" class="headerlink" title="6. 部署与运行"></a>6. 部署与运行</h3><ol><li><strong>打包和提交</strong>： 将 Flink 作业打包为 jar 文件并提交到 Flink 集群。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run -c your.main.class /path/to/your/jarfile.jar</span><br></pre></td></tr></table></figure><ol><li><strong>监控和调整</strong>： 监控 Flink 作业的运行情况，根据需求进行调整和优化。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，可以构建一个从 Pulsar 读取搜索日志，使用 Flink 进行分析，并将结果写回 Pulsar 的数据流处理系统。可以根据实际需求对分析逻辑进行调整和优化，以提高系统的性能和准确性。</p><h3 id="说明文档：基于-Flink-和-Pulsar-的搜索日志分析系统"><a href="#说明文档：基于-Flink-和-Pulsar-的搜索日志分析系统" class="headerlink" title="说明文档：基于 Flink 和 Pulsar 的搜索日志分析系统"></a>说明文档：基于 Flink 和 Pulsar 的搜索日志分析系统</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本系统旨在通过 Apache Pulsar 和 Apache Flink 的结合，实时分析搜索日志中的搜索词与用户地理位置之间的相关性。本文档将详细解释系统的架构、实现步骤以及其优势。</p><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p>系统主要包括以下几个部分：</p><ol><li><strong>数据源（Pulsar）</strong>：搜索日志通过 Pulsar 消息队列进行存储和传输。</li><li><strong>数据处理引擎（Flink）</strong>：Flink 从 Pulsar 中读取搜索日志，进行实时的流数据处理和分析。</li><li><strong>结果存储（Pulsar）</strong>：分析结果被写回 Pulsar 以供后续处理和查询。</li></ol><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><strong>Pulsar 数据源</strong>：</li></ol><ul><li><ul><li>Pulsar 是一个高性能的消息队列系统，能够处理大量的实时数据。</li><li>在 Pulsar 中创建用于存储搜索日志和分析结果的主题。</li></ul></li></ul><ol><li><strong>Flink 数据处理</strong>：</li></ol><ul><li><ul><li>Flink 是一个分布式流处理框架，适用于大规模数据处理。</li><li>配置 Flink 与 Pulsar 的连接，读取搜索日志数据。</li><li>使用 Flink 的 DataStream API 进行流数据处理，提取搜索词和用户地理位置信息，并进行相关性分析。</li><li>将分析结果写回 Pulsar。</li></ul></li></ul><ol><li><strong>数据流设计</strong>：</li></ol><ul><li><ul><li>通过 Flink 的流处理功能，可以实时处理从 Pulsar 中读取的日志数据，进行分析并及时输出结果。</li></ul></li></ul><h4 id="工程架构优势"><a href="#工程架构优势" class="headerlink" title="工程架构优势"></a>工程架构优势</h4><ol><li><strong>实时性</strong>：</li></ol><ul><li><ul><li>通过 Pulsar 和 Flink 的结合，系统能够实时处理和分析搜索日志数据，快速响应变化。</li><li>实时分析可以帮助业务更快地识别和响应趋势，从而提高用户体验和业务决策的准确性。</li></ul></li></ul><ol><li><strong>扩展性</strong>：</li></ol><ul><li><ul><li>Pulsar 和 Flink 都是分布式系统，能够水平扩展以处理大规模的数据。</li><li>当数据量增加时，可以通过增加更多的节点来扩展系统的处理能力。</li></ul></li></ul><ol><li><strong>高可用性</strong>：</li></ol><ul><li><ul><li>Pulsar 提供了强大的消息持久化和多副本机制，保证了数据的高可用性和可靠性。</li><li>Flink 具有内置的容错机制，能够在节点故障时自动恢复处理状态，保证数据处理的连续性。</li></ul></li></ul><ol><li><strong>灵活性</strong>：</li></ol><ul><li><ul><li>Flink 提供了丰富的 API，用于数据的过滤、转换和聚合，支持复杂的分析逻辑。</li><li>可以根据业务需求，灵活地调整分析逻辑和处理流程。</li></ul></li></ul><ol><li><strong>集成性</strong>：</li></ol><ul><li><ul><li>Flink 和 Pulsar 都支持多种数据源和接收器，方便与其他系统进行集成。</li><li>可以将分析结果进一步处理，存储到数据库或其他数据仓库中，方便后续查询和分析。</li></ul></li></ul><h4 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h4><ol><li><strong>Pulsar 主题配置</strong>：</li></ol><ul><li><ul><li>创建用于存储搜索日志的主题：search-logs</li><li>创建用于存储分析结果的主题：analysis-results</li></ul></li></ul><ol><li><strong>Flink 程序开发</strong>：</li></ol><ul><li><ul><li>配置 Pulsar 客户端，读取 search-logs 主题中的数据。</li><li>使用 Flink DataStream API 进行数据处理，提取搜索词和地理位置，并进行相关性分析。</li><li>将分析结果写回 analysis-results 主题。</li></ul></li></ul><ol><li><strong>部署和监控</strong>：</li></ol><ul><li><ul><li>将 Flink 程序打包为 jar 文件，并提交到 Flink 集群中运行。</li><li>通过 Flink 和 Pulsar 的管理界面，监控数据处理的状态和结果。</li></ul></li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>通过采用 Apache Pulsar 和 Apache Flink 的组合，构建了一个高效、实时和可扩展的搜索日志分析系统。该系统不仅能够快速处理和分析大规模的搜索日志数据，还能够根据业务需求灵活调整分析逻辑，并确保数据处理的高可用性和可靠性。这种架构在处理大规模实时数据分析时具有显著优势，能够帮助业务快速做出响应和决策。</p><hr><p>这样一个说明文档不仅解释了系统的实现步骤，还从工程架构上分析了使用 Pulsar 和 Flink 的优势，能够帮助相关团队更好地理解和实现这一系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flink和Pulsar实践&quot;&gt;&lt;a href=&quot;#Flink和Pulsar实践&quot; class=&quot;headerlink&quot; title=&quot;Flink和Pulsar实践&quot;&gt;&lt;/a&gt;Flink和Pulsar实践&lt;/h1&gt;&lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解搜索架构</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/03/06/search-system/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/03/06/search-system/</id>
    <published>2024-03-06T11:06:53.000Z</published>
    <updated>2024-05-06T11:08:27.601Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想要深入的了解和熟悉搜索引擎，我可以推荐一本书：<br><strong>这就是搜索引擎</strong></p><p>作者:张俊林<br>出版社:电子工业出版社<br>ISBN: 9787121148651</p><p>从本人了解到了知识储备而言，搜索引擎技术在工业界似乎变化不大，即使过去了很多年，整体的思想并没有发生很大的变化，来来回回都是这么个用法，召回，排序，求交，整体的信息检索水平并没有像软件工程一样分化出例如诸多的SOA，Mesh架构，也没有诞生出MVC，DDD等特定的软件设计模式，搜索引擎更多的变化在于一些性能上吗的优化，而贴合业务更做出改变。虽然本人学识并不丰富，但是也可以感觉到落后很多年了。</p><h2 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h2><p>这是一般搜索从离线到在线的整条数据流处理流程：</p><p>类似于百度，Google等搜索服务商，整体来说都是这样的流程。</p><p>但是搜一搜比较特殊，搜一搜的信息来源并不需要从网络爬取，而是自行产生的，比如公众号，小程序，这些数据来源都比较规范，而且一些基本属性，都是必须有的，这让整个搜索架构在建立索引的时候，会减少很多的功夫，所以相对于网络爬虫去爬去数据，要减少不少不必要的流程。</p><p>目前六组主要负责的是富展示模块，主要是业务端，商业变现的内容。</p><p>先看整个搜索架构，</p><p>搜一搜架构中搜索常用简称释义：</p><ul><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li></ul><p>整体从逻辑上也分为五层，如下：</p><p>虽然整体架构看起来非常复杂，但是总的来说还是在干这些事情：</p><p><strong>(离线)建立索引-&gt;召回求交排序-&gt;展示</strong></p><p>现在结合本人看到的知识，一步步推导中间的过程，中途可能还会出现不少的错误，望评论区指正</p><p>首先建立索引，这是最初步的过程，比如说我有很多的公众号文章和小程序数据，这里的每一个数据都是doc，doc_id就是每个doc的唯一标识，这些数据都是未经过处理的，没有任何意义的数据。这个时候我们肯定是需要先进行一步粗处理，将每个文档中的单词，都逐个分离出来，先变成一个正排索引：</p><p>为什么不一开始就建立倒排呢？本人理解是一个将原doc经过粗处理变成更加适合检索的doc类型，这样系统就不用存储原doc，第二个是在进行摘要检索的时候更加方便。</p><p>然后倒排索引就更加明确了：</p><p>但是要注意的是，这只是一个抽象的索引，实际上搜一搜的索引非常复杂，会涉及到诸多方面的知识和要求，一个索引不仅仅这么简单，可以参考这个：</p><p>在建立索引的过程中，还会涉及到很多的知识，这里再详细描述建立正排和倒排的过程</p><p>建立正排其实</p><p><strong>六要素</strong><br>不论索引结构如何改变，其核心依然是以下六类数据：</p><ol><li>Term词典<br>提供Term到Term对应倒排链位置的查询功能，常规实现如hash map，二分查找(有序数组)</li><li>倒排索引<br>保存Term-&gt;文档id列表数据，通常实现为有序数组，实际上可以有多种实现形式</li><li>Payload<br>Term或者文档的有效载荷，即每个Term/文档携带的额外数据，例如Term Payload通常存放Term对应文档的权重，Doc Payload则是文档的特征数据，定位是召回阶段可用的特征数据</li><li>Forward<br>文档正排数据，定位为存放文档在粗排打分阶段时需要访问的特征数据</li><li>PosOffset<br>各个Term在文档中各个域的精确位置偏移信息(原则上Pos数据也属于正排数据，同样是需要在粗排打分阶段才可访问)</li><li>Abstract<br>文档摘要数据，通常用于存放文档富展现数据 </li></ol><p>接着是这些doc的存储问题，在一个海量数据的数据中，这些doc也必定是分布式存储的，这些数据会被分发到一个个的分片中，分片数是固定的，但是每个分片的节点数是不固定的，一般是多个分片对应一个节点。比如说，doc_id 114514，假设分片是100个，那么该doc会进入分片14，但是整个分片群中节点只有10个。如果我的节点扩展到20个，分片也会随着节点扩张也迁移。</p><p>既然说了doc的存储，那么索引呢？其实常见的索引比如FOB，GOB，这些索引的存储一般不在磁盘中，而是在内存中，这里会采用一个LSM的方式去加速存储和当访问。</p><p><strong>GOB</strong> ： <strong>全量索引库 FOB</strong> ： <strong>实时索引库</strong></p><p>这里可以举一个例子去理解，比如说我们公众号每产生一个文章，就可能产生多个GOB，但是文章的更新程度其实一般不会太频繁，那如果更新了，希望现网可快速也进行更新，就产生了FOB，GOB的更新是一批一批，FOB的更新是实时的，每次GOB更新的时候都会覆盖掉所有的FOB。这个关系就像是cache和磁盘的关系一样，每次更新，先更新cache，每次落库，cache就清空。这个也是很好理解的。那么为什么不用FOB去更新GOB呢？个人感觉是这样会在现网产生很大的时延和抖动，因为会产生很大的计算量，而分别更新的话，GOB建立是离线的，只需要上线替换就好了，几乎没有计算量，综合下来还是这种方式更好。</p><p>（未完待续。。。。。。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你想要深入的了解和熟悉搜索引擎，我可以推荐一本书：&lt;br&gt;&lt;strong&gt;这就是搜索引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者:张俊林&lt;br&gt;出版社:电子工业出版社&lt;br&gt;ISBN: 9787121148651&lt;/p&gt;
&lt;p&gt;从本人了解到了知识储备而言，搜索引擎技术在工</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>搜一搜运营系统 WXG实践</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/02/24/s1s-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/02/24/s1s-1/</id>
    <published>2024-02-24T15:15:26.000Z</published>
    <updated>2024-04-18T15:46:15.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜一搜运营系统"><a href="#搜一搜运营系统" class="headerlink" title="搜一搜运营系统"></a>搜一搜运营系统</h1><p>这个是实习中碰到的主要业务。</p><p>主要是搜索评估系统，需求是抓取数据，然后更新，并且评估。效果好的话放入理想集合，再放入拨测。</p><p>涉及Python，ClickHouse，Hive，MySQL，等多种技术</p><p>规则组配置系统，需求是配置搜索词，哪些搜索词会命中大卡，然后分批次发布。</p><p>涉及MQ等技术</p><p>MP端穿透白板，需求是，搜索词所检索公众号和小程序等信息，需要展示出来。这里是需要去获取经过离线计算后的到HDFS的存储信息，然后放入MySQL分表分区存储，每个内容100个表，30个区。共四组内容。</p><p>涉及Spark，MySQL，HDFS等技术</p><p>大卡管理系统，需求是配置大卡，完成组卡逻辑。</p><p>涉及ElasticSearch，RPC，KV等技术</p><p>大卡系统，需求是线上的富展示模块，会涉及到商业变现等内容，会去拉内容提供方的信息，展示到用户端。</p><p>涉及C++，KV等技术</p><p>logicsvr，网关，完善规则引擎等内容，并提供审计上报等功能。</p><p>涉及Flask，规则引擎等。</p><p>数据过滤计算，需求是为了实现将pulsar的内容拉取到Flink中初步处理，然后出到HDFS文件当中，方面后续流程去读取</p><p>涉及Java，Pulsar，Flink</p><p>大卡索引加载优化，需求是本来用kv存储自建索引，后面使用共享内存去实现</p><p>涉及技术C++</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搜一搜运营系统&quot;&gt;&lt;a href=&quot;#搜一搜运营系统&quot; class=&quot;headerlink&quot; title=&quot;搜一搜运营系统&quot;&gt;&lt;/a&gt;搜一搜运营系统&lt;/h1&gt;&lt;p&gt;这个是实习中碰到的主要业务。&lt;/p&gt;
&lt;p&gt;主要是搜索评估系统，需求是抓取数据，然后更新，并且评估。</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常见场景问题总结</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/02/20/scene/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/02/20/scene/</id>
    <published>2024-02-20T15:45:21.000Z</published>
    <updated>2024-04-19T15:48:37.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见场景题总结"><a href="#常见场景题总结" class="headerlink" title="常见场景题总结"></a>常见场景题总结</h1><h2 id="1-扫码登陆如何实现"><a href="#1-扫码登陆如何实现" class="headerlink" title="1.扫码登陆如何实现"></a>1.扫码登陆如何实现</h2><p>1.答：访问PC端二维码生成页面，PC端请求服务端获取二维码ID 服务端生成相应的二维码ID，设置二维码的过期时间，状态等。 PC获取二维码ID，生成相应的二维码。 手机端扫描二维码，获取二维码ID。 手机端将手机端token和二维码ID发送给服务端，确认登录。 服务端校验手机端token，根据手机端token和二维码ID生成PC端token PC端通过轮询方式请求服务端，通过二维码ID获取二维码状态，如果已成功，返回PC token，登录成功。</p><p>好了，这样我们一个扫描登录的功能就设计完成了。</p><h2 id="2-一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？"><a href="#2-一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？" class="headerlink" title="2.一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？"></a>2.一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？</h2><p>2.确保你的Spring Boot项目已经集成了Redis，并正确配置了Redis连接信息。</p><p>在发布外卖配送单时，生成一个唯一的标识符（比如订单ID或随机UUID），作为这个配送单的唯一标识。</p><p>在Redis中设置一个键，用来表示当前已经被接单的配送单。这个键可以是一个字符串类型的键，例如：“delivery_order_accepted”。</p><p>当骑手想要接单时，首先通过Redis的分布式锁机制尝试获取锁。只有一个骑手能够成功获取到锁，表示该骑手接到了单子。</p><p>如果骑手成功获取到锁，即成功接到单子，将配送单的信息存储在Redis中，例如使用Hash结构保存配送单的详细信息。</p><p>如果骑手没有成功获取到锁，表示已经有其他骑手接到了单子，可以给骑手返回一个提示或者重新获取其他的配送单。</p><h2 id="3-如何把一个文件快速下发到100w个服务器？"><a href="#3-如何把一个文件快速下发到100w个服务器？" class="headerlink" title="3.如何把一个文件快速下发到100w个服务器？"></a>3.如何把一个文件快速下发到100w个服务器？</h2><ul><li>使用分发工具：使用专门的分发工具，如BitTorrent、rsync等，可以帮助在多个服务器之间并行地进行文件传输，提高传输效率。</li><li>利用分布式文件系统：使用分布式文件系统，如Hadoop HDFS、GlusterFS等，将文件存储在分布式节点上，可以更快地将文件分发到多个服务器上。</li><li>使用多线程或并行传输：在传输文件时，采用多线程或并行传输的方式，可以同时向多个服务器传输文件，提高传输速度。</li><li>使用多个传输通道：尝试使用多个传输通道同时传输文件，可以增加传输的带宽，加快传输速度。</li><li><strong>利用CDN（内容分发网络）：如果服务器部署在不同的地理位置，可以考虑使用CDN服务，将文件缓存到离用户较近的CDN节点，通过CDN节点将文件分发给多个服务器，提高传输速度和可靠性。</strong></li></ul><p>需要根据具体情况选择合适的方法，考虑网络带宽、服务器性能等因素，以实现快速和高效地将文件下发到大量服务器。</p><h2 id="4-给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的"><a href="#4-给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的" class="headerlink" title="4.给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?"></a>4.给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?</h2><p>可以使用CIDR（无类域间路由）来设计一种结构，该结构可以快速确定一个IP属于哪个组。以下是一种可能的设计方案：</p><p>将每个组分配不同的CIDR块，确保它们不重叠。</p><p>将每个CIDR块分配给该组的网络。</p><p>构建一个CIDR前缀树（也称为路由转发表或路由表）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-  在前缀树中，每个节点表示一个CIDR块。</span><br><span class="line">  -  子节点表示更具体的CIDR块。</span><br><span class="line">  -  叶节点表示最具体的CIDR块，并将其与相应的组关联起来。</span><br></pre></td></tr></table></figure><p>在前缀树中搜索给定的IP地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-  从根节点开始，比较IP地址与每个节点的CIDR块。</span><br><span class="line"> -  如果IP地址匹配节点的CIDR块，则继续向下搜索。</span><br><span class="line"> -  如果IP地址不匹配任何节点的CIDR块，则停止搜索，找到了最接近IP地址的匹配块。</span><br></pre></td></tr></table></figure><p>通过前缀树中找到的节点，确定IP所属的组。</p><p>通过这种设计，可以快速确定给定IP地址所属的组，而不需要遍历所有CIDR块。此外，这种结构还可以支持动态的CIDR块分配和组织变化，只需更新前缀树即可。</p><h2 id="5-典型TOPk系列的问题：10亿个数，找出最大的10个。等-10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？"><a href="#5-典型TOPk系列的问题：10亿个数，找出最大的10个。等-10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？" class="headerlink" title="5.典型TOPk系列的问题：10亿个数，找出最大的10个。等(10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？)"></a>5.典型TOPk系列的问题：10亿个数，找出最大的10个。等(10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？)</h2><p>5.典型TOPk系列问题是指在给定一组数据中，找出其中的前k个元素或者按照某种规则进行排序的问题。两个典型的TOPk问题分别是：</p><p>在10亿个数中找出最大的10个数： - 解法1：使用堆数据结构。维护一个大小为10的最小堆，遍历10亿个数，如果当前数比堆顶元素大，则将堆顶元素替换为当前数并对堆进行调整，保持堆的大小为10。最终堆中的数就是最大的10个数。 - 解法2：使用快速选择算法。类似于快速排序算法，每次选择一个枢纽元素将数据分为两部分，左边的部分均小于枢纽元素，右边的部分均大于枢纽元素。如果枢纽元素的位置大于k，则在左边部分继续查找，否则在右边部分继续查找。最终得到的子数组中的前k个元素就是最大的k个数。</p><p>在10万个数中输出从小到大的排序结果： - 解法1：使用快速排序算法。对于给定的数组，选择一个枢纽元素将数组分为两部分，左边的部分都小于枢纽元素，右边的部分都大于枢纽元素。然后递归地对左右两个部分进行快速排序，最终得到的数组就是从小到大的排序结果。 - 解法2：使用归并排序算法。将数组分成两个部分，分别对两个部分进行排序，然后将排好序的两个部分合并成一个有序的数组。通过递归地进行这个操作，最终得到的数组就是从小到大的排序结果。</p><p>另外，对于十万个单词中找出重复次数最高的十个单词的问题，可以使用哈希表来统计每个单词出现的次数，并维护一个大小为10的最小堆，遍历哈希表，对于每个单词的出现次数，如果大于堆顶元素，则将堆顶元素替换为当前单词，并对堆进行调整。最终堆中的元素就是重复次数最高的十个单词。</p><h2 id="6-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"><a href="#6-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。" class="headerlink" title="6.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"></a>6.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</h2><p>6.为了实现微信发红包的API，并确保红包金额精确到分且不能有人领到的红包里面没钱，可以按照以下步骤设计：</p><p>确定红包发放的总金额和红包个数。 确定每个红包的最小和最大金额范围，以确保每个红包都有一定金额。 根据总金额和红包个数，计算出每个红包的平均金额。 为避免红包金额出现小数位，将平均金额放大100倍，以分为单位进行操作。 将红包金额转化为分后，依次生成每个红包的金额。 随机生成每个红包的金额，但要保证每个红包金额在最小和最大金额范围内，并且总金额不超过设定的总金额。 将每个红包金额再转化回元，以方便显示。 返回生成的红包列表。</p><p>这样设计可以确保每个红包都有一定金额，并且总金额精确到分。</p><h2 id="7-分布式多个机器生成id，如何保证不重复"><a href="#7-分布式多个机器生成id，如何保证不重复" class="headerlink" title="7.分布式多个机器生成id，如何保证不重复?"></a>7.分布式多个机器生成id，如何保证不重复?</h2><p>7.确保分布式多个机器生成的id不重复可以采用以下方法：</p><ol><li>使用全局唯一标识符（UUID）：每个机器都可以使用UUID算法生成独特的标识符，并且无需进行全局同步即可保证唯一性。这种方法的缺点是UUID通常比较长，不适合作为简短id使用。</li><li>使用数据库的自增主键：可以使用数据库的自增主键功能生成唯一id。每个机器在插入数据时，都向数据库请求一个唯一的id，数据库会自动保证递增且唯一。缺点是需要使用数据库，并且会有一定的性能开销。</li><li>Redis的incr命令：使用Redis的incr命令实现全局自增的计数器。每个机器向Redis请求递增的计数值，并将该计数值作为id。Redis会保证incr命令的原子性，保证了id的唯一性。缺点是需要使用Redis，并且Redis的性能可能会成为瓶颈。</li><li>Twitter的Snowflake算法：Snowflake算法是一种在分布式系统中生成唯一id的算法。它使用一个64位的整数，其中包含了时间戳、机器id、序列号等信息。每个机器都有一个唯一的机器id，保证了id的唯一性。Snowflake算法的优点是生成的id比较短且有序。缺点是需要保证机器id的唯一性，并且需要有一个时钟的同步。</li></ol><p>以上方法均可以用于分布式环境下生成唯一id，选择哪种方法取决于具体系统的需求和限制。</p><h2 id="8-分布式集群中如何保证线程安全？"><a href="#8-分布式集群中如何保证线程安全？" class="headerlink" title="8.分布式集群中如何保证线程安全？"></a>8.分布式集群中如何保证线程安全？</h2><p>8.在分布式集群中，线程安全问题需要特别注意，以下是几种保证线程安全的方法：</p><ol><li>加锁：在多线程访问共享资源时，使用锁机制（如互斥锁、读写锁等）来保证同一时间只能有一个线程访问该资源。对于分布式集群，可以使用分布式锁来协调多个节点对共享资源的访问。</li><li>使用线程安全的数据结构：选择并使用线程安全的数据结构，例如线程安全的集合类（如ConcurrentHashMap、CopyOnWriteArrayList等），这些数据结构内部实现了同步机制，保证了在并发环境下的线程安全性。</li><li>避免共享状态：尽量避免多个线程共享同一份数据，而是让每个线程拥有自己的局部变量，这样就不需要考虑线程安全性的问题。可以使用ThreadLocal类来实现每个线程独立拥有自己的变量。</li><li>确保数据同步：在分布式环境下，如果涉及到跨节点之间的数据共享，需要确保数据的一致性和同步，可以通过分布式事务、分布式缓存、消息队列等机制来实现。</li><li>使用乐观锁或悲观锁：乐观锁适用于读操作较多的场景，通过版本号或时间戳等方式来控制并发访问，而悲观锁适用于写操作较多的场景，通过加锁来确保同一时间只能有一个线程写入。</li><li>合理划分任务：将任务划分成多个独立的子任务，每个子任务由一个线程处理，从而降低了并发冲突的可能性，提高了线程安全性。</li></ol><p>无论采取哪种方法，都需要在设计和实现时充分考虑并发访问的场景，评估并发冲突的可能性，并选择合适的线程安全措施来保护共享资源。</p><h2 id="9-某网站-app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？"><a href="#9-某网站-app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？" class="headerlink" title="9.某网站/app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？"></a>9.某网站/app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？</h2><p>9.推荐过程：</p><ol><li>初始推荐：根据商家的权值进行排序，选取排名前50的商家作为推荐商家，并将其置顶在网站/app首页上。权值高的商家有更大的概率被选中。</li></ol><p>更新推荐的商家：</p><ol><li>更新商家权值：根据前一天推荐商家的点击量、购买量、评价等指标，对商家的权值进行更新。点击量高、购买量多、评价好的商家权值会提高。</li><li>选择推荐商家：根据更新后的商家权值重新排序，选取排名前50的商家作为第二天的推荐商家，并进行置顶。</li></ol><p>通过这种方式，每天根据商家的表现和用户的反馈实时更新商家的权值，从而不断优化推荐的商家列表，提供更为精准和个性化的推荐服务。</p><h2 id="10-如何设计一个本地缓存？需要考虑哪些方面？"><a href="#10-如何设计一个本地缓存？需要考虑哪些方面？" class="headerlink" title="10.如何设计一个本地缓存？需要考虑哪些方面？"></a>10.如何设计一个本地缓存？需要考虑哪些方面？</h2><ol><li>缓存策略：选择合适的缓存策略，如LRU（Least Recently Used，最近最少使用）、LFU（Least Frequently Used，最不经常使用）等，根据实际需求选择适合的缓存策略。</li><li>缓存容量：确定缓存的最大容量，以避免缓存过多占用过多的内存空间。</li><li>缓存淘汰机制：当缓存容量达到上限时，需要决定淘汰哪些缓存项。可以根据缓存策略、缓存项的使用频率、过期时间等进行淘汰。</li><li>缓存过期机制：设置缓存项的过期时间，当缓存项超过过期时间未被使用时，需要从缓存中移除。</li><li>缓存命中率：记录并统计缓存命中次数和未命中次数，以评估缓存效果，并可根据需求进行优化。</li><li>并发访问控制：考虑多线程或多进程同时访问缓存的情况，确保并发访问时的数据一致性。</li><li>键值存储方式：选择合适的键值存储方式，如哈希表、二叉树等，以便高效地进行缓存项的存取操作。</li><li>数据持久化：可选项，如果需要在应用重启后仍然能够加载之前的缓存数据，则需要考虑将缓存数据持久化到磁盘或数据库中。</li><li>内存管理：合理利用内存，控制缓存占用的内存大小，避免过多的内存占用导致系统性能下降。</li><li>缓存更新机制：对于数据的更新操作，需要及时更新缓存中的缓存项，以保证缓存数据的一致性。可以使用订阅发布模式、数据库触发器等方法来实现缓存的更新。</li></ol><p>以上是设计一个本地缓存需要考虑的一些方面，具体的实现方式和细节根据实际需求和场景来确定。</p><h2 id="11-在1G大小的文件中，找出高频top100的单词"><a href="#11-在1G大小的文件中，找出高频top100的单词" class="headerlink" title="11.在1G大小的文件中，找出高频top100的单词"></a>11.在1G大小的文件中，找出高频top100的单词</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假如有一个<strong>1G</strong>大小的文件，文件里每一行是一个词，每个词的大小不超过<strong>16byte</strong>，要求返回出现频率最高的100个词。内存大小限制是<strong>10M</strong></p><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>由于内存限制，我们无法直接将大文件的所有词一次性读到内存中。</p><p>可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于10M，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>第一步</strong>，首先遍历大文件，对遍历到的每个词x，执行 hash(x) % 500，将结果为i的词存放到文件f(i)中，遍历结束后，可以得到500个小文件，每个小文件的大小为2M左右；</p><p><strong>第二步</strong>，接着统计每个小文件中出现频数最高的100个词。可以使用HashMap来实现，其中key为词，value为该词出现的频率。</p><p>对于遍历到的词x，如果在map中不存在，则执行 map.put(x, 1)。</p><p>若存在，则执行 map.put(x, map.get(x)+1)，将该词出现的次数加1。</p><p><strong>第三步</strong>，在第二步中找出了每个文件出现频率最高的100个词之后，通过维护一个<strong>小顶堆</strong>来找出所有小文件中出现频率最高的100个词。</p><p>具体方法是，遍历第一个文件，把第一个文件中出现频率最高的100个词构建成一个小顶堆。</p><p>如果第一个文件中词的个数小于100，可以继续遍历第二个文件，直到构建好有100个结点的小顶堆为止。</p><p>继续遍历其他小文件，如果遍历到的词的出现次数大于堆顶上词的出现次数，可以用新遍历到的词替换堆顶的词，然后重新调整这个堆为小顶堆。</p><p>当遍历完所有小文件后，这个小顶堆中的词就是出现频率最高的100个词。</p><p>总结一下，这种解法的主要思路如下：</p><ol><li>采用<strong>分治</strong>的思想，进行哈希取余</li><li>使用<strong>HashMap</strong>统计每个小文件单词出现的次数</li><li>使用<strong>小顶堆</strong>，遍历步骤2中的小文件，找出词频top100的单词</li></ol><p>但是很容易可以发现问题，在第二步中，如果这个1G的大文件中有某个词词频过高，可能导致小文件大小超过10m。这种情况下该怎么处理呢？</p><p>接下来看另外一种解法。</p><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p><strong>第一步</strong>：使用多路归并排序对大文件进行排序，这样相同的单词肯定是紧挨着的</p><p>多路归并排序对大文件进行排序的步骤如下：</p><p>① 将文件按照顺序切分成大小不超过2m的小文件，总共500个小文件</p><p>② 使用10MB内存<strong>分别</strong>对 500 个小文件中的单词进行<strong>排序</strong></p><p>③ 使用一个大小为500大小的堆，对500个小文件进行<strong>多路排序</strong>，结果写到一个大文件中</p><p>其中第三步，对500个小文件进行多路排序的思路如下：</p><ul><li>初始化一个最小堆，大小就是有序小文件的个数500。堆中的每个节点存放每个有序小文件对应的输入流。</li><li>按照每个有序文件中的下一行数据对所有文件输入流进行排序，单词小的输入文件流放在堆顶。</li><li>拿出堆顶的输入流，并其下一行数据写入到最终排序的文件中，如果拿出来的输入流中还有数据的话，那么将这个输入流再一次添加到栈中。否则说明该文件输入流中没有数据了，那么可以关闭这个流。</li><li>循环这个过程，直到所有文件输入流都没有数据为止。</li></ul><p><strong>第二步</strong>：</p><p>① 初始化一个100个节点的<strong>小顶堆</strong>，用于保存100个出现频率最多的单词</p><p>② 遍历整个文件，一个单词一个单词的从文件中取出来，并计数</p><p>③ 等到遍历的单词和上一个单词不同的话，那么上一个单词及其频率如果大于堆顶的词的频率，那么放在堆中，否则不放</p><p>最终，小顶堆中就是出现频率前100的单词了。</p><p>解法2相对解法1，更加严谨，如果某个词词频过高或者整个文件都是同一个词的话，解法1不适用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见场景题总结&quot;&gt;&lt;a href=&quot;#常见场景题总结&quot; class=&quot;headerlink&quot; title=&quot;常见场景题总结&quot;&gt;&lt;/a&gt;常见场景题总结&lt;/h1&gt;&lt;h2 id=&quot;1-扫码登陆如何实现&quot;&gt;&lt;a href=&quot;#1-扫码登陆如何实现&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="场景" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%9C%BA%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>准召系统</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/11/evaluate-recall/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/11/evaluate-recall/</id>
    <published>2024-01-11T11:04:03.000Z</published>
    <updated>2024-05-06T11:06:16.152Z</updated>
    
    <content type="html"><![CDATA[<p>准召平台的目的是打造一个评估系统，简而言之是将一些query放入到诊断系统当中，通过诊断结果去判断当前的算法有没有成功召回大卡，从而帮助算法工程师去进一步优化这个问题。</p><h2 id="数据从何而来"><a href="#数据从何而来" class="headerlink" title="数据从何而来"></a>数据从何而来</h2><p>这里的数据来源会根据创造的评估任务的不同而不同，比如说，现在这里有两个评估功能。</p><h3 id="准确评估"><a href="#准确评估" class="headerlink" title="准确评估"></a>准确评估</h3><p>一个功能是去创建一个准确任务，这个准确任务的目的是判断召回大卡的位置是否达到了预期，这里并不是指将其召回到最上面或者只要召回了就好了，这里会对不同的query词造成的召回位置有不同的要求，不同搜索词的召回结果和位置，会根据搜索人的意图，而有自己最佳的位置。</p><p>不过，在讲逻辑之前，先说一下背景：<strong>数据来源其实是现网的历史搜索结果，现网的历史搜索结果会先放入hdfs，因为hdfs的特性，特别适合这种只写入，不修改不查询的场景，当天历史搜索结果写入完后，会执行一定的计算，把数据全部放入到clickhouse当中(原来是hive)，这样就可以执行sql去灵活的获取数据了。</strong></p><p>我们的目的是要进行的选择某一个垂直搜索的某一个业务进行准确召回，所以业务肯定会有对应的业务类型，那么去数据库中执行sql语句抓取就好了，抓取完数据后会进行一定的初步梳理，再落入mysql数据库，后面还需要二次处理。</p><p>当然，你也可以自己选择query放进去，比如说自选query就是这样的。</p><p>值得注意的是，在准确评估条件下，需要根据不同的条件去Clickhouse取数据。对于全搜而言，reqbusinesstype_ 和scene_是：reqbusinesstype_=0，scene_=(3, 20, 101, 74 )</p><p>对于视频号内搜而言：<br>reqbusinesstype_=14，scene_=(123)</p><p>SQL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">敏感数据</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br></pre></td></tr></table></figure><h3 id="召回评估"><a href="#召回评估" class="headerlink" title="召回评估"></a>召回评估</h3><p>那么前面说了，准确评估的数据可以直接去clickhouse取，那么召回评估的是否也可以呢？其实不行，因为这里涉及到很多的因素，比如，对于召回而言，其实需要去判断这个词组有没有被召回，那么就不能直接去数据库里面取，因为数据库里面的都是挑选好类别的，而是需要去现网打捞数据，然后把打捞回来的数据经过进一步的计算和预处理，才会变成适合去进行召回评估的数据，那么这种数据就会直接放入到hdfs文件里面，需要召回的时候再进行数据的读取。</p><p>当然，这里你也可以自己选择query放进去，因为这里本质上两个操作首先做的都是获取数据，而不是真正的算法评估结果。</p><p>值得注意的是，对于目前而言，是不区分全搜和视频号内搜的数据的，因为HDFS文件其实只有一份，所以不能够精确的去区分这个query词组是属于全搜还是视频号内搜的。</p><h4 id="召回为什么要区分数据"><a href="#召回为什么要区分数据" class="headerlink" title="召回为什么要区分数据"></a>召回为什么要区分数据</h4><p>其实对于搜索词而言，虽然都只是一些字符串，但是更多的是期望当前搜索词就是触发该垂直搜索的真实的字符串，如果使用别的垂搜的搜索词去还原这个搜索现场，虽然也是可以看到算法的结果，但是对于真实的搜索词组和搜索情况而言，可能就没这么的精确，所以，要去限制reqbusinesstype_ 和scene_是有原因的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;准召平台的目的是打造一个评估系统，简而言之是将一些query放入到诊断系统当中，通过诊断结果去判断当前的算法有没有成功召回大卡，从而帮助算法工程师去进一步优化这个问题。&lt;/p&gt;
&lt;h2 id=&quot;数据从何而来&quot;&gt;&lt;a href=&quot;#数据从何而来&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SOFASTACK/SOFA-RPC</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/08/opensource1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/08/opensource1/</id>
    <published>2024-01-08T15:55:53.000Z</published>
    <updated>2024-06-28T15:30:52.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>这里会去介绍一下关于我的小小的开源经历 SOFASTACK/SOFA-RPC和Apache/fury<br>看起来是两个，但是其实是一个，因为主要是在做如何将fury融入到sofa-rpc里面，这里做了很多工作，特别是要感谢 <strong>@EvenLjj @Lo1n  @chaokunyang</strong><br>下面直接开始介绍：<br>首先是对sofa-rpc的改造，这里最大的需求是需要读取一个黑白名单作为配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackAndWhiteListFileLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger      LOGGER                     = LoggerFactory</span><br><span class="line">                                                                    .getLogger(BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SOFA_SERIALIZE_BLACK_LIST  = loadBlackListFile(<span class="string">"/sofa-rpc/serialize_blacklist.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SOFA_SERIALIZER_WHITE_LIST = loadWhiteListFile(<span class="string">"/sofa-rpc/serialize_whitelist.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadBlackListFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; blackPrefixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readToList(input, <span class="string">"UTF-8"</span>, blackPrefixList);</span><br><span class="line">            &#125;</span><br><span class="line">            String overStr = SofaConfigs.getOrCustomDefault(SERIALIZE_BLACKLIST_OVERRIDE, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overStr)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"Serialize blacklist will override with configuration: &#123;&#125;"</span>, overStr);</span><br><span class="line">                &#125;</span><br><span class="line">                overrideBlackList(blackPrefixList, overStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isErrorEnabled()) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> blackPrefixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadWhiteListFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; whitePrefixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readToList(input, <span class="string">"UTF-8"</span>, whitePrefixList);</span><br><span class="line">            &#125;</span><br><span class="line">            String overStr = SofaConfigs.getOrCustomDefault(SERIALIZE_WHITELIST_OVERRIDE, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overStr)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"Serialize whitelist will override with configuration: &#123;&#125;"</span>, overStr);</span><br><span class="line">                &#125;</span><br><span class="line">                overrideWhiteList(whitePrefixList, overStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isErrorEnabled()) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> whitePrefixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读文件，将结果丢入List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input           输入流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encoding        编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blackPrefixList 保持黑名单前缀的List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readToList</span><span class="params">(InputStream input, String encoding, List&lt;String&gt; blackPrefixList)</span> </span>&#123;</span><br><span class="line">        InputStreamReader reader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> InputStreamReader(input, encoding);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">            String lineText;</span><br><span class="line">            <span class="keyword">while</span> ((lineText = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String pkg = lineText.trim();</span><br><span class="line">                <span class="keyword">if</span> (pkg.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    blackPrefixList.add(pkg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isWarnEnabled()) &#123;</span><br><span class="line">                LOGGER.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(bufferedReader);</span><br><span class="line">            closeQuietly(reader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Override blacklist with override string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originList  Origin black list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> overrideStr The override string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">overrideBlackList</span><span class="params">(List&lt;String&gt; originList, String overrideStr)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; adds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] overrideItems = StringUtils.splitWithCommaOrSemicolon(overrideStr);</span><br><span class="line">        <span class="keyword">for</span> (String overrideItem : overrideItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overrideItem)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (overrideItem.startsWith(<span class="string">"!"</span>) || overrideItem.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                    overrideItem = overrideItem.substring(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"*"</span>.equals(overrideItem) || <span class="string">"default"</span>.equals(overrideItem)) &#123;</span><br><span class="line">                        originList.clear();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        originList.remove(overrideItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!originList.contains(overrideItem)) &#123;</span><br><span class="line">                        adds.add(overrideItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            originList.addAll(adds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">overrideWhiteList</span><span class="params">(List&lt;String&gt; originList, String overrideStr)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; adds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] overrideItems = StringUtils.splitWithCommaOrSemicolon(overrideStr);</span><br><span class="line">        <span class="keyword">for</span> (String overrideItem : overrideItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overrideItem)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!originList.contains(overrideItem)) &#123;</span><br><span class="line">                    adds.add(overrideItem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            originList.addAll(adds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的主要作用是加载黑名单和白名单文件，并将文件中的内容读取到对应的列表中。<br>具体来说，这段代码包含以下主要功能：</p><ol><li>loadBlackListFile方法：加载黑名单文件并将文件中的内容读取到blackPrefixList列表中。首先，通过BlackAndWhiteListFileLoader.class.getResourceAsStream(path)方法获取黑名单文件的输入流。然后，使用readToList方法将输入流中的内容按行读取，并将非空的行添加到blackPrefixList列表中。最后，根据配置文件中的覆盖字符串，通过overrideBlackList方法对黑名单列表进行覆盖操作。</li><li>loadWhiteListFile方法：加载白名单文件并将文件中的内容读取到whitePrefixList列表中。与loadBlackListFile方法类似，它通过相同的步骤读取白名单文件，并根据配置文件中的覆盖字符串，通过overrideWhiteList方法对白名单列表进行覆盖操作。</li><li>readToList方法：将输入流中的内容按行读取，并将非空的行添加到指定的列表中。</li><li>overrideBlackList方法：根据覆盖字符串对原始的黑名单列表进行覆盖操作。根据覆盖字符串中的规则，可以添加、删除或清空黑名单列表中的元素。</li><li>overrideWhiteList方法：根据覆盖字符串对原始的白名单列表进行覆盖操作。根据覆盖字符串中的规则，可以添加白名单列表中不存在的元素。</li></ol><p>总体而言，这段代码的主要作用是加载黑名单和白名单文件，并提供方法来对这些列表进行覆盖操作，以便在后续的逻辑中使用这些列表进行过滤或其他处理<br>这是一个最基本的需求，就是通过读取一个黑白名单文件，这里也可以展示一下文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clojure.core$constantly</span><br><span class="line">clojure.main$eval_opt</span><br><span class="line">com.alibaba.citrus.springext.support.parser.AbstractNamedProxyBeanDefinitionParser$ProxyTargetFactory</span><br><span class="line">com.alibaba.citrus.springext.support.parser.AbstractNamedProxyBeanDefinitionParser$ProxyTargetFactoryImpl</span><br><span class="line">com.alibaba.citrus.springext.util.SpringExtUtil.AbstractProxy</span><br><span class="line">com.alipay.custrelation.service.model.redress.Pair</span><br><span class="line">com.caucho.hessian.test.TestCons</span><br><span class="line">com.mchange.v2.c3p0.JndiRefForwardingDataSource</span><br><span class="line">com.mchange.v2.c3p0.WrapperConnectionPoolDataSource</span><br><span class="line">com.rometools.rome.feed.impl.EqualsBean</span><br><span class="line">com.rometools.rome.feed.impl.ToStringBean</span><br><span class="line">com.sun.jndi.rmi.registry.BindingEnumeration</span><br><span class="line">com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>格式就是这样，具体就不全部放出了<br>然后从设计模式上，会使用一个枚举类去展示出有哪些情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lipan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FurySecurityMode &#123;</span><br><span class="line"></span><br><span class="line">    WHITELIST_MODE(<span class="string">"whitelist"</span>), BLACKLIST_MODE(<span class="string">"blacklist"</span>), NONE_MODE(<span class="string">"none"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String securityMode;</span><br><span class="line"></span><br><span class="line">    FurySecurityMode(String securityMode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.securityMode = securityMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecurityMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就只会出现三种情况，黑名单，白名单，什么都不使用<br>会有一个判断逻辑去判断会出现那种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not use any configuration</span></span><br><span class="line"><span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.NONE_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker noChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.DISABLE);</span><br><span class="line">    f.getClassResolver().setClassChecker(noChecker);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.BLACKLIST_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker blackListChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.WARN);</span><br><span class="line">    List&lt;String&gt; blackList = BlackAndWhiteListFileLoader.SOFA_SERIALIZE_BLACK_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackListChecker);</span><br><span class="line">    blackListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// BlackList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : blackList) &#123;</span><br><span class="line">        blackListChecker.disallowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.WHITELIST_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker blackAndWhiteListChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.STRICT);</span><br><span class="line">    List&lt;String&gt; whiteList = BlackAndWhiteListFileLoader.SOFA_SERIALIZER_WHITE_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackAndWhiteListChecker);</span><br><span class="line">    blackAndWhiteListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// WhiteList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : whiteList) &#123;</span><br><span class="line">        blackAndWhiteListChecker.allowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; blackList = BlackAndWhiteListFileLoader.SOFA_SERIALIZE_BLACK_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackAndWhiteListChecker);</span><br><span class="line">    blackAndWhiteListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// BlackList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : blackList) &#123;</span><br><span class="line">        blackAndWhiteListChecker.disallowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里涉及到fury的两个能力，一个是注册过的类 进行序列化/反序列化的时候效率会更高，一个是可以通过checker去判断，当前的类是否在名单内。<br>然后下面进入了编码阶段，这里其实会对不同请求进行区别，将SOFA请求和普通的类区分开来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractByteBuf <span class="title">encode</span><span class="params">(<span class="keyword">final</span> Object object, <span class="keyword">final</span> Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> buildSerializeError(<span class="string">"Unsupported null message!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fury.setClassLoader(contextClassLoader);</span><br><span class="line">        CustomSerializer customSerializer = getObjCustomSerializer(object);</span><br><span class="line">        <span class="keyword">if</span> (customSerializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> customSerializer.encodeObject(object, context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MemoryBuffer writeBuffer = MemoryBuffer.newHeapBuffer(<span class="number">32</span>);</span><br><span class="line">            writeBuffer.writerIndex(<span class="number">0</span>);</span><br><span class="line">            fury.serialize(writeBuffer, object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayWrapperByteBuf(writeBuffer.getBytes(<span class="number">0</span>, writeBuffer.writerIndex()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> buildSerializeError(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fury.clearClassLoader(contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个方法的实现，用于将对象编码为字节缓冲区（ByteBuf）。<br>具体来说，这段代码的作用如下：<br>首先，检查传入的对象是否为null，如果是null，则抛出一个序列化错误异常。获取当前线程的上下文类加载器（contextClassLoader），以便后续使用。然后会设置fury（一个自定义序列化框架）的类加载器为上下文类加载器，以确保在序列化过程中使用正确的类加载器加载所需的类。<br>获取对象的自定义序列化器（customSerializer），如果存在自定义序列化器，则使用自定义序列化器对对象进行编码，并返回编码后的字节缓冲区。<br>如果不存在自定义序列化器，则创建一个内存缓冲区（MemoryBuffer），并使用fury对对象进行序列化，将序列化后的数据写入内存缓冲区。<br>将内存缓冲区中的字节数据封装到一个ByteArrayWrapperByteBuf对象中，并返回该对象作为编码后的结果。需要注意的是，在整个过程中，如果发生任何异常，都会抛出一个序列化错误异常，并将异常信息作为错误消息进行构建。<br>这段代码的主要作用是根据对象的类型和上下文信息，使用自定义序列化器或默认的fury序列化框架，将对象编码为字节缓冲区。<br>这里可以着重讲一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure><p>这个设计的主要目的是为了获得当前线程最新的类加载器，因为在这里会遇到一个场景，那就是当客户端在发送rpc的时候，服务端的rpc协议或者说类变更了，这样会导致两端不一样的问题， 所以需要通过这种方式去实时更新类。动态类加载和热更新：使用动态类加载和热更新的机制，可以在运行时动态加载和更新类。这样可以避免重启应用程序或重新部署的麻烦，使得类的变更能够及时生效。<br>然后就是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomSerializer customSerializer = getObjCustomSerializer(object);</span><br></pre></td></tr></table></figure><p>这里实际上是，会有自己的序列化器去实现这个CustomSerializer接口，然后这里会通过判断这个object的class是否为CustomSerializer的实现类，然后CustomSerializer有自己的处理方式。<br>然后看看它的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractByteBuf <span class="title">encodeObject</span><span class="params">(SofaRequest object, Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryBuffer writeBuffer = MemoryBuffer.newHeapBuffer(<span class="number">32</span>);</span><br><span class="line">        writeBuffer.writerIndex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据SerializeType信息决定序列化器</span></span><br><span class="line">        <span class="keyword">boolean</span> genericSerialize = context != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            isGenericRequest(context.get(RemotingConstants.HEAD_GENERIC_TYPE));</span><br><span class="line">        <span class="keyword">if</span> (genericSerialize) &#123;</span><br><span class="line">            <span class="comment">// TODO support generic call</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Generic call is not supported for now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fury.serialize(writeBuffer, object);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = object.getMethodArgs();</span><br><span class="line">        fury.serialize(writeBuffer, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayWrapperByteBuf(writeBuffer.getBytes(<span class="number">0</span>, writeBuffer.writerIndex()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里默认会去构造一个buffer，将序列化的实例的写入buffer里面，并且同时需要将每个参数也同步写入。同时定好fury的序列化模式，然后转为byte数组传回去。这里涉及到fury的底层实现，比较难说为什么要这么做，但是做法确实比较直观和简洁。<br>然后，就是进行反序列化了，但在这里有一个不同的实现方式，sofa会去定义是否要将结果直接反序列化到传入的实例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SofaRequest <span class="title">decodeObject</span><span class="params">(AbstractByteBuf data, Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    MemoryBuffer readBuffer = MemoryBuffer.fromByteArray(data.array());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SofaRequest sofaRequest = (SofaRequest) fury.deserialize(readBuffer);</span><br><span class="line">        String targetServiceName = sofaRequest.getTargetServiceUniqueName();</span><br><span class="line">        <span class="keyword">if</span> (targetServiceName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Target service name of request is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String interfaceName = ConfigUniqueNameGenerator.getInterfaceName(targetServiceName);</span><br><span class="line">        sofaRequest.setInterfaceName(interfaceName);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = (Object[]) fury.deserialize(readBuffer);</span><br><span class="line">        sofaRequest.setMethodArgs(args);</span><br><span class="line">        <span class="keyword">return</span> sofaRequest;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decodeObjectByTemplate</span><span class="params">(AbstractByteBuf data, Map&lt;String, String&gt; context, SofaRequest template)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.readableBytes() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Deserialized array is empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryBuffer readBuffer = MemoryBuffer.fromByteArray(data.array());</span><br><span class="line">        SofaRequest tmp = (SofaRequest) fury.deserialize(readBuffer);</span><br><span class="line">        String targetServiceName = tmp.getTargetServiceUniqueName();</span><br><span class="line">        <span class="keyword">if</span> (targetServiceName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Target service name of request is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy values to template</span></span><br><span class="line">        template.setMethodName(tmp.getMethodName());</span><br><span class="line">        template.setMethodArgSigs(tmp.getMethodArgSigs());</span><br><span class="line">        template.setTargetServiceUniqueName(tmp.getTargetServiceUniqueName());</span><br><span class="line">        template.setTargetAppName(tmp.getTargetAppName());</span><br><span class="line">        template.addRequestProps(tmp.getRequestProps());</span><br><span class="line">        String interfaceName = ConfigUniqueNameGenerator.getInterfaceName(targetServiceName);</span><br><span class="line">        template.setInterfaceName(interfaceName);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = (Object[]) fury.deserialize(readBuffer);</span><br><span class="line">        template.setMethodArgs(args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体操作比较类似，就是读出对应的实例和参数。<br>然后，这个sofa-rpc也是使用扩展机制，去将序列化方式融入到整体当中的。</p><h2 id="Fury"><a href="#Fury" class="headerlink" title="Fury"></a>Fury</h2><p>这里我还在fury这个项目中做了点贡献，尤其是对StringBuilder的修改：<br>在 JDK 8 和 JDK 11 中，StringBuilder 类的底层实现数组的方式有一些区别。<br>在 JDK 8 中，StringBuilder 类使用的是一个字符数组（char[]）作为底层的缓冲区。初始时，该字符数组的长度为 16。当需要追加更多字符时，StringBuilder 会检查当前缓冲区是否有足够的空间，如果没有，则会创建一个新的字符数组，将原有的字符数组内容复制到新数组中，并将新的字符数组作为底层缓冲区。<br>在 JDK 11 中，StringBuilder 类的底层实现有所改进。它引入了一个新的类，称为 CompactStrings。CompactStrings 类使用的是一个字节数组（byte[]）作为底层的缓冲区。这个字节数组中的每个字节都可以存储一个字符，而不仅仅是一个字节。这样可以节省内存空间，特别是对于包含大量 ASCII 字符的字符串。<br>在 JDK 11 中，默认情况下，CompactStrings 是启用的。当字符串中的字符都可以用一个字节表示时，CompactStrings 会将字符串存储在字节数组中。只有当字符串中包含无法用一个字节表示的字符时，才会使用字符数组来存储字符串。<br>这种改进的底层实现方式可以提供更高的内存效率，特别是对于包含大量 ASCII 字符的字符串。它可以减少内存的使用量，并提高性能。需要注意的是，CompactStrings 的启用与否可以通过 JVM 的参数进行配置。在某些情况下，可能需要手动禁用 CompactStrings，以便与旧版本的 JDK 兼容或满足特定的需求。<br>于是，即使是面对同样的类，也要有不一样的序列化方式，当然，这里其实可以通过启动时去获取jdk版本，然后做区分操作，现在要展示的是，如何在版本不同的StringBuilder下做出不同的序列化结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ToIntFunction GET_CODER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Function GET_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  GET_VALUE = (Function) makeGetterFunction(StringBuilder.class.getSuperclass(), "getValue");</span><br><span class="line">  ToIntFunction&lt;CharSequence&gt; getCoder;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Method getCoderMethod = StringBuilder.class.getSuperclass().getDeclaredMethod("getCoder");</span><br><span class="line">    getCoder = (ToIntFunction&lt;CharSequence&gt;) makeGetterFunction(getCoderMethod, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    getCoder = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  GET_CODER = getCoder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个静态代码块，用于初始化两个私有静态变量 GET_VALUE 和 GET_CODER。<br>首先，代码使用 makeGetterFunction 方法创建了一个函数对象 GET_VALUE，该函数对象用于获取 StringBuilder 类的父类的 getValue 方法。接下来，代码尝试通过反射获取 StringBuilder 类的父类的 getCoder 方法，并将其转换为 ToIntFunction<CharSequence> 类型。如果找不到该方法，则将 GET_CODER 设置为 null。最终，将获取到的 getCoder 赋值给 GET_CODER 变量。<br>这段代码的目的是为了获取 StringBuilder 类的父类的 getValue 方法和 getCoder 方法，并将它们分别赋值给 GET_VALUE 和 GET_CODER 变量。这些变量可能在后续的代码中使用，用于执行相应的操作。<br>因为既然它们的底层实现不一样，就需要通过反射的方式去获取到实际的底层数组，这里只需要做区分了。然后，写入的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(MemoryBuffer buffer, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GET_CODER != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> coder = GET_CODER.applyAsInt(value);</span><br><span class="line">      <span class="keyword">byte</span>[] v = (<span class="keyword">byte</span>[]) GET_VALUE.apply(value);</span><br><span class="line">      buffer.writeByte(coder);</span><br><span class="line">      <span class="keyword">if</span> (coder == <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.writePrimitiveArrayWithSizeEmbedded(v, Platform.BYTE_ARRAY_OFFSET, value.length());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coder != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported coder "</span> + coder);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.writePrimitiveArrayWithSizeEmbedded(</span><br><span class="line">            v, Platform.BYTE_ARRAY_OFFSET, value.length() &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">char</span>[] v = (<span class="keyword">char</span>[]) GET_VALUE.apply(value);</span><br><span class="line">      <span class="keyword">if</span> (StringSerializer.isLatin(v)) &#123;</span><br><span class="line">        stringSerializer.writeCharsLatin(buffer, v, value.length());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stringSerializer.writeCharsUTF16(buffer, v, value.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，代码检查 GET_CODER 是否为 null，如果不为 null，则说明 StringBuilder 对象使用了编码器（coder）。在这种情况下，代码通过调用 GET_CODER.applyAsInt(value) 获取编码器的值，并将其写入 buffer 中。<br>接下来，根据编码器的值进行不同的处理。如果编码器的值为 0，表示使用 Latin 编码，此时将 byte[] 类型的值 v 写入 buffer，并使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将数组的内容写入 buffer。如果编码器的值不为 0 或 1，则抛出 UnsupportedOperationException 异常。如果编码器的值为 1，表示使用 UTF-16 编码，此时将 byte[] 类型的值 v 写入 buffer，并将数组的长度乘以 2，然后使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将数组的内容写入 buffer。<br>如果 GET_CODER 为 null，则说明 StringBuilder 对象没有使用编码器。在这种情况下，代码通过调用 GET_VALUE.apply(value) 获取 char[] 类型的值 v，然后根据 v 是否为 Latin 编码来决定使用 stringSerializer 的 writeCharsLatin 方法还是 writeCharsUTF16 方法将字符数组写入 buffer。<br><strong>为什么要区分Latin 和UTF-16呢？Latin 编码和 UTF-16 编码所占的位数是不同的！</strong><br>Latin 编码是一种字符编码方式，它使用一个字节（8位）来表示一个字符。它主要用于表示拉丁字母字符集，包括英文字母和一些特殊字符。由于使用一个字节表示一个字符，Latin 编码可以节省存储空间，但它只能表示有限的字符集。<br>UTF-16 编码是一种可变长度的字符编码方式，它使用 16 位（2个字节）来表示一个字符。它可以表示几乎所有的字符，包括拉丁字母、非拉丁字母、符号、表情符号等。UTF-16 编码可以表示更广泛的字符集，但相对于 Latin 编码，它在存储空间上需要更多的字节。<br>因此，当将字符数组序列化时，如果使用 Latin 编码，每个字符只需要一个字节来表示；而如果使用 UTF-16 编码，每个字符需要两个字节来表示。在代码中，根据编码器的值选择适当的序列化方式，可以根据编码器的值来确定使用 Latin 编码还是 UTF-16 编码，并相应地调整序列化的字节数。</p><h3 id="高效的判断该字符串是否纯Latin字符串-SIMD"><a href="#高效的判断该字符串是否纯Latin字符串-SIMD" class="headerlink" title="高效的判断该字符串是否纯Latin字符串(SIMD)"></a>高效的判断该字符串是否纯Latin字符串(SIMD)</h3><p>这里是使用了向量化操作去快速的判断，主要还是使用了UNSAFE方法去加速判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLatin</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numChars = chars.length;</span><br><span class="line">  <span class="keyword">int</span> vectorizedLen = numChars &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> vectorizedChars = vectorizedLen &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> endOffset = Platform.CHAR_ARRAY_OFFSET + (vectorizedChars &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">boolean</span> isLatin = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> offset = Platform.CHAR_ARRAY_OFFSET; offset &lt; endOffset; offset += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">// check 4 chars in a vectorized way, 4 times faster than scalar check loop.</span></span><br><span class="line">    <span class="comment">// See benchmark in CompressStringSuite.latinSuperWordCheck.</span></span><br><span class="line">    <span class="keyword">long</span> multiChars = Platform.getLong(chars, offset);</span><br><span class="line">    <span class="keyword">if</span> ((multiChars &amp; MULTI_CHARS_NON_LATIN_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">      isLatin = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isLatin) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vectorizedChars; i &lt; numChars; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (chars[i] &gt; <span class="number">0xFF</span>) &#123;</span><br><span class="line">        isLatin = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isLatin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先获取字符数组的长度 numChars，然后计算出向量化长度 vectorizedLen，即将字符数组长度右移两位得到的结果。这里的len是指需要向量化检测的次数，比如numChars=81，vectorizedLen=20。接着，根据向量化长度计算出向量化字符数 vectorizedChars，即将向量化长度左移两位得到的结果。既，检测的字符数量。</p><p>然后，根据向量化字符数计算出结束偏移量 endOffset，即将字符数组的偏移量 Platform.CHAR_ARRAY_OFFSET 加上向量化字符数左移一位得到的结果。Platform.CHAR_ARRAY_OFFSET默认数值为16。在Java中，数组对象在内存中的布局通常包含一些元数据，比如数组的长度、类型信息等。Platform.CHAR_ARRAY_OFFSET 指定了字符数组数据部分的起始偏移量，表示从数组对象的起始位置到实际字符数据开始的距离。在很多JVM实现中，这个偏移量是16字节。这是因为：</p><ol><li>JVM实现细节：不同的JVM实现可能有不同的对象头结构。通常，对象头包含一些元数据，如对象的类型信息、标记信息、数组长度等。对于数组对象，这些元数据会占用一定的空间，具体值可能会因JVM版本和实现的不同而有所差异。</li><li>内存对齐：为了性能优化，JVM可能会对内存进行对齐操作，使数据起始位置是某个倍数（如8字节或16字节）的地址。</li></ol><p>接下来，函数使用一个布尔变量 isLatin 来表示字符数组是否全部由 Latin 字符组成，初始值为 true。然后，函数通过一个循环，从字符数组的偏移量开始，每次增加 8，以向量化方式检查字符数组中的四个字符。具体地，函数使用 Platform.getLong(chars, offset) 获取一个长整型数，一次读取8个字节（即4个字符）。然后，函数将这个长整型数与 MULTI_CHARS_NON_LATIN_MASK 进行按位与操作，如果结果不为 0，说明存在非 Latin 字符，此时将 isLatin 设置为 false 并跳出循环。</p><p><strong>怎么知道掩码是什么数值的呢？</strong> 掩码 <strong>MULTI_CHARS_NON_LATIN_MASK= -71777214294589696</strong> (即 0xFF80FF80FF80FF80) 是通过位运算来检查字符是否是拉丁字符的。这是通过以下方式实现的：</p><ol><li><p>掩码计算：</p><p>0xFF80是一个16位掩码，表示非拉丁字符的范围。0xFF80的二进制表示为 11111111 10000000，即前8位为1，后8位为0，用于标识非拉丁字符。</p><p>为了检查4个字符，我们需要将这个16位掩码扩展到64位，即重复4次 0xFF80，得到 0xFF80FF80FF80FF80，表示 11111111 10000000 11111111 10000000 11111111 10000000 11111111 10000000。</p></li><li><p>使用掩码进行位运算：</p><p>UNSAFE.getLong(chars, offset) 读取8字节（即4个字符）的数据。</p><p>将这些数据与 0xFF80FF80FF80FF80 进行按位与运算。如果结果不为0，说明这4个字符中至少有一个字符的高字节部分非零，即不是拉丁字符。</p></li></ol><p>如果在向量化检查中没有发现非 Latin 字符，函数会继续进行后续的检查。去检测费向量化的部分，函数使用一个循环，从向量化字符数开始，逐个检查字符数组中的字符。如果发现字符的值大于 0xFF（即超过一个字节的范围），则说明存在非 Latin 字符，此时将 isLatin 设置为 false 并跳出循环。<br>最后，函数返回 isLatin 的值，表示字符数组是否全部由 Latin 字符组成。</p><p>在Unicode标准中，0xFF（255）并不是最大的字符。事实上，Unicode字符的范围远超过255。具体解释如下：</p><p>字符范围：</p><ol><li>在ASCII码表中，字符范围是0到127。</li><li>在扩展ASCII码表中，字符范围是0到255。</li><li>Unicode字符的范围从 0x0000 到 0x10FFFF，支持大量的字符，包括各种语言的字符、符号、表情符号等。</li></ol><p>0xFF的意义：</p><ol><li>0xFF表示255，主要用于表示扩展ASCII字符的范围。</li><li>在检查拉丁字符时，判断条件 chars[i] &gt; 0xFF 用于检查字符是否超出了扩展ASCII范围，即是否包含非拉丁字符（Unicode字符）。</li></ol><p>因此，0xFF并不是最大的字符。在这个方法中，chars[i] &gt; 0xFF 用来检测字符数组中是否有字符的值大于255，以判断是否包含非拉丁字符。</p><p>这个函数的目的是通过向量化方式快速检查字符数组中是否存在非 Latin 字符，以及通过逐个检查剩余字符的方式进一步确认是否全部为 Latin 字符。这样可以提高判断的效率，并且可以在序列化过程中根据判断结果选择合适的序列化方式。</p><h3 id="零拷贝StringBuilder-StringBuffer"><a href="#零拷贝StringBuilder-StringBuffer" class="headerlink" title="零拷贝StringBuilder/StringBuffer"></a>零拷贝StringBuilder/StringBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCharsLatin</span><span class="params">(MemoryBuffer buffer, <span class="keyword">char</span>[] chars, <span class="keyword">final</span> <span class="keyword">int</span> strLen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> writerIndex = buffer.writerIndex();</span><br><span class="line">  <span class="comment">// The `ensure` ensure next operations are safe without bound checks,</span></span><br><span class="line">  <span class="comment">// and inner heap buffer doesn't change.</span></span><br><span class="line">  buffer.ensure(writerIndex + <span class="number">9</span> + strLen);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] targetArray = buffer.getHeapMemory();</span><br><span class="line">  <span class="keyword">if</span> (targetArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetIndex = buffer.unsafeHeapWriterIndex();</span><br><span class="line">    <span class="keyword">int</span> arrIndex = targetIndex;</span><br><span class="line">    targetArray[arrIndex++] = LATIN1;</span><br><span class="line">    arrIndex += MemoryUtils.writePositiveVarInt(targetArray, arrIndex, strLen);</span><br><span class="line">    writerIndex += arrIndex - targetIndex + strLen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      targetArray[arrIndex + i] = (<span class="keyword">byte</span>) chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buffer.unsafePut(writerIndex++, LATIN1);</span><br><span class="line">    writerIndex += buffer.unsafePutPositiveVarInt(writerIndex, strLen);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] tmpArray = getByteArray(strLen);</span><br><span class="line">    <span class="comment">// Write to heap memory then copy is 60% faster than unsafe write to direct memory.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      tmpArray[i] = (<span class="keyword">byte</span>) chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.put(writerIndex, tmpArray, <span class="number">0</span>, strLen);</span><br><span class="line">    writerIndex += strLen;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCharsUTF16</span><span class="params">(MemoryBuffer buffer, <span class="keyword">char</span>[] chars, <span class="keyword">int</span> strLen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numBytes = MathUtils.doubleExact(strLen);</span><br><span class="line">  <span class="keyword">if</span> (Platform.IS_LITTLE_ENDIAN) &#123;</span><br><span class="line">    buffer.writeByte(UTF16);</span><br><span class="line">    <span class="comment">// FIXME JDK11 utf16 string uses little-endian order.</span></span><br><span class="line">    buffer.writePrimitiveArrayWithSizeEmbedded(chars, Platform.CHAR_ARRAY_OFFSET, numBytes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The `ensure` ensure next operations are safe without bound checks,</span></span><br><span class="line">    <span class="comment">// and inner heap buffer doesn't change.</span></span><br><span class="line">    <span class="keyword">int</span> writerIndex = buffer.writerIndex();</span><br><span class="line">    buffer.ensure(writerIndex + <span class="number">9</span> + numBytes);</span><br><span class="line">    <span class="keyword">byte</span>[] targetArray = buffer.getHeapMemory();</span><br><span class="line">    <span class="keyword">if</span> (targetArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> targetIndex = buffer.unsafeHeapWriterIndex();</span><br><span class="line">      <span class="keyword">int</span> arrIndex = targetIndex;</span><br><span class="line">      targetArray[arrIndex++] = UTF16;</span><br><span class="line">      arrIndex += MemoryUtils.writePositiveVarInt(targetArray, arrIndex, strLen);</span><br><span class="line">      <span class="comment">// Write to heap memory then copy is 250% faster than unsafe write to direct memory.</span></span><br><span class="line">      <span class="keyword">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = arrIndex, end = i + numBytes; i &lt; end; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[charIndex++];</span><br><span class="line">        targetArray[i] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.HI_BYTE_SHIFT);</span><br><span class="line">        targetArray[i + <span class="number">1</span>] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.LO_BYTE_SHIFT);</span><br><span class="line">      &#125;</span><br><span class="line">      writerIndex += arrIndex - targetIndex + numBytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer.unsafePut(writerIndex++, UTF16);</span><br><span class="line">      writerIndex += buffer.unsafePutPositiveVarInt(writerIndex, numBytes);</span><br><span class="line">      <span class="keyword">byte</span>[] tmpArray = getByteArray(strLen);</span><br><span class="line">      <span class="keyword">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBytes; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[charIndex++];</span><br><span class="line">        tmpArray[i] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.HI_BYTE_SHIFT);</span><br><span class="line">        tmpArray[i + <span class="number">1</span>] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.LO_BYTE_SHIFT);</span><br><span class="line">      &#125;</span><br><span class="line">      buffer.put(writerIndex, tmpArray, <span class="number">0</span>, numBytes);</span><br><span class="line">      writerIndex += numBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码包含了两个函数：writeCharsLatin 和 writeCharsUTF16，用于将字符数组按照 Latin 编码或 UTF-16 编码写入到内存缓冲区 buffer 中。<br>writeCharsLatin 函数首先获取当前写入位置 writerIndex，然后通过 buffer.ensure 方法确保内存缓冲区有足够的空间来写入字符数组。接下来，函数检查 buffer 是否是基于堆内存的，如果是，则使用堆内存的方式进行写入。<br>在堆内存方式下，函数将 Latin 编码的标识符 LATIN1 写入到目标数组中，并使用 MemoryUtils.writePositiveVarInt 方法将字符数组的长度写入到目标数组中。然后，函数使用一个循环，将字符数组中的每个字符转换为字节，并写入到目标数组中。最后，函数更新写入位置 writerIndex，并将其设置为新的值。<br>如果 buffer 不是基于堆内存的，函数使用直接内存的方式进行写入。函数先将 Latin 编码的标识符 LATIN1 写入到 buffer 中，然后使用 buffer.unsafePutPositiveVarInt 方法将字符数组的长度写入到 buffer 中。接着，函数创建一个临时的字节数组 tmpArray，并使用一个循环，将字符数组中的每个字符转换为字节，并写入到 tmpArray 中。最后，函数使用 buffer.put 方法将 tmpArray 中的字节写入到 buffer 中，并更新写入位置 writerIndex。<br>writeCharsUTF16 函数首先根据字符数组的长度计算出需要的字节数 numBytes。如果当前平台是小端序（little-endian），函数先将 UTF-16 编码的标识符 UTF16 写入到 buffer 中，然后使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将字符数组按照 UTF-16 编码写入到 buffer 中。<br>如果当前平台不是小端序，函数使用与 writeCharsLatin 函数类似的逻辑进行写入。函数首先获取当前写入位置 writerIndex，然后通过 buffer.ensure 方法确保内存缓冲区有足够的空间来写入字符数组。接下来，函数检查 buffer 是否是基于堆内存的，如果是，则使用堆内存的方式进行写入。<br>在堆内存方式下，函数将 UTF-16 编码的标识符 UTF16 写入到目标数组中，并使用 MemoryUtils.writePositiveVarInt 方法将字符数组的长度写入到目标数组中。然后，函数使用一个循环，将字符数组中的每个字符转换为字节，并按照 UTF-16 编码的规则写入到目标数组中。最后，函数更新写入位置 writerIndex。<br>如果 buffer 不是基于堆内存的，函数使用直接内存的方式进行写入。函数先将 UTF-16 编码的标识符 UTF16 写入到 buffer 中，然后使用 buffer.unsafePutPositiveVarInt 方法将字符数组的长度写入到 buffer 中。接着，函数创建一个临时的字节数组 tmpArray，并使用一个循环，将字符数组中的每个字符按照 UTF-16 编码的规则转换为字节，并写入到 tmpArray 中。最后，函数使用 buffer.put 方法将 tmpArray 中的字节写入到 buffer 中，并更新写入位置 writerIndex。<br>这两个函数的目的是将字符数组按照 Latin 编码或 UTF-16 编码写入到内存缓冲区中，以便进行后续的序列化操作。具体的写入方式根据 buffer 是否基于堆内存以及当前平台的字节序来确定。</p><h3 id="获取器函数"><a href="#获取器函数" class="headerlink" title="获取器函数"></a>获取器函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">makeGetterFunction</span><span class="params">(Method method, Class&lt;?&gt; returnType)</span> </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = _JDKAccess._trustedLookup(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Why `lookup.findGetter` doesn't work?</span></span><br><span class="line">      <span class="comment">// MethodHandle handle = lookup.findGetter(field.getDeclaringClass(), field.getName(),</span></span><br><span class="line">      <span class="comment">// field.getType());</span></span><br><span class="line">      MethodHandle handle = lookup.unreflect(method);</span><br><span class="line">      <span class="keyword">return</span> _JDKAccess.makeGetterFunction(lookup, handle, returnType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个静态方法 makeGetterFunction，用于创建一个获取器函数（getter function）。该方法接受两个参数：method 和 returnType。method 是一个方法对象，表示要创建获取器函数的方法；returnType 是一个 Class 对象，表示方法的返回类型。<br>首先，方法通过 _JDKAccess._trustedLookup 方法获取一个 MethodHandles.Lookup 对象，用于执行方法句柄的查找操作。然后，使用 lookup.unreflect 方法将 method 转换为一个方法句柄（MethodHandle）对象，以便后续的操作。<br>接下来，方法调用 _JDKAccess.makeGetterFunction 方法，传递 lookup、handle 和 returnType 作为参数，以创建获取器函数。具体的实现细节在该方法内部。如果在获取方法句柄或创建获取器函数的过程中发生了 IllegalAccessException 异常，方法将捕获该异常并抛出一个 RuntimeException，将原始异常作为其原因。<br>总体而言，该方法的目的是通过反射和方法句柄机制，创建一个获取器函数，用于获取指定方法的返回值。</p><ol><li>writeCharsLatin 函数用于将字符数组按照 Latin 编码写入到内存缓冲区中。</li><li>writeCharsUTF16 函数用于将字符数组按照 UTF-16 编码写入到内存缓冲区中。</li><li>这两个函数根据内存缓冲区是否基于堆内存以及当前平台的字节序来确定写入方式。</li><li>makeGetterFunction 方法用于创建获取器函数，通过反射和方法句柄机制获取指定方法的返回值。</li><li>makeGetterFunction 方法使用 _JDKAccess._trustedLookup 方法获取方法句柄的查找对象。</li><li>方法句柄通过 lookup.unreflect 方法将方法对象转换为方法句柄。</li><li>_JDKAccess.makeGetterFunction 方法使用方法句柄和返回类型创建获取器函数。</li><li>如果在获取方法句柄或创建获取器函数的过程中发生 IllegalAccessException 异常，将抛出 RuntimeException。</li><li>这些代码涉及了字节转换、内存缓冲区操作、反射和方法句柄等底层操作。</li><li>目的是实现字符编码的写入和获取器函数的创建，用于后续的序列化和数据访问操作。</li></ol><h3 id="热加载能力"><a href="#热加载能力" class="headerlink" title="热加载能力"></a>热加载能力</h3><p>其实这个能力并非是本人设计的，是根据原理去利用的：</p><p>在Java中，类加载器（ClassLoader）用于加载类和资源。每个类加载器都有其特定的加载范围和优先级。线程的上下文类加载器（Context ClassLoader）是一个特殊的类加载器，它与当前线程相关联，并且可以在加载类和资源时被使用。</p><p>上下文类加载器的设置可以由应用程序自行决定，通常用于解决类加载器层次结构中的资源查找问题。在某些情况下，应用程序可能需要使用第三方库或框架，而这些库或框架使用了自定义的类加载器。在这种情况下，上下文类加载器可以被设置为第三方类加载器，以确保正确加载所需的类和资源。</p><p>因此，Thread.currentThread().getContextClassLoader() 方法返回的类加载器可以是第三方类加载器，它可能是应用程序中使用的自定义类加载器或其他第三方库中的类加载器。</p><p>于是可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="comment">//获取第三方加载器</span></span><br></pre></td></tr></table></figure><p>ref: <a href="https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/" target="_blank" rel="noopener">https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开源经历更多的是提升了自己的创造力和动手能力，更多的时候是去编写一些从未有过的代码逻辑，没有多少参考代码是可以直接复用的。从一方面说，需要根据这个项目的需求，去从零到一的去实现这个逻辑，有时候会感觉每一行代码都写的很生涩很不好，但是写的代码多了，再回过去去思考，又可以发现自己不足的地方，然后继续去优化原有的代码块，提高代码质量，我想很多项目都是通过反复思考，推导，才会让自己的项目更加的完善。另一方面，这其实也是挺有乐趣的一件事，这其实也让我找到了当初学习数据结构的时候的那种乐趣，老师给你一个二叉树或者是图的逻辑，然后一点一点的去完成它，中途可能会碰到各种问题，但是将这个逻辑彻底实现为你的代码中，也会感到一些成就感，这给你的反馈也是一种特殊的礼物。虽然，开源看起来也是一件比较困难的事情，但是每一点的努力都会让你有所提升，这也是很值得去投入的事情，相信，道阻且长，行则将至。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RPC&quot;&gt;&lt;a href=&quot;#RPC&quot; class=&quot;headerlink&quot; title=&quot;RPC&quot;&gt;&lt;/a&gt;RPC&lt;/h2&gt;&lt;p&gt;这里会去介绍一下关于我的小小的开源经历 SOFASTACK/SOFA-RPC和Apache/fury&lt;br&gt;看起来是两个，但是其实是</summary>
      
    
    
    
    
    <category term="open source" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/open-source/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝技术说明书</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/05/zero-copy/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/05/zero-copy/</id>
    <published>2024-01-05T12:33:44.000Z</published>
    <updated>2024-02-18T13:13:32.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>零拷贝技术（Zero-copy）是一种优化数据传输和处理的技术，旨在减少数据在内存之间的复制次数，提高系统性能和效率。</p><p>在传统的数据传输过程中，当数据从一个缓冲区（如磁盘或网络）复制到另一个缓冲区（如应用程序的内存），通常需要经过多次数据复制操作。这些复制操作会占用CPU时间和内存带宽，降低系统的性能。</p><p>而零拷贝技术通过避免数据的中间复制，直接在数据源和目标之间传输数据，从而减少了数据复制的次数。它可以通过以下几种方式实现：</p><ol><li>零拷贝文件传输：在传输文件时，使用操作系统提供的零拷贝API，如sendfile()或splice()，将文件数据直接从磁盘传输到网络，避免了数据在用户空间和内核空间之间的复制。</li><li>零拷贝网络传输：在网络传输中，使用操作系统提供的零拷贝API，如sendfile()或scatter-gather I/O，将数据直接从应用程序的内存传输到网络设备，避免了数据在内核空间和用户空间之间的复制。</li><li>零拷贝内存操作：在内存操作中，使用内存映射（mmap）或共享内存（shared memory）等技术，将数据直接映射到应用程序的地址空间，避免了数据在不同缓冲区之间的复制。</li></ol><p>通过使用零拷贝技术，可以减少数据复制的次数，降低CPU和内存的负载，提高数据传输和处理的效率。这对于高性能计算、大规模数据处理和网络通信等场景非常有益。</p><p><strong>下面开始举例子</strong></p><p>当使用零拷贝技术时，数据在传输过程中避免了额外的数据复制，从而提高了性能和效率。为了展示使用零拷贝和不使用零拷贝的区别，提供两个示例代码。</p><p>首先，我们来看一下不使用零拷贝的传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputFile = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">            FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputFile.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputFile.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inputFile.close();</span><br><span class="line">            outputFile.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"文件传输完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用传统的方式进行文件复制。我们创建了一个缓冲区（byte数组），然后从输入文件中读取数据到缓冲区，再将缓冲区中的数据写入输出文件。这个过程中，数据在内存中进行了多次复制，从输入缓冲区到输出缓冲区，然后再写入输出文件。这些复制操作会占用CPU时间和内存带宽，降低系统的性能。</p><p>接下来，我们来看一下使用零拷贝技术的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputFile = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">            FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>);</span><br><span class="line"></span><br><span class="line">            FileChannel inputChannel = inputFile.getChannel();</span><br><span class="line">            FileChannel outputChannel = outputFile.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> fileSize = inputChannel.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接将输入通道的数据传输到输出通道，避免了数据复制</span></span><br><span class="line">            inputChannel.transferTo(<span class="number">0</span>, fileSize, outputChannel);</span><br><span class="line"></span><br><span class="line">            inputChannel.close();</span><br><span class="line">            outputChannel.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"文件传输完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用了FileChannel的transferTo()方法，直接将输入通道的数据传输到输出通道。这样，数据在传输过程中避免了额外的复制，提高了性能和效率。</p><p>通过对比这两个示例代码，你可以清楚地看到使用零拷贝技术相对于传统方式的优势，它避免了数据在内存中的多次复制，提高了系统的性能和效率。</p><p><strong>当然，也可以使用一个很简单的例子去说明</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"Hello, "</span>);</span><br><span class="line">        sb.append(<span class="string">"world!"</span>);</span><br><span class="line"></span><br><span class="line">        String result = sb.toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个StringBuilder对象，并使用append()方法将两个字符串进行拼接。最后，我们使用toString()方法将StringBuilder对象转换为一个不可变的字符串对象。</p><p>尽管这个例子中没有直接涉及到零拷贝的概念，但是通过使用StringBuilder，我们可以避免创建多个中间字符串对象，从而提高了字符串拼接的效率。这种技术在处理大量字符串拼接的场景下特别有用，因为它避免了频繁创建和销毁字符串对象的开销。</p><h2 id="为什么不一开始就用零拷贝？"><a href="#为什么不一开始就用零拷贝？" class="headerlink" title="为什么不一开始就用零拷贝？"></a>为什么不一开始就用零拷贝？</h2><p>那么零拷贝似乎是一开始就可以这么做的吧。那么，为什么设计者在一开始就不通过传递变量的方式来实现他的编程逻辑，而是要采用多次复制呢？</p><p>零拷贝的概念并不是一开始就存在的，而是随着计算机系统和网络技术的发展逐渐被提出和应用的。在早期的计算机系统中，内存和网络传输的速度相对较慢，因此多次复制数据是为了提高数据访问和传输的效率。</p><p>设计者在一开始采用多次复制的方式，主要是出于以下几个原因：</p><ol><li>简化编程逻辑：通过多次复制数据，可以将数据从一个地方复制到另一个地方，使得编程逻辑更加简单和直观。这种方式在早期的计算机系统中更容易实现和理解。</li><li>数据安全性：通过多次复制数据，可以确保数据在不同的内存区域或网络传输中的安全性。每次复制都可以创建数据的副本，以防止原始数据被修改或损坏。</li><li>兼容性和可移植性：在早期的计算机系统中，硬件和操作系统的支持可能有限，无法直接实现零拷贝技术。因此，通过多次复制数据可以在不同的系统和平台上实现数据的传输和处理。</li></ol><p>随着计算机系统和网络技术的进步，零拷贝的概念逐渐被提出和应用。通过使用零拷贝技术，可以避免数据在内存和网络传输中的多次复制，提高数据访问和传输的效率。现代的操作系统和网络协议栈已经提供了对零拷贝技术的支持，使得开发者可以更方便地应用零拷贝技术来优化系统性能。</p><h2 id="那原来为什么还要涉及缓冲区？"><a href="#那原来为什么还要涉及缓冲区？" class="headerlink" title="那原来为什么还要涉及缓冲区？"></a>那原来为什么还要涉及缓冲区？</h2><p>在之前的代码示例中，使用了一个缓冲区（buffer）来读取文件数据并写入到输出文件中。这是因为在实际的文件读写操作中，使用缓冲区可以提高读写的效率。</p><p>缓冲区是一块内存区域，用于临时存储数据。它可以减少对底层存储设备的频繁访问，从而提高读写操作的效率。当我们从输入流中读取数据时，可以将数据先存储到缓冲区中，然后再一次性地将缓冲区中的数据写入到输出流中，而不是每次读取一个字节或一个字符就立即写入。</p><p>在示例代码中，buffer是一个字节数组，用于存储从输入流中读取的数据。bytesRead是实际读取的字节数。通过使用缓冲区，我们可以一次性读取多个字节，并将它们存储在缓冲区中。然后，我们使用outputFile.write(buffer, 0, bytesRead)将缓冲区中的数据写入到输出文件中。</p><p>使用缓冲区的好处是可以减少对磁盘或网络的频繁访问，从而提高读写操作的效率。通过一次性读取和写入多个字节，可以减少系统调用的次数，减少了读写操作的开销。此外，缓冲区还可以提供一些额外的功能，如数据的预读取和预写入，以进一步优化读写操作的性能</p><h2 id="缓冲区能减少磁盘I-O，是不是更好呢？"><a href="#缓冲区能减少磁盘I-O，是不是更好呢？" class="headerlink" title="缓冲区能减少磁盘I/O，是不是更好呢？"></a>缓冲区能减少磁盘I/O，是不是更好呢？</h2><p>虽然使用缓冲区可以提高读写操作的效率，但它仍然需要将数据从内核空间复制到用户空间，然后再从用户空间复制到输出通道（如磁盘或网络）。这些复制操作会增加额外的CPU和内存开销，并且可能成为性能瓶颈。</p><p>相比之下，零拷贝技术可以避免数据在内核空间和用户空间之间的多次复制，从而减少了CPU和内存的开销，提高了读写操作的效率。零拷贝技术通过直接在内核空间中操作数据，将数据从输入通道传输到输出通道，而无需在用户空间和内核空间之间复制数据。</p><p>使用零拷贝技术的好处包括：</p><ol><li>减少数据复制：零拷贝技术避免了数据在内核空间和用户空间之间的多次复制，减少了CPU和内存的开销。</li><li>提高系统吞吐量：通过减少数据复制和降低CPU和内存开销，零拷贝技术可以提高系统的吞吐量，使得系统能够更高效地处理大量的数据。</li><li>减少磁盘IO：零拷贝技术可以直接将数据从输入通道传输到输出通道，减少了对磁盘IO的需求，从而提高了读写操作的效率。</li></ol><p>需要注意的是，零拷贝并不是在所有情况下都比缓冲区更好。它的应用场景通常是在需要高性能和大数据处理的场景下，例如高速网络传输、大规模数据处理等。在一些简单的场景中，使用缓冲区已经足够满足需求，并且更易于实现和理解。因此，在选择使用零拷贝还是缓冲区时，需要根据具体的应用场景和需求进行权衡和选择。</p><p>没错，最后得出了最关键的要素，<strong>内核空间和用户空间</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;零拷贝技术（Zero-copy）是一种优化数据传输和处理的技术，旨在减少数据在内存之间的复制次数，提高系统性能和效率。&lt;/p&gt;
&lt;p&gt;在传统</summary>
      
    
    
    
    
    <category term="zero-copy" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/zero-copy/"/>
    
  </entry>
  
  <entry>
    <title>大卡 WXG实践</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/01/card1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/01/card1/</id>
    <published>2024-01-01T15:10:08.000Z</published>
    <updated>2024-07-09T15:37:12.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大卡"><a href="#大卡" class="headerlink" title="大卡"></a>大卡</h1><p>这个是实习中碰到的主要业务，混合C++，Python多种语言，比较复杂的后端项目。</p><p>大卡这部分分为管理系统和大卡模块，可以分开来说。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大卡&quot;&gt;&lt;a href=&quot;#大卡&quot; class=&quot;headerlink&quot; title=&quot;大卡&quot;&gt;&lt;/a&gt;大卡&lt;/h1&gt;&lt;p&gt;这个是实习中碰到的主要业务，混合C++，Python多种语言，比较复杂的后端项目。&lt;/p&gt;
&lt;p&gt;大卡这部分分为管理系统和大卡模块，可以分开</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++函数记录</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/12/29/cpp-record/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/12/29/cpp-record/</id>
    <published>2023-12-29T15:44:59.000Z</published>
    <updated>2024-04-19T15:49:22.942Z</updated>
    
    <content type="html"><![CDATA[<p>不常见的内存调用函数等</p><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><p>munmap 是 C/C++ 标准库中的一个函数，用于解除内存映射。它通常用于释放通过 mmap 函数创建的内存映射区域。munmap 函数的作用是将指定的内存区域从进程的虚拟地址空间中解除映射，并释放相关的资源。</p><p>在 C/C++ 中，munmap 函数的原型通常在 &lt;sys/mman.h&gt; 头文件中声明。它接受两个参数：映射区域的起始地址和映射区域的大小。调用 munmap 函数后，操作系统会将指定的内存区域从进程的虚拟地址空间中移除，并释放相关的资源。</p><p>需要注意的是，munmap 函数是与操作系统紧密相关的函数，因此在使用时需要谨慎，并遵循操作系统的相关规则和限制。</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>open 是 C/C++ 标准库中的一个函数，用于打开文件。它通常用于在程序中访问和操作文件。</p><p>在 C/C++ 中，open 函数的原型通常在 &lt;fcntl.h&gt; 或 &lt;sys/stat.h&gt; 头文件中声明。它接受两个参数：文件路径和打开模式。调用 open 函数后，它会尝试打开指定路径的文件，并返回一个文件描述符，用于后续对文件的读写操作。</p><p>open 函数的打开模式参数可以指定文件的访问权限、打开方式、创建方式等。常见的打开模式包括 O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写）、O_CREAT（如果文件不存在则创建）、O_TRUNC（清空文件内容）等。</p><p>需要注意的是，open 函数是与操作系统紧密相关的函数，因此在使用时需要谨慎，并遵循操作系统的相关规则和限制。此外，C++ 标准库也提供了更高级的文件操作接口，如 fstream 类，可以更方便地进行文件的读写操作。</p><h2 id="ftruncate64"><a href="#ftruncate64" class="headerlink" title="ftruncate64"></a>ftruncate64</h2><p>ftruncate64 不是 C++ 标准库函数，而是一个特定于 Linux/Unix 系统的函数。它用于调整已打开文件的大小。</p><p>在 Linux/Unix 系统中，ftruncate64 函数用于将已打开文件的大小截断为指定的长度。它接受两个参数：文件描述符和目标文件大小。通过调用 ftruncate64 函数，可以将文件截断为指定的大小，可能会删除文件末尾的内容或在文件末尾添加空字节。</p><p>需要注意的是，ftruncate64 函数是特定于 64 位文件大小的版本，用于处理大于 2GB 的文件。对于小于 2GB 的文件，可以使用 ftruncate 函数。</p><p>要使用 ftruncate64 函数，通常需要包含 &lt;unistd.h&gt; 头文件，并在链接时链接对应的库（如 -lrt）。请注意，ftruncate64 函数在不同的操作系统和编译环境中可能会有所不同，因此在使用时请参考相关的系统文档和编译器文档。</p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap 不是 C++ 标准库函数，而是一个系统调用函数，用于在内存中创建映射区域。</p><p>mmap 函数在 Linux/Unix 系统中使用，用于将一个文件或设备映射到进程的地址空间，从而可以通过内存访问来读取或写入文件内容。它可以用于实现高效的文件 I/O 操作，以及共享内存的通信。</p><p>在 C++ 中，可以使用 mmap 函数通过调用操作系统提供的接口来创建映射区域。通常需要包含 &lt;sys/mman.h&gt; 头文件，并在链接时链接对应的库（如 -lrt）。</p><p>需要注意的是，mmap 函数是特定于操作系统的，因此在不同的操作系统和编译环境中可能会有所不同。在使用 mmap 函数时，请参考相关的系统文档和编译器文档，以了解其使用方法和注意事项。</p><h2 id="msync"><a href="#msync" class="headerlink" title="msync"></a>msync</h2><p>msync 是一个系统调用函数，而不是一个 C++ 库函数。它用于将指定的内存区域同步到对应的文件中。</p><p>在 C++ 中，可以使用 &lt;unistd.h&gt; 头文件来包含 msync 函数的声明。这个函数通常用于与 mmap 函数一起使用，以确保对内存映射区域所做的修改能够及时地写入到文件中。</p><p>msync 函数被用于同步 ShmLogReadStruct 结构体中 status 字段的修改。msync 函数的第一个参数是要同步的内存区域的起始地址，第二个参数是要同步的内存区域的大小，第三个参数是同步的选项。</p><p>通过调用 msync(&amp;read_struct-&gt;status, sizeof(read_struct-&gt;status), MS_SYNC)，代码将 ShmLogReadStruct 结构体中 status 字段的修改同步到磁盘上的文件系统。这样做可以确保在修改 status 字段后，对应的数据被持久化，以便在系统重启或其他情况下仍然可用。</p><p>需要注意的是，msync 是一个 POSIX 标准的函数，因此它在不同的操作系统上可能会有一些细微的差异。在 Windows 系统上，可能需要使用相应的系统调用函数来实现类似的功能。</p><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>memcpy 是一个 C++ 标准库函数，用于在内存之间进行数据的拷贝。</p><p>它的函数原型通常在 <cstring> 或 &lt;string.h&gt; 头文件中声明，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* destination, <span class="keyword">const</span> <span class="keyword">void</span>* source, <span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>memcpy 函数接受三个参数：</p><ul><li>destination：目标内存的指针，表示拷贝后数据的存放位置。</li><li>source：源内存的指针，表示要拷贝的数据的起始位置。</li><li>num：要拷贝的字节数。</li></ul><p>memcpy 函数将从源内存中拷贝 num 个字节的数据到目标内存中。它是一种高效的内存拷贝方法，可以用于拷贝任意类型的数据，包括基本类型、结构体、数组等。</p><p>需要注意的是，memcpy 函数不会检查目标内存和源内存的边界，因此在使用时需要确保目标内存有足够的空间来存放拷贝的数据，以避免发生内存越界错误。</p><h2 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h2><p>shmctl 是一个用于控制共享内存段的系统调用函数。它可以用于执行各种操作，如获取、修改或删除共享内存段。</p><p>函数原型如下：</p><p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</p><p>参数说明：</p><ul><li>shmid：共享内存段的标识符，由 shmget 函数返回。</li><li>cmd：要执行的操作命令，可以是以下值之一：</li></ul><ol><li>IPC_STAT：获取共享内存段的状态信息，并将其存储在 buf 参数指向的 shmid_ds 结构体中。</li><li>IPC_SET：设置共享内存段的状态信息，buf 参数指向的 shmid_ds 结构体中包含要设置的新值。</li><li>IPC_RMID：删除共享内存段。</li></ol><ul><li>buf：指向 shmid_ds 结构体的指针，用于存储共享内存段的状态信息。</li></ul><p>返回值：</p><ul><li>成功时，返回 0 或执行的操作相关的值。</li><li>失败时，返回 -1，并设置 errno 来指示错误的原因。</li></ul><p>通过调用 shmctl 函数，可以获取共享内存段的状态信息、修改共享内存段的状态或删除共享内存段。这个函数在对共享内存进行管理和控制时非常有用。</p><h2 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h2><p>shmat 是一个系统调用函数，用于将共享内存段附加到调用进程的地址空间中。</p><p>函数原型如下：</p><p>void *shmat(int shmid, const void *shmaddr, int shmflg);</p><p>参数说明：</p><ul><li>shmid：共享内存段的标识符，由 shmget 函数返回。</li><li>shmaddr：指定共享内存段附加到进程地址空间的地址。通常设置为 NULL，表示由系统自动选择一个合适的地址。</li><li>shmflg：附加标志，可以使用 SHM_RDONLY 表示只读模式，其他情况下可以设置为 0。</li></ul><p>返回值：</p><ul><li>成功时，返回共享内存段附加的地址。</li><li>失败时，返回 (void *) -1，并设置 errno 来指示错误的原因。</li></ul><p>通过调用 shmat 函数，可以将共享内存段连接到调用进程的地址空间中，使得进程可以访问共享内存中的数据。返回的地址可以用于访问共享内存中的数据。需要注意的是，使用完共享内存后，应该使用 shmdt 函数将其从进程地址空间中分离。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不常见的内存调用函数等&lt;/p&gt;
&lt;h2 id=&quot;munmap&quot;&gt;&lt;a href=&quot;#munmap&quot; class=&quot;headerlink&quot; title=&quot;munmap&quot;&gt;&lt;/a&gt;munmap&lt;/h2&gt;&lt;p&gt;munmap 是 C/C++ 标准库中的一个函数，用于解除内存映射。它</summary>
      
    
    
    
    
    <category term="C++" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>py后端是怎么样的</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/12/20/Python-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/12/20/Python-1/</id>
    <published>2023-12-20T14:49:10.000Z</published>
    <updated>2024-03-14T15:08:14.282Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始对实习过程中的工程进行简单的总结，不涉及业务。</p><p>这里使用的py去实现一个后端架构，但是这里使用的后台框架并非是类似于Django或者是flask等框架。而是单纯使用原生的方式去实现，用法其实和C++写后台没有本质的区别，仅仅是因为编程语言不同。</p><p>这里的后端，其实也大绝大多数的后端架构类似，都是采用B/S三层架构，有专门的Controller层去接受请求，也有专门的ORM层去DB访问数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1703151599325-7ee23777-53cb-4f72-9931-2417cdabd6ab.png" alt="img"></p><p>这样的系统还是比较类似的，但是也有着很大的不同。</p><h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>比如说，这里的Controller层接受的不在是http请求，而是rpc请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service.reg(name='ExactReCall')</span></span><br><span class="line"><span class="meta">@rpc_log</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">ExactReCallUpdateEvaluateTask</span><span class="params">(ctx, req: mm_pb2.ExactReCallReq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        resp: mm_pb2.ExactReCallResp)</span>:</span></span><br></pre></td></tr></table></figure><p>这里的rpc协议请求使用的都是proto文件去定义的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.py -s=combo -f=ModifyBizTemplateSave --build</span><br></pre></td></tr></table></figure><p>通过命令去rebuild proto，s是模块，f是方法，这样会生成相应的proto映射文件</p><p>看到这里大家可能会感到疑惑，这个接口全都是rpc调用，难道前端会发起rpc请求吗？那当然不会，前端发起的显然都是http请求，不过中间有一层网关，会将所有的http请求都转为rpc请求，这一层的主要目的与单体服务无关，之所以要这么做最大的目的是为<strong>让所有的服务都能够互通</strong>。</p><p>这里可能和传统的Spring全家桶的微服务不一样，在以往的微服务架构之间，所有的前端发起，后端接收的请求都是http，而服务与服务之间发送的请求基本都是RPC，这可能是一种规范，为了提升效率的规范。但是我目前工作中使用的架构全都是基于Service Mesh的，也就是说，在所有的服务下面都有一层Mesh层，服务与服务之间不能够直接通信，就算是显示的发送RPC请求，服务的链路都是先传入底下的mesh层，再由mesh层传到目标服务的。</p><p>这种解决方案目的其实也是为了解开耦合，从而提供<strong>高内聚</strong>的能力，基本每个服务根本不用去在意自己的rpc，自己的基础设施，应该是什么样的版本，什么样的协议与组件。可以说，因为有了mesh层，可以极大的杜绝了重复造轮子导致的资源浪费。</p><h2 id="orm"><a href="#orm" class="headerlink" title="orm"></a>orm</h2><p>使用session = get_session()，可以根据需要去获取当前的session。目的是为了获取一个数据库会话对象。这里做了层层的封装，比如说当前的orm是否需要事务等等，都会进行一定程度的判定，最后才会返回一个最终的实例，我们就是通过操作这个实例，去进行保存和更新的。</p><p><strong>这里的做法不像是Spring全家桶的风格，不过倒是和Go后端非常相似</strong></p><p>可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017803857459008" target="_blank" rel="noopener">使用SQLAlchemy - 廖雪峰的官方网站</a></p><p>通过session.query去获取表后，根据使用需求进行操作，比如</p><p>session.query(表名).filter(</p><p>​    表名.属性 == aaa.bbb, 表名.属性 == aaa.bbb</p><p>).first()</p><p>这样就可以获取到相应的数据了，这种写法非常简单，基本没有什么特别难的点</p><p>我们还可以进入MySQL，show create table，  SHOW INDEX FROM 数据表；查看表信息，这些都是基本的操作了</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>梳理一下逻辑，现在主要学习如何去排查问题，这里使用原生的调试器，去排查问题。</p><p>Pdb是Python自带的调试器，它可以帮助你在程序运行时暂停程序的执行，查看变量的值，执行代码行，以及跟踪程序的执行流程。使用Pdb可以帮助你快速定位代码中的错误，并且可以提高代码的可读性和可维护性。</p><p>使用Pdb非常简单，只需要在代码中插入一行 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb; </span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(proto_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> proto_path:</span><br><span class="line">        pdb.set_trace()</span><br></pre></td></tr></table></figure><p>当程序执行到这一行时，程序会暂停执行并进入Pdb调试模式。在Pdb模式下，你可以使用一系列命令来查看变量的值，执行代码行，以及跟踪程序的执行流程。</p><p>例如：</p><p>可以使用p命令来查看变量的值</p><p>使用n命令来执行下一行代码</p><p>使用c命令来继续执行程序。</p><p>使用h命令是查看有哪些命令</p><p>可以使用args查看具体是什么问题</p><p>使用u和d分别对应上游和下游</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始对实习过程中的工程进行简单的总结，不涉及业务。&lt;/p&gt;
&lt;p&gt;这里使用的py去实现一个后端架构，但是这里使用的后台框架并非是类似于Django或者是flask等框架。而是单纯使用原生的方式去实现，用法其实和C++写后台没有本质的区别，仅仅是因为编程语言不同。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>补偿框架</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/11/02/compensate/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/11/02/compensate/</id>
    <published>2023-11-02T15:29:00.000Z</published>
    <updated>2024-02-18T13:13:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>这个框架主要的目的是为了当我们的服务涉及到与外部系统交互的时候，我们服务的事务和外部接口可能由于各种问题不能保证一致，出现两个系统数据不一致的情况，往往需要去手动处理数据。</p><h2 id="理论解决方案"><a href="#理论解决方案" class="headerlink" title="理论解决方案"></a>理论解决方案</h2><p>当服务涉及与外部系统交互时，确保数据一致性是一个重要的问题。以下是一些解决方案：</p><ol><li>使用分布式事务：如果外部系统支持分布式事务，可以使用分布式事务管理器（如Atomikos、Bitronix、Narayana等）来确保服务和外部接口的事务一致性。通过将服务和外部接口的操作纳入同一个分布式事务中，可以在两者之间实现原子性和一致性。</li><li>异步消息队列：将服务与外部接口的交互改为异步方式，使用消息队列作为中间件。服务将需要与外部接口交互的数据发送到消息队列中，然后由消费者异步处理。这样可以将服务和外部接口的事务解耦，即使其中一个失败，也不会影响另一个。如果发生故障，可以通过重试机制来保证数据最终一致性。</li><li>补偿机制：在服务与外部接口交互时，记录交互的操作和状态信息，以便在发生故障或数据不一致时进行补偿。可以使用补偿模式来处理这种情况，例如在服务中实现一个补偿机制，当发生故障时，自动触发补偿操作来修复数据不一致性。</li><li>重试和回滚：在与外部接口交互时，可以使用重试机制来处理临时的通信故障。如果发生故障，可以尝试重新发送请求，直到成功为止。另外，如果服务的事务失败，可以回滚事务并进行相应的错误处理。</li><li>监控和报警：建立监控系统来实时监测服务与外部接口的交互情况。通过监控指标和日志，可以及时发现潜在的数据不一致问题，并触发相应的报警机制，以便及时采取措施解决问题。</li></ol><p>这里其实最常见的是使用分布式事务去解决，但是其实这种解决方式其实不一定能适用于所有情况，比如说</p><ul><li>复杂性：分布式事务的实现相对复杂，需要引入额外的组件和技术栈，如分布式事务管理器、消息队列等。这增加了系统的复杂性和维护成本。</li><li>性能影响：分布式事务通常需要进行多次网络通信和资源协调，这可能导致性能开销增加。特别是在高并发和大规模系统中，分布式事务的性能问题可能会成为瓶颈。</li><li>扩展性限制：分布式事务在跨多个服务和数据库进行协调时，可能会受到扩展性的限制。当系统需要水平扩展时，分布式事务可能会成为限制因素，因为它需要全局锁和协调。</li><li>依赖外部系统：使用分布式事务时，需要确保外部系统也支持分布式事务。如果外部系统不支持或与服务的事务管理器不兼容，可能需要进行额外的工作来解决这个问题。</li><li>高可用性和故障恢复：分布式事务的高可用性和故障恢复是一个挑战。当分布式事务管理器或其他组件发生故障时，需要有相应的机制来处理故障并保证数据的一致性。</li><li>学习和开发成本：使用分布式事务需要对相关技术和概念有一定的了解，并且需要在开发过程中遵循一些规范和最佳实践。这可能需要额外的学习和培训成本。</li></ul><p>综上所述，尽管分布式事务可以解决数据一致性的问题，但也需要权衡其复杂性、性能开销和扩展性限制等因素。在设计和选择系统架构时，需要综合考虑业务需求、系统规模和可用性要求，选择适合的事务处理方式。</p><p>所以为了避免将整个系统变得更加复杂，这里其实并不建议使用分布式事务，其次，这里还涉及到需要去增加维护，增加耦合，其实是非常不推荐的做法，也比如说使用MQ，其实也是一样的，需要多一个维护。</p><p>再细说一下MQ的解决方案</p><p>补偿机制和消息队列（MQ）是两种不同的处理方式，适用于不同的场景。以下是一些情况下可以考虑使用补偿机制而不使用消息队列：</p><ol><li>低延迟要求：如果系统对低延迟有较高要求，即需要实时或近实时的处理能力，使用补偿机制可能更为合适。补偿机制通常是同步或异步的方式，可以直接在服务内部进行处理，而不需要依赖消息队列的异步处理和传递。</li><li>简化架构：使用消息队列需要引入额外的组件和技术栈，如消息中间件、消息生产者和消费者等。如果系统的架构相对简单，没有复杂的异步消息传递需求，使用补偿机制可以简化系统架构，减少复杂性和维护成本。</li><li>有限的系统规模：如果系统规模相对较小，没有大规模的并发和高吞吐量的需求，使用补偿机制可以更轻量级地处理事务和数据一致性，而不需要引入消息队列的复杂性。</li><li>事务性操作：如果需要进行事务性的操作，即需要保证一组操作的原子性和一致性，使用补偿机制可能更为合适。补偿机制可以在事务内部进行操作和补偿，而不需要依赖消息队列的事务性支持。</li></ol><p>但是结合我们的场景，其实并不需要低延迟，而更多的是需要调通不同渠道的接口，所以，这里需要去实现简单，无侵入式，高可用，低耦合的框架，所以，再三选择之下，还是补偿机制更合适。</p><p>这里推荐使用自己去实现一个补偿机制</p><h3 id="补偿机制"><a href="#补偿机制" class="headerlink" title="补偿机制"></a>补偿机制</h3><p>补偿机制和分布式事务是两种不同的处理方式，适用于不同的场景。以下是一些情况下可以考虑使用补偿机制而不是分布式事务：</p><ol><li>高可扩展性要求：如果系统需要高度可扩展性，即需要支持大规模的并发和水平扩展，使用分布式事务可能会成为限制因素。在这种情况下，可以考虑使用补偿机制，将服务的事务解耦，通过异步处理和补偿操作来保证数据的一致性。</li><li>异构系统集成：当系统需要与多个异构的外部系统进行集成时，这些外部系统可能不支持分布式事务或与服务的事务管理器不兼容。在这种情况下，使用补偿机制可以更灵活地处理与外部系统的交互，通过记录操作和状态信息，进行补偿操作来保证数据的一致性。</li><li>高可用性和故障恢复：补偿机制可以更好地应对系统的高可用性和故障恢复需求。当发生故障或数据不一致时，补偿机制可以自动触发补偿操作来修复数据，而无需依赖全局的分布式事务协调。</li><li>非关键业务操作：对于一些非关键的业务操作，数据一致性要求可能相对较低。在这种情况下，使用补偿机制可以提供更好的性能和可扩展性，而不需要引入复杂的分布式事务。</li></ol><h2 id="生产环境遇到的问题"><a href="#生产环境遇到的问题" class="headerlink" title="生产环境遇到的问题"></a>生产环境遇到的问题</h2><p>目前常见的处理手段及存在的问题</p><p>手段1: 本地数据库操作和外部接口调用放在同一个事务中</p><p>问题：外部接口成功，本地事务由于异常原因回滚，数据不一致</p><p>手段2:本地数据库事务提交后，再调用外部接口</p><p>问题：本地事务成功后，外部接口失败或者机器挂掉，数据不一致</p><p>手段3:使用mq、redis临时存储消息，后续消费</p><p>问题：mq、redis本身就是一个外部系统，一样存在问题</p><p>rocketmq提供了和本地事务一致的机制，但是需要申请维护mq且实现一套消费逻辑</p><h3 id="设计一个补偿框架"><a href="#设计一个补偿框架" class="headerlink" title="设计一个补偿框架"></a>设计一个补偿框架</h3><p>这里考虑到无侵入式，和开箱即用，所以考虑将整个流程，融入到Spring的生命周期。并且，使用注解的方式去标注需要调用外部接口的方法，然后当接口调用失败的时候，会存入数据库，然后隔一段时间再去调用，并且为了加强效率，也会使用线程池去增强实现。</p><p>现在设计的补偿框架，主要有几个功能：</p><ul><li>在启动的时候，可以扫描整个包，看看哪里用到了@Component注解，将所有用到了这个注解的，都加入到hashmap中，从而全局持有这个方法的信息。</li><li>然后，可以去使用执行链设计模式，去创建一个执行链，将需要的方法通通加入链上，分批次执行相关的方法</li><li>对于每次执行方法，必然会出现成功或者是失败的状况，如果出现执行失败的情况，可以将其写入到数据库中，等待后续再逐步从数据库中读出相应的数据，然后去尝试不断的重新执行方法。</li><li>在执行方法的时候，可以使用一个AOP切面，去根据注解信息去拦截想要执行的方法，然后先将方法持久化到数据库中，再执行相关的方法，如果执行成功，再去删除相应的ID，其次，如果执行失败，则暂时不做任何行为，因为还有定时任务去执行。</li><li>那么对于那些执行失败的任务怎么办？对于失败的任务，就会定时的去数据库中读取出来，然后去进行反复的重试，直到成功为止。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个框架主要的目的是为了当我们的服务涉及到与外部系统交互的时候，我们服务的事务和外部接口可能由于各种问题不能保证一致，出现两个系统数据不一致的情况，往往需要去手动处理数据。&lt;/p&gt;
&lt;h2 id=&quot;理论解决方案&quot;&gt;&lt;a href=&quot;#理论解决方案&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring高级注解与接口</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/08/28/ab-12yebjavab/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/08/28/ab-12yebjavab/</id>
    <published>2023-08-28T13:33:31.000Z</published>
    <updated>2024-02-18T13:11:25.856Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始记录一些学到的强力的注解和接口</p><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>CommandLineRunner是Spring Boot框架中的一个接口，用于定义在应用程序启动后执行的任务。它包含一个run方法，该方法在应用程序启动后被调用，并接收命令行参数作为参数。<br>具体来说，CommandLineRunner接口的作用是允许开发人员在应用程序启动后执行一些初始化或后续操作的逻辑。通过实现CommandLineRunner接口并重写run方法，你可以在应用程序启动后执行自定义的逻辑代码。<br>当应用程序启动时，Spring Boot会自动扫描并检测实现了CommandLineRunner接口的Bean，并在启动后调用它们的run方法。这样，你可以在应用程序启动后执行一些必要的初始化任务，例如加载数据、启动定时任务、建立连接等。<br>在CommandLineRunner接口的run方法中，你可以编写任何你希望在应用程序启动后执行的代码。该方法可以抛出Exception异常，因此你可以在其中处理任何可能发生的异常情况。<br>总结起来，CommandLineRunner接口允许你在应用程序启动后执行自定义的逻辑代码。通过实现该接口并重写run方法，你可以在应用程序启动后执行一些初始化或后续操作的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"ConfigProperties properties:&#123;&#125;"</span>, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>@PostConstruct是Java标准库中的一个注解，它用于标记一个方法，在对象创建后立即执行。在Spring框架中，@PostConstruct注解被用于定义在Bean初始化之后执行的方法。</p><p>具体来说，当一个Bean被实例化并完成依赖注入后，Spring容器会检测该Bean中是否存在被@PostConstruct注解标记的方法。如果存在，Spring容器会在Bean初始化完成后立即调用该方法。</p><p>@PostConstruct注解的作用是允许开发人员在Bean初始化之后执行一些自定义的初始化逻辑。这些逻辑可以包括数据加载、资源初始化、建立连接等操作。通过在方法上添加@PostConstruct注解，你可以确保在Bean完全初始化之后执行这些操作。</p><p>需要注意的是，@PostConstruct注解只能用于非静态方法，并且只能标记一个方法。如果在一个类中存在多个被@PostConstruct注解标记的方法，它们的执行顺序是不确定的。</p><p>总结起来，@PostConstruct注解用于标记一个方法，在Bean初始化之后立即执行。它允许开发人员在Bean初始化完成后执行一些自定义的初始化逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String targetService = properties.getTargetService();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(targetService))&#123;</span><br><span class="line">        targetService = System.getenv(<span class="string">"TService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CompensateContextHolder.setTargetService(targetService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p>@ConditionalOnProperty是Spring Boot框架中的一个条件注解，用于根据配置属性的值来决定是否启用或禁用特定的组件或配置。<br>具体来说，@ConditionalOnProperty注解用于在特定的配置属性满足条件时才加载或启用某个组件。它接收一个或多个属性参数，用于指定要检查的配置属性的名称和期望的值。<br>比如：@ConditionalOnProperty注解的value参数设置为”compensate.enabled”，表示要检查名为”compensate.enabled”的配置属性。而havingValue参数设置为”true”，表示期望该配置属性的值为”true”。<br>因此，当配置属性”compensate.enabled”的值为”true”时，被注解的组件或配置将被加载或启用。如果配置属性的值不是”true”，则被注解的组件或配置将被禁用或忽略。<br>这个注解通常用于根据配置属性的值来决定是否启用某些特定的功能或组件。通过使用@ConditionalOnProperty注解，你可以根据配置属性的值来动态地控制应用程序的行为，使其更加灵活和可配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"compensate.enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompensateManager <span class="title">compensateManager</span><span class="params">(DataSource dataSource, CompensateExecutionChain chain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompensateManager(properties, dataSource, chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NestedConfigurationProperty"><a href="#NestedConfigurationProperty" class="headerlink" title="@NestedConfigurationProperty"></a>@NestedConfigurationProperty</h2><p>@NestedConfigurationProperty是Spring框架中的一个注解，用于指示一个属性应该被视为嵌套的配置属性。它通常用于嵌套类中的属性，以便在配置文件中以嵌套的方式组织属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="keyword">private</span> String country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Employee类包含一个嵌套类Address，它表示员工的地址信息。Address类具有三个属性：street、city和country。<br>通过这种方式，可以在Employee类中组织员工的信息，并将地址信息作为嵌套类的属性。这样，可以更清晰地表示员工对象的结构，并在配置文件中以嵌套的方式配置地址信息。<br>在配置文件中，可以使用以下方式配置Employee对象的属性和Address对象的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">employee.name=John Doe</span><br><span class="line">employee.age=<span class="number">30</span></span><br><span class="line">employee.address.street=<span class="number">123</span> Main St</span><br><span class="line">employee.address.city=New York</span><br><span class="line">employee.address.country=USA</span><br></pre></td></tr></table></figure><p>这样，就可以通过嵌套类的方式组织和配置复杂的对象结构。</p><h2 id="InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessorAdapter</h2><p>InstantiationAwareBeanPostProcessorAdapter是Spring框架中的一个接口，它是InstantiationAwareBeanPostProcessor接口的适配器类。这个接口在Spring的Bean生命周期中扮演着重要的角色。<br>InstantiationAwareBeanPostProcessor接口定义了一组回调方法，用于在Spring容器实例化Bean之前和之后进行自定义处理。而InstantiationAwareBeanPostProcessorAdapter是一个适配器类，它提供了默认的空实现，使得我们可以只关注我们感兴趣的回调方法，而不需要实现接口中的所有方法。<br>这个接口的作用是允许开发者在Bean实例化的不同阶段进行自定义的处理。它提供了以下几个重要的回调方法：<br>postProcessBeforeInstantiation(): 在实例化Bean之前调用，允许开发者返回一个自定义的Bean实例，或者返回null来使用默认的实例化机制。<br>postProcessAfterInstantiation(): 在实例化Bean之后调用，允许开发者对实例进行自定义的处理，例如修改属性值或执行其他初始化操作。<br>postProcessPropertyValues(): 在Bean的属性注入之前调用，允许开发者对属性值进行自定义的处理，例如修改属性值或验证属性的合法性。<br>通过实现InstantiationAwareBeanPostProcessor接口或使用InstantiationAwareBeanPostProcessorAdapter适配器类，开发者可以在Bean实例化的不同阶段进行自定义的处理。这样，我们可以在Spring容器实例化Bean时，对Bean进行额外的操作或修改，以满足特定的需求。<br>以下是一个简单的示例，展示了如何使用InstantiationAwareBeanPostProcessorAdapter接口来自定义处理Bean实例化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == MyBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之前，返回一个自定义的Bean实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">"Custom Instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null，使用默认的实例化机制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyBean) &#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之后，对其进行自定义的处理</span></span><br><span class="line">            MyBean myBean = (MyBean) bean;</span><br><span class="line">            myBean.setSomeProperty(<span class="string">"Custom Property Value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个名为CustomBeanPostProcessor的类，它继承自InstantiationAwareBeanPostProcessorAdapter适配器类。我们重写了postProcessBeforeInstantiation()和postProcessAfterInstantiation()方法来实现自定义的处理逻辑。<br>在postProcessBeforeInstantiation()方法中，我们检查要实例化的Bean是否是MyBean类。如果是，我们返回一个自定义的MyBean实例，否则返回null，使用默认的实例化机制。<br>在postProcessAfterInstantiation()方法中，我们检查实例化后的Bean是否是MyBean类的实例。如果是，我们对其进行自定义的处理，例如设置属性值。<br>通过使用CustomBeanPostProcessor类，我们可以在Bean实例化的过程中对特定的Bean进行自定义处理。这样，我们可以根据需要修改Bean的实例或属性，以满足特定的业务逻辑或需求。</p><h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><p>ApplicationContextAware接口是Spring框架中的一个接口，用于实现对应用程序上下文（ApplicationContext）的感知。<br>该接口继承自Aware接口，通过实现ApplicationContextAware接口，可以让Bean获取对应用程序上下文的引用，并在需要时进行操作。<br>具体来说，ApplicationContextAware接口定义了一个方法setApplicationContext(ApplicationContext var1)，当Bean被实例化并注入到Spring容器中时，Spring容器会自动调用该方法，并将当前的应用程序上下文作为参数传递进来。<br>通过实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文的引用，并利用它来进行一些操作，例如获取其他Bean、发布事件、访问资源等。<br>一般来说，这么整就行了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来，ApplicationContextAware接口的作用是让Bean获取对应用程序上下文的引用，以便在需要时进行操作。通过实现该接口并实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文，并利用它进行各种操作。</p><h2 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h2><p>@Aspect注解是Spring框架中的一个注解，用于声明一个切面（Aspect）。切面是一种用于横切关注点（Cross-cutting Concerns）的模块化方式，它可以定义一组通用的横切逻辑，并将其应用到多个目标对象中。<br>具体来说，@Aspect注解用于标记一个类为切面类，该类中定义了一些通用的横切逻辑，例如日志记录、性能监控、事务管理等。切面类通常包含一些切点（Pointcut）和通知（Advice）的定义。</p><ul><li>切点（Pointcut）：切点定义了在哪些连接点（Join Point）上应用通知。连接点是程序执行过程中可以插入切面逻辑的点，例如方法调用、方法执行、异常抛出等。切点通过表达式或注解来定义，用于匹配符合条件的连接点。</li><li>通知（Advice）：通知定义了在切点上执行的具体逻辑。通知可以在切点之前、之后、抛出异常时等不同的时机执行。常见的通知类型包括前置通知（Before）、后置通知（After）、返回通知（AfterReturning）和异常通知（AfterThrowing）等。</li></ul><p>通过使用@Aspect注解，Spring框架可以识别并将切面类纳入到AOP（面向切面编程）的管理中。在运行时，Spring会根据切点和通知的定义，将切面逻辑织入到目标对象的相应连接点上，从而实现横切关注点的功能。<br>要使用切面，需要完成以下步骤：</p><ol><li>在Spring配置文件中启用AOP的自动代理功能。可以使用<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a>标签或@EnableAspectJAutoProxy注解来实现。这将告诉Spring框架在运行时自动创建代理对象，并将切面逻辑织入到目标对象的连接点上。</li><li>创建目标对象。目标对象是需要应用切面逻辑的对象。可以是任何Spring管理的Bean，例如服务类、控制器等。</li><li>创建切面类。切面类是包含切点和通知的类。使用@Aspect注解标记切面类，并在其中定义切点和通知的方法。</li><li>在切面类中定义切点。切点定义了在哪些连接点上应用通知。可以使用表达式或注解来定义切点，以匹配符合条件的连接点。</li><li>在切面类中定义通知。通知定义了在切点上执行的具体逻辑。可以使用@Before、@After、@AfterReturning、@AfterThrowing等注解来定义不同类型的通知。</li><li>运行应用程序。当目标对象的方法被调用时，切面逻辑会自动织入到连接点上，根据切点和通知的定义执行相应的逻辑。</li></ol><p>以下是一个简单的示例，演示如何使用切面类来实现日志记录的横切逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        MyService myService = context.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        myService.doSomething();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Doing something..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.example.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethodExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个MyService类作为目标对象，其中包含一个doSomething()方法。我们还创建了一个LoggingAspect类作为切面类，其中定义了一个前置通知，用于在目标对象的方法执行之前记录日志。<br>在MainApp类中，我们使用AnnotationConfigApplicationContext来加载Spring配置，并获取MyService的实例。当调用myService.doSomething()方法时，切面类中的前置通知会被触发，输出日志信息：”Before method execution: Logging…”。<br>通过以上步骤，我们成功地将切面逻辑应用到目标对象的连接点上，实现了日志记录的横切逻辑<br>总结起来，@Aspect注解用于声明一个切面类，该类中定义了切点和通知，用于实现横切关注点的功能。通过使用@Aspect注解，Spring框架可以识别并管理切面类，将切面逻辑织入到目标对象的连接点上。</p><h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>@Around是一个用于定义环绕通知的注解。在Spring AOP中，环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。<br>使用@Around注解可以将一个方法标记为环绕通知方法。这个方法会在目标方法执行之前和之后执行，可以在这个方法中编写自定义的逻辑来控制目标方法的执行。<br>环绕通知方法需要满足一些要求：</p><ul><li>方法的返回类型可以是任意类型，通常是Object。</li><li>方法的参数可以是ProceedingJoinPoint类型，用于执行目标方法，也可以是其他参数，根据需要进行定义。</li></ul><p>在环绕通知方法中，可以通过调用ProceedingJoinPoint对象的proceed()方法来执行目标方法。在调用proceed()方法之前，可以在目标方法执行前进行一些前置操作，而在调用proceed()方法之后，可以在目标方法执行后进行一些后置操作。通过使用@Around注解，我们可以更灵活地控制目标方法的执行过程，例如在执行前后进行日志记录、性能监控、事务管理等操作。<br>比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.example.service.MyService.doSomething(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"After method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个LoggingAspect切面类，并在其中使用@Around注解标记了一个环绕通知方法aroundAdvice()。该方法接受一个ProceedingJoinPoint参数，用于执行目标方法。<br>在aroundAdvice()方法中，我们首先输出了一条日志信息，表示在目标方法执行之前的前置操作。然后，通过调用joinPoint.proceed()方法，执行了目标方法。最后，我们又输出了一条日志信息，表示在目标方法执行之后的后置操作。<br>通过这个示例，我们可以在目标方法执行前后添加自定义的逻辑，例如记录日志、计算方法执行时间等。这样，每次调用MyService的doSomething()方法时，都会触发切面的环绕通知方法。</p><h3 id="Aspect和-Around"><a href="#Aspect和-Around" class="headerlink" title="@Aspect和@Around"></a>@Aspect和@Around</h3><p>@Aspect和@Around是Spring AOP框架中的两个不同的注解，它们在AOP的实现中扮演不同的角色。</p><ul><li>@Aspect注解用于标记一个类为切面类。切面类是包含切面逻辑的类，它定义了在哪些连接点上应用切面逻辑，并且可以包含多个通知类型（如前置通知、后置通知、环绕通知等）。通过使用@Aspect注解，我们可以将一个普通的类声明为切面类，以便在Spring AOP中使用。</li><li>@Around注解是一个通知类型的注解，用于定义环绕通知。环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。通过使用@Around注解，我们可以将一个方法标记为环绕通知方法，以便在切面中定义自定义的逻辑。</li></ul><p>因此，@Aspect注解用于标记切面类，而@Around注解用于标记环绕通知方法。切面类可以包含多个通知类型的方法，而环绕通知方法是其中的一种。切面类通过@Aspect注解告诉Spring AOP框架它是一个切面类，而环绕通知方法通过@Around注解告诉框架它是一个环绕通知方法。</p><p>综上所述，@Aspect和@Around是Spring AOP框架中的两个不同的注解，用于不同的目的。@Aspect用于标记切面类，而@Around用于标记环绕通知方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里开始记录一些学到的强力的注解和接口&lt;/p&gt;
&lt;h2 id=&quot;CommandLineRunner&quot;&gt;&lt;a href=&quot;#CommandLineRunner&quot; class=&quot;headerlink&quot; title=&quot;CommandLineRunner&quot;&gt;&lt;/a&gt;CommandL</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>高性能队列：Disruptor</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/04/14/Disruptor-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/04/14/Disruptor-1/</id>
    <published>2023-04-14T14:01:04.000Z</published>
    <updated>2023-12-14T14:02:57.819Z</updated>
    
    <content type="html"><![CDATA[<p><a name="oYoyt"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易所中的低延迟和高吞吐量需求而设计的。它主要用来解决在多线程环境中生产者和消费者之间的数据传递问题。Disruptor 由 LMAX 的 Martin Thompson 和 Dave Farley 于 2011 年发明，现在是一个开源项目。</p><blockquote><p>The Disruptor is the result of our efforts to build the world’s highest performance financial exchange at LMAX. Early designs focused on architectures derived from SEDA [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_1" target="_blank" rel="noopener">1</a>] and Actors [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_2" target="_blank" rel="noopener">2</a>] using pipelines for throughput. After profiling various implementations it became evident that the queuing of events between stages in the pipeline was dominating the costs. We found that queues also introduced latency and high levels of jitter. We expended significant effort on developing new queue implementations with better performance. However it became evident that queues as a fundamental data structure are limited due to the conflation of design concerns for the producers, consumers, and their data storage. The Disruptor is the result of our work to build a concurrent structure that cleanly separates these concerns.</p></blockquote><p>Disruptor 的核心思想是，通过使用环形的数据结构（RingBuffer）和避免锁来实现数据的高速传递。RingBuffer 类似于一个循环队列，内部包含一个预先分配好的对象数组，该数组的大小为 2 的幂次方。这样设计的一个原因是可以通过位运算快速计算数组中的索引，提升性能。创建此环形数据结构后，生产者可以将事件（通常是某个类的实例）发布到 RingBuffer 的下一个可用位置，同时消费者可以从 RingBuffer 中读取和处理事件。通过使用序号（Sequence）来表示 RingBuffer 中各个条目的位置，生产者和消费者之间可以实现非阻塞的协同工作模式，从而达到最大的性能优势。<br />Disruptor 还支持多个生产者和多个消费者的场景，消费者可以独立处理事件，也可以按照依赖关系顺序进行处理。这使得Disruptor 可以在保持低延迟的同时，实现并行处理并提高整体系统吞吐量。</p><p>那Disruptor相比于Java内置的队列而言，有什么优势呢，这里需要进一步的分析<br><a name="CVc3m"></a></p><h2 id="Java的内置队列"><a href="#Java的内置队列" class="headerlink" title="Java的内置队列"></a>Java的内置队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232326187-0473b7b4-ba77-4943-a805-2a343871d150.png#averageHue=%23e1e1e1&clientId=u294810c7-fb47-4&from=paste&height=186&id=ud6f9c576&originHeight=372&originWidth=1212&originalType=binary&ratio=2&rotation=0&showTitle=false&size=68156&status=done&style=none&taskId=ub09db3d5-5196-46d9-acc2-89707ac10fe&title=&width=606" alt="image.png"><br />在Java中ArrayBlockingQueue是靠锁去控制它的并发安全的，而且是有界的队列。</p><p>ArrayBlockingQueue（数组阻塞队列）通过内部的锁（ReentrantLock）和两个条件变量（Condition）notEmpty和notFull来保证线程安全。</p><ol><li>ReentrantLock（可重入锁）：ArrayBlockingQueue使用ReentrantLock作为内部的锁来控制对队列的访问。在读取、写入、删除等操作时，需要先获取锁，完成操作后再释放锁。使用lock及unlock方法对数据进行保护，确保同一时刻只有一个线程能执行特定的操作。 </li><li>条件变量（Condition）：ArrayBlockingQueue有两个Condition，分别是notEmpty和notFull。当队列为空时，使用notEmpty.await()方法阻塞读线程；当队列满时，使用notFull.await()方法阻塞写线程。当数据被删除后，notEmpty.signal()唤醒读线程继续读取；当数据被添加后，notFull.signal()唤醒写线程继续写入。 </li></ol><p>通过这些同步措施，ArrayBlockingQueue确保了在多线程环境下的线程安全性<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232394025-16fa469d-9921-4e33-acb5-4c8d725374d4.png#averageHue=%232d2d2d&clientId=u294810c7-fb47-4&from=paste&height=236&id=u00680c6f&originHeight=472&originWidth=1282&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44409&status=done&style=none&taskId=u06f63704-23cf-4250-8d9c-269cc5fecf6&title=&width=641" alt="image.png"><br />而LinkedTransferQueue都是通过原子变量CAS这种不加锁的方式来实现的，但是它们都是使用链表的方式去实现的，这种方式的会出现两个问题，一个是由于无界导致的OOM，一个是这种数据结构也会影响到JVM的GC效率，所以，在大多数时候，还是使用ArrayBlockingQueue比较的常见，那么，ArrayBlockingQueue 有什么问题呢。</p><p><a name="oLbbN"></a></p><h3 id="加锁导致的效率问题"><a href="#加锁导致的效率问题" class="headerlink" title="加锁导致的效率问题"></a>加锁导致的效率问题</h3><p>这里引用LMAX交易所的数据：</p><blockquote><p>We will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which increments a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel Westmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar across all languages with the same basic primitives.<br>Once a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up significantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results of this simple experiment are shown in the table below:</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233609316-d2ddb2d5-2975-480c-a740-3463916fb39e.png#averageHue=%23fbfafa&clientId=u294810c7-fb47-4&from=paste&height=367&id=ua84c85bb&originHeight=734&originWidth=2064&originalType=binary&ratio=2&rotation=0&showTitle=false&size=113743&status=done&style=none&taskId=u86ed9446-fa4e-421c-9e57-fa897f4eea4&title=&width=1032" alt="image.png"><br />这里LMAX使用一个程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。测试结果显然，加锁与CAS的差别还是比较大的。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233889498-6c9beec5-949e-4088-b74e-00bdb38af9a0.png#averageHue=%232b2b2b&clientId=u294810c7-fb47-4&from=paste&height=492&id=ub7be082a&originHeight=984&originWidth=1434&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126074&status=done&style=none&taskId=uced54ebb-973c-4a4b-a939-456ce64a777&title=&width=717" alt="image.png"><br />这个加锁加在了offer，以此来保证线程的安全性，但是这样的方式显然会损失不少性能。<br />而CAS的呢，这里则使用了unsafe去使用魔法，使其不加锁的情况下，仍然可以保证线程安全：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234138046-0d2ed826-05bc-459f-87de-af5aa633a9e4.png#averageHue=%232d2c2b&clientId=u294810c7-fb47-4&from=paste&height=189&id=u78cb1884&originHeight=378&originWidth=1370&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79015&status=done&style=none&taskId=uad351660-7a33-427d-a31f-ae88e1069cb&title=&width=685" alt="image.png"></p><p>那为什么ArrayBlockingQueue非要加锁<br />看到这里大家可能会有一个疑惑，那为什么ArrayBlockingQueue不用cas而选择加锁呢？<br />使用ArrayBlockingQueue而非CAS的原因主要包括以下几点：</p><ol><li>锁的简化。ArrayBlockingQueue适用于生产者和消费者的场景。当队列为空时，消费者线程需要等待；当队列已满时，生产者线程需要等待。这种有固定边界的队列在这种场景下可以简化设计。通过使用锁，可以简化这种等待-通知的逻辑。锁本身支持等待-通知机制，使用条件变量Condition实现。 </li><li>性能。考虑到在有边界的队列情况下，竞争可能会比较激烈。当队列为空或已满时，CAS操作可能会导致大量的失败尝试和自旋。这会影响性能，并消耗更多的CPU资源。而在这些竞争激烈的情况下，锁的性能往往优于CAS操作。 </li><li>简单性。相比于使用CAS操作实现的非阻塞数据结构，使用锁实现的数据结构通常更容易理解和实现。这意味着更少的错误和更容易维护的代码。 </li></ol><p>而Disruptor是一个高性能队列库，它的设计初衷是为了解决高并发、低延迟的场景。Disruptor之所以能够使用CAS（Compare And Swap）操作，主要是基于以下几个原因：</p><ol><li>缓存行填充。Disruptor利用缓存行填充（Cache Line Padding）来减少伪共享（False Sharing）的问题。伪共享会导致缓存行失效，从而影响性能。通过将生产者和消费者的指针放置在不同的缓存行上，避免了伪共享问题，从而提高了使用CAS操作的性能。 </li><li>锁消除。Disruptor消除了锁的使用，通过使用原子操作（如CAS）进行并发控制。这减少了锁带来的开销，提高了性能。在高并发场景下，锁的竞争可能会导致严重的性能问题，而CAS操作可以更好地支持这些场景。 </li><li>数据结构设计。Disruptor的数据结构设计是基于环形缓冲区（Ring Buffer）的，这使得它在内存分配和管理上更加高效。通常情况下，无锁队列的设计和实现相对复杂，但Disruptor通过使用环形缓冲区，将其复杂程度降低，使得CAS操作的实现变得可行。 </li><li>无阻塞。Disruptor采用无阻塞算法，避免了死锁、阻塞等问题。在高并发场景下，无阻塞算法通常具有更好的伸缩性。当线程之间存在很多竞争时，锁定资源可能会导致性能瓶颈。而CAS操作提供了一种无锁的方式来解决资源竞争问题。 </li><li>批处理。Disruptor支持批处理，它可以将多个操作组合在一起执行。这样可以充分利用CPU缓存、减少上下文切换，从而提高CAS操作的性能。 </li></ol><p>Disruptor之所以能够使用CAS操作，主要是因为其数据结构设计、缓存行填充、无锁算法和批处理等技术的应用。这些技术使得Disruptor在高并发和低延迟场景下具有优秀的性能，满足了高性能队列的需求。<br><a name="XJbbR"></a></p><h3 id="被破坏的共享"><a href="#被破坏的共享" class="headerlink" title="被破坏的共享"></a>被破坏的共享</h3><p>这里需要提一提一个比较底层的知识，那就是CPU的三级cache：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238904423-7c2ab82a-340e-4193-933d-f40108692896.png#averageHue=%23f4f4f4&clientId=u294810c7-fb47-4&from=paste&height=703&id=u96748072&originHeight=1406&originWidth=1502&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275200&status=done&style=none&taskId=u7bb6a08a-075c-48ad-ade2-9790ddae633&title=&width=751" alt="4-modified.png"><br />CPU的三级缓存，即L1、L2和L3缓存，是一种位于CPU内部的高速存储器。它们主要用于存储那些频繁使用的数据和指令，从而提高CPU处理速度。<br />L1缓存（一级缓存）：它是CPU内部最接近执行单元的缓存，速度非常快，但存储容量相对较小，通常在32KB-64KB之间。L1缓存通常分为数据缓存（用于存储操作数）和指令缓存（用于存储已经预取的指令）。<br />L2缓存（二级缓存）：它位于L1缓存之后，速度略低于L1缓存，但具有较大的存储容量，通常在256KB到8MB之间。L2缓存通常用于存储那些不太频繁使用的数据和指令。在某些CPU设计中，L2缓存可能是共享的，这意味着它可以存储来自不同执行单元的数据和指令。<br />L3缓存（三级缓存）：它位于L2缓存之后，速度低于L2缓存，但在容量和访问速度方面，它将较之主存储器（例如DDR RAM）有很大优势。L3缓存容量范围通常在8MB至32MB之间，但在某些高端处理器中可能更大。L3缓存主要用于在L2缓存中未命中的数据和指令的存储，它可以在多个核之间共享。<br />这种分级存储的方式有效地将处理器的计算能力靠近主存储器的速度。当CPU需要访问数据或指令时，它首先检查L1缓存，然后是L2缓存，最后是L3缓存。如果三级缓存都未命中，CPU将从主存储器中获取数据。由于L1、L2和L3缓存的访问速度逐级降低，但存储容量逐级增加，因此它们一起建立了一个高效的层次结构，将最频繁使用的内容存储在越来越快的缓存中，从而提高处理速度。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234350571-75b183be-3153-4664-aaa3-c841032acea7.png#averageHue=%23e5e5e5&clientId=u294810c7-fb47-4&from=paste&height=135&id=u26a1a90a&originHeight=226&originWidth=1246&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35435&status=done&style=none&taskId=u35f7847f-ab8f-4446-9329-30b47597cde&title=&width=742" alt="image.png"><br><a name="zGraA"></a></p><h4 id="共享缓存带来的影响"><a href="#共享缓存带来的影响" class="headerlink" title="共享缓存带来的影响"></a>共享缓存带来的影响</h4><p>缓存由许多缓存行组成。通常情况下，每个缓存行包含64字节，它们有效地引用了主内存中的一系列地址。在这种情况下，一个Java的long类型变量占用8字节，所以一个缓存行可以容纳8个long类型的变量。<br />当CPU从主存中获取数据时，相邻的数据也会被存储到相同的缓存行中。<br />在访问一个long类型的数组时，如果数组中的一个值被加载到缓存中，相邻的7个值也会自动被加载。这使得你可以快速地遍历该数组。实际上，在连续的内存块中分配的任何数据结构都可以被快速遍历。<br />以下示例展示了利用缓存行特性与不利用缓存行特性之间效果的对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineEffect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//考虑一般缓存行大小是64字节，一个 long 类型占8字节</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">long</span>[][] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">                sum = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">1024</span> * <span class="number">1024</span>;j++)&#123;</span><br><span class="line">                sum = arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234667637-b701dcd8-2230-437d-8483-dd0adece47f8.png#averageHue=%23303030&clientId=u294810c7-fb47-4&from=paste&height=62&id=uc4c05076&originHeight=124&originWidth=622&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10940&status=done&style=none&taskId=u021fd135-9ce1-4a0c-a783-98314c511c7&title=&width=311" alt="image.png"><br><a name="NRlFb"></a></p><h4 id="那么缓存与ArrayBlockingQueue有什么关系呢？"><a href="#那么缓存与ArrayBlockingQueue有什么关系呢？" class="headerlink" title="那么缓存与ArrayBlockingQueue有什么关系呢？"></a><strong>那么缓存与ArrayBlockingQueue有什么关系呢？</strong></h4><p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量<br />这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234428482-ef2034bb-27f7-41f5-a649-5ecfd622a3b3.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=327&id=u0f02d98d&originHeight=654&originWidth=1966&originalType=binary&ratio=2&rotation=0&showTitle=false&size=131679&status=done&style=none&taskId=u1010804e-920f-4f30-9e79-f63781197f8&title=&width=983" alt="3-modified.png"><br />如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。<br />这种无法充分使用缓存行特性的现象，称为伪共享。<br />对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。<br /><strong>不知道大家有没有看过《Java并发编程艺术》，那本书也写了有无共享缓存导致的区别</strong><br /><strong>而解决伪共享的最好方法，就是填充</strong><br />下面是一个验证程序，去表达有填充和无填充导致的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValueNoPadding[] longs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            runTest(i);</span><br><span class="line">            System.out.println(<span class="string">"Thread num "</span> + i + <span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        longs = <span class="keyword">new</span> ValueNoPadding[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> ValueNoPadding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235086298-b4fd3d05-611f-47b2-a3cf-ee5403674406.png#averageHue=%23383838&clientId=u294810c7-fb47-4&from=paste&height=236&id=uebb152fa&originHeight=472&originWidth=550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=51500&status=done&style=none&taskId=uafd42923-c20d-4e89-9d3a-492afc10140&title=&width=275" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235220121-d84e6b19-a9b3-426c-a382-4eca89265e03.png#averageHue=%23393939&clientId=u294810c7-fb47-4&from=paste&height=227&id=ua3371d3a&originHeight=454&originWidth=484&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46562&status=done&style=none&taskId=ud852761a-cefd-4547-9b5d-2fe30fbd767&title=&width=242" alt="image.png"><br />左边是ValueNoPadding，右边是ValuePadding。</p><p>由此可见，有无共享导致的区别还是挺大的。<br />那么这么明显的问题，他们都没有注意到吗？那当然不是，事实上，已经有一个注解@Contended去解决了这个问题：<br /><code>@Contended</code> 注解用于在Java类及其字段上提高内存访问性能。它可以显式地向JVM表示，被修饰的元素（通常是字段）可能会产生伪共享（false sharing）问题。<br />伪共享是指多个线程频繁访问不同变量，但这些变量位于同一个缓存行上。这会导致缓存行频繁失效和重载，从而降低多线程程序的性能。<br /><code>@Contended</code> 注解提示JVM在分配内存时为标注元素添加额外的内存填充，以确保它们分布在不同的缓存行上。这有助于消除伪共享，从而提高线程间的并发性能。<br />要注意的是，<code>@Contended</code> 支持并不是所有JVM版本都有。在Oracle的Hotspot JVM上，默认情况下仅在Java 9及以上版本可用。 若要在低于Java 9的JVM版本上使用<code>@Contended</code>, 需要启动JVM时添加 <code>-XX:-RestrictContended</code> 参数。<br />示例使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.vm.annotation.Contended;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value1 &amp; Value2 with padding to avoid False Sharing</span></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，<code>Foo</code> 类及其字段 <code>value1</code> 和 <code>value2</code> 使用了 <code>@Contended</code> 注解，以避免伪共享问题。</p><p><a name="e83UL"></a></p><h2 id="Disruptor的设计"><a href="#Disruptor的设计" class="headerlink" title="Disruptor的设计"></a>Disruptor的设计</h2><p><a name="aaV5Q"></a></p><h3 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h3><p>Disruptor是一个高性能、低延迟的并发框架，最初由LMAX公司开发。它用于解决在复杂多线程环境下数据共享和并发访问的问题。Disruptor的设计目标是使开发人员能够在高负载场景下编写出较低延迟和高吞吐量的应用程序。其的核心设计模式主要包括以下几个方面：</p><ol><li>Ring Buffer（环形缓冲区）：Disruptor框架的核心数据结构。Ring Buffer用于存储和共享数据。它是一个环形的数组，长度固定且是2的整数次幂。由于是环形，当写入到达计数器尾部时，将回到数组的开头覆盖旧数据。Ring Buffer提高了数据存储和访问效率，同时降低了并发冲突的可能性。并且，由于数组的特性对处理器的缓存机制更加友好。</li><li>Producer（生产者）：生产者将事件数据添加到Ring Buffer中。在Disruptor框架中，可以有多个生产者同时添加事件。</li><li>Sequence Barrier（序列屏障）：提供了一种协调机制，以确保生产者和消费者在并行执行时可以正确访问Ring Buffer。</li><li>Consumer（消费者）：消费者是处理Ring Buffer中事件的实际执行者。Disruptor支持多个消费者同时处理事件，可以为消费者定义依赖关系。当多个消费者同时访问Ring Buffer时，事件将根据消费者依赖关系顺序处理。</li><li>WaitStrategy（等待策略）：Disruptor提供了一组内置的等待策略，用于控制生产者和消费者在等待事件处理时的行为。例如，线程执行、空轮询、阻塞等待等。</li></ol><p>使用Disruptor可以高效地处理多线程的并发问题。相比传统的阻塞队列和锁，Disruptor通过这些设计模式实现了更低的延迟和更高的吞吐量，适用于高性能需求的场景。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235832610-789e1be7-524d-4d8f-80c8-e187a86cd8ba.png#averageHue=%23f5f5f5&clientId=u294810c7-fb47-4&from=paste&height=719&id=ud1e82361&originHeight=1438&originWidth=1964&originalType=binary&ratio=2&rotation=0&showTitle=false&size=267070&status=done&style=none&taskId=u81cba5c1-7ebd-4d0e-9fa9-ce68b93ba42&title=&width=982" alt="image.png"><br><a name="yFUmD"></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Disruptor还具有元素位置定位和无锁这两个优势特点，它们可以进一步提高Disruptor的性能。接下来详细介绍这三个特点：</p><ol><li>元素位置定位：<br />在Disruptor的Ring Buffer中，每个元素（事件）的位置都是通过一个序列号（Sequence）来表示的。这个序列号对应于Ring Buffer数组的一个索引位置。根据序列号计算索引位置的公式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; sequence % bufferSize</span><br></pre></td></tr></table></figure><p>其中<code>sequence</code>表示元素的序列号（从0开始递增），<code>bufferSize</code>表示Ring Buffer的大小（长度）。<br />由于Ring Buffer的长度是2的整数次幂，这样的设计使得计算索引位置非常高效。只需要进行按位与（<code>sequence &amp; (bufferSize - 1)</code>）操作即可完成计算，避免了除法和取余运算，从而提高了性能。</p><ol start="2"><li>无锁：<br />Disruptor在设计时确保了多个生产者和消费者在操作Ring Buffer时都无需使用锁。利用了无锁数据结构的原子操作，例如CAS（Compare And Swap）等，确保了在高并发环境下正确、高效地访问共享数据。无锁设计相对于基于锁的同步方式减少了线程上下文切换的开销，降低了竞争冲突，从而大幅提高了应用程序的性能。</li><li>环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好（CPU加载空间局部性原则）。</li></ol><p>在Disruptor框架中，生产者和消费者都使用单调递增的序列号（Sequence）来表示所操作的元素。当生产者或消费者需要添加或处理事件时，它们会使用CAS操作更新相应的Sequence。因此，消费者之间即使在并行执行时，也能够正确地知道对方的处理进度，这样消费者之间可以互不干扰地处理事件。</p><p><a name="KDa9A"></a></p><h3 id="使用无锁的设计"><a href="#使用无锁的设计" class="headerlink" title="使用无锁的设计"></a>使用无锁的设计</h3><p>Disruptor中的主要无锁设计是通过RingBuffer来实现的。RingBuffer是Disruptor中一个循环的缓冲区，使用无锁技术实现高性能的并发访问。<br />在Disruptor中，生产者和消费者共同操作RingBuffer。生产者发布事件时(下面的demo有示例)，会通过<strong>next()</strong>方法申请序号，并一次性地预分配多个序列号。消费者根据序列号处理相应的事件，确保消费者事件间无锁、无阻塞地运行。<br />Disruptor通过使用设计如<strong>Sequence</strong>、<strong>Sequencer</strong>和<strong>Cursor</strong>等类和遵循一定的规则，在高并发环境下保证了生产者和消费者间的正确交互，实现了高性能的无锁设计。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239186747-7e49977c-3b81-43e7-bd05-adc3aa5de15f.png#averageHue=%233a3734&clientId=u294810c7-fb47-4&from=paste&height=331&id=udce0dff4&originHeight=662&originWidth=2358&originalType=binary&ratio=2&rotation=0&showTitle=false&size=223750&status=done&style=none&taskId=u1b7af166-361f-4a85-b8d1-4f7f7f12eb0&title=&width=1179" alt="image.png"></p><p><a name="xlu1z"></a></p><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>Disruptor的RingBuffer是一个环形缓冲区，它是Disruptor框架的核心组件。它采用环形数据结构使得生产者和消费者能够高效地在无锁的情况下共享数据。下面详细讲解RingBuffer的原理：</p><ol><li>数据结构：RingBuffer实际上是一个包含预定义大小的对象数组，这个数组的大小必须为2的幂。之所以使用2的幂，是因为这样可以优化某些计算，例如通过位运算取模运算，提高性能。数组中的每个元素对应一个事件（Event），生产者负责产生事件，消费者负责处理事件。 </li><li>序列号（Sequence）：在Disruptor中，生产者和消费者通过序列号（Sequence）来定位RingBuffer中的位置。序列号是一个单调递增的long值，用于表示事件的位置。生产者申请序列号时，序列号递增。消费者处理事件时，根据序列号在RingBuffer中找到相应的事件。 </li><li>环形缓冲区：由于RingBuffer是环形的，当数组的末尾已经用完时，生产者可以从数组的开头开始重用位置。这样，在RingBuffer不满的情况下，生产者总是可以写入事件而不会遇到阻塞。当然，在RingBuffer满的情况下，生产者可能需要等待消费者消费事件来释放空间。 </li><li>索引计算：由于RingBuffer的长度是2的幂，例如长度为8的RingBuffer，可以通过位运算得到索引：<code>index = sequence &amp; (bufferSize - 1)</code>。这比取模运算效率更高。 </li><li>生产者-消费者交互：在Disruptor中，生产者和消费者通过遵循一定的规则实现环形缓冲区的无锁访问，提高并发性能。主要有以下规则：a) 生产者只需要关心最慢的消费者，因为只有当所有消费者完成对当前事件的处理，才能确保生产者可以安全地覆盖之前的事件；b) 消费者之间可能存在依赖关系，可以通过屏障（Barrier）等方法确保消费者按照顺序处理事件。 </li></ol><p>下面通过一个过程示例，来表达Disruptor的解决思路：<br />启动时，将预先分配环形缓冲区的所有内存。环形缓冲区可以存储指向 entry 的指针数组，也可以存储表示 entry 的结构数组。这些 entry 中的每一个通常不是传递的数据本身，类似对象池机制，而是它的容器。这种 entry 的预分配消除了支持垃圾回收的语言中的问题，因为 entry 将被重用，并在整个 Disruptor 实例存活期间都有效。这些 entry 的内存是同时分配的。<br />一般的数据结构是像下面这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239747113-fa180ee3-e71d-44be-9b6c-ba59c58dff57.png#averageHue=%23f6f6f6&clientId=u294810c7-fb47-4&from=paste&height=518&id=u09798d04&originHeight=1426&originWidth=1536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=214415&status=done&style=none&taskId=u0a61dd2e-e675-4e3e-b624-e76156bbf00&title=&width=558" alt="5-modified.png"><br />我们可以使用一个环状的数组结构改进成下面这样：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239757886-48ce5b14-d7fa-4a54-a762-b2f41cff6647.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=623&id=u749158d5&originHeight=1658&originWidth=958&originalType=binary&ratio=2&rotation=0&showTitle=false&size=203627&status=done&style=none&taskId=uaf451706-9b1e-4450-8a06-017678ed102&title=&width=360" alt="6-modified.png"><br />数组的连续多个元素会一并加载到 CPU Cache 里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。遍历访问时 CPU 层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。</p><p>在像 Java 这样的托管运行时环境中开发低延迟系统时，垃圾收集机制可能会带来问题。分配的内存越多，给垃圾收集器带来的负担就越大。当对象的寿命很短或实际上是常驻的时候，垃圾收集器工作得最好。在环形缓冲区中预先分配 entry 意味着它对于垃圾收集器来说是常驻内存的，垃圾回收的负担就很轻。同时，数组结构对处理器的缓存机制更加友好。数组长度 2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心 index 溢出的问题。index 是 long 类型，即使 100 万 QPS 的处理速度，也需要 30 万年才能用完。</p><p>一般的 Cache Line 大小在 64 字节左右，然后 Disruptor 在非常重要的字段前后加了很多额外的无用字段。可以让这一个字段占满一整个缓存行，这样就可以避免未共享导致的误杀。</p><p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。<br><a name="hIbfE"></a></p><h4 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h4><p>下面用非环形的结构模拟无锁读写：</p><ol><li>申请写入m个元素</li><li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素</li><li>若是返回的正确，则生产者开始写入元素</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239966093-8f5b4adc-c6a0-43b7-8194-be501aa8c466.png#averageHue=%23f7f7f7&clientId=u294810c7-fb47-4&from=paste&height=555&id=ub77b53b5&originHeight=1550&originWidth=1108&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146321&status=done&style=none&taskId=u0824520d-67aa-42c3-897e-9eec115f60d&title=&width=397" alt="7-modified.png"><br><a name="CqVJN"></a></p><h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor 的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过 CAS 很容易达到。只需要在分配元素的时候，通过 CAS 判断一下这段空间是否已经分配出去即可。</p><p>但如何防止读取的时候，读到还未写的元素。Disruptor 在多个生产者的情况下，引入了一个与 Ring Buffer 大小相同的 buffer，Available Buffer。当某个位置写入成功的时候，便把 Availble Buffer 相应的位置置位，标记为写入成功。读取的时候，会遍历 Available Buffer，来判断元素是否已经就绪。<br><a name="XHwEt"></a></p><h5 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h5><p>生产者多线程写入的情况会复杂很多：</p><p>申请读取到序号n；<br />若 writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从 reader cursor 开始读取 available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；<br />消费者读取元素。<br />如下图所示，读线程读到下标为 2 的元素，三个线程 Writer1/Writer2/Writer3 正在向 RingBuffer 相应位置写数据，写线程被分配到的最大元素下标是 11。</p><p>读线程申请读取到下标从3到11的元素，判断 writer cursor&gt;=11。然后开始读取 availableBuffer，从 3 开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p><p>然后，消费者读取下标从 3 到 6 共计 4 个元素（多个生产者情况下，消费者消费过程示意图）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240468257-7e87656e-2609-4e11-892c-80c9499fcbfb.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=439&id=u20b89bf1&originHeight=1278&originWidth=1538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=186527&status=done&style=none&taskId=u6c6dc0d3-e25c-4be8-b703-9df811896ab&title=&width=528" alt="8-modified.png"></p><p><a name="H7wxf"></a></p><h5 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h5><p>多个生产者写入的时候：</p><ol><li>申请写入 m 个元素；</li><li>若是有 m 个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li><li>生产者写入元素，写入元素的同时设置 available Buffer 里面相应的位置，以标记自己哪些位置是已经写入成功的。</li></ol><p>如下图所示，Writer1 和 Writer2 两个线程写入数组，都申请可写的数组空间。Writer1 被分配了下标 3 到下表 5 的空间，Writer2 被分配了下标 6 到下标 9 的空间。<br />Writer1 写入下标 3 位置的元素，同时把 available Buffer 相应位置置位，标记已经写入成功，往后移一位，开始写下标 4 位置的元素。Writer2 同样的方式。最终都写入完成。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240479384-12ad2519-4832-4a2f-b322-be738d75bd89.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=454&id=ue940e65d&originHeight=1216&originWidth=1544&originalType=binary&ratio=2&rotation=0&showTitle=false&size=170725&status=done&style=none&taskId=uf080f650-c299-46f0-ab23-8b0a327bde7&title=&width=576" alt="9-modified.png"></p><p><a name="zLdit"></a></p><h3 id="解决伪共享的问题"><a href="#解决伪共享的问题" class="headerlink" title="解决伪共享的问题"></a>解决伪共享的问题</h3><p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可即缓存行填充（Padding），使一个对象占用的内存大小刚好为64bytes或它的整数倍，这样就保证了一个缓存行里不会有多个对象，这其实是一种以空间换时间的方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689237986676-153e1cdb-479e-47d0-9dba-e8146605e61a.png#averageHue=%232c2c2b&clientId=u294810c7-fb47-4&from=paste&height=433&id=ud05fae06&originHeight=866&originWidth=1384&originalType=binary&ratio=2&rotation=0&showTitle=false&size=90326&status=done&style=none&taskId=u010ab547-b40b-4b4e-a891-4c20e58822c&title=&width=692" alt="image.png"></p><p>而Sequence选择继承PhsPadding：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238216429-1e66812a-2ce7-40f6-9ff1-9c858e9cec60.png#averageHue=%232c2b2b&clientId=u294810c7-fb47-4&from=paste&height=639&id=u129d6da7&originHeight=1278&originWidth=1688&originalType=binary&ratio=2&rotation=0&showTitle=false&size=180493&status=done&style=none&taskId=uc4925b8e-d6e1-4cf4-9dc3-ebbf22379c1&title=&width=844" alt="image.png"></p><p>Sequence实际value变量的左右均被填充了7个long型变量，其自身也是long型变量，一个long型变量占据8个字节，所以序号与他上一个/下一个序号之间的最小内存距离为：158=120byte，加上对象头的8个字节，可以确保sequence大小128byte=264byte（有的CPU缓存行是128byte）<br />这样直接的代价就是增大的15倍的内存消耗空间，这样的设计导致不可能有两个cursor出现在同一个cpu cache line中, 就解决了”伪共享”问题。</p><p><a name="b5l5B"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后，官网也提供了很多测试用例：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241111749-4f61900f-733d-42ca-9517-7d8816ab5e9b.png#averageHue=%23745e3e&clientId=u294810c7-fb47-4&from=paste&height=631&id=u2b078ad4&originHeight=1262&originWidth=2372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=354512&status=done&style=none&taskId=uc7f47b10-d568-47a6-a524-bfaaf2ab59b&title=&width=1186" alt="image.png"><br><a name="h9Ao1"></a></p><h2 id="延迟性能测试"><a href="#延迟性能测试" class="headerlink" title="延迟性能测试"></a>延迟性能测试</h2><blockquote><p>To measure latency we take the three stage pipeline and generate events at less than saturation. This is achieved by waiting 1 microsecond after injecting an event before injecting the next and repeating 50 million times. To time at this level of precision it is necessary to use time stamp counters from the CPU. We chose CPUs with an invariant TSC because older processors suffer from changing frequency due to power saving and sleep states. Intel Nehalem and later processors use an invariant TSC which can be accessed by the latest Oracle JVMs running on Ubuntu 11.04. No CPU binding has been employed for this test. For comparison we use the ArrayBlockingQueue once again. We could have used ConcurrentLinkedQueueviii which is likely to give better results but we want to use a bounded queue implementation to ensure producers do not outpace consumers by creating back pressure. The results below are for 2.2Ghz Core i7-2720QM running Java 1.6.0_25 64-bit on Ubuntu 11.04. Mean latency per hop for the Disruptor comes out at 52 nanoseconds compared to 32,757 nanoseconds for ArrayBlockingQueue. Profiling shows the use of locks and signalling via a condition variable are the main cause of latency for the ArrayBlockingQueue.</p></blockquote><p>为了测量延迟，我们采用三级管道并在低于饱和度的情况下生成事件。这是通过在注入一个事件之后等待 1 微秒，然后再注入下一个事件并重复 5000 万次来实现的。为了达到这种精度水平，必须使用 CPU 的时间戳计数器。我们选择具有不变 TSC 的 CPU，因为较旧的处理器会因省电和睡眠状态而发生频率变化。Intel Nehalem 及更高版本的处理器使用不变的 TSC，可由 Ubuntu 11.04 上运行的最新 Oracle JVM 访问。此测试未使用 CPU 绑定。为了进行比较，我们再次使用 ArrayBlockingQueue。我们本可以使用 ConcurrentLinkedQueueviii，它可能会提供更好的结果，但我们希望使用有界队列实现来确保生产者不会因产生背压而超过消费者。以下结果适用于在 Ubuntu 11.04 上运行 Java 1.6.0_25 64 位的 2.2Ghz Core i7-2720QM。Disruptor 的每跳平均延迟为 52 纳秒，而 ArrayBlockingQueue 的平均每跳延迟为 32,757 纳秒。分析显示，使用锁和通过条件变量发送信号是 ArrayBlockingQueue 延迟的主要原因。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241005080-b62ef96a-8687-4c10-95b5-5cd418cf4500.png#averageHue=%23fafaf9&clientId=u294810c7-fb47-4&from=paste&height=315&id=ub74af72d&originHeight=630&originWidth=2000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=112876&status=done&style=none&taskId=u6f04c628-8884-4568-b617-d8c2d0d0ecc&title=&width=1000" alt="image.png"><br><a name="oXwBS"></a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Disruptor是一个高性能、低延迟的并发框架，源自LMAX公司，主要用于实现开发者在多线程程序中无锁队列的操作。ArrayBlockingQueue则是一个基于数组实现的有界阻塞队列，是Java标准库中的一个组件。两者各有优点和局限性，具体如下：</p><p>根据上面的分析，可以得出一个结论，Disruptor的性能远高于ArrayBlockingQueue。Disruptor采用一种基于环形数组的数据结构（RingBuffer），通过适当的同步策略和无锁优化技术，实现了非常高的并发性能。因此，在高并发、低延迟场景下，Disruptor的吞吐量和延迟表现显著优于ArrayBlockingQueue。相比之下，ArrayBlockingQueue基于传统的锁和条件变量机制，性能较低、延迟能力有限。<br />但是，相对而言，想要更高的性能吗，就不得不放弃易用。，Disruptor编写相对复杂，可读性较差。由于Disruptor采用了更为底层的原理并使用了许多高级优化技术，例如缓存行填充，预分配对象，内存屏障等，使得其代码实现较为复杂，不易上手。而ArrayBlockingQueue实现相对简单，开发者能更容易理解和使用其原理。<br />最后，Disruptor对依赖环境要求较高。Disruptor的优化策略需要在特定的运行环境下生效，例如，其环形数组的大小需要设置为2的次幂，以充分利用硬件缓存。此外，Disruptor优化适用于JAVA SE环境，在ANDROID等其他环境尚未被广泛验证。而ArrayBlockingQueue作为JDK内置组件，在不同平台环境下的兼容性和稳定性更优。<br />所以，可以得出一个结论，Disruptor与ArrayBlockingQueue在性能、易用性和兼容性方面存在差异。若应用场景追求极致的并发性能、低延迟并能承担较高的开发成本，应选择Disruptor。但若应用场景对性能要求较低，需要简单、易用且兼容性强的阻塞队列，ArrayBlockingQueue则是更好的选择。总之，开发者需要根据实际需求权衡两者的优势和劣势。<br />写到这里，我想起了计算机界的经典名言：*<em>没有银弹  *</em>。意思是没有什么东西是最好最有效而又没有任何缺点的。<br />在软件工程中也是一样，没有最好的技术，只有最合适的技术。面对不同的场景，应该使用更加适合这个场景的技术，这样才能使得效率提高。我想，如何将手中的知识掌握好，然后在合适的环境中发挥它的效果，不仅仅是技术中的艺术，也是软件的工程。</p><p><a name="p6ZMt"></a></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><blockquote><p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started</a></p></blockquote><p>结合用例写一个demo<br />事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"LongEvent&#123;"</span> + <span class="string">"value="</span> + value + <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.ringBuffer 事件队列 下一个槽</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        Long data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.取出空的事件队列</span></span><br><span class="line">            LongEvent longEvent = ringBuffer.get(sequence);</span><br><span class="line">            data = byteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//3.获取事件队列传递的数据</span></span><br><span class="line">            longEvent.setValue(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者准备发送数据："</span>);</span><br><span class="line">            <span class="comment">//4.发布事件</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LongEventMain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F; 2.创建工厂</span><br><span class="line">        EventFactory&lt;LongEvent&gt; eventFactory &#x3D; new LongEventFactory();</span><br><span class="line">        &#x2F;&#x2F; 3.创建ringBuffer 大小</span><br><span class="line">        int ringBufferSize &#x3D; 1024 * 1024; &#x2F;&#x2F; ringBufferSize大小一定要是2的N次方</span><br><span class="line">        &#x2F;&#x2F; 4.创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,</span><br><span class="line">                ProducerType.SINGLE, new YieldingWaitStrategy());</span><br><span class="line">        &#x2F;&#x2F; 5.连接消费端方法</span><br><span class="line">        disruptor.handleEventsWith(new LongEventHandler());</span><br><span class="line">        &#x2F;&#x2F; 6.启动</span><br><span class="line">        disruptor.start();</span><br><span class="line">        &#x2F;&#x2F; 7.创建RingBuffer容器</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line">        &#x2F;&#x2F; 8.创建生产者</span><br><span class="line">        LongEventProducer producer &#x3D; new LongEventProducer(ringBuffer);</span><br><span class="line">        &#x2F;&#x2F; 9.指定缓冲区大小</span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;</span><br><span class="line">            byteBuffer.putLong(0, i);</span><br><span class="line">            producer.onData(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;10.关闭disruptor和executor</span><br><span class="line">        disruptor.shutdown();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689236784814-f6573ce5-7ae5-4dbb-8ab5-23494429c7db.png#averageHue=%23313131&clientId=u294810c7-fb47-4&from=paste&height=219&id=uc5f85ba0&originHeight=438&originWidth=1228&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67544&status=done&style=none&taskId=u9e26cf5a-6617-4ad3-ac64-93a6fc72847&title=&width=614" alt="image.png"><br /></p><p><a name="Ohdad"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_memory_barriers" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/disruptor.html</a><br><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a><br><a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/</a><br><a href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/18/disruptor.html</a><br><a href="https://zhuanlan.zhihu.com/p/229338771" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/229338771</a><br><a href="https://zhuanlan.zhihu.com/p/513468454" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/513468454</a><br><a href="https://qin.news/disruptor/" target="_blank" rel="noopener">https://qin.news/disruptor/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;oYoyt&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易</summary>
      
    
    
    
    
    <category term="队列" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="Disruptor" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>实现Spring框架中的IOC和AOP</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/</id>
    <published>2023-01-05T05:59:20.000Z</published>
    <updated>2023-03-26T16:39:37.398Z</updated>
    
    <content type="html"><![CDATA[<p><a name="Bk5lF"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a><br /></h1><p><a name="vHThd"></a></p><h1 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h1><p><a name="GCsad"></a></p><h2 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h2><p>我们知道Java 是一门面向对象的语言，在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586204787-8e47e2aa-7ad0-4df8-8c02-ab5b48ccf51b.png#averageHue=%23fcfcfc&clientId=u426a4097-24c8-4&from=paste&height=271&id=u2625783a&name=image.png&originHeight=406&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62561&status=done&style=none&taskId=u59dd5fa3-6a83-4d1d-a27d-f26295c1a96&title=&width=388" alt="image.png"></p><p>这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586265815-d527e12e-f00d-495f-ae51-7e3e8d3cdf8e.png#averageHue=%23fdfdfd&clientId=u426a4097-24c8-4&from=paste&height=265&id=ud4222345&name=image.png&originHeight=398&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48632&status=done&style=none&taskId=u1d036425-b7d4-4fd4-94b3-985ef332386&title=&width=400.6666666666667" alt="image.png"></p><p>这个时候我们发现，我们类之间的关系都由 IoC 框架负责维护类，同时将类注入到需要的类中。也就是类的使用者只负责使用，而不负责维护。把专业的事情交给专业的框架来完成。大大的减少开发的复杂度。<br><a name="KMNbL"></a></p><h2 id="IOC的实现步骤"><a href="#IOC的实现步骤" class="headerlink" title="IOC的实现步骤"></a>IOC的实现步骤</h2><ol><li>初始化 IoC 容器。</li><li>读取配置文件。</li><li>将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition</li><li>利用数据结构依次实例化相应的对象</li><li>注入对象之间的依赖关系</li></ol><p><a name="iZZUZ"></a></p><h2 id="bean-定义了框架的数据结构"><a href="#bean-定义了框架的数据结构" class="headerlink" title="bean 定义了框架的数据结构"></a>bean 定义了框架的数据结构</h2><p>定义了bean的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] interfaceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;PropertyArg&gt; propertyArgs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了对象的 name，class的名称。如果是接口的实现，还有该对象实现的接口。以及构造函数的传参的列表 constructorArgs 和需要注入的参数列表 propertyArgs</p><p><a name="rgpUm"></a></p><h2 id="Utils工具包"><a href="#Utils工具包" class="headerlink" title="Utils工具包"></a>Utils工具包</h2><p><a name="pETF3"></a></p><h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefultClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefultClassLoader().loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ClassUtils，提供了两个静态方法：</p><ol><li>getDefultClassLoader() 方法返回当前线程的上下文类加载器（Context Class Loader）；</li><li>loadClass(String className) 方法用于根据类名加载对应的 Class 对象，首先调用 getDefultClassLoader() 方法获取默认的类加载器，然后使用该类加载器加载指定的类。如果指定的类名不存在，该方法将会打印异常栈信息，并返回 null。</li></ol><p>这个工具类可以方便地加载任何类，尤其在使用反射技术时非常有用，因为你可以通过类名动态地获取 Class 对象。同时，由于使用了线程的上下文类加载器，也可以避免一些类加载器隔离的问题。<br><a name="Hd0uf"></a></p><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instanceByCglib</span><span class="params">(Class&lt;T&gt; clz,Constructor ctr,Object[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clz);</span><br><span class="line">        enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ctr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create(ctr.getParameterTypes(),args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 BeanUtils，提供了一个静态方法 instanceByCglib，用于创建对象。具体而言：</p><ol><li>Class<T> 参数表示要创建的对象的类；</li><li>Constructor 参数表示要使用的构造方法，可以为 null；</li><li>Object[] 参数表示构造方法的参数数组，如果 Constructor 参数为 null，则此参数也应为 null。</li></ol><p>该方法使用 CGLIB 库创建对象。首先创建一个 Enhancer 对象，并设置其父类为 clz，然后设置回调为 NoOp.INSTANCE，这意味着创建的对象不会被代理。如果 ctr 为 null，则直接通过 enhancer.create() 创建对象，否则通过 enhancer.create(ctr.getParameterTypes(), args) 使用指定的构造方法创建对象。</p><p>CGLIB 是一个基于 ASM 库的代码生成库，可以用于创建动态代理、增强类等。在本代码中，CGLIB 用于创建对象并调用构造方法。这种方式相对于使用 new 运算符创建对象，具有更高的灵活性和动态性。</p><p><a name="Ts732"></a></p><h4 id="用法举例：AOP"><a href="#用法举例：AOP" class="headerlink" title="用法举例：AOP"></a>用法举例：AOP</h4><p>这个也是aop的用法<br />在cglib包下，Enhancer这个类的作用是为指定的类创建代理类。具体来说，Enhancer类可以动态地生成一个指定类的子类，该子类可以用来拦截指定类中的方法调用，从而实现代理模式。<br />Enhancer类的使用方法类似于Java动态代理中的Proxy类。首先，需要创建一个Enhancer对象，并设置要代理的目标类和回调方法。然后，通过调用Enhancer对象的create方法，生成代理类的实例。这个代理类会继承目标类，同时实现回调方法，从而实现对目标类方法的拦截和处理。<br />Enhancer类的使用比较灵活，可以代理任意的类，包括没有实现任何接口的类。但是，由于Enhancer是通过生成目标类的子类来实现代理的，所以目标类必须有默认的构造函数，并且不能是final类。<br />假设我们有一个简单的UserService接口，其中定义了一个getUser方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想为该接口创建一个代理类，记录getUser方法的调用次数。我们可以使用cglib的Enhancer类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceProxy(target));</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getUser"</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个UserServiceProxy类，它实现了MethodInterceptor接口，用于拦截目标对象的方法调用。在构造方法中，我们传入了目标对象target，并使用Enhancer类生成一个UserService的代理对象。在intercept方法中，我们记录了getUser方法的调用次数，并使用MethodProxy类来调用目标对象的对应方法。<br />接下来，我们可以使用该代理类来调用getUser方法，并检查调用次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = UserServiceProxy.createProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">userService.getUser(<span class="number">1</span>);</span><br><span class="line">userService.getUser(<span class="number">2</span>);</span><br><span class="line">System.out.println(userService.getCount()); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们首先使用createProxy方法创建了UserService的代理对象，并调用了getUser方法两次。最后，我们打印了代理对象的调用次数，发现它的确记录了两次getUser方法的调用。<br /><strong>它为什么要这么做呢，直接new难道不行吗？</strong><br />使用代理模式的一个主要目的是在不改变原有代码的情况下，为现有对象添加额外的行为或功能。在上面的例子中，我们通过使用cglib的Enhancer类创建了一个代理对象，使得我们可以在不修改原有UserServiceImpl类的情况下，为getUser方法添加了记录调用次数的功能。<br />如果直接new一个新的对象，虽然可以实现类似的功能，但是需要对原有代码进行修改，将原有的对象替换成新的对象，这样就不太符合“开闭原则”，即对扩展开放，对修改关闭的设计原则。同时，在某些情况下，我们可能无法直接访问到原有对象的构造函数，这就导致了不能直接创建新对象的限制。<br />使用代理模式，可以通过创建代理对象来扩展原有对象的行为，而不需要修改原有对象的代码。同时，代理对象还可以在原有对象的基础上增加额外的行为，提高代码的可扩展性和可维护性。</p><p><a name="uyyXf"></a></p><h3 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectField</span><span class="params">(Field field,Object obj,Object value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ReflectionUtils，提供了一个静态方法 injectField，用于设置某个对象的属性值。具体而言：</p><ol><li>Field 参数表示要设置的属性的字段；</li><li>Object 参数表示要设置属性值的对象；</li><li>Object 参数表示要设置的属性值。</li></ol><p>该方法首先判断 field 是否为空，如果不为空则将其设置为可访问，然后使用 field.set(obj, value) 方法设置对象的属性值。如果属性为 final 修饰的静态变量，则此方法将无法修改其值。</p><p>这个工具类可以方便地在代码中设置对象的属性值，尤其在使用反射技术时非常有用，因为你可以通过反射动态修改对象的属性。但是，使用反射技术也有一些缺点，例如性能较低、容易引起安全问题等，需要谨慎使用。<br><a name="UZCBE"></a></p><h3 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a>JsonUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*JsonUtils 的作用就是为了解析我们的json配置文件。代码比较长，与我们的 IoC 原理关系不大*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is,Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is,cls);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">writeValue</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] writeByteValue(Object entity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsBytes(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line">        mapper.getDeserializationConfig().withoutFeatures(<span class="keyword">new</span> DeserializationFeature[]&#123;DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES&#125;);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_YAML_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类，封装了基于Jackson库的Json序列化和反序列化功能。具体作用如下：</p><ul><li>定义了一个ObjectMapper对象，用于将Java对象转化为JSON格式，或将JSON格式转化为Java对象。</li><li>提供了多个readValue()和writeValue()方法，用于不同类型之间的转化。其中，readValue()方法支持将JSON格式的字符串、输入流或字节数组反序列化成Java对象，而writeValue()方法则将Java对象序列化成JSON格式的字符串或字节数组。</li><li>设置了一些序列化和反序列化的配置，如格式化输出、忽略空值、支持单引号、允许注释等。</li><li>如果反序列化失败，则返回null</li></ul><p><a name="fz6Ke"></a></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>先定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有对应的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryImpl</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefineMap= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//查找对象是否已经实例化过</span></span><br><span class="line">        Object bean = beanMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环依赖问题</span></span><br><span class="line">        Object earlyBean = earlySingletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span> (earlyBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生了循环依赖，提前返回尚未加载完成的bean:"</span> + name);</span><br><span class="line">            <span class="keyword">return</span> earlyBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有实例化，那就需要调用createBean来创建对象</span></span><br><span class="line">        BeanDefinition beanDefinition = beanDefineMap.get(name);</span><br><span class="line">        bean = createBean(beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为了解决循环依赖，先添加到早期单例中</span></span><br><span class="line">            earlySingletonObjects.put(name, bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对象创建成功以后，注入对象需要的参数</span></span><br><span class="line">            populateBean(bean,beanDefinition);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再吧对象存入Map中方便下次使用。</span></span><br><span class="line">            beanMap.put(name,bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从早期单例Map中移除</span></span><br><span class="line">            earlySingletonObjects.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束返回</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, BeanDefinition bd)</span></span>&#123;</span><br><span class="line">        beanDefineMap.put(name,bd);</span><br><span class="line">        beanNameSet.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String beanName = beanDefinition.getClassName();</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        Class&lt;?&gt; clz = ClassUtils.loadClass(beanName);</span><br><span class="line">        <span class="keyword">if</span>(clz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"can not find bean by beanName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取构造器参数</span></span><br><span class="line">        List&lt;ConstructorArg&gt; constructorArgs = beanDefinition.getConstructorArgs();</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty())&#123;</span><br><span class="line">            List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConstructorArg constructorArg : constructorArgs) &#123;</span><br><span class="line">                <span class="comment">//放入Map</span></span><br><span class="line">                objects.add(getBean(constructorArg.getRef()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,clz.getConstructor(),objects.toArray());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(Object bean, BeanDefinition bd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;PropertyArg&gt; propertyArgs = bd.getPropertyArgs();</span><br><span class="line">        <span class="keyword">if</span> (propertyArgs != <span class="keyword">null</span> &amp;&amp; !propertyArgs.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历在json中配置的属性</span></span><br><span class="line">            <span class="keyword">for</span> (PropertyArg arg : propertyArgs) &#123;</span><br><span class="line">                String propertyName = arg.getName();</span><br><span class="line">                String value = arg.getValue();</span><br><span class="line">                String ref = arg.getRef();</span><br><span class="line">                Object injectValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接赋值</span></span><br><span class="line">                    injectValue = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(ref)) &#123;</span><br><span class="line">                    <span class="comment">//获取bean</span></span><br><span class="line">                    injectValue = getBean(ref);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">                method.invoke(bean, injectValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取具体某个属性的setter方法</span></span><br><span class="line"><span class="comment">     * 此处做法比较简单粗暴</span></span><br><span class="line"><span class="comment">     * 实际上Spring在读取配置文件时就已经将各属性，方法，getter/setter都读取好了。</span></span><br><span class="line"><span class="comment">     * 在这就只需要调用BeanWrapper的方法来为属性赋值就可以了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getPropertySetter</span><span class="params">(BeanDefinition bd, String propertyName, Object injectValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = Class.forName(bd.getClassName());</span><br><span class="line">        Class&lt;?&gt; injectClazz = injectValue.getClass();</span><br><span class="line">        Class&lt;?&gt; supClass = injectValue.getClass().getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (supClass != <span class="keyword">null</span> &amp;&amp; supClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            injectClazz = supClass;</span><br><span class="line">        &#125;</span><br><span class="line">        propertyName = propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">        Method setter = beanClass.getMethod(<span class="string">"set"</span> + propertyName, injectClazz);</span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了一个简单的Bean工厂，主要功能是通过Bean的名字获取Bean的实例，实现了Bean的创建、注入属性和循环依赖的处理。</p><p>其中，BeanFactoryImpl类实现了BeanFactory接口，定义了三个ConcurrentHashMap类型的变量，分别用来存储Bean实例、Bean定义和Bean名称集合。它还包含了一个earlySingletonObjects成员变量，用来处理循环依赖的问题。</p><p><a name="TT8Dj"></a></p><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><p>getBean 方法是 Spring 框架中的一个核心方法，用于从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例。该方法接收一个参数 name，表示需要获取的 Bean 的名称。该方法会根据给定的名称先在 BeanFactory 中查找是否已经有该名称对应的 Bean 实例，如果没有找到，则尝试创建一个新的实例并将其注册到 BeanFactory 中。<br />在实现类 BeanFactoryImpl 中，该方法会先从 beanMap 中查找是否已经有该名称对应的 Bean 实例，如果找到了则直接返回该实例。如果没有找到，则需要通过 createBean 方法创建一个新的实例。在创建实例之前，该方法会检查 earlySingletonObjects 中是否已经有该名称对应的早期单例对象，如果有则说明存在循环依赖的问题，此时会返回早期单例对象，避免出现死锁的情况。<br />getBean 方法会调用 createBean 方法创建 Bean 实例，然后调用 populateBean 方法为实例注入需要的属性。在注入属性之后，该方法会将创建好的 Bean 实例注册到 beanMap 中，以备下次获取时直接返回。<br />总之，getBean 方法的作用是从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例，如果找不到则创建一个新的实例，并且可以解决循环依赖的问题。<br><a name="qkBoo"></a></p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>createBean 方法的作用是通过传入的 BeanDefinition 对象，使用反射来实例化一个 Java 对象，并返回该对象的实例。该方法首先通过 BeanDefinition 对象中的类名获取该类的 Class 对象，然后根据该对象获取相应的构造函数，如果有构造函数的参数，则递归调用 getBean 方法获取构造函数的参数，最后使用 CGLIB 库的 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果构造函数没有参数，则直接使用 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果获取 Class 对象失败，会抛出异常。<br><a name="kaiGR"></a></p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>populateBean方法的作用是为一个JavaBean对象注入它所依赖的其他对象或属性，这些对象或属性在BeanDefinition中被定义，并且在配置文件中被配置好。populateBean方法会根据BeanDefinition中的属性列表，将对应的属性值设置到JavaBean对象中。属性的值可能是简单类型的值，也可能是其他JavaBean对象的引用。<br />具体而言，populateBean方法会遍历BeanDefinition中的属性列表，对于每一个属性，它会根据属性的名称、值或引用，找到JavaBean对象中对应的setter方法，然后调用该方法将属性值设置到JavaBean对象中。需要注意的是，setter方法的名称是根据属性名生成的，例如，如果属性名是foo，那么setter方法的名称就是setFoo。<br />populateBean方法的实现比较简单粗暴，实际上，Spring框架在读取配置文件时已经将各属性、方法、getter/setter都读取好了，并且使用了更加高效和灵活的方式来为JavaBean对象注入属性值。</p><p>这两行代码的作用是为一个Java Bean对象的属性赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">method.invoke(bean, injectValue);</span><br></pre></td></tr></table></figure><p>第一行代码使用getPropertySetter方法获取一个指定属性的Setter方法。getPropertySetter方法根据属性名称、注入值类型和Bean定义，动态地获取该属性的Setter方法。这里使用反射机制，构造出要调用的方法，以便在第二行代码中使用。<br />第二行代码使用反射机制调用Java Bean对象的Setter方法，并把该属性的值作为参数传入。这里的bean是要赋值的Java Bean对象，injectValue是要注入的值。<br><a name="E6WQy"></a></p><h3 id="getPropertySetter"><a href="#getPropertySetter" class="headerlink" title="getPropertySetter"></a>getPropertySetter</h3><p>getPropertySetter方法的作用是根据传入的BeanDefinition、属性名和属性值，获取对应的setter方法，并返回该方法。在populateBean方法中，会根据BeanDefinition中配置的属性名、属性值以及对应的setter方法，将属性值设置到对象中，实现对对象属性的注入。getPropertySetter方法通过反射获取类的setter方法，并根据属性值的类型确定setter方法的参数类型，最终返回setter方法，供populateBean方法调用。<br><a name="ptLbT"></a></p><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>这段代码实现了一个简单的 Bean 工厂。主要功能包括：</p><ol><li>实现了 BeanFactory 接口，提供了 getBean() 方法来获取指定名称的 Bean 实例。</li><li>实现了注册 BeanDefinition 的方法 registerBean()，用来将 BeanDefinition 存储到 Map 中。</li><li>使用 ConcurrentHashMap 来存储 Bean 实例对象和 BeanDefinition 对象。</li><li>支持循环依赖。通过使用 ConcurrentHashMap 存储早期的 Bean 实例对象，解决了循环依赖问题。</li><li>支持注入属性。通过在 BeanDefinition 中配置 PropertyArg 属性参数列表，来对 Bean 实例对象进行属性注入。</li><li>支持构造器注入。通过在 BeanDefinition 中配置 ConstructorArg 构造器参数列表，来对 Bean 实例对象进行构造器注入。</li><li>支持通过反射创建 Bean 实例对象，使用 CGLib 动态代理技术生成代理对象。</li></ol><p>总体来说，这段代码实现了一个简单的 IoC 容器，能够解决基本的 Bean 创建、管理和依赖注入的问题。但是这个容器还有一些限制，例如只支持单例模式、只支持 setter 注入、只能通过 BeanDefinition 来配置 Bean 等等。真正的 IoC 容器，例如 Spring，还有更多更复杂的功能和特性。</p><p><a name="zPI4R"></a></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        loadFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = JsonUtils.readValue(is,<span class="keyword">new</span> TypeReference&lt;List&lt;BeanDefinition&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(beanDefinitions != <span class="keyword">null</span> &amp;&amp; !beanDefinitions.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">                registerBean(beanDefinition.getName(), beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为JsonApplicationContext的类，继承了BeanFactoryImpl类。JsonApplicationContext类的作用是通过从Json文件中读取bean定义来初始化IoC容器。它包含了一个构造方法和两个私有方法：init()和loadFile()。<br />构造方法JsonApplicationContext(String fileName)接收Json文件的名称，并将其存储在fileName变量中。<br />方法init()用于初始化IoC容器，它调用了loadFile()方法从Json文件中加载bean定义。<br />方法loadFile()用于加载Json文件并注册bean定义到IoC容器中。它首先通过当前线程的类加载器获取Json文件的输入流，然后通过JsonUtils.readValue()方法将输入流转换成BeanDefinition对象列表。最后，它遍历BeanDefinition列表，并调用registerBean()方法注册bean定义到IoC容器中。<br />总之，这段代码是一个简单的IoC容器实现，它可以从Json文件中读取bean定义，并将其注册到容器中，以供应用程序使用。<br><a name="ADAO4"></a></p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679590784248-a8543b7e-dd3d-46b8-abdd-300c77964292.png#averageHue=%23f5f3f2&clientId=u426a4097-24c8-4&from=paste&height=209&id=u14ed6355&name=image.png&originHeight=313&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27393&status=done&style=none&taskId=u042025fc-fe77-4110-8479-550549e9f78&title=&width=651.3333333333334" alt="image.png"></p><p><a name="P6I4h"></a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br /></h2><p><a name="fFT0I"></a></p><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><br /></h1><p><a name="xvv2L"></a></p><h1 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h1><p><a name="lvOkY"></a></p><h2 id="Aop-是什么"><a href="#Aop-是什么" class="headerlink" title="Aop 是什么"></a>Aop 是什么</h2><p>面向切面的程序设计（aspect-oriented programming，AOP）。通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。</p><p><a name="rbIL5"></a></p><h2 id="为什么需要使用Aop"><a href="#为什么需要使用Aop" class="headerlink" title="为什么需要使用Aop"></a>为什么需要使用Aop</h2><p>面向切面编程，实际上就是通过预编译或者动态代理技术在不修改源代码的情况下给原来的程序统一添加功能的一种技术。我们看几个关键词，第一个是“动态代理技术”，这个就是Spring Aop实现底层技术。第二个“不修改源代码”，这个就是Aop最关键的地方，也就是我们平时所说的非入侵性。。第三个“添加功能”，不改变原有的源代码，为程序添加功能。</p><p>举个例子：如果某天你需要统计若干方法的执行时间，如果不是用Aop技术，你要做的就是为每一个方法开始的时候获取一个开始时间，在方法结束的时候获取结束时间。二者之差就是方法的执行时间。如果对每一个需要统计的方法都做如上的操作，那代码简直就是灾难。如果我们使用Aop技术，在不修改代码的情况下，添加一个统计方法执行时间的切面。代码就变得十分优雅。具体这个切面怎么实现？<br />Spring Aop实现的代码非常非常的绕。也就是说 Spring 为了灵活做了非常深层次的抽象。同时 Spring为了兼容 @AspectJ 的Aop协议，使用了很多 Adapter （适配器）模式又进一步的增加了代码的复杂程度。<br />Spring 的 Aop 实现主要以下几个步骤：</p><ol><li>初始化 Aop 容器。</li><li>读取配置文件。</li><li>将配置文件装换为 Aop 能够识别的数据结构 – Advisor。这里展开讲一讲这个advisor。Advisor对象中包又含了两个重要的数据结构，一个是 Advice，一个是 Pointcut。Advice的作用就是描述一个切面的行为，pointcut描述的是切面的位置。两个数据结的组合就是”在哪里，干什么“。这样 Advisor 就包含了”在哪里干什么“的信息，就能够全面的描述切面了。</li><li>Spring 将这个 Advisor 转换成自己能够识别的数据结构 – AdvicedSupport。Spirng 动态的将这些方法拦截器织入到对应的方法。</li><li>生成动态代理代理。</li><li>提供调用，在使用的时候，调用方调用的就是代理方法。也就是已经织入了增强方法的方法</li></ol><p><a name="acqJR"></a></p><h2 id="Invocation"><a href="#Invocation" class="headerlink" title="Invocation"></a>Invocation</h2><p>先定义好方法调用接口和代理方法调用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] getArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理方法的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyMethodInvocation</span> <span class="keyword">extends</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="AkGkM"></a></p><h3 id="CglibMethodInvocation"><a href="#CglibMethodInvocation" class="headerlink" title="CglibMethodInvocation"></a>CglibMethodInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title">ReflectioveMethodeInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibMethodInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(proxy, target, method, arguments, interceptorList);</span><br><span class="line">        <span class="keyword">this</span>.methodProxy = methodProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是定义了一个基于CGLIB动态代理的方法调用类CglibMethodInvocation，它继承了ReflectiveMethodeInvocation类，其中包含了目标对象、目标方法、方法参数以及一组方法拦截器，它们一起构成了一个完整的方法调用链。CglibMethodInvocation在父类的基础上增加了一个MethodProxy类型的属性methodProxy，并重写了invokeOriginal()方法，该方法使用methodProxy对象调用目标方法，实现了方法的调用。该类主要在AOP中使用，用于执行目标方法，并将方法拦截器应用于目标方法之前或之后的操作。</p><p><a name="G0Nbp"></a></p><h3 id="ReflectioveMethodeInvocation"><a href="#ReflectioveMethodeInvocation" class="headerlink" title="ReflectioveMethodeInvocation"></a>ReflectioveMethodeInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectioveMethodeInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectioveMethodeInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] arguments = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行完所有的拦截器后，执行目标方法</span></span><br><span class="line">        <span class="keyword">if</span>(currentInterceptorIndex == <span class="keyword">this</span>.interceptorList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeOriginal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代的执行拦截器。回顾上面的讲解，我们实现的拦击都会执行 im.proceed() 实际上就在调用这个方法。</span></span><br><span class="line">        AopMethodInterceptor interceptor = interceptorList.get(++currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invokeMethodUseReflection(target,method,arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基础的反射方法调用的实现类 ReflectiveMethodInvocation，实现了 ProxyMethodInvocation 接口。在 Spring 的 AOP 中，每个被拦截的方法都会被包装成一个 MethodInvocation，这个包装类里包含了目标对象、方法、参数等信息，并提供了一个 proceed 方法用来执行下一个拦截器或目标方法。</p><p>ReflectiveMethodInvocation 中的 proceed 方法主要用于按照拦截器链依次执行 AopMethodInterceptor 的拦截逻辑。如果拦截器都执行完成，最后就会调用 invokeOriginal 方法来执行目标方法。另外，这个类也提供了获取代理对象、获取方法、获取参数等方法。</p><p><a name="osu7V"></a></p><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeMethodAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeforeMethodAdvice advice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeforeMethodAdviceInterceptor</span><span class="params">(BeforeMethodAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        advice.before(mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterRunningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AfterRunningAdvice advice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterRunningAdviceInterceptor</span><span class="params">(AfterRunningAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnVal = mi.proceed();</span><br><span class="line">        advice.after(returnVal,mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <strong>mi.proceed()</strong>才是执行原有的方法。而advice我们上文就说过，是描述增强的方法”干什么“的数据结构，所以对于这个before拦截器，我们就把advice对应的增强方法放在了真正执行的方法前面。而对于after拦截器而言，就放在了真正执行的方法后面。<br />这里主要是定义拦截器，一个before，一个after。<br><a name="Kqika"></a></p><h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//干什么</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line">    <span class="comment">//在哪里</span></span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AopMethodInterceptor&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptor</span><span class="params">(AopMethodInterceptor interceptor)</span></span>&#123;</span><br><span class="line">        list.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptors</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptors)</span></span>&#123;</span><br><span class="line">        list.addAll(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个AdvisedSupport就是我们Aop框架能够理解的数据结构，这个时候问题就变成了<strong>对于哪个目标，增加哪些拦截器</strong>。这里的AopMethodInterceptor 是一个接口，before拦截器和after拦截器都实现了这个接口。都能够使用这个功能。<br><a name="a0X2d"></a></p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p><a name="yJ9IG"></a></p><h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] constructorArgTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; rootClass = advised.getTargetSource().getTagetClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)&#123;</span><br><span class="line">            classLoader = ClassUtils.getDefultClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(rootClass.getSuperclass());</span><br><span class="line">        <span class="comment">//增加拦截器的核心方法</span></span><br><span class="line">        Callback callbacks = getCallBack(advised);</span><br><span class="line">        enhancer.setCallback(callbacks);</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; constructorArgs.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> enhancer.create(constructorArgTypes,constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Callback <span class="title">getCallBack</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是实现 Cglib AOP 代理的核心逻辑。其中 CglibAopProxy 类实现了 AopProxy 接口，用于创建代理对象，而 AdvisedSupport 是 AOP 配置信息的载体。<br />具体来说，getProxy() 方法返回代理对象，getProxy(ClassLoader classLoader) 方法返回通过指定类加载器加载的代理对象。在这两个方法中，通过使用 CGLIB 提供的 Enhancer 类，实现代理对象的创建和设置拦截器。<br />在 getCallBack(AdvisedSupport advised) 方法中，通过将 AdvisedSupport 中的拦截器链和目标对象传递给 DynamicAdvisedInterceptor，最终得到一个 Callback 对象，它是 Enhancer 的回调函数。<br />回到 getProxy() 和 getProxy(ClassLoader classLoader) 方法，它们的核心是通过 Enhancer 的 setSuperclass 方法，设置代理对象的父类，然后通过 setCallback 方法，将 Callback 对象设置为拦截器。<br />在这个过程中，如果 constructorArgs 不为空，则使用带参数的 enhancer.create 方法创建代理对象。否则，使用不带参数的 enhancer.create 方法创建代理对象。<br />最后，通过调用 enhancer.create 方法返回代理对象。<br />看看核心方法：<br>:::info<br>//增加拦截器的核心方法<br />Callback callbacks = getCallBack(advised);<br>:::</p><blockquote><p>private Callback getCallBack(AdvisedSupport advised) {<br />    return new DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());<br />}</p></blockquote><p><a name="xdGBY"></a></p><h3 id="DynamicAdvisedInterceptor"><a href="#DynamicAdvisedInterceptor" class="headerlink" title="DynamicAdvisedInterceptor"></a>DynamicAdvisedInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptorList, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">        <span class="keyword">this</span>.targetSource = targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了CGLib动态代理中的拦截器，它实现了MethodInterceptor接口。在intercept方法中，它接收了被代理的对象(obj)、目标方法(method)、方法参数(args)以及方法代理(proxy)，然后使用这些参数创建一个CglibMethodInvocation对象，然后调用该对象的proceed()方法，实现拦截器的链式执行。这个拦截器类将所有的AOP拦截器封装成了一个拦截器链，同时传入了目标对象的引用(TargetSource)，以便执行目标方法。在实际调用的时候，这个拦截器会按照拦截器列表依次调用所有的拦截器，并在最后调用目标方法，实现了AOP拦截器的动态织入。</p><p>而其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法正是：<strong>CglibMethodInvocation</strong></p><p><a name="IBgca"></a></p><h2 id="AopBeanFactoryImpl"><a href="#AopBeanFactoryImpl" class="headerlink" title="AopBeanFactoryImpl"></a>AopBeanFactoryImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopBeanFactoryImpl</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AopBeanDefinition&gt; aopBeanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; aopBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object aopBean = aopBeanMap.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBeanDefinitionMap.containsKey(name))&#123;</span><br><span class="line">            AopBeanDefinition aopBeanDefinition = aopBeanDefinitionMap.get(name);</span><br><span class="line">            AdvisedSupport advisedSupport = getAdvisedSupport(aopBeanDefinition);</span><br><span class="line">            aopBean = <span class="keyword">new</span> CglibAopProxy(advisedSupport).getProxy();</span><br><span class="line">            aopBeanMap.put(name,aopBean);</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, AopBeanDefinition aopBeanDefinition)</span></span>&#123;</span><br><span class="line">        aopBeanDefinitionMap.put(name,aopBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AdvisedSupport <span class="title">getAdvisedSupport</span><span class="params">(AopBeanDefinition aopBeanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        List&lt;String&gt; interceptorNames = aopBeanDefinition.getInterceptorNames();</span><br><span class="line">        <span class="keyword">if</span>(interceptorNames != <span class="keyword">null</span> &amp;&amp; !interceptorNames.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (String interceptorName : interceptorNames) &#123;</span><br><span class="line"></span><br><span class="line">                Advice advice = (Advice) getBean(interceptorName);</span><br><span class="line"></span><br><span class="line">                Advisor advisor = <span class="keyword">new</span> Advisor();</span><br><span class="line">                advisor.setAdvice(advice);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> BeforeMethodAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = BeforeMethodAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> AfterRunningAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = AfterRunningAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">new</span> TargetSource();</span><br><span class="line"></span><br><span class="line">        Object object = getBean(aopBeanDefinition.getTarget());</span><br><span class="line"></span><br><span class="line">        targetSource.setTagetClass(object.getClass());</span><br><span class="line">        targetSource.setTagetObject(object);</span><br><span class="line"></span><br><span class="line">        advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisedSupport;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个AOP Bean Factory，它是一个扩展了普通Bean Factory的类，用于创建和管理AOP bean。该类继承了BeanFactoryImpl，并重写了getBean方法，用于检查所请求的Bean是否已经是AOP bean，如果是则返回AOP bean。如果不是AOP bean，则继续通过调用父类的getBean方法获取普通bean。AopBeanFactoryImpl还有registerBean方法，用于将定义的AOP bean注册到AOP Bean Factory的aopBeanDefinitionMap中。</p><p>在getAdvisedSupport方法中，它会创建一个AdvisedSupport对象，将目标对象和增强器（Advice）封装到Advisor对象中，并根据Advice类型将它们转化为对应的AopMethodInterceptor对象，然后将所有的AopMethodInterceptor对象添加到AdvisedSupport对象中。最后将目标对象封装到TargetSource对象中，并设置到AdvisedSupport对象中。然后返回AdvisedSupport对象。</p><p>当getBean方法检测到所请求的Bean是AOP bean时，它会从aopBeanDefinitionMap中获取Bean的定义，并创建相应的AdvisedSupport对象。然后创建一个CglibAopProxy对象，并使用该对象创建代理对象，最后将代理对象添加到aopBeanMap中。最终返回代理对象。</p><p><a name="BIrI3"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a name="mlhhh"></a></p><h3 id="TestClass"><a href="#TestClass" class="headerlink" title="TestClass"></a>TestClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"开始计时"</span>);</span><br><span class="line">        ThreadLocalUtils.set(startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印随机数值: "</span>+ UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndTimeAfterMethod</span> <span class="keyword">implements</span> <span class="title">AfterRunningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">after</span><span class="params">(Object returnVal, Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> startTime = ThreadLocalUtils.get();</span><br><span class="line">        ThreadLocalUtils.remove();</span><br><span class="line">        System.out.println(<span class="string">"方法耗时："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a test method"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JGPr2"></a></p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"beforeMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"StartTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"processMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"ProcessTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"afterMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"EndTimeAfterMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"TestService"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testServiceProxy"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"core.ProxyFactoryBean"</span>,</span><br><span class="line">    <span class="attr">"target"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"interceptorNames"</span>:[</span><br><span class="line">      <span class="string">"beforeMethod"</span>,</span><br><span class="line">      <span class="string">"processMethod"</span>,</span><br><span class="line">      <span class="string">"afterMethod"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a name="Z3M5m"></a></p><h3 id="MainTest"><a href="#MainTest" class="headerlink" title="MainTest"></a>MainTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AopApplictionContext aopApplictionContext = <span class="keyword">new</span> AopApplictionContext(<span class="string">"application.json"</span>);</span><br><span class="line">        aopApplictionContext.init();</span><br><span class="line">        TestService testService = (TestService) aopApplictionContext.getBean(<span class="string">"testServiceProxy"</span>);</span><br><span class="line">        testService.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="hemjx"></a></p><h3 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679659265097-017a1abd-1cbb-4840-9849-5c67b070dbed.png#averageHue=%23f7f6f5&clientId=u4abc7da4-0982-4&from=paste&height=171&id=u5b9f1a31&name=image.png&originHeight=256&originWidth=1143&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18875&status=done&style=none&taskId=ue6550e3c-a161-4300-b134-338c0010524&title=&width=762" alt="image.png"></p><p><a name="FXW4m"></a></p><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><a name="SO1vU"></a></p><h2 id="Jdk动态代理和Cglib动态代理什么关系"><a href="#Jdk动态代理和Cglib动态代理什么关系" class="headerlink" title="Jdk动态代理和Cglib动态代理什么关系"></a>Jdk动态代理和Cglib动态代理什么关系</h2><p>JDK动态代理和Cglib动态代理是两种常用的Java动态代理方式，它们都是用于在运行时动态地创建代理对象，实现对目标对象的增强功能。<br />JDK动态代理是通过Java反射机制来实现的，它只能为接口创建代理对象，而无法为类创建代理对象。JDK动态代理通过实现目标对象所实现的接口，在运行时生成一个代理类，代理类中包含了目标对象的引用以及拦截器对象的引用，从而可以在调用代理对象的方法时，将方法调用转发给拦截器对象进行处理。<br />Cglib动态代理则是通过生成目标对象的子类来实现的，它可以为类创建代理对象。Cglib动态代理在运行时通过生成目标对象的子类，重写目标对象的方法，并将目标对象的引用注入到代理对象中。当调用代理对象的方法时，代理对象会先调用目标对象的方法，然后再调用拦截器对象的方法进行增强处理。<br />虽然JDK动态代理和Cglib动态代理实现方式不同，但它们都可以实现对目标对象的增强功能，常用于实现AOP（面向切面编程）功能。在实际开发中，根据需要选择不同的动态代理方式，如果目标对象实现了接口，则可以使用JDK动态代理；如果目标对象没有实现接口，则可以使用Cglib动态代理。</p><p><a name="qRBPD"></a></p><h3 id="那是不是Cglib效率更高？为什么还需要JDK动态代理-？"><a href="#那是不是Cglib效率更高？为什么还需要JDK动态代理-？" class="headerlink" title="那是不是Cglib效率更高？为什么还需要JDK动态代理 ？"></a>那是不是Cglib效率更高？为什么还需要JDK动态代理 ？</h3><p>一般情况下，使用CGLIB生成代理类的效率确实比使用JDK动态代理更高，因为CGLIB是通过在编译时生成字节码来实现代理的，相对于JDK动态代理而言，不需要在运行时动态生成代理类。因此，在需要频繁生成代理类的场景下，使用CGLIB可能更适合。</p><p>然而，需要注意的是，CGLIB生成的代理类通常比原始类的大小要大，且CGLIB代理使用了更多的内存，这在创建大量代理对象的场景下可能会成为性能瓶颈。此外，由于CGLIB使用了底层字节码操作库，因此在某些环境下可能存在兼容性问题，需要额外考虑。</p><p>因此，在选择代理方式时，需要考虑实际场景和需求，并根据具体情况选择合适的代理方式。如果需要生成大量代理对象，并且不考虑内存占用问题，CGLIB可能更适合；如果需要更轻量级的代理方式，或者需要支持多态性、继承等特性，则JDK动态代理可能更合适。</p><p><a name="iHnyN"></a></p><h2 id="AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别"><a href="#AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别" class="headerlink" title="(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别"></a>(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别</h2><p>假设我们有一个接口UserService和一个实现类UserServiceImpl，其中UserService提供了一个getUserById()方法用于获取用户信息。我们需要对getUserById()方法进行日志记录，以便监控用户信息查询情况。<br><a name="VA788"></a></p><h3 id="使用JDK动态代理实现AOP功能："><a href="#使用JDK动态代理实现AOP功能：" class="headerlink" title="使用JDK动态代理实现AOP功能："></a>使用JDK动态代理实现AOP功能：</h3><p>我们可以使用JDK动态代理来创建UserService接口的代理对象，并将一个实现了InvocationHandler接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的invoke()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class[]&#123;UserService.class&#125;, proxy);</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="uzJJw"></a></p><h3 id="使用Cglib动态代理实现AOP功能："><a href="#使用Cglib动态代理实现AOP功能：" class="headerlink" title="使用Cglib动态代理实现AOP功能："></a>使用Cglib动态代理实现AOP功能：</h3><p>我们可以使用Cglib动态代理来创建UserServiceImpl类的代理对象，并将一个实现了MethodInterceptor接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的intercept()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceInterceptor());</span><br><span class="line"></span><br><span class="line">        UserServiceImpl userServiceProxy = (UserServiceImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述示例代码可以看出，使用JDK动态代理时，需要创建一个实现了InvocationHandler接口的拦截器对象，并将其注入到代理对象中；而使用Cglib动态代理时，需要创建一个实现了MethodInterceptor接口的拦截器对象，并将其注入到代理对象中。在JDK动态代理中，代理对象必须实现目标对象所实现的接口；而在Cglib动态代理中，代理对象</p><p><a name="lHuvV"></a></p><h2 id="IOC-使用反射、JDK、Cglib去实现依赖注入的区别"><a href="#IOC-使用反射、JDK、Cglib去实现依赖注入的区别" class="headerlink" title="(IOC)使用反射、JDK、Cglib去实现依赖注入的区别"></a>(IOC)使用反射、JDK、Cglib去实现依赖注入的区别</h2><p><a name="MOXbp"></a></p><h3 id="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用Cglib和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"></a>只使用反射与使用Cglib和反射来完成依赖注入有什么区别？</h3><p>在Spring中，依赖注入可以通过只使用反射或使用Cglib和反射来完成。下面是它们之间的一些区别：</p><ol><li>实现方式：只使用反射时，Spring通过反射机制来动态创建对象并设置属性值。而使用Cglib和反射时，Spring通过Cglib在运行时动态创建代理类，并在代理类中使用反射来设置属性值。</li><li>性能：只使用反射时，每次获取Bean时都需要通过反射机制来动态创建对象和设置属性值，因此在性能上可能存在一定的开销。而使用Cglib和反射时，Spring可以在第一次获取Bean时创建代理类，并缓存代理类实例，之后每次获取Bean时都可以直接使用代理类，从而提高了性能。</li><li>功能扩展：只使用反射时，Spring的功能扩展比较有限，因为只能使用Java反射机制来动态创建对象和设置属性值。而使用Cglib和反射时，Spring可以通过Cglib来实现更多的功能扩展，比如实现AOP切面等。</li></ol><p>总的来说，只使用反射相对于使用Cglib和反射来完成依赖注入，性能可能会稍差一些，但是在一些场景下可能会更加灵活，因为不需要引入Cglib这样的第三方库。而使用Cglib和反射来完成依赖注入则能够更好地支持一些功能扩展，比如实现AOP切面等。</p><p>举一个简单的例子，假设有一个名为UserService的服务类，它依赖于名为UserDao的DAO类。下面是使用只使用反射和使用Cglib和反射来实现依赖注入的代码示例：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring会通过反射来动态创建UserService和UserDao对象，并在运行时调用setUserDao方法来设置依赖关系。</p><p>使用Cglib和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDaoInterceptor拦截器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法执行前做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"Before method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="comment">// 在方法执行后做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"After method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDaoProxy"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoProxy"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cglib.proxy.Enhancer"</span></span><br><span class="line">        factory-method=<span class="string">"create"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"interceptor"</span></span><br><span class="line">        ref=<span class="string">"userDaoInterceptor"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoInterceptor"</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDaoInterceptor"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring使用Cglib创建一个名为userDaoProxy的代理类，这个代理类继承自UserDao类，并在运行时动态生成。代理类中有一个拦截器UserDaoInterceptor，它会在UserDao类的方法执行前后做一些额外的处理，比如日志记录等。当Spring需要注入UserDao依赖时，会注入userDaoProxy代理类，代理类会使用反射来设置依赖关系。此外，当调用UserService的saveUser方法时，userDaoProxy代理类会通过反射调用UserDao的save方法，并在方法执行前后调用UserDaoInterceptor的相关方法。</p><p><a name="jlq4z"></a></p><h3 id="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"></a>只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？</h3><p>使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象。<br />举个例子，假设有一个UserService接口和UserService实现类，实现类需要注入一个UserDao对象。下面分别使用反射和JDK动态代理来完成依赖注入：<br />使用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            userDao = (UserDao) constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用Class.forName方法获取UserDaoImpl类的Class对象，然后使用反射获取构造函数，并创建UserDaoImpl对象。</p><p>使用JDK动态代理和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            Object dao = constructor.newInstance();</span><br><span class="line">            method.invoke(target, dao);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">this</span>);</span><br><span class="line">        ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">        userDao = (UserDao) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; UserDao<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">proxy</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个UserServiceProxy代理类，实现了InvocationHandler接口，并重写了invoke方法。在invoke方法中，如果是set方法，我们使用反射获取UserDaoImpl类的Class对象和构造函数，创建UserDaoImpl对象，并通过反射调用set方法来完成依赖注入。否则，我们通过反射调用目标对象的方法。</p><p>然后，在UserServiceImpl构造方法中，我们创建了UserServiceProxy代理对象，并使用Proxy.newProxyInstance方法创建了一个UserDao的代理对象。这个代理对象会拦截所有UserDao的方法调用，并通过InvocationHandler的invoke方法进行处理。</p><p>需要注意的是，由于代理对象实现了UserDao接口，因此在使用代理对象时，需要将其转换为UserDao类型。</p><p>总的来说，使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象，可以对其方法进行拦截和处理。</p><p><a name="j91gI"></a></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><a name="AQ3Uy"></a></p><h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3><p>Cglib是通过字节码生成技术来实现动态代理的，它会在运行时动态生成被代理类的子类，并在子类中覆盖被代理类的方法，从而实现方法拦截和增强。</p><p>在Spring中，当使用Cglib代理时，Spring会在运行时动态生成被代理类的子类，并在子类中实现依赖注入。Cglib会通过反射机制获取被代理类的构造函数和参数，然后通过Constructor.newInstance方法创建被代理类的实例。</p><p>具体来说，Spring会在运行时动态生成一个类，继承被代理类，并重写其中需要拦截和增强的方法。同时，它还会在生成的类中添加一个无参构造函数，并在其中通过反射机制实例化被代理类，并完成依赖注入。在这个过程中，Cglib会使用asm字节码操作库来生成字节码，完成类的定义和加载。</p><p>因此，使用Cglib代理时，它会通过字节码生成技术来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用JDK动态代理，不需要被代理类实现接口，可以拦截和增强非public方法，但是会比JDK动态代理更消耗内存和CPU资源。<br><a name="Mu6c3"></a></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过反射机制来实现动态代理的，它会在运行时动态生成一个实现了被代理接口的代理类，并在代理类中实现方法拦截和增强。</p><p>在Spring中，当使用JDK动态代理时，Spring会使用Java提供的Proxy类来生成代理类，并在代理类中实现依赖注入。具体来说，Spring会使用Proxy类的newProxyInstance方法来生成代理类，该方法需要传入一个ClassLoader对象、一组被代理的接口、和一个InvocationHandler对象。在生成代理类的过程中，JDK动态代理会通过反射机制获取被代理接口的方法，然后通过InvocationHandler对象的invoke方法来进行方法的拦截和增强。</p><p>因此，使用JDK动态代理时，它会通过反射机制来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用Cglib代理，需要被代理类实现接口，不能拦截和增强非public方法，但是会比Cglib代理更节省内存和CPU资源。<br><a name="UrKkw"></a></p><h3 id="Cglib相对于JDK动态代理"><a href="#Cglib相对于JDK动态代理" class="headerlink" title="Cglib相对于JDK动态代理"></a>Cglib相对于JDK动态代理</h3><p>Cglib相对于JDK动态代理来说，有以下两个方面的优势，导致它在一些情况下可能比JDK动态代理更快：</p><ol><li><p>Cglib代理不需要被代理类实现接口，可以拦截和增强非public方法，而JDK动态代理只能代理实现了接口的类。因此，在需要拦截非public方法的情况下，Cglib代理可能比JDK动态代理更适合。</p></li><li><p>在拦截方法调用的时候，Cglib代理不需要调用被代理类的方法，而JDK动态代理需要通过反射调用被代理类的方法。因此，在需要进行大量方法调用的情况下，Cglib代理可能比JDK动态代理更快。</p></li></ol><p>总的来说，Cglib代理和JDK动态代理各有优缺点，在具体的应用场景中需要根据实际情况选择合适的代理方式。</p><p><a name="aSPZk"></a></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><a name="eXFA4"></a></p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理是基于继承来实现代理，它会在运行时动态生成目标对象的子类，并在子类中重写目标对象的非final方法，从而实现对目标对象的代理。这个子类会被当作代理类，被加载到JVM中，并用来完成方法调用。</p><p>具体来说，Cglib会使用ASM等字节码操作库生成代理类的字节码，然后通过ClassLoader将其加载到JVM中。生成的代理类会继承目标对象的类，并重写目标对象的非final方法。在生成代理类后，Cglib会创建代理对象，这个代理对象实际上就是生成的代理类的实例。当代理对象调用目标对象的方法时，实际上是调用了生成的代理类中重写的方法，从而实现了代理的功能。</p><p>因此，Cglib生成的子类会替代原始的目标对象，成为代理对象的实现。这个子类重写了目标对象的方法，从而实现了对目标对象方法的增强和拦截。<br><a name="r0cru"></a></p><h3 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是基于接口来实现代理的，它会在运行时动态生成一个代理接口的代理类，并将这个代理类实例化成代理对象。这个代理类会实现目标对象实现的接口，并且会拦截所有接口中定义的方法调用。</p><p>具体来说，JDK动态代理会在运行时使用Java反射机制动态生成代理类的字节码，并将其加载到JVM中。生成的代理类会实现目标对象实现的接口，并在代理类中实现对目标对象方法的拦截和增强。当代理对象调用目标对象的方法时，实际上是通过反射机制调用了代理类中的方法，从而实现了代理的功能。</p><p>因此，JDK动态代理实现了对接口的代理，可以通过实现一个代理接口来实现代理功能，而且可以在运行时动态生成代理类，并将其加载到JVM中，实现了对目标对象的动态代理。同时，由于是基于接口来实现代理的，所以在类型上更加灵活，但也因为这个原因，只能代理实现了接口的类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;Bk5lF&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;br /&gt;&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;vHThd&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现IOC&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于循环依赖的见解</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-12-18T12:20:46.000Z</published>
    <updated>2023-04-26T10:14:11.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于循环依赖的见解"><a href="#关于循环依赖的见解" class="headerlink" title="关于循环依赖的见解"></a>关于循环依赖的见解</h1><p>关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章（虽然很多是错误的）。</p><p>发现，<strong>其实二级缓存就能够解决循环依赖问题，根本不需要三级缓存</strong>。</p><p>首先，在单纯IOC的状态下，出现了循环依赖问题，在Bean不涉及代理对象的情况下，是只需要二级缓存的，但是很多文章说，因为涉及到AOP产生了代理对象，所以需要三级缓存，因为二级缓存和三级缓存存的对象不一样。但实际上，就算直接使用二级缓存，也是可以解决循环依赖问题，即使他们不一样。</p><p><strong>在任何状态下，二级缓存都能够完全的解决循环依赖问题，不管Bean有没有产生代理</strong>。</p><p>证明：(代补充)</p><p>但是Spring 为什么还是要使用三级缓存呢？因为设计者对于AOP一直都有一个原则：<strong>在对象初始化完毕后，再去创建代理对象</strong> </p><p>所以<strong>设计者一直在试图延迟代理对象的创建</strong>：</p><p>举例：</p><p>只有二级缓存：</p><p>1、发生了循环依赖，自然，在需要的时候就创建出来代理对象，放入缓存</p><p>2、没发生循环依赖，但是还是每一个对象在创建出原始对象后，就都会去创建代理对象</p><p>有三级缓存：</p><p>1、发生了循环依赖，在需要的时候就创建出来代理对象，放入二级缓存。</p><p>2、没发生循环依赖，正常的在初始化的后置处理器中创建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于循环依赖的见解&quot;&gt;&lt;a href=&quot;#关于循环依赖的见解&quot; class=&quot;headerlink&quot; title=&quot;关于循环依赖的见解&quot;&gt;&lt;/a&gt;关于循环依赖的见解&lt;/h1&gt;&lt;p&gt;关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty+Nacos+Protobuf制作RPC框架</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/11/02/srpc/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/11/02/srpc/</id>
    <published>2022-11-02T06:39:27.000Z</published>
    <updated>2023-04-18T08:23:57.368Z</updated>
    
    <content type="html"><![CDATA[<p><a name="ly3F9"></a></p><h1 id="使用Netty-Nacos-Protobuf制作RPC框架"><a href="#使用Netty-Nacos-Protobuf制作RPC框架" class="headerlink" title="使用Netty+Nacos+Protobuf制作RPC框架"></a>使用Netty+Nacos+Protobuf制作RPC框架</h1><p><a name="KeQ2k"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a name="FQTT2"></a></p><h3 id="显现的功能"><a href="#显现的功能" class="headerlink" title="显现的功能"></a>显现的功能</h3><p>这个RPC实现了一些基本的功能：</p><ul><li>使用Netty来进行网络传输，效率比起传统的NIO要高很多。</li><li>使用单例模式，在Netty获取Channel的过程中，会有一个ChannelProvider去提供Channel单例。</li><li>使用Nacos作为服务的注册中心，用于管理注册的服务，当客户端请求发过来时，Nacos会寻找合适的服务返回给客户端消费。</li><li>实现了负载均衡的功能，，客户端对于Nacos返回的服务列表，会使用负载均衡算法，选择一个自己需要的服务加入，目前实现了轮询算法和随机选取算法。</li><li>加入了心跳检测机制，并不会发送完消息立即结束，而是保持的长连接，提高效率。</li><li>使用Potobuf作为对象的的序列化工具，实现Netty中的编/解码的功能，提高了效率。</li><li>实现了钩子函数，当服务端下线的时候会自动去Nacos注销服务。</li><li>使用CompletableFuture来接受客户端返回的结果。</li></ul><p><a name="UlREa"></a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>由于使用Nacos，调试比较简单：<br />下载好Nacos，无论是win版还是linux版，在官网都有，比较方便；<br />但是由于Nacos一般都要配置数据库，为了方便测试，可以使用命令先进行单机运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">114514</span>, <span class="string">"Client send a Message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> NettyServer(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后会有一个测试结果：<br />客户端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513541152-f58818bf-b30d-438c-bebd-3374cb6f6b3f.png#averageHue=%23f5ecea&clientId=ucfcf756b-0ecd-4&from=paste&height=400&id=uc9973f1d&name=image.png&originHeight=600&originWidth=2205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111506&status=done&style=none&taskId=ubbd01eee-67bf-4697-b872-6eef4c3b304&title=&width=1470" alt="image.png"><br />服务端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513584290-393ae7f9-f650-4a6d-b6a2-ad58cd7c2360.png#averageHue=%23f5ebe9&clientId=ucfcf756b-0ecd-4&from=paste&height=301&id=u72da898a&name=image.png&originHeight=452&originWidth=2307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88585&status=done&style=none&taskId=u57f54541-d548-4720-aca7-051e4b65050&title=&width=1538" alt="image.png"></p><p><a name="VFwOu"></a></p><h2 id="服务端分析"><a href="#服务端分析" class="headerlink" title="服务端分析"></a>服务端分析</h2><p>首先服务端都会实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.PROTOBUF_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口通常定义了默认的序列化方法，开始方法，和发布服务的方法。<br />接着会有一个抽象类去实现这个接口：<br><a name="DbRAB"></a></p><h3 id="AbstractRpcServer"><a href="#AbstractRpcServer" class="headerlink" title="AbstractRpcServer"></a>AbstractRpcServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"启动类缺少 @ServiceScan 注解"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"出现未知错误"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service<span class="class">.<span class="keyword">class</span>).<span class="title">name</span>()</span>;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"创建 "</span> + clazz + <span class="string">" 时有错误发生"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">""</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    这段代码是在判断 Service 注解中的 name 属性是否为空，如果为空，</span></span><br><span class="line"><span class="comment">                    则说明该服务实现类实现了多个接口，并且需要将每个接口都发布成一个独立的服务。</span></span><br><span class="line"><span class="comment">                    所以，代码通过获取该服务实现类的所有接口，然后将每个接口都作为一个独立的服务进行发布。</span></span><br><span class="line"><span class="comment">                    如果 name 属性不为空，则说明只需要将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                    此时，代码直接将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanServices 的作用：这段代码是服务扫描的核心实现，它通过获取启动类的信息，获取服务扫描的基础包路径，然后扫描该路径下的所有类，判断是否有@Service注解，如果有，就将该服务发布到注册中心。<br />具体的实现流程如下：</p><ol><li>调用ReflectUtil.getStackTrace()方法获取当前方法调用的栈信息，得到启动类的全限定名。</li><li>使用Class.forName()方法加载启动类，判断启动类是否被@ServiceScan注解所标注，如果没有则抛出异常。</li><li>获取@ServiceScan注解的参数值，即基础包路径。</li><li>调用ReflectUtil.getClasses()方法获取指定包下的所有类，遍历这些类，判断是否被@Service注解所标注。</li><li>如果被@Service注解所标注，则获取@Service注解的参数值，即服务名称，如果未指定服务名称，则获取该服务实现类实现的所有接口，并将该服务发布到注册中心。</li><li>如果指定了服务名称，则直接将该服务发布到注册中心。</li></ol><p>该方法主要的功能就是扫描服务，将服务发布到注册中心，为后续的服务调用提供依据<br />接着我们来看看这个所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务扫描的基包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上述提到的ReflectUtil这个类是一个比较常见的类，这个类是一个工具类，提供了两个静态方法：getStackTrace(): 返回当前调用栈顶部的类名。利用Java的反射机制，调用 new Throwable().getStackTrace() 方法获取当前调用栈信息，返回调用栈顶部的类名。<br />getClasses(String packageName): 获取指定包名下所有的类。该方法通过输入一个包名，然后通过反射机制查找该包下的所有类，返回一个 Set&lt;Class&lt;?&gt;&gt; 对象。该方法实现的过程比较复杂，具体过程为：</p><ol><li>通过 Thread.currentThread().getContextClassLoader().getResources(packageDirName) 获取指定包名下的所有资源。</li><li>遍历所有资源，如果是文件，则通过递归方式查找该文件夹下所有的类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li><li>如果是 Jar 包，则通过 JarFile 对象查找该 Jar 包中的所有类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li></ol><p>该工具类可以用于类加载器等需要动态加载类的场景，例如 Spring 框架中的 Bean 加载、RPC 框架中的服务注册等</p><p><a name="azGEB"></a></p><h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><p>接着便是这个RPC服务端的逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同时也继承了serviceRegistry和serviceProvider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 256)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"启动服务器时有错误发生: "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类实现了一个基于Netty框架的RPC服务器，它继承了抽象类AbstractRpcServer，并且拥有服务注册表（serviceRegistry）和服务提供者（serviceProvider）的实例。<br />在构造函数中，传入了服务器的主机名和端口号，以及序列化器（serializer）。在构造函数中还调用了扫描服务的方法scanServices()。<br />在start()方法中，创建了两个EventLoopGroup，用于处理连接和IO的事件。然后使用ServerBootstrap创建了一个服务端的引导类，通过设置一系列的选项和处理器来配置Netty服务器。其中，ChannelInitializer是一个特殊的处理器，用于在Channel被创建时执行一些初始化操作。在这个ChannelInitializer中，注册了一个IdleStateHandler用于处理空闲连接，以及自定义的编解码器和处理器。<br />最后，通过调用bind()方法绑定主机名和端口号，并且调用sync()方法等待服务器启动完成。当关闭服务器时，调用shutdownGracefully()方法优雅地关闭EventLoopGroup。<br />这就是这个类的大体流程，接下来，可以一个个分开来看<br />其中，NacosServiceRegistry会返回一个服务注册器实例，但是这个实例实际上会调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"注册服务时有错误发生:"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是NacosUtil去实现服务注册：<br><a name="Q2Adh"></a></p><h4 id="NacosUtil"><a href="#NacosUtil" class="headerlink" title="NacosUtil"></a>NacosUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">"127.0.0.1:8848"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接到Nacos时有错误发生: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"注销服务 &#123;&#125; 失败"</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个Nacos工具类，用于连接到Nacos服务注册中心并与之进行交互。主要包含以下几个方法：</p><ol><li>getNacosNamingService()方法用于获取NacosNamingService实例。</li><li>registerService(String serviceName, InetSocketAddress address)方法用于向Nacos注册服务实例，即将提供服务的服务地址和端口注册到Nacos中，以便客户端可以通过服务名称查找到该服务。</li><li>getAllInstance(String serviceName)方法用于获取指定服务名称下的所有服务实例，返回一个Instance列表。</li><li>clearRegistry()方法用于清空注册中心中注册的服务实例，即将服务注销。</li></ol><p>通过这个工具类，我们可以将服务注册到Nacos服务注册中心，并通过Nacos中心来查找并获取服务实例，以便客户端可以通过服务名称调用相应的服务。<br><a name="wIRIl"></a></p><h4 id="ServiceProviderImpl"><a href="#ServiceProviderImpl" class="headerlink" title="ServiceProviderImpl"></a>ServiceProviderImpl</h4><p>而ServiceProviderImpl默认的服务注册表，保存服务端本地服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">"向接口: &#123;&#125; 注册服务: &#123;&#125;"</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个服务提供者的默认实现类，它实现了 ServiceProvider 接口中的方法，可以将提供者实例添加到服务注册表中，提供了一种方便地访问服务的方式。在服务注册表中，服务名与服务实例之间的映射关系是使用 ConcurrentHashMap 实现的。它有两个主要方法：</p><ol><li>addServiceProvider(T service, String serviceName)：将服务提供者添加到服务注册表中，当服务名已经存在于注册表中时，则不进行任何操作。</li><li>getServiceProvider(String serviceName)：根据服务名从服务注册表中获取相应的服务实例。如果服务不存在，则抛出 RpcException 异常，表示未找到服务。</li></ol><p><a name="RA6ZR"></a></p><h4 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h4><p>当一个服务开启之后，也会开始一个钩子函数，它的Runtime类会使用getRuntime().addShutdownHook()方法，在服务结束前，注销掉所有的在Nacos的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"关闭后将自动注销所有服务"</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个单例，它提供了一个静态方法getShutdownHook()来获取一个实例。它注册了一个JVM shutdown hook，该hook会在JVM关闭前被执行，清除所有注册到Nacos服务注册中心上的服务和所有线程池。这个类的作用是确保在JVM关闭前执行清除操作，避免可能的资源泄漏和数据一致性问题。</p><p><a name="klHf5"></a></p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>这里在SocketChannel中加入了一个IdleStateHandler，使其具有心跳检测功能<br />在 Netty 中，IdleStateHandler 是一个用于处理空闲状态的处理器。它可以在 Channel 上检测特定类型的空闲时间，并在这些时间段内未发生读取、写入或读写事件时触发相应的事件。常用的空闲状态类型有三种：READER_IDLE，WRITER_IDLE 和 ALL_IDLE。<br />IdleStateHandler 可以用于实现心跳机制，可以通过配置空闲时间间隔和触发事件来判断是否需要发送心跳包。它可以被添加到 Netty 的 ChannelPipeline 中，以监视 Channel 上的空闲事件，以便可以采取适当的措施，例如关闭连接或发送心跳消息。</p><p><a name="fWDhA"></a></p><h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><p>这里也同时添加了一个NettyServerHandler去处理在Channel中发生的时间。<br />先拿上面的心跳检测为例子，如果收到了一个心跳包，便会打印一条日志，告诉服务端收到了。而在长时间没有收到心跳包后，则会关闭上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">"接收到客户端心跳包..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"服务器接收到请求: &#123;&#125;"</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"通道不可写"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"处理过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"长时间未收到心跳包，断开连接..."</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleChannelInboundHandler 是 Netty 中的一个基础类，实现了 ChannelInboundHandler 接口。它主要用于处理入站事件，即从对等端接收到的数据或状态更改事件，例如对等端连接或断开连接。与 ChannelInboundHandlerAdapter 不同的是，SimpleChannelInboundHandler 可以自动释放资源，因此不需要显示地调用 ReferenceCountUtil.release() 释放资源。<br />当数据从远程节点传入时，SimpleChannelInboundHandler 将自动将其转换为指定类型的对象，并在调用 channelRead0() 方法时向你提供该对象，你只需要处理传入的数据。可以使用这个类来构建各种应用程序，例如聊天应用程序、游戏服务器、文件传输应用程序等。<br />而这里的requestHandler是一个单例，表示全程都使用这个单例去处理请求，这样就不会浪费大量的资源去重复创建实例。<br><a name="MTSdN"></a></p><h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">"服务:&#123;&#125; 成功调用方法:&#123;&#125;"</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个RequestHandler使用的方法不多，最为主要的方法还是：<br>:::info<br>result = method.invoke(service, rpcRequest.getParameters());<br>:::<br>这个方法会调用Method实例的invoke方法，去执行相应的请求。<br />在Java中，Method类是反射机制的一部分，它代表一个类中的一个方法。可以使用Method类来获取关于方法的信息，如方法名、参数列表、返回类型、修饰符等，并且可以使用Method类来调用该方法。Method类提供了许多用于获取和调用方法的方法，如invoke()、getName()、getParameterTypes()、getReturnType()等。反射机制中的Method类可以使得在运行时动态地获取和调用类中的方法。</p><p><a name="Le2TA"></a></p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器可以说是整个RPC框架中最为重要的一部分，那么RPC为什么需要编解码器呢？<br />因为在RPC通信过程中，数据需要在网络中传输。在不同的计算机之间通信需要将对象序列化为字节流，传输完成后再反序列化为对象。编解码器的作用就是将对象序列化和反序列化的过程封装起来，让开发者可以更方便地进行通信。在Netty中，SimpleChannelInboundHandler类可以自动完成消息的解码和编码，大大简化了编解码器的编写过程。<br />那为什么不用直接用序列化？<br />虽然序列化可以将对象转换成字节流进行网络传输，但是它并不能满足RPC的需求。<br />RPC需要一个通用的方式来序列化和反序列化各种类型的消息，包括基本数据类型、复合数据类型和自定义类型等。而不同的序列化实现可能只支持特定的类型或数据格式，因此无法满足这个需求。<br />此外，RPC需要支持不同的编解码器，以便兼容不同的协议和框架。使用编解码器可以使得不同的实现之间相互兼容，也方便进行协议升级和兼容性处理。<br />因此，编解码器是RPC中必不可少的组件，它能够实现通用的序列化和反序列化，同时兼容不同的协议和框架，满足RPC的需求。</p><p><a name="BVL84"></a></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>MessageToByteEncoder 是 Netty 提供的编码器抽象类，用于将消息转换为字节流进行网络传输。在 Netty 应用中，可以使用它将自定义的消息对象编码为二进制数据，以便通过网络进行传输。<br />实现 MessageToByteEncoder 需要重写 encode() 方法，该方法会在消息被写入通道前被自动调用。在 encode() 方法中，我们需要将消息对象转换为字节流，并将字节流写入到 ByteBuf 中。写入到 ByteBuf 中的字节流会在后续的 ChannelHandler 中被传递，最终通过网络传输到远程节点。<br />MessageToByteEncoder 中还提供了一些辅助方法，如 writeXXX() 系列方法可以将不同类型的数据写入到 ByteBuf 中，以及提供了一些钩子方法，可以在编码过程中对消息进行处理，比如对消息进行压缩、加密等操作。<br />总之，MessageToByteEncoder 是 Netty 提供的编码器抽象类，通过继承它可以实现自定义的消息编码器。<br />CommonEncoder继承了MessageToByteEncoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 Netty 中的编码器类，用于将消息对象转换为二进制字节流，以便在网络上进行传输。在 RPC 中，消息通常是由客户端和服务端之间相互传递的。因为在不同的机器之间传递数据时，需要将数据序列化为二进制流，才能在网络中传输。但是，不同的序列化方式可能具有不同的数据格式和协议，所以需要使用编解码器来统一数据格式和协议。这个类实现了 Netty 中的 MessageToByteEncoder 类，并将消息对象编码为二进制流，遵循了一个特定的协议，包括一个魔数、消息类型、序列化方式、消息长度和消息内容。其中，魔数用于识别协议版本，消息类型用于标识消息是请求还是响应，序列化方式用于指定消息内容的序列化方式，消息长度用于指定消息内容的长度，消息内容就是序列化后的消息体。这个类是 RPC 通信中必不可少的一部分。</p><p><a name="Mudkb"></a></p><h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>ReplayingDecoder是Netty提供的一种特殊类型的解码器。与普通解码器不同，ReplayingDecoder可以在缓冲区数据不足时进行暂停，并在数据可用时恢复处理，而不是等待缓冲区填满。<br />具体来说，ReplayingDecoder类通过继承ByteToMessageDecoder类并使用状态机模式实现。状态机模式通过在每个状态中重写decode()方法来定义不同的处理行为。当状态更改时，它将转移到下一个状态，直到解码完成为止。<br />ReplayingDecoder的主要作用是简化解码器的实现，尤其是对于一些不确定数据长度的解码器。通过使用ReplayingDecoder，可以避免手动跟踪缓冲区中的字节数，从而减少出错的可能性。同时，ReplayingDecoder还可以提供更好的性能，因为它只需要处理缓冲区中实际可用的数据，而不是缓冲区中的所有数据<br />CommonDecoder继承了ReplayingDecoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的协议包: &#123;&#125;"</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的数据包: &#123;&#125;"</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的反序列化器: &#123;&#125;"</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个Netty解码器，用于将字节流转换为对象。具体来说，它的作用是将从网络中接收到的字节流解码为指定的Java对象，以供后续处理。<br />在方法decode()中，它首先读取一个整数值，如果它不等于预定义的一个常量值，就会抛出一个RpcException异常，这表示该字节流不是正确的RPC协议包。接下来，它读取协议包类型和序列化器类型，并检查它们是否为预期值，否则将抛出异常。然后，它读取字节流的长度，并将剩余的字节读入到字节数组中。最后，它使用指定的序列化器将字节流反序列化为预期的Java对象，并将其添加到输出列表中</p><p><a name="y5CbI"></a></p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protocol Buffers（简称protobuf）是一种轻便高效的数据序列化格式，由Google开发。它与XML和JSON等格式相比，具有更小的数据体积和更快的解析速度，同时也可以生成各种编程语言的代码，从而方便了跨语言的数据交换和通信。在Java中，我们可以通过使用Protobuf库来实现Protobuf的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; schemaCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        Class clazz = obj.getClass();</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        Object obj = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">"PROTOBUF"</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Schema <span class="title">getSchema</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = schemaCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(schema)) &#123;</span><br><span class="line">            <span class="comment">// 这个schema通过RuntimeSchema进行懒创建并缓存</span></span><br><span class="line">            <span class="comment">// 所以可以一直调用RuntimeSchema.getSchema(),这个方法是线程安全的</span></span><br><span class="line">            schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(schema)) &#123;</span><br><span class="line">                schemaCache.put(clazz, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个实现了CommonSerializer接口的类，用于将Java对象序列化为Protobuf格式的字节数组，或者将字节数组反序列化为Java对象。<br />具体来说，该类中的serialize方法将一个Java对象序列化为Protobuf格式的字节数组，实现过程如下：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>使用该Schema对象和LinkedBuffer对象调用ProtostuffIOUtil.toByteArray方法将Java对象序列化为字节数组。</li><li>最后清空LinkedBuffer对象并返回序列化后的字节数组。</li></ol><p>而deserialize方法则是将字节数组反序列化为Java对象：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>调用schema.newMessage()创建一个该类的空对象。</li><li>使用字节数组和Schema对象调用ProtostuffIOUtil.mergeFrom方法将字节数组反序列化为Java对象并返回。</li></ol><p>同时，为了提高性能，该类中使用了缓存机制，通过ConcurrentHashMap缓存Schema对象，以便在下次序列化或反序列化时能够更快地获取Schema对象，避免了重复创建的开销。</p><p>在具体的分析下面类的作用：<br><a name="RoCQJ"></a></p><h4 id="LinkedBuffer"><a href="#LinkedBuffer" class="headerlink" title="LinkedBuffer"></a>LinkedBuffer</h4><p>LinkedBuffer是Protostuff序列化库中的一个类，用于在序列化过程中存储数据。它是一个基于链表的动态缓存区，它会自动根据当前写入数据的大小来调整缓存区的大小。<br />具体来说，LinkedBuffer维护了一个字节数组（即缓存区），一个指向缓存区首部的指针和一个指向缓存区尾部的指针。当我们往缓存区写入数据时，LinkedBuffer会先检查当前剩余的空间是否足够，如果不够则会自动扩展缓存区。扩展时会新建一个更大的缓存区，并将当前缓存区中的数据复制到新缓存区中，然后将新缓存区设置为当前缓存区。<br />LinkedBuffer使用链表来管理多个缓存区，每次扩展时都会新建一个缓存区并添加到链表尾部。这样做的好处是可以避免频繁的内存分配和拷贝，从而提高序列化性能。<br />在上面的代码中，LinkedBuffer被用于在ProtobufSerializer类中序列化对象时存储数据。当我们调用ProtostuffIOUtil.toByteArray()方法将一个对象序列化为字节数组时，需要传入一个LinkedBuffer对象作为参数，这个对象会在序列化过程中被自动扩展。当序列化完成后，我们需要手动调用LinkedBuffer.clear()方法清空缓存区，以便下次使用。<br><a name="I3nN9"></a></p><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>在 Protobuf 序列化中，Schema 是一个用于描述消息结构的类，类似于 Java 对象中的 Class。Schema 类的实例提供了一些方法来获取消息的字段和类型信息，从而可以将消息序列化和反序列化为二进制数据。<br />在使用 Protobuf 进行序列化时，我们需要为每个消息类创建一个 Schema 对象，并将其缓存起来以供重复使用。这样可以提高序列化和反序列化的效率，避免重复创建和解析 Schema 对象。<br />在上面提供的 ProtobufSerializer 类中，getSchema 方法用于获取指定类型的 Schema 对象。如果缓存中已经存在该类型的 Schema 对象，则直接返回；否则，使用 RuntimeSchema.getSchema 方法创建一个新的 Schema 对象，并将其存入缓存中。这样，在序列化和反序列化时，就可以直接使用缓存中的 Schema 对象，提高了性能。<br><a name="FAUkt"></a></p><h4 id="ProtostuffIOUtil"><a href="#ProtostuffIOUtil" class="headerlink" title="ProtostuffIOUtil"></a>ProtostuffIOUtil</h4><p>ProtostuffIOUtil是Protostuff序列化框架中的一个工具类，主要提供了将Java对象序列化成byte数组和将byte数组反序列化成Java对象的功能。<br />它提供了以下主要的静态方法：</p><ul><li>toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)：将一个Java对象序列化成byte数组。</li><li>fromByteArray(byte[] data, T message, Schema<T> schema)：将一个byte数组反序列化成Java对象。</li><li>mergeFrom(byte[] data, T message, Schema<T> schema)：将一个byte数组中的数据合并到一个Java对象中。</li></ul><p>其中，Schema是Protostuff序列化框架中的一个关键接口，用于描述Java对象的序列化格式。而LinkedBuffer则是一个可扩容的缓冲区，用于存储序列化后的数据。在使用Protostuff进行序列化时，可以通过LinkedBuffer.allocate()方法创建一个缓冲区，用于存储序列化后的数据。<br><a name="S4KTX"></a></p><h4 id="RuntimeSchema"><a href="#RuntimeSchema" class="headerlink" title="RuntimeSchema"></a>RuntimeSchema</h4><p>RuntimeSchema是Protostuff库的一个类，它提供了将Java类转换为Protobuf格式的Schema的功能。在使用Protobuf进行序列化和反序列化时，需要提供一个Schema来指定序列化的字段、类型等信息。RuntimeSchema的作用就是根据Java类的结构生成一个对应的Schema。<br />通常情况下，使用Protobuf进行序列化和反序列化时，需要手动定义一个Proto文件来描述消息的结构。而使用RuntimeSchema，可以将Java类当作Proto文件来使用，它会自动生成一个对应的Schema。<br />需要注意的是，由于RuntimeSchema是在运行时生成的，因此会对性能产生一定影响。在高性能场景中，建议使用预编译的Proto文件来进行序列化和反序列化。</p><p><a name="njTxV"></a></p><h2 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a>客户端分析</h2><p>要实现客户端的逻辑，最基本的就是要实现动态代理：<br />InvocationHandler 是 Java 标准库中的一个接口，它用于实现动态代理。<br />动态代理是一种运行时生成代理对象的技术。使用动态代理可以在运行时动态地创建一个实现特定接口的代理类，这个代理类可以将所有方法调用委托给指定的对象或方法。在委托调用前或调用后，代理类可以执行额外的逻辑，例如统计方法调用次数、记录方法调用日志等。<br />InvocationHandler 接口定义了一个方法 invoke，该方法会在代理类每次调用方法时被调用。该方法有三个参数：</p><ol><li>proxy：代理对象</li><li>method：被调用的方法</li><li>args：被调用方法的参数列表</li></ol><p>invoke 方法的返回值是 Object 类型，它表示被调用方法的返回值。因此，当我们想要使用动态代理技术时，需要实现 InvocationHandler 接口并重写 invoke 方法，来控制代理类如何处理方法调用<br><a name="mEV6K"></a></p><h3 id="RpcClientProxy"><a href="#RpcClientProxy" class="headerlink" title="RpcClientProxy"></a>RpcClientProxy</h3><p>RpcClientProxy 将实现 InvocationHandler 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用方法: &#123;&#125;#&#123;&#125;"</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"方法调用请求发送失败"</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个远程调用的客户端代理类RpcClientProxy，实现了InvocationHandler接口，用于生成一个远程服务接口的代理对象。其中，RpcClient是一个抽象类，NettyClient和SocketClient分别是其子类，用于不同的网络传输方式进行远程调用。<br />该类中的getProxy方法，使用了Java动态代理技术，生成了一个实现了远程服务接口的代理对象，该代理对象的所有方法调用都会被拦截并转化为远程调用，从而实现了RPC远程调用的透明化。<br />在invoke方法中，通过封装一个RpcRequest对象来表示对远程服务的调用，并通过客户端发送请求获取到返回结果RpcResponse，最后将返回结果中的数据返回给调用方。在发送远程调用请求之前，还进行了一些简单的参数检查，确保请求的正确性和完整性。<br><a name="Jo1Tm"></a></p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机轮询策略来进行负载均衡</span></span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//另一个构造方法，表示自定义负载均衡策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注入服务发现</span></span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="comment">//序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="comment">//保留意见</span></span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"未设置序列化器"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"客户端发送消息: %s"</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">"发送消息时有错误发生: "</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基于Netty的RPC客户端，实现了RpcClient接口，并且封装了发送请求的具体细节。<br />在类的静态代码块中，创建了一个EventLoopGroup和一个Bootstrap对象，用于配置Netty客户端。EventLoopGroup是处理事件循环的抽象类，Bootstrap则是用于客户端引导的类。在其中使用了NioEventLoopGroup和NioSocketChannel类来实现NIO客户端，这里用到了Netty的API。<br />接着在类的构造方法中，初始化了一个服务发现对象和一个序列化器对象。服务发现对象是用于从服务注册中心获取服务地址的。序列化器对象是用于将请求和响应对象序列化和反序列化的，该类的序列化器可以通过传入参数来选择使用哪种类型的序列化器。<br />在sendRequest方法中，首先判断序列化器是否为空，如果为空则抛出异常。然后通过服务发现对象获取到远程服务的地址，根据地址获取一个Channel对象，ChannelProvider.get方法会返回一个新的Channel或者已有的Channel，如果没有就会创建一个新的Channel。在获取到Channel对象后，使用Netty的writeAndFlush方法将请求对象发送到服务端，使用addListener添加一个ChannelFutureListener监听器，可以在发送成功或失败时执行相应的操作，如打印日志或者回调。发送请求时还将该请求的请求ID和响应结果对应的CompletableFuture对象存储到一个全局的UnprocessedRequests对象中。<br />最后，sendRequest方法返回一个CompletableFuture对象，用于异步等待响应结果。在响应结果到达时，UnprocessedRequests对象会将响应结果的CompletableFuture对象取出并使用complete方法设置结果。而调用sendRequest方法的线程会在CompletableFuture对象的get方法上阻塞，直到CompletableFuture对象的complete方法被调用为止，然后会返回响应结果。<br />接着我们一步步看这个客户端有哪些用到的类：</p><p><a name="Fzlss"></a></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡会共用一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有着其对应的实现。<br />随机策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮询策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以看到，无论是哪一种策略，都是要先获取到Instance实例，然后使用相应的负载均衡策略，那么这个实例，则是Nacos包提供的一个类，那么我们也自然需要一个Nacos方法来提供。</p><p><a name="fLeqg"></a></p><h3 id="NacosServiceDiscovery"><a href="#NacosServiceDiscovery" class="headerlink" title="NacosServiceDiscovery"></a>NacosServiceDiscovery</h3><p>服务发现类，同时也对上述的负载均衡做出了解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"找不到对应的服务: "</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"获取服务时有错误发生:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个 NacosServiceDiscovery 类，实现了 ServiceDiscovery 接口，主要用于在基于 Nacos 注册中心的服务发现中获取服务地址。具体作用如下：</p><ol><li>NacosServiceDiscovery 类有一个构造方法，用于初始化负载均衡策略，如果未指定，则默认使用随机负载均衡策略。</li><li>lookupService 方法用于获取指定服务名对应的 InetSocketAddress，通过调用 NacosUtil 工具类获取所有的服务实例，然后使用负载均衡策略选择一个实例，最终返回该实例的地址信息。</li><li>如果找不到对应的服务，则会抛出 RpcException 异常，并记录错误日志。</li></ol><p>总之，该类用于实现基于 Nacos 注册中心的服务发现功能，可以根据服务名从注册中心获取服务实例并进行负载均衡选择，返回可用的服务地址。</p><p><a name="XrnMt"></a></p><h3 id="UnprocessedRequests"><a href="#UnprocessedRequests" class="headerlink" title="UnprocessedRequests"></a>UnprocessedRequests</h3><p>这个类名为 UnprocessedRequests，用于处理未处理的RPC请求。同时也是更好的控制数据的获取，因为如果使用Netty自带的阻塞获取方法，太过于复杂了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中，使用了一个静态的 ConcurrentHashMap 对象，用于存储未处理的RPC请求。<br />其中，Key 值为请求的ID，Value 值为一个 CompletableFuture<RpcResponse> 对象，用于异步获取 RPC 响应结果。<br />这可以用来记录客户端发送的请求并等待响应。主要包含以下方法：</p><ol><li>put(String requestId, CompletableFuture<RpcResponse> future)：将请求 ID 和对应的 CompletableFuture 存储到 ConcurrentHashMap 中。</li><li>remove(String requestId)：从 ConcurrentHashMap 中删除指定的请求 ID。</li><li>complete(RpcResponse rpcResponse)：根据响应中的请求 ID 找到对应的 CompletableFuture 并将响应数据传递给它。如果没有找到对应的 CompletableFuture，则抛出 IllegalStateException 异常。</li></ol><p>这个类的作用是确保客户端发送的每个请求都有一个对应的 CompletableFuture 实例，用来等待服务器响应。在客户端收到服务器响应后，可以使用 UnprocessedRequests.complete() 方法将响应数据传递给对应的 CompletableFuture。这种机制使得客户端可以异步发送请求并等待响应，而不需要阻塞线程。<br><a name="rkJoD"></a></p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture类是Java8引入的一个异步编程工具，用于处理异步操作的结果。它提供了一些方法来处理异步任务的结果，例如将结果传递给下一个任务，等待任务完成，组合多个任务等。<br />在异步编程中，通常会使用回调函数来处理异步任务的结果，但这种方式会使代码变得冗长且难以维护。CompletableFuture类的出现，使得异步编程变得更加简单和可读。<br />CompletableFuture类有以下几个主要特点：</p><ol><li>可以将一个异步操作的结果传递给下一个操作，这种操作被称为”组合”。</li><li>可以等待一个异步操作的结果，并在操作完成后执行一些操作，例如打印日志、释放资源等。</li><li>可以在多个异步操作完成后执行一些操作，例如将它们的结果组合起来，计算它们的平均值等。</li><li>可以通过异常处理机制来处理异步操作中的异常。</li></ol><p>使用CompletableFuture类，可以更加方便地处理异步任务，提高代码的可读性和可维护性。同时，它也是Java并发编程中非常有用的工具之一。<br><a name="PP3yo"></a></p><h3 id="ChannelProvider"><a href="#ChannelProvider" class="headerlink" title="ChannelProvider"></a>ChannelProvider</h3><p>这段代码实现了一个用于获取客户端 Channel 的工具类 ChannelProvider。它维护了一个 Map 类型的 channels 成员变量，用于缓存已经连接的 Channel 对象，通过 get 方法获取指定地址的 Channel 对象。</p><ol><li>在 get 方法中，首先根据地址和序列化器生成 key，从 channels 缓存中查找是否已有对应的 Channel 对象。如果有，就返回已有的 Channel 对象；如果没有，就通过 bootstrap 进行连接。在连接成功后，将新建的 Channel 对象存入 channels 缓存，并返回该对象。如果连接失败，返回 null。</li><li>在 connect 方法中，通过 CompletableFuture 异步获取连接结果。在连接成功后，将 Channel 对象作为 CompletableFuture 的返回值。</li><li>initializeBootstrap 方法则初始化 Bootstrap 对象，并设置一些常用的参数，如连接超时时间、是否启用 TCP 底层心跳机制等。</li></ol><p>ChannelProvider 为客户端连接提供了一个通用的方法，简化了客户端连接的过程，提高了代码的复用性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接客户端时有错误发生"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"客户端连接成功!"</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, 5000)</span></span><br><span class="line"><span class="class">                //是否开启 <span class="title">TCP</span> 底层心跳机制</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                //<span class="title">TCP</span>默认开启了 <span class="title">Nagle</span> 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。<span class="title">TCP_NODELAY</span> 参数的作用就是控制是否启用 <span class="title">Nagle</span> 算法。</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细一点的说：<br />这段代码实现了一个用于获取Netty客户端Channel的工具类ChannelProvider。它提供了一个get方法，该方法接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取与指定服务提供者（IP地址和端口号）之间的连接。该方法首先将InetSocketAddress和序列化器的编码方式作为key，从Map中查找已有的Channel。如果找到的Channel是可用的，那么直接返回这个Channel。如果找到的Channel不可用，那么将它从Map中删除。接下来创建一个新的Channel，该Channel使用了上述编码方式进行了初始化，并且连接到了指定的服务提供者，最后将新创建的Channel保存到Map中。<br />在ChannelProvider类中，包含了一个静态的EventLoopGroup类型的变量eventLoopGroup和一个静态的Bootstrap类型的变量bootstrap。在类初始化时，这些变量被初始化为一个NioEventLoopGroup和一个Bootstrap实例。Bootstrap实例会初始化连接到远程服务提供者的客户端的参数，包括TCP连接、超时时间、TCP底层心跳机制等。这就是Channel的模板，创建一次就好了，不用每次都创建一次，这样可以很好的减少代码冗余和提高复用性。</p><ul><li>get()方法是ChannelProvider的主要方法。它接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取连接到指定服务提供者的Channel。首先，根据传入的参数，生成一个唯一的key，用于从Map中查找是否已经存在一个可用的Channel。如果找到的Channel是可用的，直接返回这个Channel对象。否则，创建一个新的Channel，并且将它保存到Map中。最后，返回新创建的Channel对象。</li><li>initChannel()方法用于初始化客户端Channel的pipeline。在这里，我们首先添加了一个自定义的序列化编解码器，然后添加了一个心跳检测处理器IdleStateHandler、一个通用解码器CommonDecoder和一个客户端处理器NettyClientHandler。这些处理器将按照顺序添加到客户端Channel的pipeline中。</li><li>connect()方法用于创建连接到指定服务提供者的Channel，并返回连接成功后的Channel对象。为了处理异步连接的结果，它使用了一个CompletableFuture对象completableFuture，该对象用于接收连接结果。当连接成功时，completableFuture将被设置为连接成功的Channel对象；当连接失败时，completableFuture将抛出异常。</li></ul><p>这个Channel包含的一个NettyClientHandler，有相应对收到请求的处理：<br><a name="ie8Yn"></a></p><h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">"客户端接收到消息: %s"</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"发送心跳包 [&#123;&#125;]"</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Netty 客户端处理器，用于处理服务器发送的响应消息。它继承了 Netty 的 SimpleChannelInboundHandler 类，实现了其中的 channelRead0() 方法和 exceptionCaught() 方法。<br />在channelRead0()方法中，通过UnprocessedRequests对象的complete()方法处理返回的RpcResponse对象。在此方法中，使用logger打印接收到的消息，然后调用UnprocessedRequests.complete()方法，将对应的CompletableFuture对象标记为完成，并将RpcResponse对象作为结果<br />在 exceptionCaught() 方法中，发生异常时，会先记录日志，然后关闭客户端通道。<br />另外，该类还重写了 userEventTriggered() 方法，用于发送心跳包。如果客户端在一段时间内没有发送数据，则会自动触发该方法，并向服务器发送一个心跳包。当客户端发送心跳包时，会调用 ChannelProvider 类的 get() 方法获取一个 Channel 对象，并向该 Channel 对象写入一个标记了心跳标志的 RpcRequest 对象，最后调用 close() 方法关闭该 Channel。</p><p><a name="RGhhY"></a></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;ly3F9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用Netty-Nacos-Protobuf制作RPC框架&quot;&gt;&lt;a href=&quot;#使用Netty-Nacos-Protobuf制作RPC框架&quot; class=&quot;headerlink&quot; title=&quot;使用Nett</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
    <category term="RPC" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>用Go语言编写一个web与分布式应用</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-web-study/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/04/27/go-web-study/</id>
    <published>2022-04-27T15:29:13.000Z</published>
    <updated>2023-03-26T14:20:53.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Go语言编写一个web应用"><a href="#使用Go语言编写一个web应用" class="headerlink" title="使用Go语言编写一个web应用"></a>使用Go语言编写一个web应用</h1><h2 id="初始知识"><a href="#初始知识" class="headerlink" title="初始知识"></a>初始知识</h2><h3 id="go语言的学习"><a href="#go语言的学习" class="headerlink" title="go语言的学习"></a>go语言的学习</h3><p>其实很简单，就不详细写了。</p><p>可以去类似于去菜鸟教程这个网站，去初步的了解编程语言的写法。</p><p>或者是类似于哔哔哔哩这样的视频网站，直接照这视频一步一步的去学习它的写法，不过这种方法比较消耗时间。但是我觉得如果你有一定的编程基础，学这个go真的很简单，没有什么复杂地方。你仅需要注意的是，语法有些不同，你可能要花一段时间去适应它的写法。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然网上很多教程都是使用VScode去写的，但是我觉得不是很好，可能自己对于这种轻量级的工具不是很适应。</p><p>我使用的是IntelliJ IDEA ，然后安装了go的插件之后去写的，我觉得这样写起来比较轻松，这个要看个人了。</p><h3 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h3><p>这个编程语言去做一个web服务的话，有点像cpp一样复古的写法，但是相比于cpp这样语言来肯定要简单得多。不过，如果你有一定的基础的话，会比较轻松吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//初始化一个函数，让其能对web应用进行响应</span></span><br><span class="line"><span class="comment">//第一个参数是路由地址，第二个参数是函数主要功能是收到请求并响应</span></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务器，第一个参数是网络地址，第二个参数是处理方式</span></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后就可以看到结果了。</p><h2 id="正式编写"><a href="#正式编写" class="headerlink" title="正式编写"></a>正式编写</h2><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h4><p>首先要编写一个go程序，就如上面的例子一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := myHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: &amp;mh, <span class="comment">//Handler实际上是一个接口</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，所有的网址都会输出同样的信息，因为每个请求都是使用同一个Handler。而我们应该使用：DefaultServeMux 去进行处理不同的Handler，而我们就需要对每个Handler进行注册，这样才能进行出结果。</p><p>所以我们应该这么改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于我们把我们需要自定义的Handler，根据自己的需要去更改，最后注册到DefaultServeMux当中，完成对不同请求产生不同的响应。</p><h4 id="HandleFunc"><a href="#HandleFunc" class="headerlink" title="HandleFunc"></a>HandleFunc</h4><p>但前面的处理完全可以简写为一个方式，增加可读性，于是乎，我们就要用到这个函数HandleFunc：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> helloHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http.ResponseWriter用于表达响应的</span></span><br><span class="line"><span class="comment">// *http.Request 收到的请求，可以是get或post等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *helloHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello, my lover"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aboutHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *aboutHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"About, my message"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//自制一个Handler</span></span><br><span class="line">mh := helloHandler&#123;&#125;</span><br><span class="line">a := aboutHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 http.ListenAndServe</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>, <span class="comment">//这样会默认使用DefaultServeMux</span></span><br><span class="line"><span class="comment">//http.DefaultServeMux也是一个Handler，使用nil是默认使用</span></span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">"/hello"</span>, &amp;mh) <span class="comment">//相信到这里，就很简单了，直接望文生义即可</span></span><br><span class="line">http.Handle(<span class="string">"/about"</span>, &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HandleFunc</span></span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个HandleFunc本质上还是调用Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把上述代码中的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, welcome)</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>其结果也是一样的。因为这其实是接口型函数，表示函数的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是go语言精妙的地方了。你可以面对多种不一样的处理方式，但是只用放在同一个接口当中，这就是go语言使用组成而不是继承的原因。</p><p>总结，如何注册DefaultServeHTTP</p><p>方法一、使用http.Handle（第二个参数是Handler）</p><p>方法二、使用http.HandleFunc（第二个参数是Handler函数）</p><p>方法三、http.HandlerFunc可以进行类型转换，将Handler函数转化成Handler（结构体）来使用</p><h3 id="内置Handler"><a href="#内置Handler" class="headerlink" title="内置Handler"></a>内置Handler</h3><ul><li>func NotFoundHandler() Handler<br>返回一个 handler，它给每个请求的响应都是“404 page not found”</li><li>func RedirectHandler(url string, code int) Handler<br>返回一个 handler，它把每个请求使用给定的状态码跳转到指定的 URL。<br>url，要跳转到的 URL<br>code，跳转的状态码（3xx），常见的：StatusMovedPermanently、StatusFound 或 StatusSeeOther 等</li><li>func StripPrefix(prefix string, h handler) Handler<br>返回一个 handler，它从请求 URL 中去掉指定的前缀，然后再调用另一个 handler。<br>如果请求的 URL 与提供的前缀不符，那么 404<br>略像中间件<br>prefix，URL 将要被移除的字符串前缀<br>h，是一个 handler，在移除字符串前缀之后，这个 handler 将会接收到请求<br>修饰了另一个 Handler </li><li>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler<br>返回一个 handler，它用来在指定时间内运行传入的 h。<br>也相当于是一个修饰器<br>h，将要被修饰的 handler<br>dt，第一个 handler 允许的处理时间<br>msg，如果超时，那么就把 msg 返回给请求，表示响应时间过长</li><li>func FileServer(root FileSystem) Handler<br>返回一个 handler，使用基于 root 的文件系统来响应请求<br>type FileSystem interface {<pre><code>Open(name string) (File, error)</code></pre>  }<br>使用时需要用到操作系统的文件系统，所以还需要委托给：<br>type Dir string<br>func (d Dir) Open(name string) (File, error)</li></ul><h4 id="代码演示：FileServer"><a href="#代码演示：FileServer" class="headerlink" title="代码演示：FileServer"></a>代码演示：FileServer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8888"</span>, http.FileServer(http.Dir(<span class="string">"root"</span>)))</span><br></pre></td></tr></table></figure><p>可以通过这个方法指定root这个根路径，这样打开文件的时候直接去root，直接找到需要的url路径，加载文件</p><h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p> 最基本的肯定是：</p><ul><li><p>HTTP Request 和 HTTP Response（请求和响应）</p></li><li><p>它们具有相同的结构：</p><ul><li><p>​    请求（响应）行</p></li><li><p>​    0 个或多个 Header</p></li><li><p>​    空行</p></li><li><p>​    可选的消息体（Body）</p></li></ul></li></ul><p>而 <strong>net/http</strong> 包提供了用于表示 HTTP 消息的结构，其中Reqeust（是个 struct），代表了客户端发送的 HTTP 请求消息</p><h4 id="URL类型"><a href="#URL类型" class="headerlink" title="URL类型"></a>URL类型</h4><h5 id="URL-Query"><a href="#URL-Query" class="headerlink" title="URL Query"></a>URL Query</h5><p>RawQuery 会提供实际查询的字符串。</p><p>例如： <a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>它的 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>还有一个简便方法可以得到 Key-Value 对：通过 Request 的 Form 字段（以后再说）</p><h5 id="URL-Fragment"><a href="#URL-Fragment" class="headerlink" title="URL Fragment"></a>URL Fragment</h5><p>如果从浏览器发出的请求，那么你无法提取出 Fragment 字段的值</p><p>浏览器在发送请求时会把 fragment 部分去掉</p><p>但不是所有的请求都是从浏览器发出的（例如从 HTTP 客户端包）。</p><h5 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h5><p>请求和响应（Request、Response）的 headers 是通过 Header 类型来描述的，它是一个 map，用来表述 HTTP Header 里的 Key-Value 对。</p><p>Header map 的 key 是 string 类型，value 是 []string</p><p>设置 key 的时候会创建一个空的 []string 作为 value，value 里面第一个元素就是新 header 的值；</p><p>为指定的 key 添加一个新的 header 值，执行 append 操作即可</p><h5 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h5><p>请求和响应的 bodies 都是使用 Body 字段来表示的</p><p>Body 是一个 io.ReadCloser 接口</p><p>一个 Reader 接口</p><p>一个 Closer 接口</p><p>Reader 接口定义了一个 Open 方法：</p><p>参数：[]byte</p><p>返回：byte 的数量、可选的错误</p><p>Closer 接口定义了一个 Close 方法：</p><p>没有参数，返回可选的错误</p><h5 id="代码演示-Fragment"><a href="#代码演示-Fragment" class="headerlink" title="代码演示:Fragment"></a>代码演示:Fragment</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/url"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.URL.Fragment)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过这种方式，看看自己请求有没有Fragment</p><h5 id="代码演示-Header"><a href="#代码演示-Header" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/header"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(writer, request.Header)</span><br><span class="line">fmt.Fprintln(writer, request.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">fmt.Fprintln(writer, request.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman测试：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/header</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[Accept:[*&#x2F;*] Accept-Encoding:[gzip, deflate, br] Connection:[keep-alive] Postman-Token:[9ddda678-d6f8-42d2-aea5-67816a86c3d7] User-Agent:[PostmanRuntime&#x2F;7.28.3]]</span><br><span class="line">[gzip, deflate, br]</span><br><span class="line">gzip, deflate, br</span><br></pre></td></tr></table></figure><h5 id="代码演示-Header-1"><a href="#代码演示-Header-1" class="headerlink" title="代码演示:Header"></a>代码演示:Header</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">"localhost:8888"</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/post"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">length := request.ContentLength</span><br><span class="line">body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">request.Body.Read(body)</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个方式去展现出body的内容</p><h4 id="URL-Query-1"><a href="#URL-Query-1" class="headerlink" title="URL Query"></a>URL Query</h4><p>例如：<a href="http://www.example.com/post?id=123&amp;thread_id=456" target="_blank" rel="noopener">http://www.example.com/post?id=123&amp;thread_id=456</a></p><p>r.URL.RawQuery 会提供实际查询的原始字符串，因为 RawQuery 的值就是 id=123&amp;thread_id=456</p><p>r.URL.Query()，会提供查询字符串对应的 map string string</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">url := request.URL</span><br><span class="line">query := url.Query() <span class="comment">//得到一个map</span></span><br><span class="line"></span><br><span class="line">id := query[<span class="string">"id"</span>]</span><br><span class="line">log.Println(id)</span><br><span class="line"></span><br><span class="line">name := query.Get(<span class="string">"name"</span>)</span><br><span class="line">log.Println(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/home?id=123&amp;name=panda&amp;id=456&amp;name=fox</span><br></pre></td></tr></table></figure><p>控制台显示结果为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[123 456]</span><br><span class="line">panda</span><br></pre></td></tr></table></figure><p>这表明 query[“id”] 是获取所有的值，而query.Get(“name”) 只会获取第一个值</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><h4 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a>enctype</h4><p>接下来看看，如何处理表单类的数据。</p><p>HTML 表单里面的数据会以 name-value 对的形式，通过 POST 请求发送出去，它的数据内容会放在 POST 请求的 Body 里面。</p><p>通过 POST 发送的 name-value 数据对的格式可以通过表单的 Content Type 来指定，也就是 enctype 属性。</p><p>默认值是：application/x-www-form-urlencoded<br>浏览器被要求至少要支持： application/x-www-form-urlencoded 、multipart/form-data。HTML 5 的话，还需要支持 text/plain</p><p>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：    first_name=sau%20sheong&amp;last_name=chang</p><p>如果 enctype 是 multipart/form-data，那么：每一个 name-value 对都会被转换为一个MIME消息部分，每一个部分都有自己的 Content Type 和 Content Disposition</p><p>那么，改如何选择enctype呢？</p><ol><li>简单文本：表单 URL 编码</li><li>大量数据，例如上传文件：multipart-MIME，甚至可以把二进制数据通过选择 Base64 编码，来当作文本进行发送</li></ol><h4 id="Form字段"><a href="#Form字段" class="headerlink" title="Form字段"></a>Form字段</h4><p>Request 上的函数允许我们从 URL 或/和 Body 中提取数据，通过这些字段：    </p><ul><li>Form</li><li>PostForm</li><li>MultipartForm</li></ul><p>Form 里面的数据是 key-value 对。通常的做法是：先调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.Form)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会打印出一个map，包含传入的所有的值。包括url的值和表单的值。</p><p>如果只想要表单的 key-value 对，不要 URL 的，可以使用 PostForm 字段。<br>PostForm 只支持 application/x-www-form-urlencoded</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseForm()</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就只有一个字段</p><p>而想要得到 multipart key-value 对，必须使用 MultipartForm 字段。</p><p>想要使用 MultipartForm 这个字段的话，首先需要调用ParseMultipartForm 这个方法，该方法会在必要时调用 ParseForm 方法<br>，参数是需要读取数据的长度<br>MultipartForm 只包含表单的 key-value 对，返回类型是一个 struct 而不是 map。这个 struct 里有两个 map：1、key 是 string，value 是 []string 。2、空的（key 是 string，value 是文件）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.PostForm)</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="FormValue-和-PostFormValue-方法"><a href="#FormValue-和-PostFormValue-方法" class="headerlink" title="FormValue 和 PostFormValue 方法"></a>FormValue 和 PostFormValue 方法</h5><ul><li>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用 ParseForm 或 ParseMultipartForm</li><li>PostFormValue 方法也一样，但只能读取 PostForm</li><li>FormValue 和 PostFormValue 都会调用 ParseMultipartForm 方法</li><li>但如果表单的 enctype 设为 multipart/form-data，那么即使你调用ParseMultipartForm 方法，也无法通过 FormValue 获得想要的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">fmt.Fprintln(writer, request.FormValue(<span class="string">"name"</span>))</span><br><span class="line">fmt.Fprintln(writer, request.PostFormValue(<span class="string">"name"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>multipart/form-data 最常见的应用场景就是上传文件（例子）：</p><ol><li>首先调用 ParseMultipartForm 方法</li><li>从 File 字段获得 FileHeader，调用其 Open 方法来获得文件</li><li>可以使用 ioutil.ReadAll 函数把文件内容读取到 byte 切片里</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">request.ParseMultipartForm(<span class="number">1024</span>)                      <span class="comment">//1024表示一次性加载到内存的最大字节数</span></span><br><span class="line">fileHeader := request.MultipartForm.File[<span class="string">"upload"</span>][<span class="number">0</span>] <span class="comment">//表示从upload字段获取值</span></span><br><span class="line">file, err := fileHeader.Open()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字如其意，非常简单。但是这部分代码仍然有改进的空间，比如使用FormFile</p><h5 id="FormFile"><a href="#FormFile" class="headerlink" title="FormFile()"></a>FormFile()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//request.ParseMultipartForm(1024)                      //1024表示一次性加载到内存的最大字节数</span></span><br><span class="line"><span class="comment">//fileHeader := request.MultipartForm.File["upload"][0] //表示从upload字段获取值</span></span><br><span class="line"><span class="comment">//file, err := fileHeader.Open()</span></span><br><span class="line"></span><br><span class="line">file, _, err := request.FormFile(<span class="string">"uploader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">data, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(writer, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MultipartReader"><a href="#MultipartReader" class="headerlink" title="MultipartReader()"></a>MultipartReader()</h5><p>方法签名：func (r <em>Request) MultipartReader() (</em>multipart.Reader, error)<br>如果是 multipart/form-data 或 multipart 混合的 POST 请求：1、MultipartReader 返回一个 MIME multipart reader 2、否则返回 nil 和一个错误<br>可以使用该函数代替 ParseMultipartForm 来把请求的 body 作为 stream 进行处理。1、不是把表单作为一个对象来处理的，不是一次性获得整个 map。2、逐个检查来自表单的值，然后每次处理一个</p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h4><p>从服务器向客户端返回响应需要使用 ResponseWriter。ResponseWriter 是一个接口，handler 用它来返回响应。而真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response。</p><p>但是，为什么request是指针，而writer不用是呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(writer http.ResponseWriter, request *http.Request)</span><br></pre></td></tr></table></figure><p>其实，这两个都是按引用进行传递的，ResponseWriter是具有Header、Write、WriteHeader三种方法的接口，response指针实现了以上三种方法，故response是一种特殊的ResponseWriter。</p><p>并且，ResponseWriter还能使用writer.Write([]byte(str))方法，把字符串写入到body里面。</p><h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接收一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回<br>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader(http.StatusOK)，所以 WriteHeader 主要用来发送错误类的 HTTP 状态码<br>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p><h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改<br>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p><h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，包装一个 404 状态码和一个额外的信息<br>ServeFile 函数，从文件系统提供文件，返回给请求者<br>ServeContent 函数，它可以把实现了 io.ReadSeeker 接口的任何东西里面的内容返回给请求者，并且，还可以处理 Range 请求（范围请求），如果只请求了资源的一部分内容，那么 ServeContent 就可以如此响应。而 ServeFile 或 io.Copy 则不行。<br>Redirect 函数，告诉客户端重定向到另一个 URL</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>Web 模板就是预先设计好的 HTML 页面，它可以被模板引擎反复的使用，来产生 HTML 页面<br>Go 的标准库提供了 text/template，html/template 两个模板库，大多数 Go 的 Web 框架都使用这些库作为 默认的模板引擎</p><h4 id="Go-的模板和模板引擎"><a href="#Go-的模板和模板引擎" class="headerlink" title="Go 的模板和模板引擎"></a>Go 的模板和模板引擎</h4><p>go主要使用的是 text/template，HTML 相关的部分使用了 html/template，是个混合体。go模板可以完全无逻辑，但又具有足够的嵌入特性。和大多数模板引擎一样，Go Web 的模板位于无逻辑和嵌入逻辑之间的某个地方</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>在 Web 应用中，通产是由 handler 来触发模板引擎。handler 调用模板引擎，并将使用的模板传递给引擎，通常是一组模板文件和动态数据。<br>模板引擎生成 HTML，并将其写入到 ResponseWriter，ResponseWriter 再将它加入到 HTTP 响应中，返回给客户端。</p><h5 id="模板的例子"><a href="#模板的例子" class="headerlink" title="模板的例子"></a>模板的例子</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go Web Programming<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模板必须是可读的文本格式，扩展名任意。对于 Web 应用通常就是 HTML，里面会内嵌一些命令（叫做 action）</span><br><span class="line">text/template 是通用模板引擎，html/template 是 HTML 模板引擎</span><br><span class="line">action 位于双层花括号之间：&#123;&#123; . &#125;&#125;。这里的 . 就是一个 action。它可以命令模板引擎将其替换成一个值。</span><br></pre></td></tr></table></figure><p>是不是有点像jsp</p><h5 id="使用模板引擎"><a href="#使用模板引擎" class="headerlink" title="使用模板引擎"></a>使用模板引擎</h5><ol><li>解析模板源（可以是字符串或模板文件），从而创建一个解析好的 模板的 struct</li><li>执行解析好的模板，并传入 ResponseWriter 和 数据。这会触发模板引擎组合解析好的模板和数据，来产生最终的 HTML，并将它传递给 ResponseWriter </li></ol><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/process"</span>, process)</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">t, _ := template.ParseFiles(<span class="string">"mytest.html"</span>) <span class="comment">//去解析一个模板文件，一个也在这个包下的html文件，</span></span><br><span class="line">t.Execute(writer, <span class="string">"hello,my friends"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是鉴于现今几乎都是前后端分离的项目了，模板引擎已经几乎要绝迹了，随便学学吧。</p><h4 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h4><h5 id="ParseFiles"><a href="#ParseFiles" class="headerlink" title="ParseFiles"></a>ParseFiles</h5><p>解析模板文件，并创建一个解析好的模板 struct，后续可以被执行<br>ParseFiles 函数是 Template struct 上 ParseFiles 方法的简便调用<br>调用 ParseFiles 后，会创建一个新的模板，模板的名字是文件名<br>ParseFiles 的参数数量可变，但只返回一个模板，当解析多个文件时，第一个文件作为返回的模板（名、内容），其余的作为 map，供后续执行使用</p><h5 id="ParseGlob"><a href="#ParseGlob" class="headerlink" title="ParseGlob"></a>ParseGlob</h5><p>使用模式匹配来解析特定的文件</p><h5 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h5><p>可以解析字符串模板，其它方式最终都会调用 Parse</p><h5 id="Lookup-方法"><a href="#Lookup-方法" class="headerlink" title="Lookup 方法"></a>Lookup 方法</h5><p>通过模板名来寻找模板，如果没找到就返回 nil</p><h5 id="Must-函数"><a href="#Must-函数" class="headerlink" title="Must 函数"></a>Must 函数</h5><p>可以包裹一个函数，返回到一个模板的指针 和 一个错误。如果错误不为 nil，那么就 panic</p><h4 id="模板的Action"><a href="#模板的Action" class="headerlink" title="模板的Action"></a>模板的Action</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action 就是 Go 模板中嵌入的命令，位于两组花括号之间 &#123;&#123; xxx &#125;&#125;，就是一个 Action，而且是最重要的一个。它代表了传入模板的数据</span><br></pre></td></tr></table></figure><p>Action 主要可以分为五类：条件类，迭代/遍历类，设置类，包含类，定义类</p><h5 id="条件Action"><a href="#条件Action" class="headerlink" title="条件Action"></a>条件Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">  other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代-遍历-Action"><a href="#迭代-遍历-Action" class="headerlink" title="迭代/遍历 Action"></a>迭代/遍历 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">  Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>这类 Action 用来遍历数组、slice、map 或 channel 等数据结构，“.”用来表示每次迭代循环中的元素</p><h5 id="设置Action"><a href="#设置Action" class="headerlink" title="设置Action"></a>设置Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>它允许在指定范围内，让“.”来表示其它指定的值（arg）</p><h5 id="包含-Action"><a href="#包含-Action" class="headerlink" title="包含 Action"></a>包含 Action</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template "name" &#125;&#125;</span><br><span class="line">它允许你在模板中包含其它的模板</span><br><span class="line">&#123;&#123; template "name" arg &#125;&#125;</span><br><span class="line">给被包含模板传递参数</span><br></pre></td></tr></table></figure><h4 id="函数与管道"><a href="#函数与管道" class="headerlink" title="函数与管道"></a>函数与管道</h4><h5 id="参数（argument）"><a href="#参数（argument）" class="headerlink" title="参数（argument）"></a>参数（argument）</h5><p>参数就是模板里面用到的值。可以是 bool、整数、string … ，也可以是 struct、struct 的字段、数组的 key 等等<br>参数可以是变量、方法（返回单个值或返回一个值和一个错误）或函数<br>参数可以是一个点“.”，也就是传入模板引擎的那个值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">  some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">这里的 arg 就是参数</span><br></pre></td></tr></table></figure><h5 id="在-Action-中设置变量"><a href="#在-Action-中设置变量" class="headerlink" title="在 Action 中设置变量"></a>在 Action 中设置变量</h5><p>可以在 action 中设置变量，变量以 $ 开头：$variable := value<br>一个迭代 action 的例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">  The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="管道（pipeline）"><a href="#管道（pipeline）" class="headerlink" title="管道（pipeline）"></a>管道（pipeline）</h5><p>管道是按顺序连接到一起的参数、函数和方法。和 Unix 的管道类似:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：&#123;&#123; p1 | p2 | p3 &#125;&#125;  ，p1、p2、p3 要么是参数，要么是函数</span><br><span class="line">管道允许我们把参数的输出发给下一个参数，下一个参数由管道（|）分隔开。</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>参数可以是一个函数，Go 模板引擎提供了一些基本的内置函数，功能比较有限。例如 fmt.Sprint 的各类变体等<br>开发者可以自定义函数，可以接收任意数量的输入参数<br>返回：一个值     或       一个值+一个错误</p><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define、template、block</span><br><span class="line">html、js、urlquery。对字符串进行转义，防止安全问题</span><br><span class="line">如果是 Web 模板，那么不会需要经常使用这些函数。</span><br><span class="line">index</span><br><span class="line">print/printf/println</span><br><span class="line">len</span><br><span class="line">with</span><br><span class="line">这些都是内置的函数</span><br></pre></td></tr></table></figure><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template.Funcs(funcMap FuncMap) *Template</span><br><span class="line"><span class="keyword">type</span> FuncMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//value 是函数</span></span><br><span class="line"><span class="comment">//可以有任意数量的参数</span></span><br><span class="line"><span class="comment">//返回单个值的函数或返回一个值+一个错误的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个 FuncMap（map 类型）。</span></span><br><span class="line"><span class="comment">key 是函数名</span></span><br><span class="line"><span class="comment">value 就是函数</span></span><br><span class="line"><span class="comment">把 FuncMap 附加到模板</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>常见用法：template.New(“”).Funcs(funcMap).Parse(…)，调用顺序非常重要。可以在管道中使用，也可以作为正常函数使用。</p><h4 id="模板组合"><a href="#模板组合" class="headerlink" title="模板组合"></a>模板组合</h4><h5 id="Layout-模板"><a href="#Layout-模板" class="headerlink" title="Layout 模板"></a>Layout 模板</h5><p>Layout 模板就是网页中固定的部分，它可以被多个网页重复使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Include（包含）action 的形式：&#123;&#123; template "name" . &#125;，</span><br></pre></td></tr></table></figure><p>以这种方式做 layout 模板是不可行的。而正确的做法是在模板文件里面使用 define action 再定义一个模板。这种形式特别像thymeleaf，就是单纯的将HTML页面强行模块化，使其具有公共部分的属性，总体而言还是比较简单的。而也可以在多个模板文件里，定义同名的模板。</p><h5 id="使用-block-action-定义默认模板"><a href="#使用-block-action-定义默认模板" class="headerlink" title="使用 block action 定义默认模板"></a>使用 block action 定义默认模板</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">  Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">block action 可以定义模板，并同时就使用它</span><br><span class="line">template：模板必须可用</span><br><span class="line">block：模板可以不存在</span><br></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eq/ne</span><br><span class="line">lt/gt</span><br><span class="line">le/ge</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><p>字如其意。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>接下来看看如何使用golang去连接数据库，并进行基本的CRUD。</p><h4 id="https-www-jianshu-com-p-7e745fefb8af"><a href="#https-www-jianshu-com-p-7e745fefb8af" class="headerlink" title="https://www.jianshu.com/p/7e745fefb8af"></a><strong><a href="https://www.jianshu.com/p/7e745fefb8af" target="_blank" rel="noopener">https://www.jianshu.com/p/7e745fefb8af</a></strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//"用户名:密码@[连接方式](主机名:端口号)/数据库名"</span></span><br><span class="line">    db,_:=sql.Open(<span class="string">"mysql"</span>,<span class="string">"root:root@(127.0.0.1:3306)/testdatabases"</span>) <span class="comment">// 设置连接数据库的参数</span></span><br><span class="line">    <span class="keyword">defer</span> db.Close()    <span class="comment">//关闭数据库</span></span><br><span class="line">    err:=db.Ping()      <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"数据库连接失败"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作一：执行数据操作语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sql:="insert into stu values (2,'berry')"</span></span><br><span class="line"><span class="comment">    result,_:=db.Exec(sql)      //执行SQL语句</span></span><br><span class="line"><span class="comment">    n,_:=result.RowsAffected(); //获取受影响的记录数</span></span><br><span class="line"><span class="comment">    fmt.Println("受影响的记录数是",n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作二：执行预处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    stu:=[2][2] string&#123;&#123;"3","ketty"&#125;,&#123;"4","rose"&#125;&#125;</span></span><br><span class="line"><span class="comment">    stmt,_:=db.Prepare("insert into stu values (?,?)")      //获取预处理语句对象</span></span><br><span class="line"><span class="comment">    for _,s:=range stu&#123;</span></span><br><span class="line"><span class="comment">        stmt.Exec(s[0],s[1])            //调用预处理语句</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作三：单行查询</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    var id,name string</span></span><br><span class="line"><span class="comment">    rows:=db.QueryRow("select * from stu where id=4")   //获取一行数据</span></span><br><span class="line"><span class="comment">    rows.Scan(&amp;id,&amp;name)        //将rows中的数据存到id,name中</span></span><br><span class="line"><span class="comment">    fmt.Println(id,"--",name)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作四：多行查询</span></span><br><span class="line">    rows,_:=db.Query(<span class="string">"select * from stu"</span>)       <span class="comment">//获取所有数据</span></span><br><span class="line">    <span class="keyword">var</span> id,name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next()&#123;        <span class="comment">//循环显示所有的数据</span></span><br><span class="line">        rows.Scan(&amp;id,&amp;name)</span><br><span class="line">        fmt.Println(id,<span class="string">"--"</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>前面很多时候，都是使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br></pre></td></tr></table></figure><p>HandleFunc这种方式去进行路由控制，但是其实还有更为方便的写法。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>main()：设置类工作<br>controller：1、静态资源 。2、把不同的请求送到不同的 controller 进行处理</p><p>我们实际上应该这么设置才是最为正确的写法。</p><p>例子，先制作出两个页面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerWelcomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/welcome"</span>, http.HandlerFunc(welcome))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">_, err := writer.Write([]<span class="keyword">byte</span>(<span class="string">"welcome,my friends"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将两个函数进行注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="comment">//RegisterRoutes 用于注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//这里还可以使用静态资源</span></span><br><span class="line">registerHomeRoutes()</span><br><span class="line">registerWelcomeRoutes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在主函数中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">server :&#x3D; http.Server&#123;</span><br><span class="line">Addr:    &quot;localhost:8888&quot;,</span><br><span class="line">Handler: nil,</span><br><span class="line">&#125;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">err :&#x3D; server.ListenAndServe()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是一种代码层面的解耦合，将我们的函数进一步模块化。</p><h4 id="路由的参数"><a href="#路由的参数" class="headerlink" title="路由的参数"></a>路由的参数</h4><p>静态路由：一个路径对应一个页面：</p><p>/home           或       /about</p><p>带参数的路由：根据路由参数，创建出一族不同的页面：</p><p>/companies/123               或            /companies/Google</p><p>这里使用HandlerFunc就可以了，将字符串传入URL，效果是相同的，与Spring+thymeleaf可以说是一模一样。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>现在讲究前后端分离，大多数数据都是使用JSON去传递数据，接下来看看如何在go中使用JSON对象。</p><h4 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h4><p>Go bool：JSON boolean<br>Go float64：JSON 数值<br>Go string：JSON strings<br>Go nil：JSON null.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于未知结构的-JSON"><a href="#对于未知结构的-JSON" class="headerlink" title="对于未知结构的 JSON"></a>对于未知结构的 JSON</h4><p>map[string]interface{} 可以存储任意 JSON 对象<br>[]interface{} 可以存储任意的 JSON 数组</p><h4 id="读取-JSON"><a href="#读取-JSON" class="headerlink" title="读取 JSON"></a>读取 JSON</h4><p>需要一个解码器：dec := json.NewDecoder(r.Body) ，参数需实现 Reader 接口<br>解码器上进行解码：dec.Decode(&amp;query)</p><h4 id="写入-JSON"><a href="#写入-JSON" class="headerlink" title="写入 JSON"></a>写入 JSON</h4><p>需要一个编码器：enc := json.NewEncoder(w)，参数需实现 Writer 接口<br>编码是：enc.Encode(results)</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//首先看看请求的类型</span></span><br><span class="line">dec := json.NewDecoder(request.Body) <span class="comment">//现在JSON就在这个body里边了，并且需要进行解码</span></span><br><span class="line">company := Company&#123;&#125;</span><br><span class="line">err := dec.Decode(&amp;company) <span class="comment">//将密码解码到company这个变量里边</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;             <span class="comment">//如果它不为空</span></span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则将客户端传过来的数据转化为json重新返回给客户端</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">err = enc.Encode(company)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err.Error())                           <span class="comment">//打印错误</span></span><br><span class="line">writer.WriteHeader(http.StatusInternalServerError) <span class="comment">//500error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr:    <span class="string">"localhost:8888"</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := server.ListenAndServe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Postman进行测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8888/companies</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">&#123;</span></span><br><span class="line">    "id": 123,</span><br><span class="line">    "name": "google",</span><br><span class="line">    "country": "USA"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码的类型：Marshal-和-Unmarshal"><a href="#编码的类型：Marshal-和-Unmarshal" class="headerlink" title="编码的类型：Marshal 和 Unmarshal"></a>编码的类型：Marshal 和 Unmarshal</h4><p>Marshal（编码）: 把 go struct 转化为 json 格式。MarshalIndent，带缩进<br>Unmarshal（解码）: 把 json 转化为 go struct</p><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "id": 123,</span></span><br><span class="line"><span class="string">    "name": "google",</span></span><br><span class="line"><span class="string">    "country": "USA"</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c := Company&#123;&#125;</span><br><span class="line">_ = json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;c)</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line">bytes, _ := json.Marshal(c)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line"></span><br><span class="line">bytes2, _ := json.MarshalIndent(c, <span class="string">","</span>, <span class="string">"     "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bytes2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果为：</span></span><br><span class="line">&#123;<span class="number">123</span> google USA&#125;</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="number">123</span>,<span class="string">"name"</span>:<span class="string">"google"</span>,<span class="string">"country"</span>:<span class="string">"USA"</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">,     <span class="string">"id"</span>: <span class="number">123</span>,</span><br><span class="line">,     <span class="string">"name"</span>: <span class="string">"google"</span>,</span><br><span class="line">,     <span class="string">"country"</span>: <span class="string">"USA"</span></span><br><span class="line">,&#125;</span><br></pre></td></tr></table></figure><p>区别：</p><p>针对 string 或 bytes：</p><ul><li>Marshal =&gt; String</li><li>Unmarshal &lt;= String</li></ul><p>针对 stream:</p><ul><li>Encode =&gt; Stream，把数据写入到 io.Writer</li><li>Decode &lt;= Stream，从 io.Reader 读取数据</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件大家都懂的，像消息队列，缓存，也是中间件。当然也可以自己捏一个中间件的处理逻辑。</p><h4 id="创建中间件"><a href="#创建中间件" class="headerlink" title="创建中间件"></a>创建中间件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//handler 如果是 nil：DefaultServeMux</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>像这个Handler接口，并可以支持中间件的处理。</p><p>首先创建一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m MyMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 在 next handler 之前做一些事情</span></span><br><span class="line">m.Next.ServeHTTP(w, r)</span><br><span class="line"><span class="comment">// 在 next handler 之后做一些事情</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>途中可以定义中间件需要做的事情。</p><h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ol><li>Logging，日志</li><li>安全，身份认证</li><li>请求超时，减少资源消耗</li><li>响应压缩，提升效率 </li></ol><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间件</span></span><br><span class="line"><span class="keyword">type</span> AuthMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *AuthMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> am.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">am.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//如果什么都没有，执行默认页面</span></span><br><span class="line">auth := request.Header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line"><span class="keyword">if</span> auth != <span class="string">""</span> &#123; <span class="comment">//说明存在身份，则执行逻辑</span></span><br><span class="line">am.Next.ServeHTTP(writer, request)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//否则报异常</span></span><br><span class="line">writer.WriteHeader(http.StatusUnauthorized) <span class="comment">//401未授权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是自定义的中间件类型，接着是主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, <span class="built_in">new</span>(middleware.AuthMiddleware))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该中间件注册过后，便可以执行逻辑。</p><p>使用Postman进行测试，一个带Authorization，而另一个不带,测试略。</p><h3 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h3><p>从请求的上下文中获取信息，以用于处理</p><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">Context</span><span class="params">()</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//返回当前请求的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="comment">//基于 Context 进行“修改”，（实际上）创建一个新的 Context</span></span><br></pre></td></tr></table></figure><p>有这么两种方式去处理上下文</p><p>看看里面实际上是什么：</p><h4 id="context-Context"><a href="#context-Context" class="headerlink" title="context.Context"></a>context.Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这些方法都是用于读取，不能进行设置</span></span><br></pre></td></tr></table></figure><p>这就是上下文接口里面的方法</p><p>context这个包，也有一些方法，可以返回新的context</p><h4 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h4><ul><li>WithCancel()，它有一个 CancelFunc</li><li>WithDeadline()，带有一个时间戳（time.Time）</li><li>WithTimeout()，带有一个具体的时间段（time.Duration）</li><li>WithValue()，在里面可以添加一些值</li></ul><h4 id="一个超时的例子"><a href="#一个超时的例子" class="headerlink" title="一个超时的例子"></a>一个超时的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeoutMiddleware <span class="keyword">struct</span> &#123;</span><br><span class="line">Next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeoutMiddleware)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tm.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">tm.Next = http.DefaultServeMux</span><br><span class="line">&#125; <span class="comment">//处理和中间件的一般方式一样</span></span><br><span class="line"></span><br><span class="line">ctx := request.Context()                         <span class="comment">//获取上下文</span></span><br><span class="line">ctx, _ = context.WithTimeout(ctx, <span class="number">3</span>*time.Second) <span class="comment">//修改context的超时判断</span></span><br><span class="line">request.WithContext(ctx)                         <span class="comment">//用我们自定义的context去代替</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)                        <span class="comment">//意图在于，如果我们请求能够在3秒内完成的话，这个chan就会收到一个信号</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                                      <span class="comment">//使用goroutine</span></span><br><span class="line">tm.Next.ServeHTTP(writer, request) <span class="comment">//执行完这个方法后，发送一个信号</span></span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;                   <span class="comment">//发送信号</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123; <span class="comment">//一个竞争的状态</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch: <span class="comment">//正常处理完，得到信号，返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//否则返回错误</span></span><br><span class="line">writer.WriteHeader(http.StatusRequestTimeout)</span><br><span class="line">&#125;</span><br><span class="line">ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先新造好这个中间件，然后注册到main函数里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/middleware"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">111</span>,</span><br><span class="line">Name:    <span class="string">"Microsoft"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//time.Sleep(4*time.Second)</span></span><br><span class="line"><span class="comment">//测试用</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:8888"</span>, &amp;middleware.TimeoutMiddleware&#123;Next: <span class="built_in">new</span>(middleware.AuthMiddleware)&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后像之前一样去测试，即可。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>这是HTTP的流程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> HTTP/1.1</span><br><span class="line">…</span><br><span class="line">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure><p>都是明文传输的，所以我们有时候就需要HTTPS</p><h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><ul><li>http.ListenAndServe 函数</li><li>http.ListenAndServeTLS 函数</li></ul><p>可以使用ListenAndServeTLS去使其页面变为HTTPS类型，看看接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServeTLS(certFile, keyFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现需要安全证书，而我们的go就可以自己生成安全证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -h</span><br><span class="line">//看看帮助</span><br><span class="line"> -ca</span><br><span class="line">        whether this cert should be its own Certificate Authority</span><br><span class="line">  -duration duration</span><br><span class="line">        Duration that certificate is valid <span class="keyword">for</span> (default <span class="number">8760</span>h0m0s)</span><br><span class="line">  -ecdsa-curve string</span><br><span class="line">        ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521</span><br><span class="line">  -ed25519</span><br><span class="line">        Generate an Ed25519 key</span><br><span class="line">  -host string</span><br><span class="line">        Comma-separated hostnames and IPs to generate a certificate <span class="keyword">for</span></span><br><span class="line">  -rsa-bits int</span><br><span class="line">        Size of RSA key to generate. Ignored <span class="keyword">if</span> --ecdsa-curve is <span class="built_in">set</span> (default <span class="number">2048</span>)</span><br><span class="line">  -<span class="built_in">start</span>-<span class="built_in">date</span> string</span><br><span class="line">        Creation <span class="built_in">date</span> formatted as Jan <span class="number">1</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span> <span class="number">2011</span></span><br></pre></td></tr></table></figure><p>于是乎，便生成证书：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run D:\Golang\sdk\go1.<span class="number">15</span>.<span class="number">1</span>\src\crypto\tls\generate_cert.go -host localhost</span><br><span class="line"> //wrote cert.pem</span><br><span class="line"> //wrote key.pem</span><br></pre></td></tr></table></figure><p>之后再测试，发现只有使用HTTPS的前缀，才能打开网页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go_web/controller"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">controller.RegisterRoutes()</span><br><span class="line">http.ListenAndServeTLS(<span class="string">"localhost:8888"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们使用的HTTP1.1协议就会自动升级到HTTP2.0协议</p><h3 id="HTTP的协议"><a href="#HTTP的协议" class="headerlink" title="HTTP的协议"></a>HTTP的协议</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>在HTTP/1.1的情况下：</p><ol><li>请求 header+body</li><li>响应 header+body</li></ol><p>这样请求和响应，他们的信息都无法被压缩，会导致传输效率低，但是HTTP2.0使得他们能够压缩加密</p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><p>在这个协议下，请求和响应都是使用Stream来进行的，把消息拆成多个Frame进行发送，每个Frame都可以单独的进行优化。</p><p>Frame类型：Headers、Continuation、Data等等，把请求和响应分成多个Frame，每个数据类型都可以单独优化。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><p>请求多路复用</p></li><li><p>Header 压缩</p></li><li><p>默认安全</p><p>​    HTTP ，但很多决定不支持 HTTP</p><p>​    HTTPS</p></li><li><p>Server Push</p></li></ul><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>在没有Server Push的情况下，每个页面的素材例如：css、html等都是必须发送一个单独的请求来进行的。</p><p>在有了Server Push的情况下，但我们的html页面包含css文件的时候，Server Push会自动传输css文件，即使这个html文件还没有进行对css的引用。这样一来，当html文件需要使用的时候，就不用再次发送请求了。节省了一些加载时间。</p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHomeRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pusher, ok := writer.(http.Pusher); ok &#123; <span class="comment">//先做类型断言，看看存不存在push</span></span><br><span class="line">pusher.Push(<span class="string">"/css/app.css"</span>, &amp;http.PushOptions&#123; <span class="comment">//如果为真，则说明支持server push</span></span><br><span class="line">Header: http.Header&#123;<span class="string">"Content-Type"</span>: []<span class="keyword">string</span>&#123;<span class="string">"text/css"</span>&#125;&#125;, <span class="comment">//使其自加载这个文件</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"back home,my son"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后启动服务，进入页面，打开F12看看，结果就清晰明了了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来学习，如何对go web应用进行测试：</p><h4 id="测试-Model-层"><a href="#测试-Model-层" class="headerlink" title="测试 Model 层"></a>测试 Model 层</h4><p>可以编写一个单独的go程序进行测试，然后编写测试函数，并且应该注重命名：</p><ul><li><p>user_test.go</p><p>​    测试代码所在文件的名称以 _test 结尾</p><p>​    对于生产编译，不会包含以 _test 结尾的文件</p><p>​    对于测试编译，会包含以 _test 结尾的文件</p></li><li><p>func TestUpdatesModifiedTime(t *testing.T) { … }</p><p>​    测试函数名应以 Test 开头（需要导出）</p><p>​    函数名需要表达出被验证的特性</p><p>​    测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Country <span class="keyword">string</span> <span class="string">`json:"country"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Company)</span> <span class="title">GetCompanyType</span><span class="params">()</span> <span class="params">(result <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(c.Name, <span class="string">".LTD"</span>) &#123;</span><br><span class="line">result = <span class="string">"Limited Liability Company"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = <span class="string">"Others"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用一个极为简易的例子去测试，判断公司的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCompany_GetCompanyType</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">c := Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google.LTD"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">companyType := c.GetCompanyType() <span class="comment">//获取类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> companyType != <span class="string">"Limited Liability Company"</span> &#123; <span class="comment">//判断</span></span><br><span class="line">t.Error(<span class="string">"this is others!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果测试通过，则会直接显示PASS</span></span><br><span class="line"><span class="comment">//如果测试不通过。结果如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UN   TestCompany_GetCompanyType</span></span><br><span class="line"><span class="comment">    company_test.go:15: this is others!</span></span><br><span class="line"><span class="comment">--- FAIL: TestCompany_GetCompanyType (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这便是测试的结果。</p><h4 id="测试-Controller-层"><a href="#测试-Controller-层" class="headerlink" title="测试 Controller 层"></a>测试 Controller 层</h4><ol><li>为了尽量保证单元测试的隔离性，测试不要使用例如数据库、外部API、文件系统等外部资源。</li><li>模拟请求和响应</li><li>需要使用 net/http/httptest 提供的功能</li></ol><p>这里有几个函数值得关注：</p><h5 id="NewRequest-函数"><a href="#NewRequest-函数" class="headerlink" title="NewRequest 函数"></a>NewRequest 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//method：HTTP Method</span></span><br><span class="line"><span class="comment">//url：请求的 URL</span></span><br><span class="line"><span class="comment">//body：请求的 Body</span></span><br><span class="line"><span class="comment">//返回的 *Request 可以传递给 handler 函数</span></span><br></pre></td></tr></table></figure><h5 id="ResponseRecorder"><a href="#ResponseRecorder" class="headerlink" title="ResponseRecorder"></a>ResponseRecorder</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseRecorder &#123;</span><br><span class="line">  Code <span class="keyword">int</span> <span class="comment">// 状态码  200、500…</span></span><br><span class="line">HeaderMap http.Header <span class="comment">// 响应的 header</span></span><br><span class="line">Body *bytes.Buffer <span class="comment">// 响应的 body</span></span><br><span class="line">Flushed <span class="keyword">bool</span> <span class="comment">// 缓存是否被 flush 了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来捕获从 handler 返回的响应，只是做记录</span></span><br><span class="line"><span class="comment">//可以用于测试断言</span></span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutesController</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/companies"</span>, handlerCompany)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerCompany</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">c := model.Company&#123;</span><br><span class="line">ID:      <span class="number">123</span>,</span><br><span class="line">Name:    <span class="string">"Google"</span>,</span><br><span class="line">Country: <span class="string">"USA"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收到请求后使用JSON编码，并写到响应里面，并返回回去</span></span><br><span class="line">enc := json.NewEncoder(writer)</span><br><span class="line">enc.Encode(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着写一个测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"go_web/model"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httptest"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandleCompanyCorrect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">r := httptest.NewRequest(http.MethodGet, <span class="string">"/companies"</span>, <span class="literal">nil</span>) <span class="comment">//模拟一个请求</span></span><br><span class="line">w := httptest.NewRecorder()                                 <span class="comment">//用于捕获和记录响应</span></span><br><span class="line">handlerCompany(w, r)                                        <span class="comment">//传入Handler</span></span><br><span class="line"></span><br><span class="line">result, _ := ioutil.ReadAll(w.Result().Body) <span class="comment">//获取响应，提取body</span></span><br><span class="line"></span><br><span class="line">c := model.Company&#123;&#125;</span><br><span class="line">json.Unmarshal(result, &amp;c) <span class="comment">//解码并重新放入c这个变量里边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.ID != <span class="number">123</span> &#123; <span class="comment">//然后判断</span></span><br><span class="line">t.Error(<span class="string">"this is a failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过就显示PASS</span></span><br><span class="line"><span class="comment">//否则显示：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">=== RUN   TestHandleCompanyCorrect</span></span><br><span class="line"><span class="comment">    company_test.go:23: this is a failed</span></span><br><span class="line"><span class="comment">--- FAIL: TestHandleCompanyCorrect (0.00s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">FAIL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这还是比较方便的</p><h3 id="Profiling-性能分析"><a href="#Profiling-性能分析" class="headerlink" title="Profiling 性能分析"></a>Profiling 性能分析</h3><h4 id="分析的对象"><a href="#分析的对象" class="headerlink" title="分析的对象"></a>分析的对象</h4><ul><li><p>内存消耗</p></li><li><p>CPU 使用</p></li><li><p>阻塞的 goroutine</p></li><li><p>执行追踪</p></li></ul><p>还有一个 Web 界面：应用的实时数据</p><h4 id="如何分析"><a href="#如何分析" class="headerlink" title="如何分析"></a>如何分析</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import _ “<span class="built_in">net</span>/http/pprof”</span><br><span class="line">引入一个包，设置一些监听的 URL，它们会提供各类诊断信息</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/heap   // 内存</span><br><span class="line">从应用获取内存 dump：应用在使用哪些内存，它们会去哪</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/profile    // CPU</span><br><span class="line">CPU 的快照，可以看到谁在用 CPU</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/block // goroutine</span><br><span class="line">看到阻塞的 goroutine</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:<span class="number">8000</span>/debug/pprof/trace?seconds=<span class="number">5</span>  // trace</span><br><span class="line">监控这段时间内，什么在执行，什么在调用什么…</span><br><span class="line"></span><br><span class="line"><span class="function">http:// <span class="title">localhost</span>:8000/<span class="title">debug</span>/<span class="title">pprof</span> // 网页</span></span><br></pre></td></tr></table></figure><p>未完待续…….</p><h1 id="使用Go语言编写一个简易的分布式系统"><a href="#使用Go语言编写一个简易的分布式系统" class="headerlink" title="使用Go语言编写一个简易的分布式系统"></a>使用Go语言编写一个简易的分布式系统</h1><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>在一开始我要去学习用go语言编写一个分布式系统的时候。我会在想什么是分布式系统，分布式系统又跟以往的系统有什么很大的差异，或者说区别嘛。带着这个好奇，我去搜索一下什么才是真正的分布式系统，我以为是非常高深，又难以明白的一门学科，但是我仔细了解分布式系统的原理后。我发现我好像学过？！</p><p>以下资料是来源于我在网上搜索得出的信息：</p><blockquote><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h3><p>​            集  群: 同一个业务,部署在多个服务器上</p><p>​            分布式: 同一个业务,拆分成多个子业务,部署在不同的服务器上</p><p>​            微服务: 同一个业务,按照功能模块拆分,每一个服务只对应一个功能模块</p><h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二.区别"></a>二.区别</h3><p>​     <strong>集群</strong>是多台服务器一起处理同一个业务,可以使用负载均衡使得每一个服务器的负载相对平衡,集群中的一台服务器出现问题,该服务器所负责的业务可以由其他的服务器代为处理.集群是一种物理形态.</p><p>​     <strong>分布式</strong>是把一个业务拆分成多个子业务,给不同的服务器去处理,这里的服务器可以是单个的服务器,也可以是多个服务器集群,一旦处理该业务的服务器出现问题,那么该业务就无法实现了.分布式是一种工作方式.</p><p>​     <strong>微服务</strong>是把一个业务中的各种功能模块进行拆分,给不同的服务去处理,每个服务只处理一个功能模块,该服务可以是单个服务器也可以是多个服务器集群,每个服务之间都是低耦合的.微服务是一种架构风格.</p><p>​    <strong>为什么说分布式不一定是微服务:</strong></p><p>​    假设有一个很大应用,拆分成几个小应用,但还是很庞大,即便使用了分布式,但其依旧不算是微服务,因为微服务的核心要素是微小,简单来说就是这个应用还不够小(嗯..没错就是这样!)</p><p>​            所以我们可以理解为:微服务是分布式的一个子集</p><h3 id="三-应用场景"><a href="#三-应用场景" class="headerlink" title="三.应用场景"></a>三.应用场景</h3><p>假设有一个业务,该业务有5个功能,每个功能单独处理需要1个小时.</p><p>此时,如果只部署一台服务器,则需要5个小时才能处理完该业务,若采用集群或者分布式来处理,结果如下:</p><p>​            1.采用集群处理:提供5台服务器一起处理该业务,则处理每个功能只需12分钟,即处理整个业务只需1个小时</p><p>​    2.采用分布式处理:提供5台服务器,每个服务器处理不同的功能,则一共也只需要一个小时.</p><p>​            该情况下,微服务和分布式的工作原理和最终结果是一样的.</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>​            分布式中的每一个节点,都可以做集群.而集群并不一定就是分布式的.</p><p>​            微服务肯定是分布式的,但分布式不一定是微服务的.</p><p>作者：晔歌歌<br>链接：<a href="https://www.jianshu.com/p/5f157ac8efcf" target="_blank" rel="noopener">https://www.jianshu.com/p/5f157ac8efcf</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>所以说分布式系统其实是一个非常广泛的概念，很多的应用都可以是一个分布式系统，所以我想以我曾经学过的知识微服务，这一方面去了解，或者说是使用：<strong>如何用go编写一个微服务</strong>，也就是分布式系统。</p><p>注：我觉得写go还用前后端耦合，并且还用模板，是非常愚蠢的行为。而微服务是天生前后端分离的（战术后仰）。</p><p>总体分为三个部分：服务注册，服务发现，状态监控。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="创建自定义的日志服务"><a href="#创建自定义的日志服务" class="headerlink" title="创建自定义的日志服务"></a>创建自定义的日志服务</h3><h4 id="实现基本逻辑"><a href="#实现基本逻辑" class="headerlink" title="实现基本逻辑"></a>实现基本逻辑</h4><p>目的在于接受请求，并把请求写入到log里面，是很多应用必备的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为标准库也有一个log，所以可以起一个别名</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log *stlog.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的在于把日志写入文件系统</span></span><br><span class="line"><span class="keyword">type</span> fileLog <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fl fileLog)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//首先要打开文件，才能写入</span></span><br><span class="line"><span class="comment">//fl文件路径，os...表示没有则创造，只写，只附加，</span></span><br><span class="line">f, err := os.OpenFile(<span class="keyword">string</span>(fl), os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//defer表示程序最后一定会执行的，这句的意思是必须把文件关闭</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="keyword">return</span> f.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把log指向某个文件地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(destination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log = stlog.New(fileLog(destination), <span class="string">"go"</span>, stlog.LstdFlags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/log"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost: <span class="comment">//如果请求是post</span></span><br><span class="line">msg, err := ioutil.ReadAll(request.Body) <span class="comment">//先读取内容</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(msg) == <span class="number">0</span> &#123;         <span class="comment">//如果有错误</span></span><br><span class="line">writer.WriteHeader(http.StatusBadRequest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有错误则写入日志</span></span><br><span class="line">write(<span class="keyword">string</span>(msg))</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//对于其他情况，方法就不进行，直接返回</span></span><br><span class="line">writer.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%v\n"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写好一个基本的日志服务的逻辑，逻辑较为简单。但还需要完善，接下来就要实现能够运行的日志服务。也就是说，还需要把web服务集中化管理，使其能够正常的运行。</p><p>接着创立一个service，去完善服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, serviceName, host, port <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, serviceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完善了服务启动的逻辑，接着还需要去使这个服务能够正常的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line"><span class="string">"Log service"</span>,</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>接着启动服务，并使用postman进行测试:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:4000/log</span></span><br></pre></td></tr></table></figure><p>输入任意文字，就会看到在根目录下，有一个日志文件生成了。</p><h3 id="服务注册的基本逻辑"><a href="#服务注册的基本逻辑" class="headerlink" title="服务注册的基本逻辑"></a>服务注册的基本逻辑</h3><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>首先需要去尝试编写一下，一个可以将服务都注册进去的注册中心。</p><p>先写一个数据结构，注册中心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注册中心包含了各个服务的名字的地址，紧接着，编写服务注册进去之后的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之后，需要让服务独立运行</p><h4 id="独立服务"><a href="#独立服务" class="headerlink" title="独立服务"></a>独立服务</h4><p>接着就需要将之前的服务，注册到服务中心中。</p><p>这就需要创建一个服务中心主要运行逻辑了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将之前的处理逻辑注册进去</span></span><br><span class="line">http.Handle(<span class="string">"/services"</span>, registry.RegistryService&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的逻辑一样，需要有取消功能，当然其实你在ide中能直接打断，但在大型服务中，每秒都要运行。还是需要自定义取消功能的</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">//一样是定义服务的地址</span></span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = registry.ServerPort</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"注册中心 的服务开始。按任意键停止. \n"</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"结束服务注册"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和日志服务的注册类似，没什么特别的,接着测试：</p><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:3000/services</span></span><br></pre></td></tr></table></figure><p>接着输入json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">     <span class="attr">"serviceName"</span>: <span class="string">"study service"</span>,</span><br><span class="line">    <span class="attr">"serviceURL"</span> : <span class="string">" http://localhost/5000/study"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着显示服务注册成功：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">接受请求：</span><br><span class="line">增加服务：study service ，该服务的//localhost/<span class="number">5000</span>/study</span><br></pre></td></tr></table></figure><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><h4 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h4><p>首先微服务的基本含义是：注册中心是一个服务，然后其他的服务注册到注册中心，然后由主要控制台相互控制和调用。</p><p>那么现在会需要一个客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着需要去改一下日志服务的逻辑，使得日志服务会主动去注册自己：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//一旦发生可错误，就取消上下文</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的<strong>registry.RegisterService(reg)</strong>实际上会去调用client的<strong>func RegisterService(r Registration)</strong>，这样会向注册中心发送一个post请求，去注册自己。</p><p>接着，要去改动日志服务的main函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: <span class="string">"log service"</span>,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是增加了<strong>serviceAddress</strong> ，也就是说所有服务都会使用这同一个逻辑。</p><h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>紧接着两个服务连续启动，先启动注册中心，后启动日志逻辑，结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:4000</span><br></pre></td></tr></table></figure><p>很简单对吧，和Spring cloud的微服务简直一模一样。</p><h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h3><p>那么我们把微服务注册进去了，自然能够调用，但是怎么主动去取消微服务呢？它肯定不是说我自己把自己的微服务关了就行了，同时也需要通知注册中心。</p><h4 id="修改注册中心"><a href="#修改注册中心" class="headerlink" title="修改注册中心"></a>修改注册中心</h4><p>直接在注册中心加上一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[i+<span class="number">1</span>:]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后直接在Switch里面增加一个情况Delete：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清晰，就是一模一样的移除服务，总体代码改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心取消服务的方法定义好了，那么也就需要在其他可注册服务的函数体中定义方法。为了进一步的解除耦合度，取消服务的方法和建立服务的方法一样，需要在client里面编写。</p><h4 id="修改客户端"><a href="#修改客户端" class="headerlink" title="修改客户端"></a>修改客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err := enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了ShutdownService去结束这个服务。</p><p>紧接着，去开始服务注册的函数里边，进行取消注册的修改：</p><h4 id="修改服务的注册功能"><a href="#修改服务的注册功能" class="headerlink" title="修改服务的注册功能"></a>修改服务的注册功能</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的函数，用于启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>, reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">registerHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//将传入的函数运行</span></span><br><span class="line">registerHandlersFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对服务进行基本的定义，完善服务，并将信息返回给主函数</span></span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动web服务之后注册：</span></span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, name registry.ServiceName, host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="comment">//使得ctx具有取消的功能</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务地址</span></span><br><span class="line"><span class="keyword">var</span> server http.Server</span><br><span class="line">server.Addr = <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//启动服务，一旦发生可错误，就取消</span></span><br><span class="line">log.Println(server.ListenAndServe())</span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v 服务开始。按任意键停止. \n"</span>, name)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用取消服务的服务</span></span><br><span class="line">err := registry.ShutdownService(fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是两个goroutine的修改，使其具有取消服务的功能。</p><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>那么注册中心和服务的逻辑都修改好了，然后和上面的步骤一样，先启动注册中心，后启动日志逻辑，结果为:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：log service ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line">log service 服务开始。按任意键停止.</span><br><span class="line">q</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">移除服务： <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function"><span class="title">http</span>: <span class="title">Server</span> <span class="title">closed</span></span></span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>前面的服务注册都是一对一的，还体现不了分布式的特点。接下来进行多服务注册，使得一个学生成绩的服务既要使用日志服务，也要注册到注册中心</p><h3 id="业务服务"><a href="#业务服务" class="headerlink" title="业务服务"></a>业务服务</h3><h4 id="基本的数据结构与方法"><a href="#基本的数据结构与方法" class="headerlink" title="基本的数据结构与方法"></a>基本的数据结构与方法</h4><p>首先要编写一个学生的基础信息的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生信息</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">int</span></span><br><span class="line">FirstName <span class="keyword">string</span></span><br><span class="line">LastName  <span class="keyword">string</span></span><br><span class="line">Grades    []Grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分数</span></span><br><span class="line"><span class="keyword">type</span> Grade <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Type  GradeType</span><br><span class="line">Score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GradeType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">//考试类型</span></span><br><span class="line">GradeQuiz = GradeType(<span class="string">"Quiz"</span>)</span><br><span class="line">GradeTest = GradeType(<span class="string">"Test"</span>)</span><br><span class="line">GradeExam = GradeType(<span class="string">"Exam"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的平均成绩</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">Average</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">for</span> _, grade := <span class="keyword">range</span> s.Grades &#123;</span><br><span class="line">result += grade.Score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="keyword">float32</span>(<span class="built_in">len</span>(s.Grades))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找学生 by ID</span></span><br><span class="line"><span class="keyword">type</span> Students []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ss Students)</span> <span class="title">GetByID</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(*Student, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ss &#123;</span><br><span class="line"><span class="keyword">if</span> ss[i].ID == id &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ss[i], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生的ID：  %d  未找到"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于外部的访问</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">students      Students</span><br><span class="line">studentsMutex sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着肯定得有一些学生的数据，来做测试，这些数据一开始就会被加载进数据结构中，这暂时是用来代替数据库的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">students = []Student&#123;</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">1</span>,</span><br><span class="line">FirstName: <span class="string">"Nick"</span>,</span><br><span class="line">LastName:  <span class="string">"Carter"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">85</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">82</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">2</span>,</span><br><span class="line">FirstName: <span class="string">"Roberto"</span>,</span><br><span class="line">LastName:  <span class="string">"Baggio"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">81</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">3</span>,</span><br><span class="line">FirstName: <span class="string">"Emma"</span>,</span><br><span class="line">LastName:  <span class="string">"Stone"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">67</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">75</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">4</span>,</span><br><span class="line">FirstName: <span class="string">"Rachel"</span>,</span><br><span class="line">LastName:  <span class="string">"McAdams"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">98</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">99</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">94</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">ID:        <span class="number">5</span>,</span><br><span class="line">FirstName: <span class="string">"Kelly"</span>,</span><br><span class="line">LastName:  <span class="string">"Clarkson"</span>,</span><br><span class="line">Grades: []Grade&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 1"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">95</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Final Exam"</span>,</span><br><span class="line">Type:  GradeExam,</span><br><span class="line">Score: <span class="number">100</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Title: <span class="string">"Quiz 2"</span>,</span><br><span class="line">Type:  GradeQuiz,</span><br><span class="line">Score: <span class="number">97</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，也肯定要有server，才能正常的启动服务，需要去编写基本的逻辑，比如获取全部学生信息，根据ID进行信息搜索，增加学生信息等功能：</p><h4 id="服务的逻辑"><a href="#服务的逻辑" class="headerlink" title="服务的逻辑"></a>服务的逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="built_in">new</span>(studentsHandler)</span><br><span class="line"><span class="comment">//这个两个地址是不同的，一个是单个页面</span></span><br><span class="line">http.Handle(<span class="string">"/students"</span>, handler)</span><br><span class="line"><span class="comment">//另一个是必须传入参数的页面</span></span><br><span class="line">http.Handle(<span class="string">"/students/"</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以一个链接需要处理很多情况</span></span><br><span class="line"><span class="comment">// /students 分割后长度是2</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125; 分割后长度是3</span></span><br><span class="line"><span class="comment">// /students/&#123;id&#125;/grades  分割后长度是4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//简单对字符进行处理：</span></span><br><span class="line">pathSegments := strings.Split(r.URL.Path, <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(pathSegments) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//获取全部信息</span></span><br><span class="line">sh.getAll(w, r)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//查询</span></span><br><span class="line"><span class="comment">//提取id</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.getOne(w, r, id)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//新增</span></span><br><span class="line">id, err := strconv.Atoi(pathSegments[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sh.addGrade(w, r, id)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取全部学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getAll</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将学生信息全部转为JSON，返回给data，最后写入</span></span><br><span class="line">data, err := sh.toJSON(students)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据ID，搜索学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">getOne</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑与获取全部信息几乎一致</span></span><br><span class="line">data, err := sh.toJSON(student)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">log.Printf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加学生成绩信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">addGrade</span><span class="params">(w http.ResponseWriter, r *http.Request, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">studentsMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> studentsMutex.Unlock()</span><br><span class="line"></span><br><span class="line">student, err := students.GetByID(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的逻辑一样的，没什么好说</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着要从URL中获取到要传达的学生成绩信息</span></span><br><span class="line"><span class="keyword">var</span> g Grade</span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line">err = dec.Decode(&amp;g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这部分逻辑是获取成绩信息</span></span><br><span class="line"><span class="comment">//如果学生成绩获取正确，就附加信息</span></span><br><span class="line">student.Grades = <span class="built_in">append</span>(student.Grades, g)</span><br><span class="line">w.WriteHeader(http.StatusCreated) <span class="comment">//201</span></span><br><span class="line"></span><br><span class="line">data, err := sh.toJSON(g)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Add(<span class="string">"Content-Type"</span>, <span class="string">"applicaiton/json"</span>)</span><br><span class="line">w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化为JSON</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh studentsHandler)</span> <span class="title">toJSON</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">enc := json.NewEncoder(&amp;b)</span><br><span class="line">err := enc.Encode(obj)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"学生信息序列化失败: %q"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，基础逻辑也已经完善了，接着就是在注册中心里增加服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后，得让web服务可以运行，在cmd文件夹下创建一个新的main函数，写入一样的逻辑代码：</p><h4 id="服务启动器"><a href="#服务启动器" class="headerlink" title="服务启动器"></a>服务启动器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么下来，这个业务服务也就完成了，他们可以互相不干扰的进行服务注册，但是现在grade服务还不能去调用日志服务。所以我们还需要服务发现。</p><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现作用能让grade服务可以请求log服务</p><h4 id="去引用日志服务"><a href="#去引用日志服务" class="headerlink" title="去引用日志服务"></a>去引用日志服务</h4><p>首先肯定是要给服务的数据结构增加一些基本信息，这样才能使得服务有这些基本的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册中心</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该服务所依赖的其他服务。用slice去保存</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line"><span class="comment">//向外暴露的服务端口</span></span><br><span class="line">ServiceUpdateURL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LogService     = ServiceName(<span class="string">"LogService"</span>)</span><br><span class="line">GradingService = ServiceName(<span class="string">"GradingService"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一条目</span></span><br><span class="line"><span class="keyword">type</span> patchEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Name ServiceName</span><br><span class="line">URL  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务变化</span></span><br><span class="line"><span class="keyword">type</span> patch <span class="keyword">struct</span> &#123;</span><br><span class="line">Added   []patchEntry</span><br><span class="line">Removed []patchEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以想想，一个服务如果还依赖着其他的服务。那么，当这个服务正要注册的时候，或者说要加入服务群体的时候。就会在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span></span></span><br></pre></td></tr></table></figure><p>进行服务注册，那么这个时候如果服务还依赖其他服务，比如正要注册的grade服务还依赖log服务，这时候就正好可以去获取依赖。</p><p>修改后代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个找到所需要服务并将其注册的过程。</p><p>接着，grade服务会向注册中心请求这些服务，但是注册中心也需要地方去存储这些请求的服务。</p><p>log服务就会向grade服务提供服务，那么会需要一些数据结构去存储：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去实现它的逻辑，总体修改后代码如下：</p><h4 id="服务的提供者"><a href="#服务的提供者" class="headerlink" title="服务的提供者"></a>服务的提供者</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的目的是给web service发送一个post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(r Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务注册中心要向URL更新一些信息</span></span><br><span class="line">serviceUpdateURL, err := url.Parse(r.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(serviceUpdateURL.Path, &amp;serviceUpdateHandler&#123;&#125;)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">enc := json.NewEncoder(buf)</span><br><span class="line">err = enc.Encode(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := http.Post(ServicesURL, <span class="string">"application/json"</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务注册失败 "</span>+<span class="string">"状态码为： %v"</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新服务的处理</span></span><br><span class="line"><span class="keyword">type</span> serviceUpdateHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suh serviceUpdateHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先进行解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line">err := dec.Decode(&amp;p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf("收到更新： %v\n", p)</span></span><br><span class="line">prov.Update(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownService</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodDelete, ServicesURL,</span><br><span class="line">bytes.NewBuffer([]<span class="keyword">byte</span>(url))) <span class="comment">//把string转化为slice</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line"><span class="comment">//紧接着发送请求</span></span><br><span class="line">res, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务取消失败，状态码为：%v"</span>,</span><br><span class="line">res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log服务会向多个服务提供服务</span></span><br><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//服务与服务的URL</span></span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line">mutex *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受到patch的时候，需要进行更新，</span></span><br><span class="line"><span class="keyword">var</span> prov = providers&#123;</span><br><span class="line">services: <span class="built_in">make</span>(<span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span>),</span><br><span class="line">mutex:    <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span> <span class="title">Update</span><span class="params">(pat patch)</span></span> &#123;</span><br><span class="line"><span class="comment">//对传进来的patch更新provider</span></span><br><span class="line">p.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增的情况</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Added &#123;</span><br><span class="line"><span class="comment">//如果这个服务名目前还不存在，就创建新的slice</span></span><br><span class="line"><span class="keyword">if</span> _, ok := p.services[patchEntry.Name]; !ok &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在的话，就在值后边附加URL</span></span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(p.services[patchEntry.Name],</span><br><span class="line">patchEntry.URL)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少的情况</span></span><br><span class="line"><span class="comment">//遍历，对比，移除</span></span><br><span class="line"><span class="keyword">for</span> _, patchEntry := <span class="keyword">range</span> pat.Removed &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs, ok := p.services[patchEntry.Name]; ok &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> providerURLs &#123;</span><br><span class="line"><span class="keyword">if</span> providerURLs[i] == patchEntry.URL &#123;</span><br><span class="line">p.services[patchEntry.Name] = <span class="built_in">append</span>(providerURLs[:i],</span><br><span class="line">providerURLs[i+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后还需要，根据服务的名称来找到它所依赖服务的url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span> <span class="title">get</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">providers, ok := p.services[name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"没有可提供服务的提供商： %v"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机数</span></span><br><span class="line">idx := <span class="keyword">int</span>(rand.Float32() * <span class="keyword">float32</span>(<span class="built_in">len</span>(providers)))</span><br><span class="line"><span class="keyword">return</span> providers[idx], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于这个get方法是私有的，对外再套一个函数：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvider</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> prov.get(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端的client"><a href="#客户端的client" class="headerlink" title="客户端的client"></a>客户端的client</h4><p>log服务现在有服务端的逻辑，但是客户端的服务想使用这个client还是比较麻烦的，所以还需要对log服务有一个自己的client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写日志，把日志写到server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetClientLogger</span><span class="params">(serviceURL <span class="keyword">string</span>, clientService registry.ServiceName)</span></span> &#123;</span><br><span class="line">stlog.SetPrefix(fmt.Sprintf(<span class="string">"[%v] - "</span>, clientService))</span><br><span class="line">stlog.SetFlags(<span class="number">0</span>)</span><br><span class="line">stlog.SetOutput(&amp;clientLogger&#123;url: serviceURL&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> clientLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">url <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl clientLogger)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">b := bytes.NewBuffer([]<span class="keyword">byte</span>(data))</span><br><span class="line"><span class="comment">//写到服务端</span></span><br><span class="line">res, err := http.Post(cl.url+<span class="string">"/log"</span>, <span class="string">"text/plain"</span>, b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to send log message. Service responded with %d - %s"</span>, res.StatusCode, res.Status)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果都没有问题，返回数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以让本地的日志服务写好日志后发送到服务器端保存</p><h4 id="使main函数具有服务发现的功能"><a href="#使main函数具有服务发现的功能" class="headerlink" title="使main函数具有服务发现的功能"></a>使main函数具有服务发现的功能</h4><p>主要是使得两个启动器拥有新的功能：</p><h5 id="grading-service"><a href="#grading-service" class="headerlink" title="grading service"></a>grading service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/grades"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"6000"</span></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%v:%v"</span>, host, port)</span><br><span class="line"></span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.GradingService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: []registry.ServiceName&#123;registry.LogService&#125;,</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line">ctx, err := service.Start(context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">grades.RegisterHandlers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在服务启动之后使用log服务</span></span><br><span class="line"><span class="keyword">if</span> logProvider, err := registry.GetProvider(registry.LogService); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"发现日志服务: %s\n"</span>, logProvider)</span><br><span class="line">log.SetClientLogger(logProvider, r.ServiceName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">"grading service 服务停止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="log-service"><a href="#log-service" class="headerlink" title="log service"></a>log service</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/log"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/registry"</span></span><br><span class="line"><span class="string">"go_distributed_system_study/service"</span></span><br><span class="line">stlog <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义日志地址</span></span><br><span class="line">log.Run(<span class="string">"./distribute.log"</span>)</span><br><span class="line"><span class="comment">//定义具体参数，其实通常应该由配置文件中定义</span></span><br><span class="line">host, port := <span class="string">"localhost"</span>, <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">serviceAddress := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line">r := registry.Registration&#123;</span><br><span class="line">ServiceName: registry.LogService,</span><br><span class="line">ServiceURL:  serviceAddress,</span><br><span class="line"><span class="comment">//添加两个信息</span></span><br><span class="line">RequiredServices: <span class="built_in">make</span>([]registry.ServiceName, <span class="number">0</span>),</span><br><span class="line">ServiceUpdateURL: serviceAddress + <span class="string">"/services"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, err := service.Start(</span><br><span class="line">context.Background(),</span><br><span class="line">host,</span><br><span class="line">port,</span><br><span class="line">r,</span><br><span class="line">log.RegisterHandler,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//如果有错误，就先执行标准库的log打印出结果</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stlog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接需要等待ctx的信号</span></span><br><span class="line"><span class="comment">//如果在启动服务器的时候出现了错误</span></span><br><span class="line"><span class="comment">//或者在按下任意键停止后，就会发送信号</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">//接受到信号后，就会继续</span></span><br><span class="line">fmt.Println(<span class="string">"停止服务"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来便可以测试了。</p><h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><p>按照：registryservice，logservice，gradingservice的顺序启动，测试结果如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span> </span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line"></span><br><span class="line">GradingService 服务开始。按任意键停止.</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br></pre></td></tr></table></figure><p>这么一来就完成了。</p><h3 id="依赖变化"><a href="#依赖变化" class="headerlink" title="依赖变化"></a>依赖变化</h3><h4 id="重新发现服务"><a href="#重新发现服务" class="headerlink" title="重新发现服务"></a>重新发现服务</h4><p>可以从上述的情况下看到一些不那么方便的点，一是：启动必须按照顺序来，不能随意。二是：当log服务下线后，再上线的话不会被再次发现。这都是服务极为脆弱的表现。那么解决这个问题的最好方法是：使服务具有依赖变化时进行通知的功能。</p><p>可以在服务中更改，使其具备通知的功能,主要是有notify函数，总体修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> registry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerPort = <span class="string">":3000"</span></span><br><span class="line"><span class="keyword">const</span> ServicesURL = <span class="string">"http://localhost"</span> + ServerPort + <span class="string">"/services"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//这个slice，是动态变化的，而且多个线程可能会并发的进行访问，</span></span><br><span class="line"><span class="comment">//为了保证线程安全，需要加锁。</span></span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在增加服务的时候是需要加锁的</span></span><br><span class="line"><span class="comment">//add方法表示增加服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line">registry.registrations = <span class="built_in">append</span>(registry.registrations, reg)</span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//正好去获取这个服务所依赖的其他服务</span></span><br><span class="line">err := registry.sendRequireServices(reg)</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务通知，当服务上线，而这个服务又被依赖时，告知依赖服务自己上线了</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Added: []patchEntry&#123;</span><br><span class="line">patchEntry&#123;</span><br><span class="line">Name: reg.ServiceName,</span><br><span class="line">URL:  reg.ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">sendRequireServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">registry.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> registry.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找服务</span></span><br><span class="line"><span class="keyword">var</span> p patch</span><br><span class="line"><span class="keyword">for</span> _, serviceReg := <span class="keyword">range</span> registry.registrations &#123;</span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line"><span class="keyword">if</span> serviceReg.ServiceName == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, patchEntry&#123;</span><br><span class="line">Name: serviceReg.ServiceName,</span><br><span class="line">URL:  serviceReg.ServiceURL,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后,注册</span></span><br><span class="line">err := registry.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知其他服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">notify</span><span class="params">(fullPatch patch)</span></span> &#123;</span><br><span class="line">r.mutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> r.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//看看服务的依赖在patch里面存不存在</span></span><br><span class="line"><span class="comment">//对已经注册的服务循环遍历</span></span><br><span class="line"><span class="keyword">for</span> _, reg := <span class="keyword">range</span> r.registrations &#123;</span><br><span class="line"><span class="comment">//并发的发出通知</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reg Registration)</span></span> &#123;</span><br><span class="line"><span class="comment">//对服务所需要的服务进行循环</span></span><br><span class="line"><span class="keyword">for</span> _, reqService := <span class="keyword">range</span> reg.RequiredServices &#123;</span><br><span class="line">p := patch&#123;Added: []patchEntry&#123;&#125;, Removed: []patchEntry&#123;&#125;&#125;</span><br><span class="line"><span class="comment">//标志位，为TRUE表示有需要更新的地方</span></span><br><span class="line">sendUpdate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, added := <span class="keyword">range</span> fullPatch.Added &#123;</span><br><span class="line"><span class="comment">//如果添加的服务正好是某个服务的依赖项</span></span><br><span class="line"><span class="keyword">if</span> added.Name == reqService &#123;</span><br><span class="line">p.Added = <span class="built_in">append</span>(p.Added, added)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看有哪些服务停止了</span></span><br><span class="line"><span class="keyword">for</span> _, removed := <span class="keyword">range</span> fullPatch.Removed &#123;</span><br><span class="line"><span class="comment">///如果停掉的服务正好是所被依赖的服务</span></span><br><span class="line"><span class="keyword">if</span> removed.Name == reqService &#123;</span><br><span class="line">p.Removed = <span class="built_in">append</span>(p.Removed, removed)</span><br><span class="line">sendUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后判断标志位，把更新发送到对应的服务</span></span><br><span class="line"><span class="keyword">if</span> sendUpdate &#123;</span><br><span class="line">err := r.sendPatch(p, reg.ServiceUpdateURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(reg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要的服务发送过去注册的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d, err := json.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = http.Post(url, <span class="string">"application/json"</span>, bytes.NewBuffer(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么肯定要有个方法取消服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = registry&#123;</span><br><span class="line">registrations: <span class="built_in">make</span>([]Registration, <span class="number">0</span>),</span><br><span class="line">mutex:         <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个web服务</span></span><br><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"等待接受请求："</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">dec := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := dec.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"增加服务：%v ，该服务的地址是：%s \n"</span>,</span><br><span class="line">r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"移除服务： %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><p>接着再进行测试，可以看到，当log服务下线后，重新上线时，grading 服务就能够发现log服务了。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125; &#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">发现日志服务: http://localhost:<span class="number">4000</span></span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br><span class="line">收到更新： &#123;[&#123;LogService http://localhost:<span class="number">4000</span>&#125;] []&#125;</span><br></pre></td></tr></table></figure><h4 id="服务下线告知"><a href="#服务下线告知" class="headerlink" title="服务下线告知"></a>服务下线告知</h4><p>接着也容易，把remove方法里面添加下线告知的功能就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(registry *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//看看服务中台有没有这服务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> reg.registrations &#123;</span><br><span class="line"><span class="keyword">if</span> reg.registrations[i].ServiceURL == url &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下线也告知</span></span><br><span class="line">registry.notify(patch&#123;</span><br><span class="line">Removed: []patchEntry&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: registry.registrations[i].ServiceName,</span><br><span class="line">URL:  registry.registrations[i].ServiceURL,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//下线告知</span></span><br><span class="line"></span><br><span class="line">registry.mutex.Lock()</span><br><span class="line"><span class="comment">//把后面的接上前面的，自然的去除了，方法其实不唯一</span></span><br><span class="line">reg.registrations = <span class="built_in">append</span>(reg.registrations[:i], reg.registrations[:i+<span class="number">1</span>]...)</span><br><span class="line"><span class="comment">//reg.registrations = append(reg.registrations[:i], reg.registrations[i+1:]...)</span></span><br><span class="line">registry.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"服务地址未发现： %s "</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这部分逻辑就完成了。接下来测试代码。</p><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><p>测试的步骤是先开启注册中心，再开启日志服务，后开始grade服务。然后使得日志服务停止，再重启。可以看到一系列的结果。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注册中心 的服务开始。按任意键停止.</span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：GradingService ，该服务的地址是：http://localhost:<span class="number">6000</span></span><br><span class="line">移除服务： http://localhost:<span class="number">4000</span></span><br><span class="line">等待接受请求：</span><br><span class="line">增加服务：LogService ，该服务的地址是：http://localhost:<span class="number">4000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LogService 服务开始。按任意键停止.</span><br><span class="line">收到更新： &#123;[] []&#125;</span><br><span class="line"><span class="function">http: <span class="title">Server</span> <span class="title">closed</span></span></span><br><span class="line"><span class="function">停止服务</span></span><br><span class="line"><span class="function"><span class="title">LogService</span> 服务开始。按任意键停止</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">GradingService</span> 服务开始。按任意键停止.</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br><span class="line"><span class="function">发现日志服务: <span class="title">http</span>://<span class="title">localhost</span>:4000</span></span><br><span class="line"><span class="function">收到更新： &#123;[] [&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;]&#125;</span></span><br><span class="line"><span class="function">收到更新： &#123;[&#123;<span class="title">LogService</span> <span class="title">http</span>://<span class="title">localhost</span>:4000&#125;] []&#125;</span></span><br></pre></td></tr></table></figure><p>使用解除了耦合的网络接口，这也是Spring Cloud的微服务思想，同时也是分布式的一种类型。所以说分布式也没什么神奇之处，最核心的一处在于：<strong>把本地接口转化为了网络接口</strong>。能够理解这一过程，也就理解了分布式的思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Go语言编写一个web应用&quot;&gt;&lt;a href=&quot;#使用Go语言编写一个web应用&quot; class=&quot;headerlink&quot; title=&quot;使用Go语言编写一个web应用&quot;&gt;&lt;/a&gt;使用Go语言编写一个web应用&lt;/h1&gt;&lt;h2 id=&quot;初始知识&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Golang" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
