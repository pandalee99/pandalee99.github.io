<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小世界</title>
  
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/Pandalee99/pandalee99.github.io/"/>
  <updated>2025-01-23T14:12:10.276Z</updated>
  <id>https://github.com/Pandalee99/pandalee99.github.io/</id>
  
  <author>
    <name>攀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bazel工程化集成google/benchmark</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/12/29/bazel/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/12/29/bazel/</id>
    <published>2024-12-29T06:39:27.000Z</published>
    <updated>2025-01-23T14:12:10.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bazel工程化集成google-benchmark"><a href="#Bazel工程化集成google-benchmark" class="headerlink" title="Bazel工程化集成google/benchmark"></a>Bazel工程化集成google/benchmark</h1><p>使用 Bazel 集成 Google Benchmark 到你的项目中：</p><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><p>在项目根目录下的<code>WORKSPACE</code>文件里添加 Google Benchmark 的依赖。你可以通过<code>http_archive</code>规则从 GitHub 下载源码。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@bazel_tools//tools/build_defs/repo:http.bzl"</span>, <span class="string">"http_archive"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载Google Benchmark</span></span><br><span class="line">http_archive(</span><br><span class="line">    name = <span class="string">"com_google_benchmark"</span>,</span><br><span class="line">    strip_prefix = <span class="string">"benchmark-1.8.3"</span>,</span><br><span class="line">    urls = [<span class="string">"https://github.com/google/benchmark/archive/refs/tags/v1.8.3.zip"</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载Google Test，因为Google Benchmark依赖它</span></span><br><span class="line">http_archive(</span><br><span class="line">    name = <span class="string">"com_google_googletest"</span>,</span><br><span class="line">    strip_prefix = <span class="string">"googletest-release-1.13.0"</span>,</span><br><span class="line">    urls = [<span class="string">"https://github.com/google/googletest/archive/refs/tags/release-1.13.0.zip"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述代码从 GitHub 下载了 Google Benchmark 1.8.3 版本和 Google Test 1.13.0 版本。可根据需求调整版本号。</p><h3 id="2-创建-BUILD-文件"><a href="#2-创建-BUILD-文件" class="headerlink" title="2. 创建 BUILD 文件"></a>2. 创建 BUILD 文件</h3><p>在包含基准测试代码的目录下创建<code>BUILD</code>文件，以定义构建规则。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@com_google_benchmark//:benchmark.bzl"</span>, <span class="string">"benchmark"</span>)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"my_benchmark"</span>,</span><br><span class="line">    srcs = [<span class="string">"my_benchmark.cc"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"@com_google_benchmark//:benchmark"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">benchmark(</span><br><span class="line">    name = <span class="string">"run_my_benchmark"</span>,</span><br><span class="line">    srcs = [<span class="string">"my_benchmark.cc"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"@com_google_benchmark//:benchmark"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>cc_binary</code>规则用于构建可执行的基准测试程序。</li><li><code>benchmark</code>规则是 Google Benchmark 提供的，用于运行基准测试并展示结果。</li></ul><h3 id="3-编写基准测试代码"><a href="#3-编写基准测试代码" class="headerlink" title="3. 编写基准测试代码"></a>3. 编写基准测试代码</h3><p>在<code>my_benchmark.cc</code>文件中编写基准测试代码，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基准测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_EmptyLoop</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="comment">// 空循环，用于测试开销</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册基准测试函数</span></span><br><span class="line">BENCHMARK(BM_EmptyLoop);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">BENCHMARK_MAIN();</span><br></pre></td></tr></table></figure><ul><li>引入<code>benchmark/benchmark.h</code>头文件。</li><li>定义<code>BM_EmptyLoop</code>函数，该函数接受<code>benchmark::State&amp; state</code>参数，函数内部是一个空循环。</li><li>利用<code>BENCHMARK(BM_EmptyLoop)</code>注册基准测试函数。</li><li><code>BENCHMARK_MAIN()</code>宏定义程序入口点。</li></ul><h3 id="4-构建并运行基准测试"><a href="#4-构建并运行基准测试" class="headerlink" title="4. 构建并运行基准测试"></a>4. 构建并运行基准测试</h3><p>在项目根目录下使用以下命令构建并运行基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel run //path/to:run_my_benchmark</span><br></pre></td></tr></table></figure><p>将<code>//path/to</code>替换为实际包含<code>BUILD</code>文件和基准测试代码的目录路径。运行命令后，Bazel 会构建基准测试程序并执行，最后输出基准测试结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bazel工程化集成google-benchmark&quot;&gt;&lt;a href=&quot;#Bazel工程化集成google-benchmark&quot; class=&quot;headerlink&quot; title=&quot;Bazel工程化集成google/benchmark&quot;&gt;&lt;/a&gt;Bazel工程化</summary>
      
    
    
    
    
    <category term="C++" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/C/"/>
    
    <category term="Bazel" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Bazel/"/>
    
  </entry>
  
  <entry>
    <title>成为Apache Committer</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/12/19/Apache1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/12/19/Apache1/</id>
    <published>2024-12-19T15:46:00.000Z</published>
    <updated>2025-01-13T06:08:58.403Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个非常值得纪念的经历</p><p><img src="/images/apache1.jpg" alt="Apache"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一个非常值得纪念的经历&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/apache1.jpg&quot; alt=&quot;Apache&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Apache" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>分片传输和流量控制</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/04/04/slice-transmit/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/04/04/slice-transmit/</id>
    <published>2024-04-04T12:58:59.000Z</published>
    <updated>2024-05-06T11:01:53.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分片传输和流量控制"><a href="#分片传输和流量控制" class="headerlink" title="分片传输和流量控制"></a>分片传输和流量控制</h1><p>这其实是一个小功能，准备拆开来细谈一下，原来的功能是，整块数据进行上传到网关，然后由网关上传到HDFS，但是现在需要做一个新的解法。</p><p>因为原来的功能碰到了上传一个文件，第一个是文件太大了，一次性上传往往会占用太多的时间和空间，如果出现网络抖动，或者文件实在太大了挤满了，都会出现问题。第二个是，没有对网关进行流量控制，如果可能存在一个消息队列，在网络发送数据的时候进行分批次导流，就不会出现流量太大使得网关不能正常工作。</p><p>其次就是，网关这里是复数台机器，如果进行升级的时候，一般都是灰度发布，这样会使得大部分流量向一个网关倾斜，所以进行分片传输和导流，还是非常有必要的。</p><p>现在的需求是：</p><p>将一个大文件，进行切分，比如说切分为每个大小25MB，而且需要通过一个队列进行导流，分批次导流进入网关，再由网关缓存，等数据全部到达后，合并数据块，最后上传HDFS</p><h2 id="分片传输功能"><a href="#分片传输功能" class="headerlink" title="分片传输功能"></a>分片传输功能</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">upload_py_fd</span><span class="params">(dst_dir_name, dst_basename, f, mode=<span class="number">0o640</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    Base_Url = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split_file</span><span class="params">(file, chunk_size=<span class="number">1024</span>)</span>:</span></span><br><span class="line">        print(f.getbuffer().nbytes)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = file.read(chunk_size)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成一个随机的 UUID</span></span><br><span class="line">    random_uuid = uuid.uuid4()</span><br><span class="line">    <span class="comment"># 如果传过来的是bytes，则需要转为file</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(f, bytes):</span><br><span class="line">        f = BytesIO(f)</span><br><span class="line">    total_size = f.getbuffer().nbytes</span><br><span class="line">    logger.info(<span class="string">"the file byte total size is  %s "</span> % total_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># md5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_md5</span><span class="params">(file_object)</span>:</span></span><br><span class="line">        hash_object = hashlib.md5()</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: file_object.read(<span class="number">4096</span>), <span class="string">b""</span>):</span><br><span class="line">            hash_object.update(chunk)</span><br><span class="line">        file_object.seek(<span class="number">0</span>)  <span class="comment"># 将文件指针重置到文件的开始位置</span></span><br><span class="line">        <span class="keyword">return</span> hash_object.hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 假设你已经有了文件对象 f</span></span><br><span class="line">    md5 = calculate_md5(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分片大小，可自定义</span></span><br><span class="line">    <span class="comment"># 表示1kb</span></span><br><span class="line">    chunk_size = <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 表示  25MB</span></span><br><span class="line">    chunk_size = chunk_size * <span class="number">25</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># resp</span></span><br><span class="line">    resp_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割文件</span></span><br><span class="line">    <span class="keyword">for</span> i, chunk <span class="keyword">in</span> enumerate(split_file(f, chunk_size=chunk_size)):</span><br><span class="line">        logger.info(<span class="string">f"Chunk index is : <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>,  the chunk is : <span class="subst">&#123;chunk&#125;</span>"</span>)</span><br><span class="line">        f = BytesIO(chunk)</span><br><span class="line"></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"dzuuid"</span>: str(random_uuid),</span><br><span class="line">            <span class="string">"dzchunkindex"</span>: str(i),</span><br><span class="line">            <span class="string">"dztotalfilesize:"</span>: str(len(chunk)),</span><br><span class="line">            <span class="string">"dzchunksize:"</span>: str(chunk_size),</span><br><span class="line">            <span class="string">"dztotalchunkcount"</span>: str((total_size - <span class="number">1</span>) // chunk_size + <span class="number">1</span>),</span><br><span class="line">            <span class="string">"dzchunkbyteoffset"</span>: str(i * chunk_size),</span><br><span class="line">            <span class="string">"md5"</span>: str(md5),</span><br><span class="line">            <span class="string">"file"</span>: f,</span><br><span class="line">            <span class="string">"file_name"</span>: dst_basename,</span><br><span class="line">            <span class="string">"upload_type"</span>: str(<span class="number">1</span>)  <span class="comment"># 分类型 0代表使用 time.time()_file_name ，1 代表只使用file_name</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"post data info : %s"</span> % data)</span><br><span class="line"></span><br><span class="line">        http_code, resp_buff = <span class="keyword">await</span> apost(setting.DOMAIN + Base_Url + dst_dir_name, data=data)</span><br><span class="line">        logger.info(<span class="string">"http code info  %s"</span> % http_code)</span><br><span class="line">        logger.info(<span class="string">"resp is  about wfs url  %s"</span> % resp_buff)</span><br><span class="line">        <span class="keyword">if</span> http_code != <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">raise</span> ErrMsgError(<span class="string">"upload version code:%s"</span> % http_code)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            resp_dict.update(resp_buff)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp_dict</span><br></pre></td></tr></table></figure><p>这里的做法是：</p><p>客户端会去将一个大的文件首先进行进行分片处理，然后初始化一些变量和参数，包括基本的URL路径、文件的UUID、文件的总大小等。计算文件的MD5哈希值，以确保文件的完整性，这里最后会到服务端去验证整个文件是否完整。</p><p>然后，设置分片大小，即将文件分割成多个较小的块。循环处理每个分片，将分片数据和相关信息构建成一个数据字典。</p><p>发起异步POST请求，将数据字典作为参数传递给apost函数，用于上传分片数据。</p><p>检查HTTP响应的状态码，如果不是200，则抛出异常。如果HTTP响应状态码为200，则将响应结果添加到结果字典中。</p><p>循环结束后，返回结果字典，其中包含了每个分片的上传结果</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>然后，接收到信息后的做法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">slice_upload_wfs</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="comment"># 鉴权等功能省略</span></span><br><span class="line">    </span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    req_body = <span class="keyword">await</span> request.form</span><br><span class="line">    files = <span class="keyword">await</span> request.files</span><br><span class="line">    logger.info(<span class="string">"show json req_body:%s, file:%s"</span> % (req_body, files))</span><br><span class="line">    file = files.get(<span class="string">"file"</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file:</span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">"not file"</span>, <span class="number">400</span>, content_type=<span class="string">"text/html; charset=UTF-8"</span>)</span><br><span class="line">    offset = int(req_body.get(<span class="string">"dzchunkbyteoffset"</span>, <span class="number">0</span>))</span><br><span class="line">    md5 = req_body.get(<span class="string">"md5"</span>, <span class="string">""</span>)</span><br><span class="line">    idx = int(req_body.get(<span class="string">"dzchunkindex"</span>, <span class="number">0</span>))</span><br><span class="line">    block_num = int(req_body.get(<span class="string">"dztotalchunkcount"</span>, <span class="number">0</span>))</span><br><span class="line">    uuid = req_body.get(<span class="string">"dzuuid"</span>, <span class="string">""</span>)</span><br><span class="line">    name = file.filename</span><br><span class="line">    logger.info(<span class="string">"origin file name info %s "</span> % name)</span><br><span class="line">    logger.info(<span class="string">" info : %s"</span> % req_body)</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"file"</span>:</span><br><span class="line">        <span class="comment"># 如果传有别名，就使用别名，接口适配</span></span><br><span class="line">        name = req_body.get(<span class="string">"file_name"</span>, <span class="string">"file"</span>)</span><br><span class="line">        logger.info(<span class="string">"now , the file name is %s "</span> % name)</span><br><span class="line"></span><br><span class="line">    tmp_full_path = os.path.join(UPLOAD_TEMP_PATH, <span class="string">"%s_%s"</span> % (str(uuid), name))</span><br><span class="line">    logger.info(<span class="string">f' slice_upload_wfs Processing <span class="subst">&#123;name&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span> <span class="keyword">and</span> os.path.exists(tmp_full_path):</span><br><span class="line">        <span class="comment"># 文件传输失败后重新上传，清空前面失败的</span></span><br><span class="line">        os.remove(tmp_full_path)</span><br><span class="line">    <span class="keyword">with</span> open(tmp_full_path, <span class="string">"ab"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(offset)</span><br><span class="line">        f.write(file.stream.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx + <span class="number">1</span> == block_num:</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        local_md5 = <span class="keyword">await</span> get_file_md5(tmp_full_path)</span><br><span class="line">        logger.info(<span class="string">"calc md5! cost:%s"</span> % (time.time() - t1,))</span><br><span class="line">        <span class="keyword">if</span> md5 == local_md5:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                upload_type = int(req_body.get(<span class="string">"upload_type"</span>, <span class="number">0</span>))  <span class="comment"># 分类型 0代表使用 time.time()_file_name ，1 代表只使用file_name</span></span><br><span class="line">                <span class="keyword">if</span> upload_type == <span class="number">1</span>:</span><br><span class="line">                    wfs_target_path = os.path.join(WFS_BASE_PATH, path, <span class="string">"%s"</span> % (str(name)))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    wfs_target_path = os.path.join(WFS_BASE_PATH, path, <span class="string">"%s_%s"</span> % (str(int(time.time() * <span class="number">1000</span>)), name))</span><br><span class="line">                t1 = time.time()</span><br><span class="line">                <span class="keyword">await</span> wfs_upload(client, tmp_full_path, wfs_target_path, overwrite=<span class="literal">True</span>)</span><br><span class="line">                logger.info(<span class="string">"end upload! cost:%s"</span> % (time.time()-t1, ))</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logger.info(<span class="string">"slice_upload_wfs Traceback:%s"</span> % e)</span><br><span class="line">                <span class="keyword">return</span> Response(e.args[<span class="number">0</span>], <span class="number">400</span>, content_type=<span class="string">"text/html; charset=UTF-8"</span>)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                os.remove(tmp_full_path)</span><br><span class="line">            res[name] = wfs_target_path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(tmp_full_path):</span><br><span class="line">                <span class="comment"># 清理失败的文件</span></span><br><span class="line">                os.remove(tmp_full_path)</span><br><span class="line">            logger.info(<span class="string">"Traceback md5 is not equal :%s  %s"</span> % (md5, local_md5))</span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">" %s md5:%s check fail!"</span> % (tmp_full_path, md5), <span class="number">500</span>,</span><br><span class="line">                            content_type=<span class="string">"text/html; charset=UTF-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(json.dumps(res), <span class="number">200</span>, content_type=<span class="string">"application/json; charset=UTF-8"</span>)</span><br></pre></td></tr></table></figure><p>这段代码是一个异步函数，用于处理分片上传文件到指定路径的功能。下面是代码的详细解释：</p><p>首先是通过await request.form获取请求的表单数据，通过await request.files获取上传的文件对象。检查是否存在名为”file”的文件对象，如果不存在则返回一个400状态码的响应。</p><p>之后从请求的表单数据中获取偏移量offset、MD5哈希值md5、分片索引idx、总块数block_num和UUIDuuid等信息。这些信息必然不是只有一次的，这里会接受到多次这种信息，每次都用来写入到文件当中</p><p>然后，构建临时文件的完整路径tmp_full_path，格式为UUID和文件名的组合。这里需要将每次传输到的信息分片存入。</p><p>如果是第一个分片（索引为0）并且临时文件已存在，则删除之前的临时文件。说明这个很可能是失效的。</p><p>打开临时文件，将文件指针定位到指定的偏移量，并将分片数据写入文件。</p><p>如果是最后一个分片（索引加1等于总块数），则进行以下操作：</p><ul><li>计算临时文件的MD5哈希值local_md5。</li><li>比较计算得到的MD5哈希值和请求中的MD5哈希值，如果相等则进行上传操作。</li><li>根据上传类型upload_type的值，构建目标路径wfs_target_path。</li><li>调用wfs_upload函数，将临时文件上传到目标路径。</li><li>如果上传成功，则将上传后的文件路径添加到结果字典res中，并删除临时文件。</li><li>如果上传失败，则返回一个400状态码的响应。</li></ul><p>最后，返回一个200状态码的响应，其中包含了上传结果的JSON格式数据。</p><p>这段代码实现了分片上传文件的功能，它通过处理每个分片的数据和相关信息，将分片数据写入临时文件，并在最后一个分片完成时进行上传操作。它还包括了对上传结果的处理和错误处理逻辑。</p><p>总体而言还是比较简单的，有些技术看起来比较唬人，其实也很简单。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分片传输和流量控制&quot;&gt;&lt;a href=&quot;#分片传输和流量控制&quot; class=&quot;headerlink&quot; title=&quot;分片传输和流量控制&quot;&gt;&lt;/a&gt;分片传输和流量控制&lt;/h1&gt;&lt;p&gt;这其实是一个小功能，准备拆开来细谈一下，原来的功能是，整块数据进行上传到网关，然后由</summary>
      
    
    
    
    
    <category term="Python" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/03/19/jvm-opt/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/03/19/jvm-opt/</id>
    <published>2024-03-19T15:46:00.000Z</published>
    <updated>2025-01-03T11:06:13.056Z</updated>
    
    <content type="html"><![CDATA[<p>这个文章会依次表述本人经过的实践</p><p>首先是如何去发现问题，为什么要去调优？</p><p>我之前在做开源项目的时候，碰到了需要优化字节码大小问题的需求，所以，这里就用到了虚拟机优化的知识：<br>在VM option里面增加参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+PrintInlining</span><br></pre></td></tr></table></figure><p>这样执行代码后，命令行会打印出运行时的内存大小</p><ol><li><strong>-XX:+UnlockDiagnosticVMOptions</strong><ul><li><strong>用途</strong>：<ul><li>这个选项主要是用于解锁Java虚拟机（JVM）中的一些诊断相关的功能选项。在JVM的默认配置中，很多用于深度诊断和性能分析的选项是被限制使用的，目的是防止因误操作或不恰当的设置对JVM的正常运行产生负面影响。而通过使用<code>-XX:+UnlockDiagnosticVMOptions</code>，就像是打开了一个“高级功能开关”，使得后续可以使用其他更具深度的诊断选项，例如<code>-XX:+PrintCompilation</code>和<code>-XX:+PrintInlining</code>。</li></ul></li><li><strong>示例</strong>：<ul><li>假设你在没有添加<code>-XX:+UnlockDiagnosticVMOptions</code>的情况下，尝试在JVM启动命令中添加<code>-XX:+PrintInlining</code>来查看方法内联的详细信息。JVM会将这个选项忽略，因为这些诊断选项默认是被锁住的。只有在添加了<code>-XX:+UnlockDiagnosticVMOptions</code>后，JVM才会识别并启用<code>-XX:+PrintInlining</code>这个用于打印内联信息的选项。</li></ul></li></ul></li><li><strong>-XX:+PrintCompilation</strong><ul><li><strong>用途</strong>：<ul><li><strong>编译活动监控</strong>：它用于输出JVM中即时编译器（JIT）的编译活动情况。当JVM运行时，会根据一定的策略（如方法的调用频率、循环执行次数等）对字节码进行编译成机器码，这个过程是由JIT编译器完成的。<code>-XX:+PrintCompilation</code>可以让你看到哪些方法被编译、编译的顺序、编译的时间等信息。例如，你可以看到类似“300  3       java.util.HashMap::put (152 bytes)”的输出，其中“300”可能是一个编译任务编号，“3”可能是编译的级别或者版本相关信息，“java.util.HashMap::put”是被编译的方法名称及签名，“(152 bytes)”表示这个方法字节码的大小。</li><li><strong>性能瓶颈发现</strong>：通过观察方法的编译情况，有助于定位性能瓶颈。如果某个方法被频繁编译，那么这个方法很可能是程序中的热点方法，也就是对性能影响较大的方法。例如，在一个Web应用程序中，如果发现某个业务逻辑处理方法被反复编译，就可以重点关注这个方法的代码实现，看是否可以通过优化算法、减少嵌套层次或者调整数据结构等方式来提高性能。</li><li><strong>理解JIT策略</strong>：可以帮助开发人员理解JVM的JIT编译策略。不同的JVM实现（如HotSpot）有自己的一套编译策略，比如根据方法的热度（调用频率和执行时间）来决定何时进行编译。通过<code>-XX:+PrintCompilation</code>输出的信息，开发人员可以了解JVM是如何根据实际运行情况来动态优化代码的。</li></ul></li><li><strong>示例</strong>：<ul><li>考虑一个大型的企业级Java应用，它包含了复杂的业务逻辑和数据处理模块。在运行该应用并添加了<code>-XX:+PrintCompilation</code>选项后，发现一个名为<code>calculateCustomerDiscount</code>的方法频繁被编译。这就提示开发人员这个方法可能是性能敏感点，进一步查看这个方法的代码后，发现其中包含了复杂的嵌套循环和大量的条件判断。于是开发人员可以对这个方法进行优化，比如简化循环结构或者提前计算一些可以复用的数据，从而提高整个应用的性能。</li></ul></li></ul></li><li><strong>-XX:+PrintInlining</strong><ul><li><strong>用途</strong>：<ul><li><strong>方法内联信息展示</strong>：这个选项用于打印JVM中方法内联的相关信息。方法内联是JIT编译器的一种重要优化技术。简单来说，当一个方法被频繁调用，并且满足一定的条件（如方法体较小、执行时间短等）时，JIT编译器会把被调用方法的代码直接嵌入到调用者的方法体中，从而减少方法调用的开销（如参数传递、栈帧创建等）。<code>-XX:+PrintInlining</code>输出的信息可以让你清楚地看到哪些方法被内联了，以及内联的具体情况，如内联的深度、哪些方法因为内联而被优化等。</li><li><strong>性能优化指导</strong>：通过查看内联信息，开发人员可以更好地理解JVM是如何对代码进行优化的，并且可以根据这些信息来调整代码结构，使代码更符合JVM的优化策略。例如，如果发现某个关键方法没有被内联，而你认为它应该被内联以提高性能，就可以通过调整方法的大小、复杂度或者调用方式等，来使它更有可能被JVM内联。</li></ul></li><li><strong>示例</strong>：<ul><li>假设你有一个简单的Java类，里面有一个<code>main</code>方法和一个<code>add</code>方法，<code>main</code>方法中多次调用<code>add</code>方法。当运行这个程序并添加了<code>-XX:+PrintInlining</code>选项后，可能会看到类似“@12   java.util.ArrayList::add inline (hot) made not entrant”的输出。其中“@12”可能是一个内部的编译编号，“java.util.ArrayList::add”是被内联的方法名称及签名，“inline (hot)”表示这个方法因为是热点（频繁调用）而被内联，“made not entrant”可能是关于这个方法在被内联后的状态说明，比如它可能不再以独立的方式被调用。通过这些信息，开发人员可以了解JVM对这个方法的优化过程，并且可以根据这个情况来优化代码，比如如果想让更多类似的方法被内联，可以考虑减少方法的复杂度或者大小。</li></ul></li></ul></li></ol><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><ol><li><p><strong>场景：优化一个高性能计算应用</strong></p><ul><li><p><strong>应用背景</strong>：</p><ul><li>假设你正在开发一个高性能计算应用，用于对大规模的金融数据进行复杂的数学模型计算。这个应用包含了许多复杂的数学运算方法，例如矩阵乘法、向量运算等，并且需要处理大量的数据集合。</li></ul></li><li><p><strong>步骤一：开启诊断功能</strong></p><ul><li>你在JVM启动参数中添加<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining</code>，这样可以深入了解JVM是如何对应用中的代码进行编译和内联优化的。例如，你的启动命令可能是<code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -jar financial_modeling_app.jar</code>。</li></ul></li><li><p><strong>步骤二：观察编译情况（使用 -XX:+PrintCompilation）</strong></p><ul><li>当应用运行时，通过<code>-XX:+PrintCompilation</code>输出的信息，你可以看到哪些数学运算方法被JIT编译器频繁编译。例如，你可能会看到类似<code>450  3       com.example.FinancialModel::matrixMultiplication (1200 bytes)</code>这样的输出，这表明<code>matrixMultiplication</code>方法被编译了，其中“450”可能是编译任务编号，“3”可能与编译级别有关，“(1200 bytes)”表示方法字节码大小。</li><li>如果这个方法频繁出现编译信息，就说明它是一个热点方法。这提示你这个方法的性能对整个应用的性能可能有很大影响。进一步检查这个方法，你可能发现它包含了多层嵌套循环用于矩阵元素的乘法和累加操作，这可能是导致它频繁编译和性能消耗的原因。</li></ul></li><li><p><strong>步骤三：查看内联信息（使用 -XX:+PrintInlining）</strong></p><ul><li>同时，<code>-XX:+PrintInlining</code>会输出方法内联的相关信息。例如，你可能会看到<code>@70   com.example.FinancialModel::vectorAddition inline (hot) made not entrant</code>，这表示<code>vectorAddition</code>方法在某个编译阶段因为是热点方法而被内联。通过观察这些内联信息，你可以了解JVM是如何优化方法调用的。</li><li>假设你发现一个频繁调用的<code>scalarMultiply</code>方法没有被内联，但是你认为它的代码结构简单且适合内联来提高性能。这个方法可能是在计算向量与标量的乘法时使用。通过查看<code>-XX:+PrintInlining</code>的输出，你可以确定它没有被内联的情况，然后通过调整方法的大小（例如，减少不必要的局部变量声明）或者复杂度（例如，简化方法中的条件判断），使它更符合JVM内联的条件。</li></ul></li><li><p><strong>步骤四：优化应用</strong></p><ul><li>根据<code>-XX:+PrintCompilation</code>发现的热点方法和性能瓶颈，你可以对代码进行优化。对于<code>matrixMultiplication</code>方法，你可以考虑采用更高效的矩阵乘法算法，如Strassen算法来减少计算量。</li><li>对于内联优化，通过调整<code>scalarMultiply</code>方法的代码结构后，再次运行应用并观察<code>-XX:+PrintInlining</code>的输出，看它是否能够被内联，从而提高方法调用的效率。通过这种方式，利用这三个JVM参数来深入分析和优化高性能计算应用的性能。</li></ul></li></ul></li><li><p><strong>场景：优化一个Java Web应用服务器的性能</strong></p><ul><li><p><strong>应用背景</strong>：</p><ul><li>考虑一个基于Java的Web应用服务器，它运行着多个企业级Web应用，处理大量的HTTP请求，包括用户认证、数据查询、业务逻辑处理等各种复杂功能。</li></ul></li><li><p><strong>步骤一：启用诊断选项</strong></p><ul><li>在服务器的JVM启动配置中添加<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining</code>。例如，在Tomcat服务器中，你可以在<code>catalina.sh</code>（对于Linux系统）或<code>catalina.bat</code>（对于Windows系统）文件中找到JVM启动参数设置的地方，添加这三个参数。</li></ul></li><li><p><strong>步骤二：分析编译活动（使用 -XX:+PrintCompilation）</strong></p><ul><li>当服务器开始处理大量请求后，通过<code>-XX:+PrintCompilation</code>输出可以看到哪些业务逻辑方法被频繁编译。比如，在一个电子商务Web应用的订单处理模块中，你可能会看到<code>380  3       com.example.ecommerce.OrderProcessor::calculateTotalPrice (800 bytes)</code>频繁出现。这表明<code>calculateTotalPrice</code>方法是一个热点方法，它在计算订单总价的过程中可能涉及复杂的价格计算规则、折扣应用、税费计算等操作，导致频繁编译。</li><li>进一步分析这个方法，你可能发现它从数据库中多次查询商品价格和折扣信息，这可能是性能瓶颈。你可以考虑采用缓存机制来减少数据库查询次数，从而优化这个方法。</li></ul></li><li><p><strong>步骤三：利用内联信息（使用 -XX:+PrintInlining）</strong></p><ul><li>通过<code>-XX:+PrintInlining</code>输出，你可以看到JVM对方法的内联情况。例如，在用户认证模块中，你可能看到<code>@45   com.example.auth.UserAuthenticator::checkPassword inline (hot) made not entrant</code>，这表示<code>checkPassword</code>方法在认证过程中被内联。这有助于你理解JVM如何优化这些频繁调用的方法。</li><li>假设在另一个用户权限检查方法<code>checkPermissions</code>没有被内联，但它的代码结构简单且频繁调用。你可以根据<code>-XX:+PrintInlining</code>的信息调整这个方法，使其更有可能被内联，例如减少方法中的参数传递或者简化方法内部的逻辑判断，从而提高性能。</li></ul></li><li><p><strong>步骤四：持续优化和监控</strong></p><ul><li>根据这些参数提供的信息，对Web应用服务器中的关键方法进行持续优化。并且在后续的运行过程中，继续观察<code>-XX:+PrintCompilation</code>和<code>-XX:+PrintInlining</code>的输出，以确保优化措施有效，并及时发现新的性能瓶颈。</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个文章会依次表述本人经过的实践&lt;/p&gt;
&lt;p&gt;首先是如何去发现问题，为什么要去调优？&lt;/p&gt;
&lt;p&gt;我之前在做开源项目的时候，碰到了需要优化字节码大小问题的需求，所以，这里就用到了虚拟机优化的知识：&lt;br&gt;在VM option里面增加参数&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Flink和Pulsar实践</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/03/14/bigdata/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/03/14/bigdata/</id>
    <published>2024-03-14T15:45:38.000Z</published>
    <updated>2025-01-23T14:17:45.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flink和Pulsar实践"><a href="#Flink和Pulsar实践" class="headerlink" title="Flink和Pulsar实践"></a>Flink和Pulsar实践</h1><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><ul><li><strong>搭建环境</strong>：确保你的环境中已经安装并配置好 Apache Pulsar 和 Apache Flink。</li><li><strong>创建 Pulsar 主题</strong>：在 Pulsar 中创建用于存储搜索日志和分析结果的主题。</li></ul><h3 id="2-数据流设计"><a href="#2-数据流设计" class="headerlink" title="2. 数据流设计"></a>2. 数据流设计</h3><p>设计一个 Flink 作业，从 Pulsar 读取数据，进行分析，并将结果写回 Pulsar。以下是详细步骤：</p><h3 id="3-Flink-读取-Pulsar-数据"><a href="#3-Flink-读取-Pulsar-数据" class="headerlink" title="3. Flink 读取 Pulsar 数据"></a>3. Flink 读取 Pulsar 数据</h3><ol><li><strong>依赖配置</strong>： 在 Flink 项目中添加 Pulsar 连接器的依赖。可以在 pom.xml 中添加以下依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-pulsar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>你的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>配置 Pulsar 客户端</strong>： 在 Flink 程序中配置 Pulsar 客户端以读取数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.FlinkPulsarSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.config.StartupMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PulsarToFlink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        String serviceUrl = <span class="string">"pulsar://localhost:6650"</span>;</span><br><span class="line">        String adminUrl = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">        String topic = <span class="string">"persistent://public/default/search-logs"</span>;</span><br><span class="line"></span><br><span class="line">        FlinkPulsarSource&lt;String&gt; pulsarSource = <span class="keyword">new</span> FlinkPulsarSource&lt;&gt;(</span><br><span class="line">                serviceUrl,</span><br><span class="line">                adminUrl,</span><br><span class="line">                topic,</span><br><span class="line">                <span class="keyword">new</span> SimpleStringSchema()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        pulsarSource.setStartFromEarliest();</span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; searchLogs = env.addSource(pulsarSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4. 数据分析"></a>4. 数据分析</h3><p>根据具体的分析需求，实现搜索词与用户地理位置的相关性分析。可以使用 Flink 的 DataStream API 进行流数据处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchLogAnalyzer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置省略</span></span><br><span class="line"></span><br><span class="line">        searchLogs.flatMap(<span class="keyword">new</span> ExtractSearchTerms())</span><br><span class="line">                  .keyBy(<span class="number">0</span>)</span><br><span class="line">                  .sum(<span class="number">1</span>)</span><br><span class="line">                  .flatMap(<span class="keyword">new</span> AnalyzeCorrelation())</span><br><span class="line">                  .addSink(<span class="keyword">new</span> FlinkPulsarSink&lt;&gt;(serviceUrl, adminUrl, resultTopic, <span class="keyword">new</span> SimpleStringSchema()));</span><br><span class="line">        </span><br><span class="line">        env.execute(<span class="string">"Search Log Analyzer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractSearchTerms</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String log, Collector&lt;Tuple2&lt;String, String&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 解析日志，提取搜索词和地理位置信息</span></span><br><span class="line">            String searchTerm = ...; <span class="comment">// 提取搜索词</span></span><br><span class="line">            String userLocation = ...; <span class="comment">// 提取用户位置</span></span><br><span class="line">            out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(searchTerm, userLocation));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnalyzeCorrelation</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Tuple2&lt;String, String&gt; value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 实现搜索词与用户地理位置相关性分析逻辑</span></span><br><span class="line">            <span class="comment">// 这里简单地示例计算每个搜索词的出现次数</span></span><br><span class="line">            out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(value.f0, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将结果写回-Pulsar"><a href="#5-将结果写回-Pulsar" class="headerlink" title="5. 将结果写回 Pulsar"></a>5. 将结果写回 Pulsar</h3><p>在 Flink 程序中，将分析结果写回 Pulsar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.FlinkPulsarSink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultToPulsar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置省略</span></span><br><span class="line"></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; analysisResult = ... <span class="comment">// 分析结果流</span></span><br><span class="line"></span><br><span class="line">        analysisResult.addSink(<span class="keyword">new</span> FlinkPulsarSink&lt;&gt;(</span><br><span class="line">            serviceUrl,</span><br><span class="line">            adminUrl,</span><br><span class="line">            <span class="string">"persistent://public/default/analysis-results"</span>,</span><br><span class="line">            <span class="keyword">new</span> Tuple2Schema()</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2Schema</span> <span class="keyword">implements</span> <span class="title">SerializationSchema</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;, <span class="title">DeserializationSchema</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化和反序列化方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-部署与运行"><a href="#6-部署与运行" class="headerlink" title="6. 部署与运行"></a>6. 部署与运行</h3><ol><li><strong>打包和提交</strong>： 将 Flink 作业打包为 jar 文件并提交到 Flink 集群。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run -c your.main.class /path/to/your/jarfile.jar</span><br></pre></td></tr></table></figure><ol><li><strong>监控和调整</strong>： 监控 Flink 作业的运行情况，根据需求进行调整和优化。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，可以构建一个从 Pulsar 读取搜索日志，使用 Flink 进行分析，并将结果写回 Pulsar 的数据流处理系统。可以根据实际需求对分析逻辑进行调整和优化，以提高系统的性能和准确性。</p><h3 id="基于-Flink-和-Pulsar-的搜索日志分析系统"><a href="#基于-Flink-和-Pulsar-的搜索日志分析系统" class="headerlink" title="基于 Flink 和 Pulsar 的搜索日志分析系统"></a>基于 Flink 和 Pulsar 的搜索日志分析系统</h3><p><img src="/images/bigdata/flink_plusar.jpg" alt=""></p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本系统旨在通过 Apache Pulsar 和 Apache Flink 的结合，实时分析搜索日志中的搜索词与用户地理位置之间的相关性。本文档将详细解释系统的架构、实现步骤以及其优势。</p><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p>系统主要包括以下几个部分：</p><ol><li><strong>数据源（Pulsar）</strong>：搜索日志通过 Pulsar 消息队列进行存储和传输。</li><li><strong>数据处理引擎（Flink）</strong>：Flink 从 Pulsar 中读取搜索日志，进行实时的流数据处理和分析。</li><li><strong>结果存储（Pulsar）</strong>：分析结果被写回 Pulsar 以供后续处理和查询。</li></ol><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><strong>Pulsar 数据源</strong>：</li></ol><ul><li><ul><li>Pulsar 是一个高性能的消息队列系统，能够处理大量的实时数据。</li><li>在 Pulsar 中创建用于存储搜索日志和分析结果的主题。</li></ul></li></ul><ol><li><strong>Flink 数据处理</strong>：</li></ol><ul><li><ul><li>Flink 是一个分布式流处理框架，适用于大规模数据处理。</li><li>配置 Flink 与 Pulsar 的连接，读取搜索日志数据。</li><li>使用 Flink 的 DataStream API 进行流数据处理，提取搜索词和用户地理位置信息，并进行相关性分析。</li><li>将分析结果写回 Pulsar。</li></ul></li></ul><ol><li><strong>数据流设计</strong>：</li></ol><ul><li><ul><li>通过 Flink 的流处理功能，可以实时处理从 Pulsar 中读取的日志数据，进行分析并及时输出结果。</li></ul></li></ul><h4 id="工程架构优势"><a href="#工程架构优势" class="headerlink" title="工程架构优势"></a>工程架构优势</h4><ol><li><strong>实时性</strong>：</li></ol><ul><li><ul><li>通过 Pulsar 和 Flink 的结合，系统能够实时处理和分析搜索日志数据，快速响应变化。</li><li>实时分析可以帮助业务更快地识别和响应趋势，从而提高用户体验和业务决策的准确性。</li></ul></li></ul><ol><li><strong>扩展性</strong>：</li></ol><ul><li><ul><li>Pulsar 和 Flink 都是分布式系统，能够水平扩展以处理大规模的数据。</li><li>当数据量增加时，可以通过增加更多的节点来扩展系统的处理能力。</li></ul></li></ul><ol><li><strong>高可用性</strong>：</li></ol><ul><li><ul><li>Pulsar 提供了强大的消息持久化和多副本机制，保证了数据的高可用性和可靠性。</li><li>Flink 具有内置的容错机制，能够在节点故障时自动恢复处理状态，保证数据处理的连续性。</li></ul></li></ul><ol><li><strong>灵活性</strong>：</li></ol><ul><li><ul><li>Flink 提供了丰富的 API，用于数据的过滤、转换和聚合，支持复杂的分析逻辑。</li><li>可以根据业务需求，灵活地调整分析逻辑和处理流程。</li></ul></li></ul><ol><li><strong>集成性</strong>：</li></ol><ul><li><ul><li>Flink 和 Pulsar 都支持多种数据源和接收器，方便与其他系统进行集成。</li><li>可以将分析结果进一步处理，存储到数据库或其他数据仓库中，方便后续查询和分析。</li></ul></li></ul><h4 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h4><ol><li><strong>Pulsar 主题配置</strong>：</li></ol><ul><li><ul><li>创建用于存储搜索日志的主题：search-logs</li><li>创建用于存储分析结果的主题：analysis-results</li></ul></li></ul><ol><li><strong>Flink 程序开发</strong>：</li></ol><ul><li><ul><li>配置 Pulsar 客户端，读取 search-logs 主题中的数据。</li><li>使用 Flink DataStream API 进行数据处理，提取搜索词和地理位置，并进行相关性分析。</li><li>将分析结果写回 analysis-results 主题。</li></ul></li></ul><ol><li><strong>部署和监控</strong>：</li></ol><ul><li><ul><li>将 Flink 程序打包为 jar 文件，并提交到 Flink 集群中运行。</li><li>通过 Flink 和 Pulsar 的管理界面，监控数据处理的状态和结果。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.FlinkPulsarSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.pulsar.config.StartupMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.PulsarClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.Schema;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.impl.conf.ClientConfigurationData;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.impl.conf.ConsumerConfigurationData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchLogAnalysisSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Flink 执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pulsar 客户端配置</span></span><br><span class="line">        ClientConfigurationData clientConf = <span class="keyword">new</span> ClientConfigurationData();</span><br><span class="line">        clientConf.setServiceUrl(<span class="string">"pulsar://localhost:6650"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pulsar 消费者配置</span></span><br><span class="line">        ConsumerConfigurationData&lt;String&gt; consumerConf = <span class="keyword">new</span> ConsumerConfigurationData&lt;&gt;();</span><br><span class="line">        consumerConf.setTopics(Collections.singletonList(<span class="string">"search-log-topic"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 Flink Pulsar 数据源</span></span><br><span class="line">            FlinkPulsarSource&lt;String&gt; pulsarSource = <span class="keyword">new</span> FlinkPulsarSource&lt;&gt;(</span><br><span class="line">                    clientConf,</span><br><span class="line">                    consumerConf,</span><br><span class="line">                    Schema.STRING,</span><br><span class="line">                    StartupMode.EARLIEST</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 Pulsar 读取搜索日志数据</span></span><br><span class="line">            DataStream&lt;String&gt; searchLogs = env.addSource(pulsarSource);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计每个搜索关键词的出现次数</span></span><br><span class="line">            DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; keywordCounts = searchLogs</span><br><span class="line">                    .map(<span class="keyword">new</span> MapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 假设搜索日志格式为纯关键词</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(value, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .keyBy(value -&gt; value.f0)</span><br><span class="line">                    .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印统计结果</span></span><br><span class="line">            keywordCounts.print();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 Flink 作业</span></span><br><span class="line">            env.execute(<span class="string">"Search Log Analysis System"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PulsarClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>通过采用 Apache Pulsar 和 Apache Flink 的组合，构建了一个高效、实时和可扩展的搜索日志分析系统。该系统不仅能够快速处理和分析大规模的搜索日志数据，还能够根据业务需求灵活调整分析逻辑，并确保数据处理的高可用性和可靠性。这种架构在处理大规模实时数据分析时具有显著优势，能够帮助业务快速做出响应和决策。</p><hr><p>这样一个说明文档不仅解释了系统的实现步骤，还从工程架构上分析了使用 Pulsar 和 Flink 的优势，能够帮助相关团队更好地理解和实现这一系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flink和Pulsar实践&quot;&gt;&lt;a href=&quot;#Flink和Pulsar实践&quot; class=&quot;headerlink&quot; title=&quot;Flink和Pulsar实践&quot;&gt;&lt;/a&gt;Flink和Pulsar实践&lt;/h1&gt;&lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解搜索架构</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/03/06/search-system/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/03/06/search-system/</id>
    <published>2024-03-06T11:06:53.000Z</published>
    <updated>2024-05-06T11:08:27.601Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想要深入的了解和熟悉搜索引擎，我可以推荐一本书：<br><strong>这就是搜索引擎</strong></p><p>作者:张俊林<br>出版社:电子工业出版社<br>ISBN: 9787121148651</p><p>从本人了解到了知识储备而言，搜索引擎技术在工业界似乎变化不大，即使过去了很多年，整体的思想并没有发生很大的变化，来来回回都是这么个用法，召回，排序，求交，整体的信息检索水平并没有像软件工程一样分化出例如诸多的SOA，Mesh架构，也没有诞生出MVC，DDD等特定的软件设计模式，搜索引擎更多的变化在于一些性能上吗的优化，而贴合业务更做出改变。虽然本人学识并不丰富，但是也可以感觉到落后很多年了。</p><h2 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h2><p>这是一般搜索从离线到在线的整条数据流处理流程：</p><p>类似于百度，Google等搜索服务商，整体来说都是这样的流程。</p><p>但是搜一搜比较特殊，搜一搜的信息来源并不需要从网络爬取，而是自行产生的，比如公众号，小程序，这些数据来源都比较规范，而且一些基本属性，都是必须有的，这让整个搜索架构在建立索引的时候，会减少很多的功夫，所以相对于网络爬虫去爬去数据，要减少不少不必要的流程。</p><p>目前六组主要负责的是富展示模块，主要是业务端，商业变现的内容。</p><p>先看整个搜索架构，</p><p>搜一搜架构中搜索常用简称释义：</p><ul><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li><li>敏感数据</li></ul><p>整体从逻辑上也分为五层，如下：</p><p>虽然整体架构看起来非常复杂，但是总的来说还是在干这些事情：</p><p><strong>(离线)建立索引-&gt;召回求交排序-&gt;展示</strong></p><p>现在结合本人看到的知识，一步步推导中间的过程，中途可能还会出现不少的错误，望评论区指正</p><p>首先建立索引，这是最初步的过程，比如说我有很多的公众号文章和小程序数据，这里的每一个数据都是doc，doc_id就是每个doc的唯一标识，这些数据都是未经过处理的，没有任何意义的数据。这个时候我们肯定是需要先进行一步粗处理，将每个文档中的单词，都逐个分离出来，先变成一个正排索引：</p><p>为什么不一开始就建立倒排呢？本人理解是一个将原doc经过粗处理变成更加适合检索的doc类型，这样系统就不用存储原doc，第二个是在进行摘要检索的时候更加方便。</p><p>然后倒排索引就更加明确了：</p><p>但是要注意的是，这只是一个抽象的索引，实际上搜一搜的索引非常复杂，会涉及到诸多方面的知识和要求，一个索引不仅仅这么简单，可以参考这个：</p><p>在建立索引的过程中，还会涉及到很多的知识，这里再详细描述建立正排和倒排的过程</p><p>建立正排其实</p><p><strong>六要素</strong><br>不论索引结构如何改变，其核心依然是以下六类数据：</p><ol><li>Term词典<br>提供Term到Term对应倒排链位置的查询功能，常规实现如hash map，二分查找(有序数组)</li><li>倒排索引<br>保存Term-&gt;文档id列表数据，通常实现为有序数组，实际上可以有多种实现形式</li><li>Payload<br>Term或者文档的有效载荷，即每个Term/文档携带的额外数据，例如Term Payload通常存放Term对应文档的权重，Doc Payload则是文档的特征数据，定位是召回阶段可用的特征数据</li><li>Forward<br>文档正排数据，定位为存放文档在粗排打分阶段时需要访问的特征数据</li><li>PosOffset<br>各个Term在文档中各个域的精确位置偏移信息(原则上Pos数据也属于正排数据，同样是需要在粗排打分阶段才可访问)</li><li>Abstract<br>文档摘要数据，通常用于存放文档富展现数据 </li></ol><p>接着是这些doc的存储问题，在一个海量数据的数据中，这些doc也必定是分布式存储的，这些数据会被分发到一个个的分片中，分片数是固定的，但是每个分片的节点数是不固定的，一般是多个分片对应一个节点。比如说，doc_id 114514，假设分片是100个，那么该doc会进入分片14，但是整个分片群中节点只有10个。如果我的节点扩展到20个，分片也会随着节点扩张也迁移。</p><p>既然说了doc的存储，那么索引呢？其实常见的索引比如FOB，GOB，这些索引的存储一般不在磁盘中，而是在内存中，这里会采用一个LSM的方式去加速存储和当访问。</p><p><strong>GOB</strong> ： <strong>全量索引库 FOB</strong> ： <strong>实时索引库</strong></p><p>这里可以举一个例子去理解，比如说我们公众号每产生一个文章，就可能产生多个GOB，但是文章的更新程度其实一般不会太频繁，那如果更新了，希望现网可快速也进行更新，就产生了FOB，GOB的更新是一批一批，FOB的更新是实时的，每次GOB更新的时候都会覆盖掉所有的FOB。这个关系就像是cache和磁盘的关系一样，每次更新，先更新cache，每次落库，cache就清空。这个也是很好理解的。那么为什么不用FOB去更新GOB呢？个人感觉是这样会在现网产生很大的时延和抖动，因为会产生很大的计算量，而分别更新的话，GOB建立是离线的，只需要上线替换就好了，几乎没有计算量，综合下来还是这种方式更好。</p><p>（未完待续。。。。。。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你想要深入的了解和熟悉搜索引擎，我可以推荐一本书：&lt;br&gt;&lt;strong&gt;这就是搜索引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者:张俊林&lt;br&gt;出版社:电子工业出版社&lt;br&gt;ISBN: 9787121148651&lt;/p&gt;
&lt;p&gt;从本人了解到了知识储备而言，搜索引擎技术在工</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>搜一搜运营系统 WXG实践</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/02/24/s1s-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/02/24/s1s-1/</id>
    <published>2024-02-24T15:15:26.000Z</published>
    <updated>2024-04-18T15:46:15.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜一搜运营系统"><a href="#搜一搜运营系统" class="headerlink" title="搜一搜运营系统"></a>搜一搜运营系统</h1><p>这个是实习中碰到的主要业务。</p><p>主要是搜索评估系统，需求是抓取数据，然后更新，并且评估。效果好的话放入理想集合，再放入拨测。</p><p>涉及Python，ClickHouse，Hive，MySQL，等多种技术</p><p>规则组配置系统，需求是配置搜索词，哪些搜索词会命中大卡，然后分批次发布。</p><p>涉及MQ等技术</p><p>MP端穿透白板，需求是，搜索词所检索公众号和小程序等信息，需要展示出来。这里是需要去获取经过离线计算后的到HDFS的存储信息，然后放入MySQL分表分区存储，每个内容100个表，30个区。共四组内容。</p><p>涉及Spark，MySQL，HDFS等技术</p><p>大卡管理系统，需求是配置大卡，完成组卡逻辑。</p><p>涉及ElasticSearch，RPC，KV等技术</p><p>大卡系统，需求是线上的富展示模块，会涉及到商业变现等内容，会去拉内容提供方的信息，展示到用户端。</p><p>涉及C++，KV等技术</p><p>logicsvr，网关，完善规则引擎等内容，并提供审计上报等功能。</p><p>涉及Flask，规则引擎等。</p><p>数据过滤计算，需求是为了实现将pulsar的内容拉取到Flink中初步处理，然后出到HDFS文件当中，方面后续流程去读取</p><p>涉及Java，Pulsar，Flink</p><p>大卡索引加载优化，需求是本来用kv存储自建索引，后面使用共享内存去实现</p><p>涉及技术C++</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搜一搜运营系统&quot;&gt;&lt;a href=&quot;#搜一搜运营系统&quot; class=&quot;headerlink&quot; title=&quot;搜一搜运营系统&quot;&gt;&lt;/a&gt;搜一搜运营系统&lt;/h1&gt;&lt;p&gt;这个是实习中碰到的主要业务。&lt;/p&gt;
&lt;p&gt;主要是搜索评估系统，需求是抓取数据，然后更新，并且评估。</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常见场景问题总结</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/02/20/scene/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/02/20/scene/</id>
    <published>2024-02-20T15:45:21.000Z</published>
    <updated>2024-04-19T15:48:37.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见场景题总结"><a href="#常见场景题总结" class="headerlink" title="常见场景题总结"></a>常见场景题总结</h1><h2 id="1-扫码登陆如何实现"><a href="#1-扫码登陆如何实现" class="headerlink" title="1.扫码登陆如何实现"></a>1.扫码登陆如何实现</h2><p>1.答：访问PC端二维码生成页面，PC端请求服务端获取二维码ID 服务端生成相应的二维码ID，设置二维码的过期时间，状态等。 PC获取二维码ID，生成相应的二维码。 手机端扫描二维码，获取二维码ID。 手机端将手机端token和二维码ID发送给服务端，确认登录。 服务端校验手机端token，根据手机端token和二维码ID生成PC端token PC端通过轮询方式请求服务端，通过二维码ID获取二维码状态，如果已成功，返回PC token，登录成功。</p><p>好了，这样我们一个扫描登录的功能就设计完成了。</p><h2 id="2-一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？"><a href="#2-一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？" class="headerlink" title="2.一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？"></a>2.一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？</h2><p>2.确保你的Spring Boot项目已经集成了Redis，并正确配置了Redis连接信息。</p><p>在发布外卖配送单时，生成一个唯一的标识符（比如订单ID或随机UUID），作为这个配送单的唯一标识。</p><p>在Redis中设置一个键，用来表示当前已经被接单的配送单。这个键可以是一个字符串类型的键，例如：“delivery_order_accepted”。</p><p>当骑手想要接单时，首先通过Redis的分布式锁机制尝试获取锁。只有一个骑手能够成功获取到锁，表示该骑手接到了单子。</p><p>如果骑手成功获取到锁，即成功接到单子，将配送单的信息存储在Redis中，例如使用Hash结构保存配送单的详细信息。</p><p>如果骑手没有成功获取到锁，表示已经有其他骑手接到了单子，可以给骑手返回一个提示或者重新获取其他的配送单。</p><h2 id="3-如何把一个文件快速下发到100w个服务器？"><a href="#3-如何把一个文件快速下发到100w个服务器？" class="headerlink" title="3.如何把一个文件快速下发到100w个服务器？"></a>3.如何把一个文件快速下发到100w个服务器？</h2><ul><li>使用分发工具：使用专门的分发工具，如BitTorrent、rsync等，可以帮助在多个服务器之间并行地进行文件传输，提高传输效率。</li><li>利用分布式文件系统：使用分布式文件系统，如Hadoop HDFS、GlusterFS等，将文件存储在分布式节点上，可以更快地将文件分发到多个服务器上。</li><li>使用多线程或并行传输：在传输文件时，采用多线程或并行传输的方式，可以同时向多个服务器传输文件，提高传输速度。</li><li>使用多个传输通道：尝试使用多个传输通道同时传输文件，可以增加传输的带宽，加快传输速度。</li><li><strong>利用CDN（内容分发网络）：如果服务器部署在不同的地理位置，可以考虑使用CDN服务，将文件缓存到离用户较近的CDN节点，通过CDN节点将文件分发给多个服务器，提高传输速度和可靠性。</strong></li></ul><p>需要根据具体情况选择合适的方法，考虑网络带宽、服务器性能等因素，以实现快速和高效地将文件下发到大量服务器。</p><h2 id="4-给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的"><a href="#4-给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的" class="headerlink" title="4.给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?"></a>4.给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?</h2><p>可以使用CIDR（无类域间路由）来设计一种结构，该结构可以快速确定一个IP属于哪个组。以下是一种可能的设计方案：</p><p>将每个组分配不同的CIDR块，确保它们不重叠。</p><p>将每个CIDR块分配给该组的网络。</p><p>构建一个CIDR前缀树（也称为路由转发表或路由表）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-  在前缀树中，每个节点表示一个CIDR块。</span><br><span class="line">  -  子节点表示更具体的CIDR块。</span><br><span class="line">  -  叶节点表示最具体的CIDR块，并将其与相应的组关联起来。</span><br></pre></td></tr></table></figure><p>在前缀树中搜索给定的IP地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-  从根节点开始，比较IP地址与每个节点的CIDR块。</span><br><span class="line"> -  如果IP地址匹配节点的CIDR块，则继续向下搜索。</span><br><span class="line"> -  如果IP地址不匹配任何节点的CIDR块，则停止搜索，找到了最接近IP地址的匹配块。</span><br></pre></td></tr></table></figure><p>通过前缀树中找到的节点，确定IP所属的组。</p><p>通过这种设计，可以快速确定给定IP地址所属的组，而不需要遍历所有CIDR块。此外，这种结构还可以支持动态的CIDR块分配和组织变化，只需更新前缀树即可。</p><h2 id="5-典型TOPk系列的问题：10亿个数，找出最大的10个。等-10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？"><a href="#5-典型TOPk系列的问题：10亿个数，找出最大的10个。等-10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？" class="headerlink" title="5.典型TOPk系列的问题：10亿个数，找出最大的10个。等(10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？)"></a>5.典型TOPk系列的问题：10亿个数，找出最大的10个。等(10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？)</h2><p>5.典型TOPk系列问题是指在给定一组数据中，找出其中的前k个元素或者按照某种规则进行排序的问题。两个典型的TOPk问题分别是：</p><p>在10亿个数中找出最大的10个数： - 解法1：使用堆数据结构。维护一个大小为10的最小堆，遍历10亿个数，如果当前数比堆顶元素大，则将堆顶元素替换为当前数并对堆进行调整，保持堆的大小为10。最终堆中的数就是最大的10个数。 - 解法2：使用快速选择算法。类似于快速排序算法，每次选择一个枢纽元素将数据分为两部分，左边的部分均小于枢纽元素，右边的部分均大于枢纽元素。如果枢纽元素的位置大于k，则在左边部分继续查找，否则在右边部分继续查找。最终得到的子数组中的前k个元素就是最大的k个数。</p><p>在10万个数中输出从小到大的排序结果： - 解法1：使用快速排序算法。对于给定的数组，选择一个枢纽元素将数组分为两部分，左边的部分都小于枢纽元素，右边的部分都大于枢纽元素。然后递归地对左右两个部分进行快速排序，最终得到的数组就是从小到大的排序结果。 - 解法2：使用归并排序算法。将数组分成两个部分，分别对两个部分进行排序，然后将排好序的两个部分合并成一个有序的数组。通过递归地进行这个操作，最终得到的数组就是从小到大的排序结果。</p><p>另外，对于十万个单词中找出重复次数最高的十个单词的问题，可以使用哈希表来统计每个单词出现的次数，并维护一个大小为10的最小堆，遍历哈希表，对于每个单词的出现次数，如果大于堆顶元素，则将堆顶元素替换为当前单词，并对堆进行调整。最终堆中的元素就是重复次数最高的十个单词。</p><h2 id="6-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"><a href="#6-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。" class="headerlink" title="6.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"></a>6.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</h2><p>6.为了实现微信发红包的API，并确保红包金额精确到分且不能有人领到的红包里面没钱，可以按照以下步骤设计：</p><p>确定红包发放的总金额和红包个数。 确定每个红包的最小和最大金额范围，以确保每个红包都有一定金额。 根据总金额和红包个数，计算出每个红包的平均金额。 为避免红包金额出现小数位，将平均金额放大100倍，以分为单位进行操作。 将红包金额转化为分后，依次生成每个红包的金额。 随机生成每个红包的金额，但要保证每个红包金额在最小和最大金额范围内，并且总金额不超过设定的总金额。 将每个红包金额再转化回元，以方便显示。 返回生成的红包列表。</p><p>这样设计可以确保每个红包都有一定金额，并且总金额精确到分。</p><h2 id="7-分布式多个机器生成id，如何保证不重复"><a href="#7-分布式多个机器生成id，如何保证不重复" class="headerlink" title="7.分布式多个机器生成id，如何保证不重复?"></a>7.分布式多个机器生成id，如何保证不重复?</h2><p>7.确保分布式多个机器生成的id不重复可以采用以下方法：</p><ol><li>使用全局唯一标识符（UUID）：每个机器都可以使用UUID算法生成独特的标识符，并且无需进行全局同步即可保证唯一性。这种方法的缺点是UUID通常比较长，不适合作为简短id使用。</li><li>使用数据库的自增主键：可以使用数据库的自增主键功能生成唯一id。每个机器在插入数据时，都向数据库请求一个唯一的id，数据库会自动保证递增且唯一。缺点是需要使用数据库，并且会有一定的性能开销。</li><li>Redis的incr命令：使用Redis的incr命令实现全局自增的计数器。每个机器向Redis请求递增的计数值，并将该计数值作为id。Redis会保证incr命令的原子性，保证了id的唯一性。缺点是需要使用Redis，并且Redis的性能可能会成为瓶颈。</li><li>Twitter的Snowflake算法：Snowflake算法是一种在分布式系统中生成唯一id的算法。它使用一个64位的整数，其中包含了时间戳、机器id、序列号等信息。每个机器都有一个唯一的机器id，保证了id的唯一性。Snowflake算法的优点是生成的id比较短且有序。缺点是需要保证机器id的唯一性，并且需要有一个时钟的同步。</li></ol><p>以上方法均可以用于分布式环境下生成唯一id，选择哪种方法取决于具体系统的需求和限制。</p><h2 id="8-分布式集群中如何保证线程安全？"><a href="#8-分布式集群中如何保证线程安全？" class="headerlink" title="8.分布式集群中如何保证线程安全？"></a>8.分布式集群中如何保证线程安全？</h2><p>8.在分布式集群中，线程安全问题需要特别注意，以下是几种保证线程安全的方法：</p><ol><li>加锁：在多线程访问共享资源时，使用锁机制（如互斥锁、读写锁等）来保证同一时间只能有一个线程访问该资源。对于分布式集群，可以使用分布式锁来协调多个节点对共享资源的访问。</li><li>使用线程安全的数据结构：选择并使用线程安全的数据结构，例如线程安全的集合类（如ConcurrentHashMap、CopyOnWriteArrayList等），这些数据结构内部实现了同步机制，保证了在并发环境下的线程安全性。</li><li>避免共享状态：尽量避免多个线程共享同一份数据，而是让每个线程拥有自己的局部变量，这样就不需要考虑线程安全性的问题。可以使用ThreadLocal类来实现每个线程独立拥有自己的变量。</li><li>确保数据同步：在分布式环境下，如果涉及到跨节点之间的数据共享，需要确保数据的一致性和同步，可以通过分布式事务、分布式缓存、消息队列等机制来实现。</li><li>使用乐观锁或悲观锁：乐观锁适用于读操作较多的场景，通过版本号或时间戳等方式来控制并发访问，而悲观锁适用于写操作较多的场景，通过加锁来确保同一时间只能有一个线程写入。</li><li>合理划分任务：将任务划分成多个独立的子任务，每个子任务由一个线程处理，从而降低了并发冲突的可能性，提高了线程安全性。</li></ol><p>无论采取哪种方法，都需要在设计和实现时充分考虑并发访问的场景，评估并发冲突的可能性，并选择合适的线程安全措施来保护共享资源。</p><h2 id="9-某网站-app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？"><a href="#9-某网站-app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？" class="headerlink" title="9.某网站/app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？"></a>9.某网站/app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？</h2><p>9.推荐过程：</p><ol><li>初始推荐：根据商家的权值进行排序，选取排名前50的商家作为推荐商家，并将其置顶在网站/app首页上。权值高的商家有更大的概率被选中。</li></ol><p>更新推荐的商家：</p><ol><li>更新商家权值：根据前一天推荐商家的点击量、购买量、评价等指标，对商家的权值进行更新。点击量高、购买量多、评价好的商家权值会提高。</li><li>选择推荐商家：根据更新后的商家权值重新排序，选取排名前50的商家作为第二天的推荐商家，并进行置顶。</li></ol><p>通过这种方式，每天根据商家的表现和用户的反馈实时更新商家的权值，从而不断优化推荐的商家列表，提供更为精准和个性化的推荐服务。</p><h2 id="10-如何设计一个本地缓存？需要考虑哪些方面？"><a href="#10-如何设计一个本地缓存？需要考虑哪些方面？" class="headerlink" title="10.如何设计一个本地缓存？需要考虑哪些方面？"></a>10.如何设计一个本地缓存？需要考虑哪些方面？</h2><ol><li>缓存策略：选择合适的缓存策略，如LRU（Least Recently Used，最近最少使用）、LFU（Least Frequently Used，最不经常使用）等，根据实际需求选择适合的缓存策略。</li><li>缓存容量：确定缓存的最大容量，以避免缓存过多占用过多的内存空间。</li><li>缓存淘汰机制：当缓存容量达到上限时，需要决定淘汰哪些缓存项。可以根据缓存策略、缓存项的使用频率、过期时间等进行淘汰。</li><li>缓存过期机制：设置缓存项的过期时间，当缓存项超过过期时间未被使用时，需要从缓存中移除。</li><li>缓存命中率：记录并统计缓存命中次数和未命中次数，以评估缓存效果，并可根据需求进行优化。</li><li>并发访问控制：考虑多线程或多进程同时访问缓存的情况，确保并发访问时的数据一致性。</li><li>键值存储方式：选择合适的键值存储方式，如哈希表、二叉树等，以便高效地进行缓存项的存取操作。</li><li>数据持久化：可选项，如果需要在应用重启后仍然能够加载之前的缓存数据，则需要考虑将缓存数据持久化到磁盘或数据库中。</li><li>内存管理：合理利用内存，控制缓存占用的内存大小，避免过多的内存占用导致系统性能下降。</li><li>缓存更新机制：对于数据的更新操作，需要及时更新缓存中的缓存项，以保证缓存数据的一致性。可以使用订阅发布模式、数据库触发器等方法来实现缓存的更新。</li></ol><p>以上是设计一个本地缓存需要考虑的一些方面，具体的实现方式和细节根据实际需求和场景来确定。</p><h2 id="11-在1G大小的文件中，找出高频top100的单词"><a href="#11-在1G大小的文件中，找出高频top100的单词" class="headerlink" title="11.在1G大小的文件中，找出高频top100的单词"></a>11.在1G大小的文件中，找出高频top100的单词</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假如有一个<strong>1G</strong>大小的文件，文件里每一行是一个词，每个词的大小不超过<strong>16byte</strong>，要求返回出现频率最高的100个词。内存大小限制是<strong>10M</strong></p><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>由于内存限制，我们无法直接将大文件的所有词一次性读到内存中。</p><p>可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于10M，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>第一步</strong>，首先遍历大文件，对遍历到的每个词x，执行 hash(x) % 500，将结果为i的词存放到文件f(i)中，遍历结束后，可以得到500个小文件，每个小文件的大小为2M左右；</p><p><strong>第二步</strong>，接着统计每个小文件中出现频数最高的100个词。可以使用HashMap来实现，其中key为词，value为该词出现的频率。</p><p>对于遍历到的词x，如果在map中不存在，则执行 map.put(x, 1)。</p><p>若存在，则执行 map.put(x, map.get(x)+1)，将该词出现的次数加1。</p><p><strong>第三步</strong>，在第二步中找出了每个文件出现频率最高的100个词之后，通过维护一个<strong>小顶堆</strong>来找出所有小文件中出现频率最高的100个词。</p><p>具体方法是，遍历第一个文件，把第一个文件中出现频率最高的100个词构建成一个小顶堆。</p><p>如果第一个文件中词的个数小于100，可以继续遍历第二个文件，直到构建好有100个结点的小顶堆为止。</p><p>继续遍历其他小文件，如果遍历到的词的出现次数大于堆顶上词的出现次数，可以用新遍历到的词替换堆顶的词，然后重新调整这个堆为小顶堆。</p><p>当遍历完所有小文件后，这个小顶堆中的词就是出现频率最高的100个词。</p><p>总结一下，这种解法的主要思路如下：</p><ol><li>采用<strong>分治</strong>的思想，进行哈希取余</li><li>使用<strong>HashMap</strong>统计每个小文件单词出现的次数</li><li>使用<strong>小顶堆</strong>，遍历步骤2中的小文件，找出词频top100的单词</li></ol><p>但是很容易可以发现问题，在第二步中，如果这个1G的大文件中有某个词词频过高，可能导致小文件大小超过10m。这种情况下该怎么处理呢？</p><p>接下来看另外一种解法。</p><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p><strong>第一步</strong>：使用多路归并排序对大文件进行排序，这样相同的单词肯定是紧挨着的</p><p>多路归并排序对大文件进行排序的步骤如下：</p><p>① 将文件按照顺序切分成大小不超过2m的小文件，总共500个小文件</p><p>② 使用10MB内存<strong>分别</strong>对 500 个小文件中的单词进行<strong>排序</strong></p><p>③ 使用一个大小为500大小的堆，对500个小文件进行<strong>多路排序</strong>，结果写到一个大文件中</p><p>其中第三步，对500个小文件进行多路排序的思路如下：</p><ul><li>初始化一个最小堆，大小就是有序小文件的个数500。堆中的每个节点存放每个有序小文件对应的输入流。</li><li>按照每个有序文件中的下一行数据对所有文件输入流进行排序，单词小的输入文件流放在堆顶。</li><li>拿出堆顶的输入流，并其下一行数据写入到最终排序的文件中，如果拿出来的输入流中还有数据的话，那么将这个输入流再一次添加到栈中。否则说明该文件输入流中没有数据了，那么可以关闭这个流。</li><li>循环这个过程，直到所有文件输入流都没有数据为止。</li></ul><p><strong>第二步</strong>：</p><p>① 初始化一个100个节点的<strong>小顶堆</strong>，用于保存100个出现频率最多的单词</p><p>② 遍历整个文件，一个单词一个单词的从文件中取出来，并计数</p><p>③ 等到遍历的单词和上一个单词不同的话，那么上一个单词及其频率如果大于堆顶的词的频率，那么放在堆中，否则不放</p><p>最终，小顶堆中就是出现频率前100的单词了。</p><p>解法2相对解法1，更加严谨，如果某个词词频过高或者整个文件都是同一个词的话，解法1不适用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见场景题总结&quot;&gt;&lt;a href=&quot;#常见场景题总结&quot; class=&quot;headerlink&quot; title=&quot;常见场景题总结&quot;&gt;&lt;/a&gt;常见场景题总结&lt;/h1&gt;&lt;h2 id=&quot;1-扫码登陆如何实现&quot;&gt;&lt;a href=&quot;#1-扫码登陆如何实现&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="场景" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%9C%BA%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>准召系统</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/11/evaluate-recall/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/11/evaluate-recall/</id>
    <published>2024-01-11T11:04:03.000Z</published>
    <updated>2024-05-06T11:06:16.152Z</updated>
    
    <content type="html"><![CDATA[<p>准召平台的目的是打造一个评估系统，简而言之是将一些query放入到诊断系统当中，通过诊断结果去判断当前的算法有没有成功召回大卡，从而帮助算法工程师去进一步优化这个问题。</p><h2 id="数据从何而来"><a href="#数据从何而来" class="headerlink" title="数据从何而来"></a>数据从何而来</h2><p>这里的数据来源会根据创造的评估任务的不同而不同，比如说，现在这里有两个评估功能。</p><h3 id="准确评估"><a href="#准确评估" class="headerlink" title="准确评估"></a>准确评估</h3><p>一个功能是去创建一个准确任务，这个准确任务的目的是判断召回大卡的位置是否达到了预期，这里并不是指将其召回到最上面或者只要召回了就好了，这里会对不同的query词造成的召回位置有不同的要求，不同搜索词的召回结果和位置，会根据搜索人的意图，而有自己最佳的位置。</p><p>不过，在讲逻辑之前，先说一下背景：<strong>数据来源其实是现网的历史搜索结果，现网的历史搜索结果会先放入hdfs，因为hdfs的特性，特别适合这种只写入，不修改不查询的场景，当天历史搜索结果写入完后，会执行一定的计算，把数据全部放入到clickhouse当中(原来是hive)，这样就可以执行sql去灵活的获取数据了。</strong></p><p>我们的目的是要进行的选择某一个垂直搜索的某一个业务进行准确召回，所以业务肯定会有对应的业务类型，那么去数据库中执行sql语句抓取就好了，抓取完数据后会进行一定的初步梳理，再落入mysql数据库，后面还需要二次处理。</p><p>当然，你也可以自己选择query放进去，比如说自选query就是这样的。</p><p>值得注意的是，在准确评估条件下，需要根据不同的条件去Clickhouse取数据。对于全搜而言，reqbusinesstype_ 和scene_是：reqbusinesstype_=0，scene_=(3, 20, 101, 74 )</p><p>对于视频号内搜而言：<br>reqbusinesstype_=14，scene_=(123)</p><p>SQL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">敏感数据</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br></pre></td></tr></table></figure><h3 id="召回评估"><a href="#召回评估" class="headerlink" title="召回评估"></a>召回评估</h3><p>那么前面说了，准确评估的数据可以直接去clickhouse取，那么召回评估的是否也可以呢？其实不行，因为这里涉及到很多的因素，比如，对于召回而言，其实需要去判断这个词组有没有被召回，那么就不能直接去数据库里面取，因为数据库里面的都是挑选好类别的，而是需要去现网打捞数据，然后把打捞回来的数据经过进一步的计算和预处理，才会变成适合去进行召回评估的数据，那么这种数据就会直接放入到hdfs文件里面，需要召回的时候再进行数据的读取。</p><p>当然，这里你也可以自己选择query放进去，因为这里本质上两个操作首先做的都是获取数据，而不是真正的算法评估结果。</p><p>值得注意的是，对于目前而言，是不区分全搜和视频号内搜的数据的，因为HDFS文件其实只有一份，所以不能够精确的去区分这个query词组是属于全搜还是视频号内搜的。</p><h4 id="召回为什么要区分数据"><a href="#召回为什么要区分数据" class="headerlink" title="召回为什么要区分数据"></a>召回为什么要区分数据</h4><p>其实对于搜索词而言，虽然都只是一些字符串，但是更多的是期望当前搜索词就是触发该垂直搜索的真实的字符串，如果使用别的垂搜的搜索词去还原这个搜索现场，虽然也是可以看到算法的结果，但是对于真实的搜索词组和搜索情况而言，可能就没这么的精确，所以，要去限制reqbusinesstype_ 和scene_是有原因的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;准召平台的目的是打造一个评估系统，简而言之是将一些query放入到诊断系统当中，通过诊断结果去判断当前的算法有没有成功召回大卡，从而帮助算法工程师去进一步优化这个问题。&lt;/p&gt;
&lt;h2 id=&quot;数据从何而来&quot;&gt;&lt;a href=&quot;#数据从何而来&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SOFASTACK/SOFA-RPC</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/08/opensource1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/08/opensource1/</id>
    <published>2024-01-08T15:55:53.000Z</published>
    <updated>2024-06-28T15:30:52.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>这里会去介绍一下关于我的小小的开源经历 SOFASTACK/SOFA-RPC和Apache/fury<br>看起来是两个，但是其实是一个，因为主要是在做如何将fury融入到sofa-rpc里面，这里做了很多工作，特别是要感谢 <strong>@EvenLjj @Lo1n  @chaokunyang</strong><br>下面直接开始介绍：<br>首先是对sofa-rpc的改造，这里最大的需求是需要读取一个黑白名单作为配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackAndWhiteListFileLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger      LOGGER                     = LoggerFactory</span><br><span class="line">                                                                    .getLogger(BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SOFA_SERIALIZE_BLACK_LIST  = loadBlackListFile(<span class="string">"/sofa-rpc/serialize_blacklist.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SOFA_SERIALIZER_WHITE_LIST = loadWhiteListFile(<span class="string">"/sofa-rpc/serialize_whitelist.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadBlackListFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; blackPrefixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readToList(input, <span class="string">"UTF-8"</span>, blackPrefixList);</span><br><span class="line">            &#125;</span><br><span class="line">            String overStr = SofaConfigs.getOrCustomDefault(SERIALIZE_BLACKLIST_OVERRIDE, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overStr)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"Serialize blacklist will override with configuration: &#123;&#125;"</span>, overStr);</span><br><span class="line">                &#125;</span><br><span class="line">                overrideBlackList(blackPrefixList, overStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isErrorEnabled()) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> blackPrefixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadWhiteListFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; whitePrefixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = BlackAndWhiteListFileLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readToList(input, <span class="string">"UTF-8"</span>, whitePrefixList);</span><br><span class="line">            &#125;</span><br><span class="line">            String overStr = SofaConfigs.getOrCustomDefault(SERIALIZE_WHITELIST_OVERRIDE, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overStr)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"Serialize whitelist will override with configuration: &#123;&#125;"</span>, overStr);</span><br><span class="line">                &#125;</span><br><span class="line">                overrideWhiteList(whitePrefixList, overStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isErrorEnabled()) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> whitePrefixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读文件，将结果丢入List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input           输入流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encoding        编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blackPrefixList 保持黑名单前缀的List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readToList</span><span class="params">(InputStream input, String encoding, List&lt;String&gt; blackPrefixList)</span> </span>&#123;</span><br><span class="line">        InputStreamReader reader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> InputStreamReader(input, encoding);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">            String lineText;</span><br><span class="line">            <span class="keyword">while</span> ((lineText = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String pkg = lineText.trim();</span><br><span class="line">                <span class="keyword">if</span> (pkg.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    blackPrefixList.add(pkg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isWarnEnabled()) &#123;</span><br><span class="line">                LOGGER.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(bufferedReader);</span><br><span class="line">            closeQuietly(reader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Override blacklist with override string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originList  Origin black list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> overrideStr The override string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">overrideBlackList</span><span class="params">(List&lt;String&gt; originList, String overrideStr)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; adds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] overrideItems = StringUtils.splitWithCommaOrSemicolon(overrideStr);</span><br><span class="line">        <span class="keyword">for</span> (String overrideItem : overrideItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overrideItem)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (overrideItem.startsWith(<span class="string">"!"</span>) || overrideItem.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                    overrideItem = overrideItem.substring(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"*"</span>.equals(overrideItem) || <span class="string">"default"</span>.equals(overrideItem)) &#123;</span><br><span class="line">                        originList.clear();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        originList.remove(overrideItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!originList.contains(overrideItem)) &#123;</span><br><span class="line">                        adds.add(overrideItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            originList.addAll(adds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">overrideWhiteList</span><span class="params">(List&lt;String&gt; originList, String overrideStr)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; adds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] overrideItems = StringUtils.splitWithCommaOrSemicolon(overrideStr);</span><br><span class="line">        <span class="keyword">for</span> (String overrideItem : overrideItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(overrideItem)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!originList.contains(overrideItem)) &#123;</span><br><span class="line">                    adds.add(overrideItem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adds.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            originList.addAll(adds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的主要作用是加载黑名单和白名单文件，并将文件中的内容读取到对应的列表中。<br>具体来说，这段代码包含以下主要功能：</p><ol><li>loadBlackListFile方法：加载黑名单文件并将文件中的内容读取到blackPrefixList列表中。首先，通过BlackAndWhiteListFileLoader.class.getResourceAsStream(path)方法获取黑名单文件的输入流。然后，使用readToList方法将输入流中的内容按行读取，并将非空的行添加到blackPrefixList列表中。最后，根据配置文件中的覆盖字符串，通过overrideBlackList方法对黑名单列表进行覆盖操作。</li><li>loadWhiteListFile方法：加载白名单文件并将文件中的内容读取到whitePrefixList列表中。与loadBlackListFile方法类似，它通过相同的步骤读取白名单文件，并根据配置文件中的覆盖字符串，通过overrideWhiteList方法对白名单列表进行覆盖操作。</li><li>readToList方法：将输入流中的内容按行读取，并将非空的行添加到指定的列表中。</li><li>overrideBlackList方法：根据覆盖字符串对原始的黑名单列表进行覆盖操作。根据覆盖字符串中的规则，可以添加、删除或清空黑名单列表中的元素。</li><li>overrideWhiteList方法：根据覆盖字符串对原始的白名单列表进行覆盖操作。根据覆盖字符串中的规则，可以添加白名单列表中不存在的元素。</li></ol><p>总体而言，这段代码的主要作用是加载黑名单和白名单文件，并提供方法来对这些列表进行覆盖操作，以便在后续的逻辑中使用这些列表进行过滤或其他处理<br>这是一个最基本的需求，就是通过读取一个黑白名单文件，这里也可以展示一下文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clojure.core$constantly</span><br><span class="line">clojure.main$eval_opt</span><br><span class="line">com.alibaba.citrus.springext.support.parser.AbstractNamedProxyBeanDefinitionParser$ProxyTargetFactory</span><br><span class="line">com.alibaba.citrus.springext.support.parser.AbstractNamedProxyBeanDefinitionParser$ProxyTargetFactoryImpl</span><br><span class="line">com.alibaba.citrus.springext.util.SpringExtUtil.AbstractProxy</span><br><span class="line">com.alipay.custrelation.service.model.redress.Pair</span><br><span class="line">com.caucho.hessian.test.TestCons</span><br><span class="line">com.mchange.v2.c3p0.JndiRefForwardingDataSource</span><br><span class="line">com.mchange.v2.c3p0.WrapperConnectionPoolDataSource</span><br><span class="line">com.rometools.rome.feed.impl.EqualsBean</span><br><span class="line">com.rometools.rome.feed.impl.ToStringBean</span><br><span class="line">com.sun.jndi.rmi.registry.BindingEnumeration</span><br><span class="line">com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>格式就是这样，具体就不全部放出了<br>然后从设计模式上，会使用一个枚举类去展示出有哪些情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lipan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FurySecurityMode &#123;</span><br><span class="line"></span><br><span class="line">    WHITELIST_MODE(<span class="string">"whitelist"</span>), BLACKLIST_MODE(<span class="string">"blacklist"</span>), NONE_MODE(<span class="string">"none"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String securityMode;</span><br><span class="line"></span><br><span class="line">    FurySecurityMode(String securityMode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.securityMode = securityMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecurityMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就只会出现三种情况，黑名单，白名单，什么都不使用<br>会有一个判断逻辑去判断会出现那种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not use any configuration</span></span><br><span class="line"><span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.NONE_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker noChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.DISABLE);</span><br><span class="line">    f.getClassResolver().setClassChecker(noChecker);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.BLACKLIST_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker blackListChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.WARN);</span><br><span class="line">    List&lt;String&gt; blackList = BlackAndWhiteListFileLoader.SOFA_SERIALIZE_BLACK_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackListChecker);</span><br><span class="line">    blackListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// BlackList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : blackList) &#123;</span><br><span class="line">        blackListChecker.disallowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkerMode.equalsIgnoreCase(FurySecurityMode.WHITELIST_MODE.getSecurityMode())) &#123;</span><br><span class="line">    AllowListChecker blackAndWhiteListChecker = <span class="keyword">new</span> AllowListChecker(AllowListChecker.CheckLevel.STRICT);</span><br><span class="line">    List&lt;String&gt; whiteList = BlackAndWhiteListFileLoader.SOFA_SERIALIZER_WHITE_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackAndWhiteListChecker);</span><br><span class="line">    blackAndWhiteListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// WhiteList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : whiteList) &#123;</span><br><span class="line">        blackAndWhiteListChecker.allowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; blackList = BlackAndWhiteListFileLoader.SOFA_SERIALIZE_BLACK_LIST;</span><br><span class="line">    <span class="comment">// To setting checker</span></span><br><span class="line">    f.getClassResolver().setClassChecker(blackAndWhiteListChecker);</span><br><span class="line">    blackAndWhiteListChecker.addListener(f.getClassResolver());</span><br><span class="line">    <span class="comment">// BlackList classes use wildcards</span></span><br><span class="line">    <span class="keyword">for</span> (String key : blackList) &#123;</span><br><span class="line">        blackAndWhiteListChecker.disallowClass(key + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里涉及到fury的两个能力，一个是注册过的类 进行序列化/反序列化的时候效率会更高，一个是可以通过checker去判断，当前的类是否在名单内。<br>然后下面进入了编码阶段，这里其实会对不同请求进行区别，将SOFA请求和普通的类区分开来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractByteBuf <span class="title">encode</span><span class="params">(<span class="keyword">final</span> Object object, <span class="keyword">final</span> Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> buildSerializeError(<span class="string">"Unsupported null message!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fury.setClassLoader(contextClassLoader);</span><br><span class="line">        CustomSerializer customSerializer = getObjCustomSerializer(object);</span><br><span class="line">        <span class="keyword">if</span> (customSerializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> customSerializer.encodeObject(object, context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MemoryBuffer writeBuffer = MemoryBuffer.newHeapBuffer(<span class="number">32</span>);</span><br><span class="line">            writeBuffer.writerIndex(<span class="number">0</span>);</span><br><span class="line">            fury.serialize(writeBuffer, object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayWrapperByteBuf(writeBuffer.getBytes(<span class="number">0</span>, writeBuffer.writerIndex()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> buildSerializeError(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fury.clearClassLoader(contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个方法的实现，用于将对象编码为字节缓冲区（ByteBuf）。<br>具体来说，这段代码的作用如下：<br>首先，检查传入的对象是否为null，如果是null，则抛出一个序列化错误异常。获取当前线程的上下文类加载器（contextClassLoader），以便后续使用。然后会设置fury（一个自定义序列化框架）的类加载器为上下文类加载器，以确保在序列化过程中使用正确的类加载器加载所需的类。<br>获取对象的自定义序列化器（customSerializer），如果存在自定义序列化器，则使用自定义序列化器对对象进行编码，并返回编码后的字节缓冲区。<br>如果不存在自定义序列化器，则创建一个内存缓冲区（MemoryBuffer），并使用fury对对象进行序列化，将序列化后的数据写入内存缓冲区。<br>将内存缓冲区中的字节数据封装到一个ByteArrayWrapperByteBuf对象中，并返回该对象作为编码后的结果。需要注意的是，在整个过程中，如果发生任何异常，都会抛出一个序列化错误异常，并将异常信息作为错误消息进行构建。<br>这段代码的主要作用是根据对象的类型和上下文信息，使用自定义序列化器或默认的fury序列化框架，将对象编码为字节缓冲区。<br>这里可以着重讲一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure><p>这个设计的主要目的是为了获得当前线程最新的类加载器，因为在这里会遇到一个场景，那就是当客户端在发送rpc的时候，服务端的rpc协议或者说类变更了，这样会导致两端不一样的问题， 所以需要通过这种方式去实时更新类。动态类加载和热更新：使用动态类加载和热更新的机制，可以在运行时动态加载和更新类。这样可以避免重启应用程序或重新部署的麻烦，使得类的变更能够及时生效。<br>然后就是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomSerializer customSerializer = getObjCustomSerializer(object);</span><br></pre></td></tr></table></figure><p>这里实际上是，会有自己的序列化器去实现这个CustomSerializer接口，然后这里会通过判断这个object的class是否为CustomSerializer的实现类，然后CustomSerializer有自己的处理方式。<br>然后看看它的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractByteBuf <span class="title">encodeObject</span><span class="params">(SofaRequest object, Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryBuffer writeBuffer = MemoryBuffer.newHeapBuffer(<span class="number">32</span>);</span><br><span class="line">        writeBuffer.writerIndex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据SerializeType信息决定序列化器</span></span><br><span class="line">        <span class="keyword">boolean</span> genericSerialize = context != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            isGenericRequest(context.get(RemotingConstants.HEAD_GENERIC_TYPE));</span><br><span class="line">        <span class="keyword">if</span> (genericSerialize) &#123;</span><br><span class="line">            <span class="comment">// TODO support generic call</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Generic call is not supported for now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fury.serialize(writeBuffer, object);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = object.getMethodArgs();</span><br><span class="line">        fury.serialize(writeBuffer, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayWrapperByteBuf(writeBuffer.getBytes(<span class="number">0</span>, writeBuffer.writerIndex()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里默认会去构造一个buffer，将序列化的实例的写入buffer里面，并且同时需要将每个参数也同步写入。同时定好fury的序列化模式，然后转为byte数组传回去。这里涉及到fury的底层实现，比较难说为什么要这么做，但是做法确实比较直观和简洁。<br>然后，就是进行反序列化了，但在这里有一个不同的实现方式，sofa会去定义是否要将结果直接反序列化到传入的实例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SofaRequest <span class="title">decodeObject</span><span class="params">(AbstractByteBuf data, Map&lt;String, String&gt; context)</span> <span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    MemoryBuffer readBuffer = MemoryBuffer.fromByteArray(data.array());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SofaRequest sofaRequest = (SofaRequest) fury.deserialize(readBuffer);</span><br><span class="line">        String targetServiceName = sofaRequest.getTargetServiceUniqueName();</span><br><span class="line">        <span class="keyword">if</span> (targetServiceName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Target service name of request is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String interfaceName = ConfigUniqueNameGenerator.getInterfaceName(targetServiceName);</span><br><span class="line">        sofaRequest.setInterfaceName(interfaceName);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = (Object[]) fury.deserialize(readBuffer);</span><br><span class="line">        sofaRequest.setMethodArgs(args);</span><br><span class="line">        <span class="keyword">return</span> sofaRequest;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decodeObjectByTemplate</span><span class="params">(AbstractByteBuf data, Map&lt;String, String&gt; context, SofaRequest template)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> SofaRpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.readableBytes() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Deserialized array is empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryBuffer readBuffer = MemoryBuffer.fromByteArray(data.array());</span><br><span class="line">        SofaRequest tmp = (SofaRequest) fury.deserialize(readBuffer);</span><br><span class="line">        String targetServiceName = tmp.getTargetServiceUniqueName();</span><br><span class="line">        <span class="keyword">if</span> (targetServiceName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(<span class="string">"Target service name of request is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy values to template</span></span><br><span class="line">        template.setMethodName(tmp.getMethodName());</span><br><span class="line">        template.setMethodArgSigs(tmp.getMethodArgSigs());</span><br><span class="line">        template.setTargetServiceUniqueName(tmp.getTargetServiceUniqueName());</span><br><span class="line">        template.setTargetAppName(tmp.getTargetAppName());</span><br><span class="line">        template.addRequestProps(tmp.getRequestProps());</span><br><span class="line">        String interfaceName = ConfigUniqueNameGenerator.getInterfaceName(targetServiceName);</span><br><span class="line">        template.setInterfaceName(interfaceName);</span><br><span class="line">        <span class="keyword">final</span> Object[] args = (Object[]) fury.deserialize(readBuffer);</span><br><span class="line">        template.setMethodArgs(args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体操作比较类似，就是读出对应的实例和参数。<br>然后，这个sofa-rpc也是使用扩展机制，去将序列化方式融入到整体当中的。</p><h2 id="Fury"><a href="#Fury" class="headerlink" title="Fury"></a>Fury</h2><p>这里我还在fury这个项目中做了点贡献，尤其是对StringBuilder的修改：<br>在 JDK 8 和 JDK 11 中，StringBuilder 类的底层实现数组的方式有一些区别。<br>在 JDK 8 中，StringBuilder 类使用的是一个字符数组（char[]）作为底层的缓冲区。初始时，该字符数组的长度为 16。当需要追加更多字符时，StringBuilder 会检查当前缓冲区是否有足够的空间，如果没有，则会创建一个新的字符数组，将原有的字符数组内容复制到新数组中，并将新的字符数组作为底层缓冲区。<br>在 JDK 11 中，StringBuilder 类的底层实现有所改进。它引入了一个新的类，称为 CompactStrings。CompactStrings 类使用的是一个字节数组（byte[]）作为底层的缓冲区。这个字节数组中的每个字节都可以存储一个字符，而不仅仅是一个字节。这样可以节省内存空间，特别是对于包含大量 ASCII 字符的字符串。<br>在 JDK 11 中，默认情况下，CompactStrings 是启用的。当字符串中的字符都可以用一个字节表示时，CompactStrings 会将字符串存储在字节数组中。只有当字符串中包含无法用一个字节表示的字符时，才会使用字符数组来存储字符串。<br>这种改进的底层实现方式可以提供更高的内存效率，特别是对于包含大量 ASCII 字符的字符串。它可以减少内存的使用量，并提高性能。需要注意的是，CompactStrings 的启用与否可以通过 JVM 的参数进行配置。在某些情况下，可能需要手动禁用 CompactStrings，以便与旧版本的 JDK 兼容或满足特定的需求。<br>于是，即使是面对同样的类，也要有不一样的序列化方式，当然，这里其实可以通过启动时去获取jdk版本，然后做区分操作，现在要展示的是，如何在版本不同的StringBuilder下做出不同的序列化结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ToIntFunction GET_CODER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Function GET_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  GET_VALUE = (Function) makeGetterFunction(StringBuilder.class.getSuperclass(), "getValue");</span><br><span class="line">  ToIntFunction&lt;CharSequence&gt; getCoder;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Method getCoderMethod = StringBuilder.class.getSuperclass().getDeclaredMethod("getCoder");</span><br><span class="line">    getCoder = (ToIntFunction&lt;CharSequence&gt;) makeGetterFunction(getCoderMethod, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    getCoder = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  GET_CODER = getCoder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个静态代码块，用于初始化两个私有静态变量 GET_VALUE 和 GET_CODER。<br>首先，代码使用 makeGetterFunction 方法创建了一个函数对象 GET_VALUE，该函数对象用于获取 StringBuilder 类的父类的 getValue 方法。接下来，代码尝试通过反射获取 StringBuilder 类的父类的 getCoder 方法，并将其转换为 ToIntFunction<CharSequence> 类型。如果找不到该方法，则将 GET_CODER 设置为 null。最终，将获取到的 getCoder 赋值给 GET_CODER 变量。<br>这段代码的目的是为了获取 StringBuilder 类的父类的 getValue 方法和 getCoder 方法，并将它们分别赋值给 GET_VALUE 和 GET_CODER 变量。这些变量可能在后续的代码中使用，用于执行相应的操作。<br>因为既然它们的底层实现不一样，就需要通过反射的方式去获取到实际的底层数组，这里只需要做区分了。然后，写入的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(MemoryBuffer buffer, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GET_CODER != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> coder = GET_CODER.applyAsInt(value);</span><br><span class="line">      <span class="keyword">byte</span>[] v = (<span class="keyword">byte</span>[]) GET_VALUE.apply(value);</span><br><span class="line">      buffer.writeByte(coder);</span><br><span class="line">      <span class="keyword">if</span> (coder == <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.writePrimitiveArrayWithSizeEmbedded(v, Platform.BYTE_ARRAY_OFFSET, value.length());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coder != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported coder "</span> + coder);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.writePrimitiveArrayWithSizeEmbedded(</span><br><span class="line">            v, Platform.BYTE_ARRAY_OFFSET, value.length() &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">char</span>[] v = (<span class="keyword">char</span>[]) GET_VALUE.apply(value);</span><br><span class="line">      <span class="keyword">if</span> (StringSerializer.isLatin(v)) &#123;</span><br><span class="line">        stringSerializer.writeCharsLatin(buffer, v, value.length());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stringSerializer.writeCharsUTF16(buffer, v, value.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，代码检查 GET_CODER 是否为 null，如果不为 null，则说明 StringBuilder 对象使用了编码器（coder）。在这种情况下，代码通过调用 GET_CODER.applyAsInt(value) 获取编码器的值，并将其写入 buffer 中。<br>接下来，根据编码器的值进行不同的处理。如果编码器的值为 0，表示使用 Latin 编码，此时将 byte[] 类型的值 v 写入 buffer，并使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将数组的内容写入 buffer。如果编码器的值不为 0 或 1，则抛出 UnsupportedOperationException 异常。如果编码器的值为 1，表示使用 UTF-16 编码，此时将 byte[] 类型的值 v 写入 buffer，并将数组的长度乘以 2，然后使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将数组的内容写入 buffer。<br>如果 GET_CODER 为 null，则说明 StringBuilder 对象没有使用编码器。在这种情况下，代码通过调用 GET_VALUE.apply(value) 获取 char[] 类型的值 v，然后根据 v 是否为 Latin 编码来决定使用 stringSerializer 的 writeCharsLatin 方法还是 writeCharsUTF16 方法将字符数组写入 buffer。<br><strong>为什么要区分Latin 和UTF-16呢？Latin 编码和 UTF-16 编码所占的位数是不同的！</strong><br>Latin 编码是一种字符编码方式，它使用一个字节（8位）来表示一个字符。它主要用于表示拉丁字母字符集，包括英文字母和一些特殊字符。由于使用一个字节表示一个字符，Latin 编码可以节省存储空间，但它只能表示有限的字符集。<br>UTF-16 编码是一种可变长度的字符编码方式，它使用 16 位（2个字节）来表示一个字符。它可以表示几乎所有的字符，包括拉丁字母、非拉丁字母、符号、表情符号等。UTF-16 编码可以表示更广泛的字符集，但相对于 Latin 编码，它在存储空间上需要更多的字节。<br>因此，当将字符数组序列化时，如果使用 Latin 编码，每个字符只需要一个字节来表示；而如果使用 UTF-16 编码，每个字符需要两个字节来表示。在代码中，根据编码器的值选择适当的序列化方式，可以根据编码器的值来确定使用 Latin 编码还是 UTF-16 编码，并相应地调整序列化的字节数。</p><h3 id="高效的判断该字符串是否纯Latin字符串-SIMD"><a href="#高效的判断该字符串是否纯Latin字符串-SIMD" class="headerlink" title="高效的判断该字符串是否纯Latin字符串(SIMD)"></a>高效的判断该字符串是否纯Latin字符串(SIMD)</h3><p>这里是使用了向量化操作去快速的判断，主要还是使用了UNSAFE方法去加速判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLatin</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numChars = chars.length;</span><br><span class="line">  <span class="keyword">int</span> vectorizedLen = numChars &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> vectorizedChars = vectorizedLen &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> endOffset = Platform.CHAR_ARRAY_OFFSET + (vectorizedChars &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">boolean</span> isLatin = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> offset = Platform.CHAR_ARRAY_OFFSET; offset &lt; endOffset; offset += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">// check 4 chars in a vectorized way, 4 times faster than scalar check loop.</span></span><br><span class="line">    <span class="comment">// See benchmark in CompressStringSuite.latinSuperWordCheck.</span></span><br><span class="line">    <span class="keyword">long</span> multiChars = Platform.getLong(chars, offset);</span><br><span class="line">    <span class="keyword">if</span> ((multiChars &amp; MULTI_CHARS_NON_LATIN_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">      isLatin = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isLatin) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vectorizedChars; i &lt; numChars; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (chars[i] &gt; <span class="number">0xFF</span>) &#123;</span><br><span class="line">        isLatin = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isLatin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先获取字符数组的长度 numChars，然后计算出向量化长度 vectorizedLen，即将字符数组长度右移两位得到的结果。这里的len是指需要向量化检测的次数，比如numChars=81，vectorizedLen=20。接着，根据向量化长度计算出向量化字符数 vectorizedChars，即将向量化长度左移两位得到的结果。既，检测的字符数量。</p><p>然后，根据向量化字符数计算出结束偏移量 endOffset，即将字符数组的偏移量 Platform.CHAR_ARRAY_OFFSET 加上向量化字符数左移一位得到的结果。Platform.CHAR_ARRAY_OFFSET默认数值为16。在Java中，数组对象在内存中的布局通常包含一些元数据，比如数组的长度、类型信息等。Platform.CHAR_ARRAY_OFFSET 指定了字符数组数据部分的起始偏移量，表示从数组对象的起始位置到实际字符数据开始的距离。在很多JVM实现中，这个偏移量是16字节。这是因为：</p><ol><li>JVM实现细节：不同的JVM实现可能有不同的对象头结构。通常，对象头包含一些元数据，如对象的类型信息、标记信息、数组长度等。对于数组对象，这些元数据会占用一定的空间，具体值可能会因JVM版本和实现的不同而有所差异。</li><li>内存对齐：为了性能优化，JVM可能会对内存进行对齐操作，使数据起始位置是某个倍数（如8字节或16字节）的地址。</li></ol><p>接下来，函数使用一个布尔变量 isLatin 来表示字符数组是否全部由 Latin 字符组成，初始值为 true。然后，函数通过一个循环，从字符数组的偏移量开始，每次增加 8，以向量化方式检查字符数组中的四个字符。具体地，函数使用 Platform.getLong(chars, offset) 获取一个长整型数，一次读取8个字节（即4个字符）。然后，函数将这个长整型数与 MULTI_CHARS_NON_LATIN_MASK 进行按位与操作，如果结果不为 0，说明存在非 Latin 字符，此时将 isLatin 设置为 false 并跳出循环。</p><p><strong>怎么知道掩码是什么数值的呢？</strong> 掩码 <strong>MULTI_CHARS_NON_LATIN_MASK= -71777214294589696</strong> (即 0xFF80FF80FF80FF80) 是通过位运算来检查字符是否是拉丁字符的。这是通过以下方式实现的：</p><ol><li><p>掩码计算：</p><p>0xFF80是一个16位掩码，表示非拉丁字符的范围。0xFF80的二进制表示为 11111111 10000000，即前8位为1，后8位为0，用于标识非拉丁字符。</p><p>为了检查4个字符，我们需要将这个16位掩码扩展到64位，即重复4次 0xFF80，得到 0xFF80FF80FF80FF80，表示 11111111 10000000 11111111 10000000 11111111 10000000 11111111 10000000。</p></li><li><p>使用掩码进行位运算：</p><p>UNSAFE.getLong(chars, offset) 读取8字节（即4个字符）的数据。</p><p>将这些数据与 0xFF80FF80FF80FF80 进行按位与运算。如果结果不为0，说明这4个字符中至少有一个字符的高字节部分非零，即不是拉丁字符。</p></li></ol><p>如果在向量化检查中没有发现非 Latin 字符，函数会继续进行后续的检查。去检测费向量化的部分，函数使用一个循环，从向量化字符数开始，逐个检查字符数组中的字符。如果发现字符的值大于 0xFF（即超过一个字节的范围），则说明存在非 Latin 字符，此时将 isLatin 设置为 false 并跳出循环。<br>最后，函数返回 isLatin 的值，表示字符数组是否全部由 Latin 字符组成。</p><p>在Unicode标准中，0xFF（255）并不是最大的字符。事实上，Unicode字符的范围远超过255。具体解释如下：</p><p>字符范围：</p><ol><li>在ASCII码表中，字符范围是0到127。</li><li>在扩展ASCII码表中，字符范围是0到255。</li><li>Unicode字符的范围从 0x0000 到 0x10FFFF，支持大量的字符，包括各种语言的字符、符号、表情符号等。</li></ol><p>0xFF的意义：</p><ol><li>0xFF表示255，主要用于表示扩展ASCII字符的范围。</li><li>在检查拉丁字符时，判断条件 chars[i] &gt; 0xFF 用于检查字符是否超出了扩展ASCII范围，即是否包含非拉丁字符（Unicode字符）。</li></ol><p>因此，0xFF并不是最大的字符。在这个方法中，chars[i] &gt; 0xFF 用来检测字符数组中是否有字符的值大于255，以判断是否包含非拉丁字符。</p><p>这个函数的目的是通过向量化方式快速检查字符数组中是否存在非 Latin 字符，以及通过逐个检查剩余字符的方式进一步确认是否全部为 Latin 字符。这样可以提高判断的效率，并且可以在序列化过程中根据判断结果选择合适的序列化方式。</p><h3 id="零拷贝StringBuilder-StringBuffer"><a href="#零拷贝StringBuilder-StringBuffer" class="headerlink" title="零拷贝StringBuilder/StringBuffer"></a>零拷贝StringBuilder/StringBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCharsLatin</span><span class="params">(MemoryBuffer buffer, <span class="keyword">char</span>[] chars, <span class="keyword">final</span> <span class="keyword">int</span> strLen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> writerIndex = buffer.writerIndex();</span><br><span class="line">  <span class="comment">// The `ensure` ensure next operations are safe without bound checks,</span></span><br><span class="line">  <span class="comment">// and inner heap buffer doesn't change.</span></span><br><span class="line">  buffer.ensure(writerIndex + <span class="number">9</span> + strLen);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] targetArray = buffer.getHeapMemory();</span><br><span class="line">  <span class="keyword">if</span> (targetArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetIndex = buffer.unsafeHeapWriterIndex();</span><br><span class="line">    <span class="keyword">int</span> arrIndex = targetIndex;</span><br><span class="line">    targetArray[arrIndex++] = LATIN1;</span><br><span class="line">    arrIndex += MemoryUtils.writePositiveVarInt(targetArray, arrIndex, strLen);</span><br><span class="line">    writerIndex += arrIndex - targetIndex + strLen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      targetArray[arrIndex + i] = (<span class="keyword">byte</span>) chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buffer.unsafePut(writerIndex++, LATIN1);</span><br><span class="line">    writerIndex += buffer.unsafePutPositiveVarInt(writerIndex, strLen);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] tmpArray = getByteArray(strLen);</span><br><span class="line">    <span class="comment">// Write to heap memory then copy is 60% faster than unsafe write to direct memory.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      tmpArray[i] = (<span class="keyword">byte</span>) chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.put(writerIndex, tmpArray, <span class="number">0</span>, strLen);</span><br><span class="line">    writerIndex += strLen;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCharsUTF16</span><span class="params">(MemoryBuffer buffer, <span class="keyword">char</span>[] chars, <span class="keyword">int</span> strLen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numBytes = MathUtils.doubleExact(strLen);</span><br><span class="line">  <span class="keyword">if</span> (Platform.IS_LITTLE_ENDIAN) &#123;</span><br><span class="line">    buffer.writeByte(UTF16);</span><br><span class="line">    <span class="comment">// FIXME JDK11 utf16 string uses little-endian order.</span></span><br><span class="line">    buffer.writePrimitiveArrayWithSizeEmbedded(chars, Platform.CHAR_ARRAY_OFFSET, numBytes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The `ensure` ensure next operations are safe without bound checks,</span></span><br><span class="line">    <span class="comment">// and inner heap buffer doesn't change.</span></span><br><span class="line">    <span class="keyword">int</span> writerIndex = buffer.writerIndex();</span><br><span class="line">    buffer.ensure(writerIndex + <span class="number">9</span> + numBytes);</span><br><span class="line">    <span class="keyword">byte</span>[] targetArray = buffer.getHeapMemory();</span><br><span class="line">    <span class="keyword">if</span> (targetArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> targetIndex = buffer.unsafeHeapWriterIndex();</span><br><span class="line">      <span class="keyword">int</span> arrIndex = targetIndex;</span><br><span class="line">      targetArray[arrIndex++] = UTF16;</span><br><span class="line">      arrIndex += MemoryUtils.writePositiveVarInt(targetArray, arrIndex, strLen);</span><br><span class="line">      <span class="comment">// Write to heap memory then copy is 250% faster than unsafe write to direct memory.</span></span><br><span class="line">      <span class="keyword">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = arrIndex, end = i + numBytes; i &lt; end; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[charIndex++];</span><br><span class="line">        targetArray[i] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.HI_BYTE_SHIFT);</span><br><span class="line">        targetArray[i + <span class="number">1</span>] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.LO_BYTE_SHIFT);</span><br><span class="line">      &#125;</span><br><span class="line">      writerIndex += arrIndex - targetIndex + numBytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer.unsafePut(writerIndex++, UTF16);</span><br><span class="line">      writerIndex += buffer.unsafePutPositiveVarInt(writerIndex, numBytes);</span><br><span class="line">      <span class="keyword">byte</span>[] tmpArray = getByteArray(strLen);</span><br><span class="line">      <span class="keyword">int</span> charIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBytes; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[charIndex++];</span><br><span class="line">        tmpArray[i] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.HI_BYTE_SHIFT);</span><br><span class="line">        tmpArray[i + <span class="number">1</span>] = (<span class="keyword">byte</span>) (c &gt;&gt; StringUTF16.LO_BYTE_SHIFT);</span><br><span class="line">      &#125;</span><br><span class="line">      buffer.put(writerIndex, tmpArray, <span class="number">0</span>, numBytes);</span><br><span class="line">      writerIndex += numBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.unsafeWriterIndex(writerIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码包含了两个函数：writeCharsLatin 和 writeCharsUTF16，用于将字符数组按照 Latin 编码或 UTF-16 编码写入到内存缓冲区 buffer 中。<br>writeCharsLatin 函数首先获取当前写入位置 writerIndex，然后通过 buffer.ensure 方法确保内存缓冲区有足够的空间来写入字符数组。接下来，函数检查 buffer 是否是基于堆内存的，如果是，则使用堆内存的方式进行写入。<br>在堆内存方式下，函数将 Latin 编码的标识符 LATIN1 写入到目标数组中，并使用 MemoryUtils.writePositiveVarInt 方法将字符数组的长度写入到目标数组中。然后，函数使用一个循环，将字符数组中的每个字符转换为字节，并写入到目标数组中。最后，函数更新写入位置 writerIndex，并将其设置为新的值。<br>如果 buffer 不是基于堆内存的，函数使用直接内存的方式进行写入。函数先将 Latin 编码的标识符 LATIN1 写入到 buffer 中，然后使用 buffer.unsafePutPositiveVarInt 方法将字符数组的长度写入到 buffer 中。接着，函数创建一个临时的字节数组 tmpArray，并使用一个循环，将字符数组中的每个字符转换为字节，并写入到 tmpArray 中。最后，函数使用 buffer.put 方法将 tmpArray 中的字节写入到 buffer 中，并更新写入位置 writerIndex。<br>writeCharsUTF16 函数首先根据字符数组的长度计算出需要的字节数 numBytes。如果当前平台是小端序（little-endian），函数先将 UTF-16 编码的标识符 UTF16 写入到 buffer 中，然后使用 buffer.writePrimitiveArrayWithSizeEmbedded 方法将字符数组按照 UTF-16 编码写入到 buffer 中。<br>如果当前平台不是小端序，函数使用与 writeCharsLatin 函数类似的逻辑进行写入。函数首先获取当前写入位置 writerIndex，然后通过 buffer.ensure 方法确保内存缓冲区有足够的空间来写入字符数组。接下来，函数检查 buffer 是否是基于堆内存的，如果是，则使用堆内存的方式进行写入。<br>在堆内存方式下，函数将 UTF-16 编码的标识符 UTF16 写入到目标数组中，并使用 MemoryUtils.writePositiveVarInt 方法将字符数组的长度写入到目标数组中。然后，函数使用一个循环，将字符数组中的每个字符转换为字节，并按照 UTF-16 编码的规则写入到目标数组中。最后，函数更新写入位置 writerIndex。<br>如果 buffer 不是基于堆内存的，函数使用直接内存的方式进行写入。函数先将 UTF-16 编码的标识符 UTF16 写入到 buffer 中，然后使用 buffer.unsafePutPositiveVarInt 方法将字符数组的长度写入到 buffer 中。接着，函数创建一个临时的字节数组 tmpArray，并使用一个循环，将字符数组中的每个字符按照 UTF-16 编码的规则转换为字节，并写入到 tmpArray 中。最后，函数使用 buffer.put 方法将 tmpArray 中的字节写入到 buffer 中，并更新写入位置 writerIndex。<br>这两个函数的目的是将字符数组按照 Latin 编码或 UTF-16 编码写入到内存缓冲区中，以便进行后续的序列化操作。具体的写入方式根据 buffer 是否基于堆内存以及当前平台的字节序来确定。</p><h3 id="获取器函数"><a href="#获取器函数" class="headerlink" title="获取器函数"></a>获取器函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">makeGetterFunction</span><span class="params">(Method method, Class&lt;?&gt; returnType)</span> </span>&#123;</span><br><span class="line">    MethodHandles.Lookup lookup = _JDKAccess._trustedLookup(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Why `lookup.findGetter` doesn't work?</span></span><br><span class="line">      <span class="comment">// MethodHandle handle = lookup.findGetter(field.getDeclaringClass(), field.getName(),</span></span><br><span class="line">      <span class="comment">// field.getType());</span></span><br><span class="line">      MethodHandle handle = lookup.unreflect(method);</span><br><span class="line">      <span class="keyword">return</span> _JDKAccess.makeGetterFunction(lookup, handle, returnType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个静态方法 makeGetterFunction，用于创建一个获取器函数（getter function）。该方法接受两个参数：method 和 returnType。method 是一个方法对象，表示要创建获取器函数的方法；returnType 是一个 Class 对象，表示方法的返回类型。<br>首先，方法通过 _JDKAccess._trustedLookup 方法获取一个 MethodHandles.Lookup 对象，用于执行方法句柄的查找操作。然后，使用 lookup.unreflect 方法将 method 转换为一个方法句柄（MethodHandle）对象，以便后续的操作。<br>接下来，方法调用 _JDKAccess.makeGetterFunction 方法，传递 lookup、handle 和 returnType 作为参数，以创建获取器函数。具体的实现细节在该方法内部。如果在获取方法句柄或创建获取器函数的过程中发生了 IllegalAccessException 异常，方法将捕获该异常并抛出一个 RuntimeException，将原始异常作为其原因。<br>总体而言，该方法的目的是通过反射和方法句柄机制，创建一个获取器函数，用于获取指定方法的返回值。</p><ol><li>writeCharsLatin 函数用于将字符数组按照 Latin 编码写入到内存缓冲区中。</li><li>writeCharsUTF16 函数用于将字符数组按照 UTF-16 编码写入到内存缓冲区中。</li><li>这两个函数根据内存缓冲区是否基于堆内存以及当前平台的字节序来确定写入方式。</li><li>makeGetterFunction 方法用于创建获取器函数，通过反射和方法句柄机制获取指定方法的返回值。</li><li>makeGetterFunction 方法使用 _JDKAccess._trustedLookup 方法获取方法句柄的查找对象。</li><li>方法句柄通过 lookup.unreflect 方法将方法对象转换为方法句柄。</li><li>_JDKAccess.makeGetterFunction 方法使用方法句柄和返回类型创建获取器函数。</li><li>如果在获取方法句柄或创建获取器函数的过程中发生 IllegalAccessException 异常，将抛出 RuntimeException。</li><li>这些代码涉及了字节转换、内存缓冲区操作、反射和方法句柄等底层操作。</li><li>目的是实现字符编码的写入和获取器函数的创建，用于后续的序列化和数据访问操作。</li></ol><h3 id="热加载能力"><a href="#热加载能力" class="headerlink" title="热加载能力"></a>热加载能力</h3><p>其实这个能力并非是本人设计的，是根据原理去利用的：</p><p>在Java中，类加载器（ClassLoader）用于加载类和资源。每个类加载器都有其特定的加载范围和优先级。线程的上下文类加载器（Context ClassLoader）是一个特殊的类加载器，它与当前线程相关联，并且可以在加载类和资源时被使用。</p><p>上下文类加载器的设置可以由应用程序自行决定，通常用于解决类加载器层次结构中的资源查找问题。在某些情况下，应用程序可能需要使用第三方库或框架，而这些库或框架使用了自定义的类加载器。在这种情况下，上下文类加载器可以被设置为第三方类加载器，以确保正确加载所需的类和资源。</p><p>因此，Thread.currentThread().getContextClassLoader() 方法返回的类加载器可以是第三方类加载器，它可能是应用程序中使用的自定义类加载器或其他第三方库中的类加载器。</p><p>于是可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="comment">//获取第三方加载器</span></span><br></pre></td></tr></table></figure><p>ref: <a href="https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/" target="_blank" rel="noopener">https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开源经历更多的是提升了自己的创造力和动手能力，更多的时候是去编写一些从未有过的代码逻辑，没有多少参考代码是可以直接复用的。从一方面说，需要根据这个项目的需求，去从零到一的去实现这个逻辑，有时候会感觉每一行代码都写的很生涩很不好，但是写的代码多了，再回过去去思考，又可以发现自己不足的地方，然后继续去优化原有的代码块，提高代码质量，我想很多项目都是通过反复思考，推导，才会让自己的项目更加的完善。另一方面，这其实也是挺有乐趣的一件事，这其实也让我找到了当初学习数据结构的时候的那种乐趣，老师给你一个二叉树或者是图的逻辑，然后一点一点的去完成它，中途可能会碰到各种问题，但是将这个逻辑彻底实现为你的代码中，也会感到一些成就感，这给你的反馈也是一种特殊的礼物。虽然，开源看起来也是一件比较困难的事情，但是每一点的努力都会让你有所提升，这也是很值得去投入的事情，相信，道阻且长，行则将至。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RPC&quot;&gt;&lt;a href=&quot;#RPC&quot; class=&quot;headerlink&quot; title=&quot;RPC&quot;&gt;&lt;/a&gt;RPC&lt;/h2&gt;&lt;p&gt;这里会去介绍一下关于我的小小的开源经历 SOFASTACK/SOFA-RPC和Apache/fury&lt;br&gt;看起来是两个，但是其实是</summary>
      
    
    
    
    
    <category term="open source" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/open-source/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝技术说明书</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/05/zero-copy/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/05/zero-copy/</id>
    <published>2024-01-05T12:33:44.000Z</published>
    <updated>2024-02-18T13:13:32.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>零拷贝技术（Zero-copy）是一种优化数据传输和处理的技术，旨在减少数据在内存之间的复制次数，提高系统性能和效率。</p><p>在传统的数据传输过程中，当数据从一个缓冲区（如磁盘或网络）复制到另一个缓冲区（如应用程序的内存），通常需要经过多次数据复制操作。这些复制操作会占用CPU时间和内存带宽，降低系统的性能。</p><p>而零拷贝技术通过避免数据的中间复制，直接在数据源和目标之间传输数据，从而减少了数据复制的次数。它可以通过以下几种方式实现：</p><ol><li>零拷贝文件传输：在传输文件时，使用操作系统提供的零拷贝API，如sendfile()或splice()，将文件数据直接从磁盘传输到网络，避免了数据在用户空间和内核空间之间的复制。</li><li>零拷贝网络传输：在网络传输中，使用操作系统提供的零拷贝API，如sendfile()或scatter-gather I/O，将数据直接从应用程序的内存传输到网络设备，避免了数据在内核空间和用户空间之间的复制。</li><li>零拷贝内存操作：在内存操作中，使用内存映射（mmap）或共享内存（shared memory）等技术，将数据直接映射到应用程序的地址空间，避免了数据在不同缓冲区之间的复制。</li></ol><p>通过使用零拷贝技术，可以减少数据复制的次数，降低CPU和内存的负载，提高数据传输和处理的效率。这对于高性能计算、大规模数据处理和网络通信等场景非常有益。</p><p><strong>下面开始举例子</strong></p><p>当使用零拷贝技术时，数据在传输过程中避免了额外的数据复制，从而提高了性能和效率。为了展示使用零拷贝和不使用零拷贝的区别，提供两个示例代码。</p><p>首先，我们来看一下不使用零拷贝的传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputFile = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">            FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputFile.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputFile.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inputFile.close();</span><br><span class="line">            outputFile.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"文件传输完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用传统的方式进行文件复制。我们创建了一个缓冲区（byte数组），然后从输入文件中读取数据到缓冲区，再将缓冲区中的数据写入输出文件。这个过程中，数据在内存中进行了多次复制，从输入缓冲区到输出缓冲区，然后再写入输出文件。这些复制操作会占用CPU时间和内存带宽，降低系统的性能。</p><p>接下来，我们来看一下使用零拷贝技术的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream inputFile = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">            FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>);</span><br><span class="line"></span><br><span class="line">            FileChannel inputChannel = inputFile.getChannel();</span><br><span class="line">            FileChannel outputChannel = outputFile.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> fileSize = inputChannel.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接将输入通道的数据传输到输出通道，避免了数据复制</span></span><br><span class="line">            inputChannel.transferTo(<span class="number">0</span>, fileSize, outputChannel);</span><br><span class="line"></span><br><span class="line">            inputChannel.close();</span><br><span class="line">            outputChannel.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"文件传输完成！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用了FileChannel的transferTo()方法，直接将输入通道的数据传输到输出通道。这样，数据在传输过程中避免了额外的复制，提高了性能和效率。</p><p>通过对比这两个示例代码，你可以清楚地看到使用零拷贝技术相对于传统方式的优势，它避免了数据在内存中的多次复制，提高了系统的性能和效率。</p><p><strong>当然，也可以使用一个很简单的例子去说明</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"Hello, "</span>);</span><br><span class="line">        sb.append(<span class="string">"world!"</span>);</span><br><span class="line"></span><br><span class="line">        String result = sb.toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个StringBuilder对象，并使用append()方法将两个字符串进行拼接。最后，我们使用toString()方法将StringBuilder对象转换为一个不可变的字符串对象。</p><p>尽管这个例子中没有直接涉及到零拷贝的概念，但是通过使用StringBuilder，我们可以避免创建多个中间字符串对象，从而提高了字符串拼接的效率。这种技术在处理大量字符串拼接的场景下特别有用，因为它避免了频繁创建和销毁字符串对象的开销。</p><h2 id="为什么不一开始就用零拷贝？"><a href="#为什么不一开始就用零拷贝？" class="headerlink" title="为什么不一开始就用零拷贝？"></a>为什么不一开始就用零拷贝？</h2><p>那么零拷贝似乎是一开始就可以这么做的吧。那么，为什么设计者在一开始就不通过传递变量的方式来实现他的编程逻辑，而是要采用多次复制呢？</p><p>零拷贝的概念并不是一开始就存在的，而是随着计算机系统和网络技术的发展逐渐被提出和应用的。在早期的计算机系统中，内存和网络传输的速度相对较慢，因此多次复制数据是为了提高数据访问和传输的效率。</p><p>设计者在一开始采用多次复制的方式，主要是出于以下几个原因：</p><ol><li>简化编程逻辑：通过多次复制数据，可以将数据从一个地方复制到另一个地方，使得编程逻辑更加简单和直观。这种方式在早期的计算机系统中更容易实现和理解。</li><li>数据安全性：通过多次复制数据，可以确保数据在不同的内存区域或网络传输中的安全性。每次复制都可以创建数据的副本，以防止原始数据被修改或损坏。</li><li>兼容性和可移植性：在早期的计算机系统中，硬件和操作系统的支持可能有限，无法直接实现零拷贝技术。因此，通过多次复制数据可以在不同的系统和平台上实现数据的传输和处理。</li></ol><p>随着计算机系统和网络技术的进步，零拷贝的概念逐渐被提出和应用。通过使用零拷贝技术，可以避免数据在内存和网络传输中的多次复制，提高数据访问和传输的效率。现代的操作系统和网络协议栈已经提供了对零拷贝技术的支持，使得开发者可以更方便地应用零拷贝技术来优化系统性能。</p><h2 id="那原来为什么还要涉及缓冲区？"><a href="#那原来为什么还要涉及缓冲区？" class="headerlink" title="那原来为什么还要涉及缓冲区？"></a>那原来为什么还要涉及缓冲区？</h2><p>在之前的代码示例中，使用了一个缓冲区（buffer）来读取文件数据并写入到输出文件中。这是因为在实际的文件读写操作中，使用缓冲区可以提高读写的效率。</p><p>缓冲区是一块内存区域，用于临时存储数据。它可以减少对底层存储设备的频繁访问，从而提高读写操作的效率。当我们从输入流中读取数据时，可以将数据先存储到缓冲区中，然后再一次性地将缓冲区中的数据写入到输出流中，而不是每次读取一个字节或一个字符就立即写入。</p><p>在示例代码中，buffer是一个字节数组，用于存储从输入流中读取的数据。bytesRead是实际读取的字节数。通过使用缓冲区，我们可以一次性读取多个字节，并将它们存储在缓冲区中。然后，我们使用outputFile.write(buffer, 0, bytesRead)将缓冲区中的数据写入到输出文件中。</p><p>使用缓冲区的好处是可以减少对磁盘或网络的频繁访问，从而提高读写操作的效率。通过一次性读取和写入多个字节，可以减少系统调用的次数，减少了读写操作的开销。此外，缓冲区还可以提供一些额外的功能，如数据的预读取和预写入，以进一步优化读写操作的性能</p><h2 id="缓冲区能减少磁盘I-O，是不是更好呢？"><a href="#缓冲区能减少磁盘I-O，是不是更好呢？" class="headerlink" title="缓冲区能减少磁盘I/O，是不是更好呢？"></a>缓冲区能减少磁盘I/O，是不是更好呢？</h2><p>虽然使用缓冲区可以提高读写操作的效率，但它仍然需要将数据从内核空间复制到用户空间，然后再从用户空间复制到输出通道（如磁盘或网络）。这些复制操作会增加额外的CPU和内存开销，并且可能成为性能瓶颈。</p><p>相比之下，零拷贝技术可以避免数据在内核空间和用户空间之间的多次复制，从而减少了CPU和内存的开销，提高了读写操作的效率。零拷贝技术通过直接在内核空间中操作数据，将数据从输入通道传输到输出通道，而无需在用户空间和内核空间之间复制数据。</p><p>使用零拷贝技术的好处包括：</p><ol><li>减少数据复制：零拷贝技术避免了数据在内核空间和用户空间之间的多次复制，减少了CPU和内存的开销。</li><li>提高系统吞吐量：通过减少数据复制和降低CPU和内存开销，零拷贝技术可以提高系统的吞吐量，使得系统能够更高效地处理大量的数据。</li><li>减少磁盘IO：零拷贝技术可以直接将数据从输入通道传输到输出通道，减少了对磁盘IO的需求，从而提高了读写操作的效率。</li></ol><p>需要注意的是，零拷贝并不是在所有情况下都比缓冲区更好。它的应用场景通常是在需要高性能和大数据处理的场景下，例如高速网络传输、大规模数据处理等。在一些简单的场景中，使用缓冲区已经足够满足需求，并且更易于实现和理解。因此，在选择使用零拷贝还是缓冲区时，需要根据具体的应用场景和需求进行权衡和选择。</p><p>没错，最后得出了最关键的要素，<strong>内核空间和用户空间</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;零拷贝技术（Zero-copy）是一种优化数据传输和处理的技术，旨在减少数据在内存之间的复制次数，提高系统性能和效率。&lt;/p&gt;
&lt;p&gt;在传统</summary>
      
    
    
    
    
    <category term="zero-copy" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/zero-copy/"/>
    
  </entry>
  
  <entry>
    <title>大卡 WXG实践</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2024/01/01/card1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2024/01/01/card1/</id>
    <published>2024-01-01T15:10:08.000Z</published>
    <updated>2024-07-09T15:37:12.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大卡"><a href="#大卡" class="headerlink" title="大卡"></a>大卡</h1><p>这个是实习中碰到的主要业务，混合C++，Python多种语言，比较复杂的后端项目。</p><p>大卡这部分分为管理系统和大卡模块，可以分开来说。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大卡&quot;&gt;&lt;a href=&quot;#大卡&quot; class=&quot;headerlink&quot; title=&quot;大卡&quot;&gt;&lt;/a&gt;大卡&lt;/h1&gt;&lt;p&gt;这个是实习中碰到的主要业务，混合C++，Python多种语言，比较复杂的后端项目。&lt;/p&gt;
&lt;p&gt;大卡这部分分为管理系统和大卡模块，可以分开</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++函数记录</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/12/29/cpp-record/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/12/29/cpp-record/</id>
    <published>2023-12-29T15:44:59.000Z</published>
    <updated>2024-04-19T15:49:22.942Z</updated>
    
    <content type="html"><![CDATA[<p>不常见的内存调用函数等</p><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><p>munmap 是 C/C++ 标准库中的一个函数，用于解除内存映射。它通常用于释放通过 mmap 函数创建的内存映射区域。munmap 函数的作用是将指定的内存区域从进程的虚拟地址空间中解除映射，并释放相关的资源。</p><p>在 C/C++ 中，munmap 函数的原型通常在 &lt;sys/mman.h&gt; 头文件中声明。它接受两个参数：映射区域的起始地址和映射区域的大小。调用 munmap 函数后，操作系统会将指定的内存区域从进程的虚拟地址空间中移除，并释放相关的资源。</p><p>需要注意的是，munmap 函数是与操作系统紧密相关的函数，因此在使用时需要谨慎，并遵循操作系统的相关规则和限制。</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>open 是 C/C++ 标准库中的一个函数，用于打开文件。它通常用于在程序中访问和操作文件。</p><p>在 C/C++ 中，open 函数的原型通常在 &lt;fcntl.h&gt; 或 &lt;sys/stat.h&gt; 头文件中声明。它接受两个参数：文件路径和打开模式。调用 open 函数后，它会尝试打开指定路径的文件，并返回一个文件描述符，用于后续对文件的读写操作。</p><p>open 函数的打开模式参数可以指定文件的访问权限、打开方式、创建方式等。常见的打开模式包括 O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写）、O_CREAT（如果文件不存在则创建）、O_TRUNC（清空文件内容）等。</p><p>需要注意的是，open 函数是与操作系统紧密相关的函数，因此在使用时需要谨慎，并遵循操作系统的相关规则和限制。此外，C++ 标准库也提供了更高级的文件操作接口，如 fstream 类，可以更方便地进行文件的读写操作。</p><h2 id="ftruncate64"><a href="#ftruncate64" class="headerlink" title="ftruncate64"></a>ftruncate64</h2><p>ftruncate64 不是 C++ 标准库函数，而是一个特定于 Linux/Unix 系统的函数。它用于调整已打开文件的大小。</p><p>在 Linux/Unix 系统中，ftruncate64 函数用于将已打开文件的大小截断为指定的长度。它接受两个参数：文件描述符和目标文件大小。通过调用 ftruncate64 函数，可以将文件截断为指定的大小，可能会删除文件末尾的内容或在文件末尾添加空字节。</p><p>需要注意的是，ftruncate64 函数是特定于 64 位文件大小的版本，用于处理大于 2GB 的文件。对于小于 2GB 的文件，可以使用 ftruncate 函数。</p><p>要使用 ftruncate64 函数，通常需要包含 &lt;unistd.h&gt; 头文件，并在链接时链接对应的库（如 -lrt）。请注意，ftruncate64 函数在不同的操作系统和编译环境中可能会有所不同，因此在使用时请参考相关的系统文档和编译器文档。</p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap 不是 C++ 标准库函数，而是一个系统调用函数，用于在内存中创建映射区域。</p><p>mmap 函数在 Linux/Unix 系统中使用，用于将一个文件或设备映射到进程的地址空间，从而可以通过内存访问来读取或写入文件内容。它可以用于实现高效的文件 I/O 操作，以及共享内存的通信。</p><p>在 C++ 中，可以使用 mmap 函数通过调用操作系统提供的接口来创建映射区域。通常需要包含 &lt;sys/mman.h&gt; 头文件，并在链接时链接对应的库（如 -lrt）。</p><p>需要注意的是，mmap 函数是特定于操作系统的，因此在不同的操作系统和编译环境中可能会有所不同。在使用 mmap 函数时，请参考相关的系统文档和编译器文档，以了解其使用方法和注意事项。</p><h2 id="msync"><a href="#msync" class="headerlink" title="msync"></a>msync</h2><p>msync 是一个系统调用函数，而不是一个 C++ 库函数。它用于将指定的内存区域同步到对应的文件中。</p><p>在 C++ 中，可以使用 &lt;unistd.h&gt; 头文件来包含 msync 函数的声明。这个函数通常用于与 mmap 函数一起使用，以确保对内存映射区域所做的修改能够及时地写入到文件中。</p><p>msync 函数被用于同步 ShmLogReadStruct 结构体中 status 字段的修改。msync 函数的第一个参数是要同步的内存区域的起始地址，第二个参数是要同步的内存区域的大小，第三个参数是同步的选项。</p><p>通过调用 msync(&amp;read_struct-&gt;status, sizeof(read_struct-&gt;status), MS_SYNC)，代码将 ShmLogReadStruct 结构体中 status 字段的修改同步到磁盘上的文件系统。这样做可以确保在修改 status 字段后，对应的数据被持久化，以便在系统重启或其他情况下仍然可用。</p><p>需要注意的是，msync 是一个 POSIX 标准的函数，因此它在不同的操作系统上可能会有一些细微的差异。在 Windows 系统上，可能需要使用相应的系统调用函数来实现类似的功能。</p><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>memcpy 是一个 C++ 标准库函数，用于在内存之间进行数据的拷贝。</p><p>它的函数原型通常在 <cstring> 或 &lt;string.h&gt; 头文件中声明，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* destination, <span class="keyword">const</span> <span class="keyword">void</span>* source, <span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>memcpy 函数接受三个参数：</p><ul><li>destination：目标内存的指针，表示拷贝后数据的存放位置。</li><li>source：源内存的指针，表示要拷贝的数据的起始位置。</li><li>num：要拷贝的字节数。</li></ul><p>memcpy 函数将从源内存中拷贝 num 个字节的数据到目标内存中。它是一种高效的内存拷贝方法，可以用于拷贝任意类型的数据，包括基本类型、结构体、数组等。</p><p>需要注意的是，memcpy 函数不会检查目标内存和源内存的边界，因此在使用时需要确保目标内存有足够的空间来存放拷贝的数据，以避免发生内存越界错误。</p><h2 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h2><p>shmctl 是一个用于控制共享内存段的系统调用函数。它可以用于执行各种操作，如获取、修改或删除共享内存段。</p><p>函数原型如下：</p><p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</p><p>参数说明：</p><ul><li>shmid：共享内存段的标识符，由 shmget 函数返回。</li><li>cmd：要执行的操作命令，可以是以下值之一：</li></ul><ol><li>IPC_STAT：获取共享内存段的状态信息，并将其存储在 buf 参数指向的 shmid_ds 结构体中。</li><li>IPC_SET：设置共享内存段的状态信息，buf 参数指向的 shmid_ds 结构体中包含要设置的新值。</li><li>IPC_RMID：删除共享内存段。</li></ol><ul><li>buf：指向 shmid_ds 结构体的指针，用于存储共享内存段的状态信息。</li></ul><p>返回值：</p><ul><li>成功时，返回 0 或执行的操作相关的值。</li><li>失败时，返回 -1，并设置 errno 来指示错误的原因。</li></ul><p>通过调用 shmctl 函数，可以获取共享内存段的状态信息、修改共享内存段的状态或删除共享内存段。这个函数在对共享内存进行管理和控制时非常有用。</p><h2 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h2><p>shmat 是一个系统调用函数，用于将共享内存段附加到调用进程的地址空间中。</p><p>函数原型如下：</p><p>void *shmat(int shmid, const void *shmaddr, int shmflg);</p><p>参数说明：</p><ul><li>shmid：共享内存段的标识符，由 shmget 函数返回。</li><li>shmaddr：指定共享内存段附加到进程地址空间的地址。通常设置为 NULL，表示由系统自动选择一个合适的地址。</li><li>shmflg：附加标志，可以使用 SHM_RDONLY 表示只读模式，其他情况下可以设置为 0。</li></ul><p>返回值：</p><ul><li>成功时，返回共享内存段附加的地址。</li><li>失败时，返回 (void *) -1，并设置 errno 来指示错误的原因。</li></ul><p>通过调用 shmat 函数，可以将共享内存段连接到调用进程的地址空间中，使得进程可以访问共享内存中的数据。返回的地址可以用于访问共享内存中的数据。需要注意的是，使用完共享内存后，应该使用 shmdt 函数将其从进程地址空间中分离。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不常见的内存调用函数等&lt;/p&gt;
&lt;h2 id=&quot;munmap&quot;&gt;&lt;a href=&quot;#munmap&quot; class=&quot;headerlink&quot; title=&quot;munmap&quot;&gt;&lt;/a&gt;munmap&lt;/h2&gt;&lt;p&gt;munmap 是 C/C++ 标准库中的一个函数，用于解除内存映射。它</summary>
      
    
    
    
    
    <category term="C++" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>py后端是怎么样的</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/12/20/Python-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/12/20/Python-1/</id>
    <published>2023-12-20T14:49:10.000Z</published>
    <updated>2024-03-14T15:08:14.282Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始对实习过程中的工程进行简单的总结，不涉及业务。</p><p>这里使用的py去实现一个后端架构，但是这里使用的后台框架并非是类似于Django或者是flask等框架。而是单纯使用原生的方式去实现，用法其实和C++写后台没有本质的区别，仅仅是因为编程语言不同。</p><p>这里的后端，其实也大绝大多数的后端架构类似，都是采用B/S三层架构，有专门的Controller层去接受请求，也有专门的ORM层去DB访问数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1703151599325-7ee23777-53cb-4f72-9931-2417cdabd6ab.png" alt="img"></p><p>这样的系统还是比较类似的，但是也有着很大的不同。</p><h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>比如说，这里的Controller层接受的不在是http请求，而是rpc请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service.reg(name='ExactReCall')</span></span><br><span class="line"><span class="meta">@rpc_log</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">ExactReCallUpdateEvaluateTask</span><span class="params">(ctx, req: mm_pb2.ExactReCallReq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        resp: mm_pb2.ExactReCallResp)</span>:</span></span><br></pre></td></tr></table></figure><p>这里的rpc协议请求使用的都是proto文件去定义的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.py -s=combo -f=ModifyBizTemplateSave --build</span><br></pre></td></tr></table></figure><p>通过命令去rebuild proto，s是模块，f是方法，这样会生成相应的proto映射文件</p><p>看到这里大家可能会感到疑惑，这个接口全都是rpc调用，难道前端会发起rpc请求吗？那当然不会，前端发起的显然都是http请求，不过中间有一层网关，会将所有的http请求都转为rpc请求，这一层的主要目的与单体服务无关，之所以要这么做最大的目的是为<strong>让所有的服务都能够互通</strong>。</p><p>这里可能和传统的Spring全家桶的微服务不一样，在以往的微服务架构之间，所有的前端发起，后端接收的请求都是http，而服务与服务之间发送的请求基本都是RPC，这可能是一种规范，为了提升效率的规范。但是我目前工作中使用的架构全都是基于Service Mesh的，也就是说，在所有的服务下面都有一层Mesh层，服务与服务之间不能够直接通信，就算是显示的发送RPC请求，服务的链路都是先传入底下的mesh层，再由mesh层传到目标服务的。</p><p>这种解决方案目的其实也是为了解开耦合，从而提供<strong>高内聚</strong>的能力，基本每个服务根本不用去在意自己的rpc，自己的基础设施，应该是什么样的版本，什么样的协议与组件。可以说，因为有了mesh层，可以极大的杜绝了重复造轮子导致的资源浪费。</p><h2 id="orm"><a href="#orm" class="headerlink" title="orm"></a>orm</h2><p>使用session = get_session()，可以根据需要去获取当前的session。目的是为了获取一个数据库会话对象。这里做了层层的封装，比如说当前的orm是否需要事务等等，都会进行一定程度的判定，最后才会返回一个最终的实例，我们就是通过操作这个实例，去进行保存和更新的。</p><p><strong>这里的做法不像是Spring全家桶的风格，不过倒是和Go后端非常相似</strong></p><p>可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017803857459008" target="_blank" rel="noopener">使用SQLAlchemy - 廖雪峰的官方网站</a></p><p>通过session.query去获取表后，根据使用需求进行操作，比如</p><p>session.query(表名).filter(</p><p>​    表名.属性 == aaa.bbb, 表名.属性 == aaa.bbb</p><p>).first()</p><p>这样就可以获取到相应的数据了，这种写法非常简单，基本没有什么特别难的点</p><p>我们还可以进入MySQL，show create table，  SHOW INDEX FROM 数据表；查看表信息，这些都是基本的操作了</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>梳理一下逻辑，现在主要学习如何去排查问题，这里使用原生的调试器，去排查问题。</p><p>Pdb是Python自带的调试器，它可以帮助你在程序运行时暂停程序的执行，查看变量的值，执行代码行，以及跟踪程序的执行流程。使用Pdb可以帮助你快速定位代码中的错误，并且可以提高代码的可读性和可维护性。</p><p>使用Pdb非常简单，只需要在代码中插入一行 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb; </span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(proto_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> proto_path:</span><br><span class="line">        pdb.set_trace()</span><br></pre></td></tr></table></figure><p>当程序执行到这一行时，程序会暂停执行并进入Pdb调试模式。在Pdb模式下，你可以使用一系列命令来查看变量的值，执行代码行，以及跟踪程序的执行流程。</p><p>例如：</p><p>可以使用p命令来查看变量的值</p><p>使用n命令来执行下一行代码</p><p>使用c命令来继续执行程序。</p><p>使用h命令是查看有哪些命令</p><p>可以使用args查看具体是什么问题</p><p>使用u和d分别对应上游和下游</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始对实习过程中的工程进行简单的总结，不涉及业务。&lt;/p&gt;
&lt;p&gt;这里使用的py去实现一个后端架构，但是这里使用的后台框架并非是类似于Django或者是flask等框架。而是单纯使用原生的方式去实现，用法其实和C++写后台没有本质的区别，仅仅是因为编程语言不同。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="实习" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>补偿框架</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/11/02/compensate/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/11/02/compensate/</id>
    <published>2023-11-02T15:29:00.000Z</published>
    <updated>2024-02-18T13:13:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>这个框架主要的目的是为了当我们的服务涉及到与外部系统交互的时候，我们服务的事务和外部接口可能由于各种问题不能保证一致，出现两个系统数据不一致的情况，往往需要去手动处理数据。</p><h2 id="理论解决方案"><a href="#理论解决方案" class="headerlink" title="理论解决方案"></a>理论解决方案</h2><p>当服务涉及与外部系统交互时，确保数据一致性是一个重要的问题。以下是一些解决方案：</p><ol><li>使用分布式事务：如果外部系统支持分布式事务，可以使用分布式事务管理器（如Atomikos、Bitronix、Narayana等）来确保服务和外部接口的事务一致性。通过将服务和外部接口的操作纳入同一个分布式事务中，可以在两者之间实现原子性和一致性。</li><li>异步消息队列：将服务与外部接口的交互改为异步方式，使用消息队列作为中间件。服务将需要与外部接口交互的数据发送到消息队列中，然后由消费者异步处理。这样可以将服务和外部接口的事务解耦，即使其中一个失败，也不会影响另一个。如果发生故障，可以通过重试机制来保证数据最终一致性。</li><li>补偿机制：在服务与外部接口交互时，记录交互的操作和状态信息，以便在发生故障或数据不一致时进行补偿。可以使用补偿模式来处理这种情况，例如在服务中实现一个补偿机制，当发生故障时，自动触发补偿操作来修复数据不一致性。</li><li>重试和回滚：在与外部接口交互时，可以使用重试机制来处理临时的通信故障。如果发生故障，可以尝试重新发送请求，直到成功为止。另外，如果服务的事务失败，可以回滚事务并进行相应的错误处理。</li><li>监控和报警：建立监控系统来实时监测服务与外部接口的交互情况。通过监控指标和日志，可以及时发现潜在的数据不一致问题，并触发相应的报警机制，以便及时采取措施解决问题。</li></ol><p>这里其实最常见的是使用分布式事务去解决，但是其实这种解决方式其实不一定能适用于所有情况，比如说</p><ul><li>复杂性：分布式事务的实现相对复杂，需要引入额外的组件和技术栈，如分布式事务管理器、消息队列等。这增加了系统的复杂性和维护成本。</li><li>性能影响：分布式事务通常需要进行多次网络通信和资源协调，这可能导致性能开销增加。特别是在高并发和大规模系统中，分布式事务的性能问题可能会成为瓶颈。</li><li>扩展性限制：分布式事务在跨多个服务和数据库进行协调时，可能会受到扩展性的限制。当系统需要水平扩展时，分布式事务可能会成为限制因素，因为它需要全局锁和协调。</li><li>依赖外部系统：使用分布式事务时，需要确保外部系统也支持分布式事务。如果外部系统不支持或与服务的事务管理器不兼容，可能需要进行额外的工作来解决这个问题。</li><li>高可用性和故障恢复：分布式事务的高可用性和故障恢复是一个挑战。当分布式事务管理器或其他组件发生故障时，需要有相应的机制来处理故障并保证数据的一致性。</li><li>学习和开发成本：使用分布式事务需要对相关技术和概念有一定的了解，并且需要在开发过程中遵循一些规范和最佳实践。这可能需要额外的学习和培训成本。</li></ul><p>综上所述，尽管分布式事务可以解决数据一致性的问题，但也需要权衡其复杂性、性能开销和扩展性限制等因素。在设计和选择系统架构时，需要综合考虑业务需求、系统规模和可用性要求，选择适合的事务处理方式。</p><p>所以为了避免将整个系统变得更加复杂，这里其实并不建议使用分布式事务，其次，这里还涉及到需要去增加维护，增加耦合，其实是非常不推荐的做法，也比如说使用MQ，其实也是一样的，需要多一个维护。</p><p>再细说一下MQ的解决方案</p><p>补偿机制和消息队列（MQ）是两种不同的处理方式，适用于不同的场景。以下是一些情况下可以考虑使用补偿机制而不使用消息队列：</p><ol><li>低延迟要求：如果系统对低延迟有较高要求，即需要实时或近实时的处理能力，使用补偿机制可能更为合适。补偿机制通常是同步或异步的方式，可以直接在服务内部进行处理，而不需要依赖消息队列的异步处理和传递。</li><li>简化架构：使用消息队列需要引入额外的组件和技术栈，如消息中间件、消息生产者和消费者等。如果系统的架构相对简单，没有复杂的异步消息传递需求，使用补偿机制可以简化系统架构，减少复杂性和维护成本。</li><li>有限的系统规模：如果系统规模相对较小，没有大规模的并发和高吞吐量的需求，使用补偿机制可以更轻量级地处理事务和数据一致性，而不需要引入消息队列的复杂性。</li><li>事务性操作：如果需要进行事务性的操作，即需要保证一组操作的原子性和一致性，使用补偿机制可能更为合适。补偿机制可以在事务内部进行操作和补偿，而不需要依赖消息队列的事务性支持。</li></ol><p>但是结合我们的场景，其实并不需要低延迟，而更多的是需要调通不同渠道的接口，所以，这里需要去实现简单，无侵入式，高可用，低耦合的框架，所以，再三选择之下，还是补偿机制更合适。</p><p>这里推荐使用自己去实现一个补偿机制</p><h3 id="补偿机制"><a href="#补偿机制" class="headerlink" title="补偿机制"></a>补偿机制</h3><p>补偿机制和分布式事务是两种不同的处理方式，适用于不同的场景。以下是一些情况下可以考虑使用补偿机制而不是分布式事务：</p><ol><li>高可扩展性要求：如果系统需要高度可扩展性，即需要支持大规模的并发和水平扩展，使用分布式事务可能会成为限制因素。在这种情况下，可以考虑使用补偿机制，将服务的事务解耦，通过异步处理和补偿操作来保证数据的一致性。</li><li>异构系统集成：当系统需要与多个异构的外部系统进行集成时，这些外部系统可能不支持分布式事务或与服务的事务管理器不兼容。在这种情况下，使用补偿机制可以更灵活地处理与外部系统的交互，通过记录操作和状态信息，进行补偿操作来保证数据的一致性。</li><li>高可用性和故障恢复：补偿机制可以更好地应对系统的高可用性和故障恢复需求。当发生故障或数据不一致时，补偿机制可以自动触发补偿操作来修复数据，而无需依赖全局的分布式事务协调。</li><li>非关键业务操作：对于一些非关键的业务操作，数据一致性要求可能相对较低。在这种情况下，使用补偿机制可以提供更好的性能和可扩展性，而不需要引入复杂的分布式事务。</li></ol><h2 id="生产环境遇到的问题"><a href="#生产环境遇到的问题" class="headerlink" title="生产环境遇到的问题"></a>生产环境遇到的问题</h2><p>目前常见的处理手段及存在的问题</p><p>手段1: 本地数据库操作和外部接口调用放在同一个事务中</p><p>问题：外部接口成功，本地事务由于异常原因回滚，数据不一致</p><p>手段2:本地数据库事务提交后，再调用外部接口</p><p>问题：本地事务成功后，外部接口失败或者机器挂掉，数据不一致</p><p>手段3:使用mq、redis临时存储消息，后续消费</p><p>问题：mq、redis本身就是一个外部系统，一样存在问题</p><p>rocketmq提供了和本地事务一致的机制，但是需要申请维护mq且实现一套消费逻辑</p><h3 id="设计一个补偿框架"><a href="#设计一个补偿框架" class="headerlink" title="设计一个补偿框架"></a>设计一个补偿框架</h3><p>这里考虑到无侵入式，和开箱即用，所以考虑将整个流程，融入到Spring的生命周期。并且，使用注解的方式去标注需要调用外部接口的方法，然后当接口调用失败的时候，会存入数据库，然后隔一段时间再去调用，并且为了加强效率，也会使用线程池去增强实现。</p><p>现在设计的补偿框架，主要有几个功能：</p><ul><li>在启动的时候，可以扫描整个包，看看哪里用到了@Component注解，将所有用到了这个注解的，都加入到hashmap中，从而全局持有这个方法的信息。</li><li>然后，可以去使用执行链设计模式，去创建一个执行链，将需要的方法通通加入链上，分批次执行相关的方法</li><li>对于每次执行方法，必然会出现成功或者是失败的状况，如果出现执行失败的情况，可以将其写入到数据库中，等待后续再逐步从数据库中读出相应的数据，然后去尝试不断的重新执行方法。</li><li>在执行方法的时候，可以使用一个AOP切面，去根据注解信息去拦截想要执行的方法，然后先将方法持久化到数据库中，再执行相关的方法，如果执行成功，再去删除相应的ID，其次，如果执行失败，则暂时不做任何行为，因为还有定时任务去执行。</li><li>那么对于那些执行失败的任务怎么办？对于失败的任务，就会定时的去数据库中读取出来，然后去进行反复的重试，直到成功为止。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个框架主要的目的是为了当我们的服务涉及到与外部系统交互的时候，我们服务的事务和外部接口可能由于各种问题不能保证一致，出现两个系统数据不一致的情况，往往需要去手动处理数据。&lt;/p&gt;
&lt;h2 id=&quot;理论解决方案&quot;&gt;&lt;a href=&quot;#理论解决方案&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring高级注解与接口</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/08/28/ab-12yebjavab/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/08/28/ab-12yebjavab/</id>
    <published>2023-08-28T13:33:31.000Z</published>
    <updated>2024-02-18T13:11:25.856Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始记录一些学到的强力的注解和接口</p><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>CommandLineRunner是Spring Boot框架中的一个接口，用于定义在应用程序启动后执行的任务。它包含一个run方法，该方法在应用程序启动后被调用，并接收命令行参数作为参数。<br>具体来说，CommandLineRunner接口的作用是允许开发人员在应用程序启动后执行一些初始化或后续操作的逻辑。通过实现CommandLineRunner接口并重写run方法，你可以在应用程序启动后执行自定义的逻辑代码。<br>当应用程序启动时，Spring Boot会自动扫描并检测实现了CommandLineRunner接口的Bean，并在启动后调用它们的run方法。这样，你可以在应用程序启动后执行一些必要的初始化任务，例如加载数据、启动定时任务、建立连接等。<br>在CommandLineRunner接口的run方法中，你可以编写任何你希望在应用程序启动后执行的代码。该方法可以抛出Exception异常，因此你可以在其中处理任何可能发生的异常情况。<br>总结起来，CommandLineRunner接口允许你在应用程序启动后执行自定义的逻辑代码。通过实现该接口并重写run方法，你可以在应用程序启动后执行一些初始化或后续操作的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"ConfigProperties properties:&#123;&#125;"</span>, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>@PostConstruct是Java标准库中的一个注解，它用于标记一个方法，在对象创建后立即执行。在Spring框架中，@PostConstruct注解被用于定义在Bean初始化之后执行的方法。</p><p>具体来说，当一个Bean被实例化并完成依赖注入后，Spring容器会检测该Bean中是否存在被@PostConstruct注解标记的方法。如果存在，Spring容器会在Bean初始化完成后立即调用该方法。</p><p>@PostConstruct注解的作用是允许开发人员在Bean初始化之后执行一些自定义的初始化逻辑。这些逻辑可以包括数据加载、资源初始化、建立连接等操作。通过在方法上添加@PostConstruct注解，你可以确保在Bean完全初始化之后执行这些操作。</p><p>需要注意的是，@PostConstruct注解只能用于非静态方法，并且只能标记一个方法。如果在一个类中存在多个被@PostConstruct注解标记的方法，它们的执行顺序是不确定的。</p><p>总结起来，@PostConstruct注解用于标记一个方法，在Bean初始化之后立即执行。它允许开发人员在Bean初始化完成后执行一些自定义的初始化逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String targetService = properties.getTargetService();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(targetService))&#123;</span><br><span class="line">        targetService = System.getenv(<span class="string">"TService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CompensateContextHolder.setTargetService(targetService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p>@ConditionalOnProperty是Spring Boot框架中的一个条件注解，用于根据配置属性的值来决定是否启用或禁用特定的组件或配置。<br>具体来说，@ConditionalOnProperty注解用于在特定的配置属性满足条件时才加载或启用某个组件。它接收一个或多个属性参数，用于指定要检查的配置属性的名称和期望的值。<br>比如：@ConditionalOnProperty注解的value参数设置为”compensate.enabled”，表示要检查名为”compensate.enabled”的配置属性。而havingValue参数设置为”true”，表示期望该配置属性的值为”true”。<br>因此，当配置属性”compensate.enabled”的值为”true”时，被注解的组件或配置将被加载或启用。如果配置属性的值不是”true”，则被注解的组件或配置将被禁用或忽略。<br>这个注解通常用于根据配置属性的值来决定是否启用某些特定的功能或组件。通过使用@ConditionalOnProperty注解，你可以根据配置属性的值来动态地控制应用程序的行为，使其更加灵活和可配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"compensate.enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompensateManager <span class="title">compensateManager</span><span class="params">(DataSource dataSource, CompensateExecutionChain chain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompensateManager(properties, dataSource, chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NestedConfigurationProperty"><a href="#NestedConfigurationProperty" class="headerlink" title="@NestedConfigurationProperty"></a>@NestedConfigurationProperty</h2><p>@NestedConfigurationProperty是Spring框架中的一个注解，用于指示一个属性应该被视为嵌套的配置属性。它通常用于嵌套类中的属性，以便在配置文件中以嵌套的方式组织属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="keyword">private</span> String country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Employee类包含一个嵌套类Address，它表示员工的地址信息。Address类具有三个属性：street、city和country。<br>通过这种方式，可以在Employee类中组织员工的信息，并将地址信息作为嵌套类的属性。这样，可以更清晰地表示员工对象的结构，并在配置文件中以嵌套的方式配置地址信息。<br>在配置文件中，可以使用以下方式配置Employee对象的属性和Address对象的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">employee.name=John Doe</span><br><span class="line">employee.age=<span class="number">30</span></span><br><span class="line">employee.address.street=<span class="number">123</span> Main St</span><br><span class="line">employee.address.city=New York</span><br><span class="line">employee.address.country=USA</span><br></pre></td></tr></table></figure><p>这样，就可以通过嵌套类的方式组织和配置复杂的对象结构。</p><h2 id="InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessorAdapter</h2><p>InstantiationAwareBeanPostProcessorAdapter是Spring框架中的一个接口，它是InstantiationAwareBeanPostProcessor接口的适配器类。这个接口在Spring的Bean生命周期中扮演着重要的角色。<br>InstantiationAwareBeanPostProcessor接口定义了一组回调方法，用于在Spring容器实例化Bean之前和之后进行自定义处理。而InstantiationAwareBeanPostProcessorAdapter是一个适配器类，它提供了默认的空实现，使得我们可以只关注我们感兴趣的回调方法，而不需要实现接口中的所有方法。<br>这个接口的作用是允许开发者在Bean实例化的不同阶段进行自定义的处理。它提供了以下几个重要的回调方法：<br>postProcessBeforeInstantiation(): 在实例化Bean之前调用，允许开发者返回一个自定义的Bean实例，或者返回null来使用默认的实例化机制。<br>postProcessAfterInstantiation(): 在实例化Bean之后调用，允许开发者对实例进行自定义的处理，例如修改属性值或执行其他初始化操作。<br>postProcessPropertyValues(): 在Bean的属性注入之前调用，允许开发者对属性值进行自定义的处理，例如修改属性值或验证属性的合法性。<br>通过实现InstantiationAwareBeanPostProcessor接口或使用InstantiationAwareBeanPostProcessorAdapter适配器类，开发者可以在Bean实例化的不同阶段进行自定义的处理。这样，我们可以在Spring容器实例化Bean时，对Bean进行额外的操作或修改，以满足特定的需求。<br>以下是一个简单的示例，展示了如何使用InstantiationAwareBeanPostProcessorAdapter接口来自定义处理Bean实例化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == MyBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之前，返回一个自定义的Bean实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">"Custom Instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null，使用默认的实例化机制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyBean) &#123;</span><br><span class="line">            <span class="comment">// 在实例化MyBean之后，对其进行自定义的处理</span></span><br><span class="line">            MyBean myBean = (MyBean) bean;</span><br><span class="line">            myBean.setSomeProperty(<span class="string">"Custom Property Value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个名为CustomBeanPostProcessor的类，它继承自InstantiationAwareBeanPostProcessorAdapter适配器类。我们重写了postProcessBeforeInstantiation()和postProcessAfterInstantiation()方法来实现自定义的处理逻辑。<br>在postProcessBeforeInstantiation()方法中，我们检查要实例化的Bean是否是MyBean类。如果是，我们返回一个自定义的MyBean实例，否则返回null，使用默认的实例化机制。<br>在postProcessAfterInstantiation()方法中，我们检查实例化后的Bean是否是MyBean类的实例。如果是，我们对其进行自定义的处理，例如设置属性值。<br>通过使用CustomBeanPostProcessor类，我们可以在Bean实例化的过程中对特定的Bean进行自定义处理。这样，我们可以根据需要修改Bean的实例或属性，以满足特定的业务逻辑或需求。</p><h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><p>ApplicationContextAware接口是Spring框架中的一个接口，用于实现对应用程序上下文（ApplicationContext）的感知。<br>该接口继承自Aware接口，通过实现ApplicationContextAware接口，可以让Bean获取对应用程序上下文的引用，并在需要时进行操作。<br>具体来说，ApplicationContextAware接口定义了一个方法setApplicationContext(ApplicationContext var1)，当Bean被实例化并注入到Spring容器中时，Spring容器会自动调用该方法，并将当前的应用程序上下文作为参数传递进来。<br>通过实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文的引用，并利用它来进行一些操作，例如获取其他Bean、发布事件、访问资源等。<br>一般来说，这么整就行了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来，ApplicationContextAware接口的作用是让Bean获取对应用程序上下文的引用，以便在需要时进行操作。通过实现该接口并实现setApplicationContext()方法，我们可以在Bean中获取到应用程序上下文，并利用它进行各种操作。</p><h2 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h2><p>@Aspect注解是Spring框架中的一个注解，用于声明一个切面（Aspect）。切面是一种用于横切关注点（Cross-cutting Concerns）的模块化方式，它可以定义一组通用的横切逻辑，并将其应用到多个目标对象中。<br>具体来说，@Aspect注解用于标记一个类为切面类，该类中定义了一些通用的横切逻辑，例如日志记录、性能监控、事务管理等。切面类通常包含一些切点（Pointcut）和通知（Advice）的定义。</p><ul><li>切点（Pointcut）：切点定义了在哪些连接点（Join Point）上应用通知。连接点是程序执行过程中可以插入切面逻辑的点，例如方法调用、方法执行、异常抛出等。切点通过表达式或注解来定义，用于匹配符合条件的连接点。</li><li>通知（Advice）：通知定义了在切点上执行的具体逻辑。通知可以在切点之前、之后、抛出异常时等不同的时机执行。常见的通知类型包括前置通知（Before）、后置通知（After）、返回通知（AfterReturning）和异常通知（AfterThrowing）等。</li></ul><p>通过使用@Aspect注解，Spring框架可以识别并将切面类纳入到AOP（面向切面编程）的管理中。在运行时，Spring会根据切点和通知的定义，将切面逻辑织入到目标对象的相应连接点上，从而实现横切关注点的功能。<br>要使用切面，需要完成以下步骤：</p><ol><li>在Spring配置文件中启用AOP的自动代理功能。可以使用<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a>标签或@EnableAspectJAutoProxy注解来实现。这将告诉Spring框架在运行时自动创建代理对象，并将切面逻辑织入到目标对象的连接点上。</li><li>创建目标对象。目标对象是需要应用切面逻辑的对象。可以是任何Spring管理的Bean，例如服务类、控制器等。</li><li>创建切面类。切面类是包含切点和通知的类。使用@Aspect注解标记切面类，并在其中定义切点和通知的方法。</li><li>在切面类中定义切点。切点定义了在哪些连接点上应用通知。可以使用表达式或注解来定义切点，以匹配符合条件的连接点。</li><li>在切面类中定义通知。通知定义了在切点上执行的具体逻辑。可以使用@Before、@After、@AfterReturning、@AfterThrowing等注解来定义不同类型的通知。</li><li>运行应用程序。当目标对象的方法被调用时，切面逻辑会自动织入到连接点上，根据切点和通知的定义执行相应的逻辑。</li></ol><p>以下是一个简单的示例，演示如何使用切面类来实现日志记录的横切逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        MyService myService = context.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        myService.doSomething();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Doing something..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.example.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethodExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个MyService类作为目标对象，其中包含一个doSomething()方法。我们还创建了一个LoggingAspect类作为切面类，其中定义了一个前置通知，用于在目标对象的方法执行之前记录日志。<br>在MainApp类中，我们使用AnnotationConfigApplicationContext来加载Spring配置，并获取MyService的实例。当调用myService.doSomething()方法时，切面类中的前置通知会被触发，输出日志信息：”Before method execution: Logging…”。<br>通过以上步骤，我们成功地将切面逻辑应用到目标对象的连接点上，实现了日志记录的横切逻辑<br>总结起来，@Aspect注解用于声明一个切面类，该类中定义了切点和通知，用于实现横切关注点的功能。通过使用@Aspect注解，Spring框架可以识别并管理切面类，将切面逻辑织入到目标对象的连接点上。</p><h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>@Around是一个用于定义环绕通知的注解。在Spring AOP中，环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。<br>使用@Around注解可以将一个方法标记为环绕通知方法。这个方法会在目标方法执行之前和之后执行，可以在这个方法中编写自定义的逻辑来控制目标方法的执行。<br>环绕通知方法需要满足一些要求：</p><ul><li>方法的返回类型可以是任意类型，通常是Object。</li><li>方法的参数可以是ProceedingJoinPoint类型，用于执行目标方法，也可以是其他参数，根据需要进行定义。</li></ul><p>在环绕通知方法中，可以通过调用ProceedingJoinPoint对象的proceed()方法来执行目标方法。在调用proceed()方法之前，可以在目标方法执行前进行一些前置操作，而在调用proceed()方法之后，可以在目标方法执行后进行一些后置操作。通过使用@Around注解，我们可以更灵活地控制目标方法的执行过程，例如在执行前后进行日志记录、性能监控、事务管理等操作。<br>比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.example.service.MyService.doSomething(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"After method execution: Logging..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个LoggingAspect切面类，并在其中使用@Around注解标记了一个环绕通知方法aroundAdvice()。该方法接受一个ProceedingJoinPoint参数，用于执行目标方法。<br>在aroundAdvice()方法中，我们首先输出了一条日志信息，表示在目标方法执行之前的前置操作。然后，通过调用joinPoint.proceed()方法，执行了目标方法。最后，我们又输出了一条日志信息，表示在目标方法执行之后的后置操作。<br>通过这个示例，我们可以在目标方法执行前后添加自定义的逻辑，例如记录日志、计算方法执行时间等。这样，每次调用MyService的doSomething()方法时，都会触发切面的环绕通知方法。</p><h3 id="Aspect和-Around"><a href="#Aspect和-Around" class="headerlink" title="@Aspect和@Around"></a>@Aspect和@Around</h3><p>@Aspect和@Around是Spring AOP框架中的两个不同的注解，它们在AOP的实现中扮演不同的角色。</p><ul><li>@Aspect注解用于标记一个类为切面类。切面类是包含切面逻辑的类，它定义了在哪些连接点上应用切面逻辑，并且可以包含多个通知类型（如前置通知、后置通知、环绕通知等）。通过使用@Aspect注解，我们可以将一个普通的类声明为切面类，以便在Spring AOP中使用。</li><li>@Around注解是一个通知类型的注解，用于定义环绕通知。环绕通知是一种切面通知类型，它可以在目标方法执行前后进行拦截，并且可以完全控制目标方法的执行。通过使用@Around注解，我们可以将一个方法标记为环绕通知方法，以便在切面中定义自定义的逻辑。</li></ul><p>因此，@Aspect注解用于标记切面类，而@Around注解用于标记环绕通知方法。切面类可以包含多个通知类型的方法，而环绕通知方法是其中的一种。切面类通过@Aspect注解告诉Spring AOP框架它是一个切面类，而环绕通知方法通过@Around注解告诉框架它是一个环绕通知方法。</p><p>综上所述，@Aspect和@Around是Spring AOP框架中的两个不同的注解，用于不同的目的。@Aspect用于标记切面类，而@Around用于标记环绕通知方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里开始记录一些学到的强力的注解和接口&lt;/p&gt;
&lt;h2 id=&quot;CommandLineRunner&quot;&gt;&lt;a href=&quot;#CommandLineRunner&quot; class=&quot;headerlink&quot; title=&quot;CommandLineRunner&quot;&gt;&lt;/a&gt;CommandL</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>高性能队列：Disruptor</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/04/14/Disruptor-1/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/04/14/Disruptor-1/</id>
    <published>2023-04-14T14:01:04.000Z</published>
    <updated>2023-12-14T14:02:57.819Z</updated>
    
    <content type="html"><![CDATA[<p><a name="oYoyt"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易所中的低延迟和高吞吐量需求而设计的。它主要用来解决在多线程环境中生产者和消费者之间的数据传递问题。Disruptor 由 LMAX 的 Martin Thompson 和 Dave Farley 于 2011 年发明，现在是一个开源项目。</p><blockquote><p>The Disruptor is the result of our efforts to build the world’s highest performance financial exchange at LMAX. Early designs focused on architectures derived from SEDA [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_1" target="_blank" rel="noopener">1</a>] and Actors [<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_footnotedef_2" target="_blank" rel="noopener">2</a>] using pipelines for throughput. After profiling various implementations it became evident that the queuing of events between stages in the pipeline was dominating the costs. We found that queues also introduced latency and high levels of jitter. We expended significant effort on developing new queue implementations with better performance. However it became evident that queues as a fundamental data structure are limited due to the conflation of design concerns for the producers, consumers, and their data storage. The Disruptor is the result of our work to build a concurrent structure that cleanly separates these concerns.</p></blockquote><p>Disruptor 的核心思想是，通过使用环形的数据结构（RingBuffer）和避免锁来实现数据的高速传递。RingBuffer 类似于一个循环队列，内部包含一个预先分配好的对象数组，该数组的大小为 2 的幂次方。这样设计的一个原因是可以通过位运算快速计算数组中的索引，提升性能。创建此环形数据结构后，生产者可以将事件（通常是某个类的实例）发布到 RingBuffer 的下一个可用位置，同时消费者可以从 RingBuffer 中读取和处理事件。通过使用序号（Sequence）来表示 RingBuffer 中各个条目的位置，生产者和消费者之间可以实现非阻塞的协同工作模式，从而达到最大的性能优势。<br />Disruptor 还支持多个生产者和多个消费者的场景，消费者可以独立处理事件，也可以按照依赖关系顺序进行处理。这使得Disruptor 可以在保持低延迟的同时，实现并行处理并提高整体系统吞吐量。</p><p>那Disruptor相比于Java内置的队列而言，有什么优势呢，这里需要进一步的分析<br><a name="CVc3m"></a></p><h2 id="Java的内置队列"><a href="#Java的内置队列" class="headerlink" title="Java的内置队列"></a>Java的内置队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232326187-0473b7b4-ba77-4943-a805-2a343871d150.png#averageHue=%23e1e1e1&clientId=u294810c7-fb47-4&from=paste&height=186&id=ud6f9c576&originHeight=372&originWidth=1212&originalType=binary&ratio=2&rotation=0&showTitle=false&size=68156&status=done&style=none&taskId=ub09db3d5-5196-46d9-acc2-89707ac10fe&title=&width=606" alt="image.png"><br />在Java中ArrayBlockingQueue是靠锁去控制它的并发安全的，而且是有界的队列。</p><p>ArrayBlockingQueue（数组阻塞队列）通过内部的锁（ReentrantLock）和两个条件变量（Condition）notEmpty和notFull来保证线程安全。</p><ol><li>ReentrantLock（可重入锁）：ArrayBlockingQueue使用ReentrantLock作为内部的锁来控制对队列的访问。在读取、写入、删除等操作时，需要先获取锁，完成操作后再释放锁。使用lock及unlock方法对数据进行保护，确保同一时刻只有一个线程能执行特定的操作。 </li><li>条件变量（Condition）：ArrayBlockingQueue有两个Condition，分别是notEmpty和notFull。当队列为空时，使用notEmpty.await()方法阻塞读线程；当队列满时，使用notFull.await()方法阻塞写线程。当数据被删除后，notEmpty.signal()唤醒读线程继续读取；当数据被添加后，notFull.signal()唤醒写线程继续写入。 </li></ol><p>通过这些同步措施，ArrayBlockingQueue确保了在多线程环境下的线程安全性<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689232394025-16fa469d-9921-4e33-acb5-4c8d725374d4.png#averageHue=%232d2d2d&clientId=u294810c7-fb47-4&from=paste&height=236&id=u00680c6f&originHeight=472&originWidth=1282&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44409&status=done&style=none&taskId=u06f63704-23cf-4250-8d9c-269cc5fecf6&title=&width=641" alt="image.png"><br />而LinkedTransferQueue都是通过原子变量CAS这种不加锁的方式来实现的，但是它们都是使用链表的方式去实现的，这种方式的会出现两个问题，一个是由于无界导致的OOM，一个是这种数据结构也会影响到JVM的GC效率，所以，在大多数时候，还是使用ArrayBlockingQueue比较的常见，那么，ArrayBlockingQueue 有什么问题呢。</p><p><a name="oLbbN"></a></p><h3 id="加锁导致的效率问题"><a href="#加锁导致的效率问题" class="headerlink" title="加锁导致的效率问题"></a>加锁导致的效率问题</h3><p>这里引用LMAX交易所的数据：</p><blockquote><p>We will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which increments a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel Westmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar across all languages with the same basic primitives.<br>Once a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up significantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results of this simple experiment are shown in the table below:</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233609316-d2ddb2d5-2975-480c-a740-3463916fb39e.png#averageHue=%23fbfafa&clientId=u294810c7-fb47-4&from=paste&height=367&id=ua84c85bb&originHeight=734&originWidth=2064&originalType=binary&ratio=2&rotation=0&showTitle=false&size=113743&status=done&style=none&taskId=u86ed9446-fa4e-421c-9e57-fa897f4eea4&title=&width=1032" alt="image.png"><br />这里LMAX使用一个程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。测试结果显然，加锁与CAS的差别还是比较大的。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689233889498-6c9beec5-949e-4088-b74e-00bdb38af9a0.png#averageHue=%232b2b2b&clientId=u294810c7-fb47-4&from=paste&height=492&id=ub7be082a&originHeight=984&originWidth=1434&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126074&status=done&style=none&taskId=uced54ebb-973c-4a4b-a939-456ce64a777&title=&width=717" alt="image.png"><br />这个加锁加在了offer，以此来保证线程的安全性，但是这样的方式显然会损失不少性能。<br />而CAS的呢，这里则使用了unsafe去使用魔法，使其不加锁的情况下，仍然可以保证线程安全：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234138046-0d2ed826-05bc-459f-87de-af5aa633a9e4.png#averageHue=%232d2c2b&clientId=u294810c7-fb47-4&from=paste&height=189&id=u78cb1884&originHeight=378&originWidth=1370&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79015&status=done&style=none&taskId=uad351660-7a33-427d-a31f-ae88e1069cb&title=&width=685" alt="image.png"></p><p>那为什么ArrayBlockingQueue非要加锁<br />看到这里大家可能会有一个疑惑，那为什么ArrayBlockingQueue不用cas而选择加锁呢？<br />使用ArrayBlockingQueue而非CAS的原因主要包括以下几点：</p><ol><li>锁的简化。ArrayBlockingQueue适用于生产者和消费者的场景。当队列为空时，消费者线程需要等待；当队列已满时，生产者线程需要等待。这种有固定边界的队列在这种场景下可以简化设计。通过使用锁，可以简化这种等待-通知的逻辑。锁本身支持等待-通知机制，使用条件变量Condition实现。 </li><li>性能。考虑到在有边界的队列情况下，竞争可能会比较激烈。当队列为空或已满时，CAS操作可能会导致大量的失败尝试和自旋。这会影响性能，并消耗更多的CPU资源。而在这些竞争激烈的情况下，锁的性能往往优于CAS操作。 </li><li>简单性。相比于使用CAS操作实现的非阻塞数据结构，使用锁实现的数据结构通常更容易理解和实现。这意味着更少的错误和更容易维护的代码。 </li></ol><p>而Disruptor是一个高性能队列库，它的设计初衷是为了解决高并发、低延迟的场景。Disruptor之所以能够使用CAS（Compare And Swap）操作，主要是基于以下几个原因：</p><ol><li>缓存行填充。Disruptor利用缓存行填充（Cache Line Padding）来减少伪共享（False Sharing）的问题。伪共享会导致缓存行失效，从而影响性能。通过将生产者和消费者的指针放置在不同的缓存行上，避免了伪共享问题，从而提高了使用CAS操作的性能。 </li><li>锁消除。Disruptor消除了锁的使用，通过使用原子操作（如CAS）进行并发控制。这减少了锁带来的开销，提高了性能。在高并发场景下，锁的竞争可能会导致严重的性能问题，而CAS操作可以更好地支持这些场景。 </li><li>数据结构设计。Disruptor的数据结构设计是基于环形缓冲区（Ring Buffer）的，这使得它在内存分配和管理上更加高效。通常情况下，无锁队列的设计和实现相对复杂，但Disruptor通过使用环形缓冲区，将其复杂程度降低，使得CAS操作的实现变得可行。 </li><li>无阻塞。Disruptor采用无阻塞算法，避免了死锁、阻塞等问题。在高并发场景下，无阻塞算法通常具有更好的伸缩性。当线程之间存在很多竞争时，锁定资源可能会导致性能瓶颈。而CAS操作提供了一种无锁的方式来解决资源竞争问题。 </li><li>批处理。Disruptor支持批处理，它可以将多个操作组合在一起执行。这样可以充分利用CPU缓存、减少上下文切换，从而提高CAS操作的性能。 </li></ol><p>Disruptor之所以能够使用CAS操作，主要是因为其数据结构设计、缓存行填充、无锁算法和批处理等技术的应用。这些技术使得Disruptor在高并发和低延迟场景下具有优秀的性能，满足了高性能队列的需求。<br><a name="XJbbR"></a></p><h3 id="被破坏的共享"><a href="#被破坏的共享" class="headerlink" title="被破坏的共享"></a>被破坏的共享</h3><p>这里需要提一提一个比较底层的知识，那就是CPU的三级cache：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238904423-7c2ab82a-340e-4193-933d-f40108692896.png#averageHue=%23f4f4f4&clientId=u294810c7-fb47-4&from=paste&height=703&id=u96748072&originHeight=1406&originWidth=1502&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275200&status=done&style=none&taskId=u7bb6a08a-075c-48ad-ade2-9790ddae633&title=&width=751" alt="4-modified.png"><br />CPU的三级缓存，即L1、L2和L3缓存，是一种位于CPU内部的高速存储器。它们主要用于存储那些频繁使用的数据和指令，从而提高CPU处理速度。<br />L1缓存（一级缓存）：它是CPU内部最接近执行单元的缓存，速度非常快，但存储容量相对较小，通常在32KB-64KB之间。L1缓存通常分为数据缓存（用于存储操作数）和指令缓存（用于存储已经预取的指令）。<br />L2缓存（二级缓存）：它位于L1缓存之后，速度略低于L1缓存，但具有较大的存储容量，通常在256KB到8MB之间。L2缓存通常用于存储那些不太频繁使用的数据和指令。在某些CPU设计中，L2缓存可能是共享的，这意味着它可以存储来自不同执行单元的数据和指令。<br />L3缓存（三级缓存）：它位于L2缓存之后，速度低于L2缓存，但在容量和访问速度方面，它将较之主存储器（例如DDR RAM）有很大优势。L3缓存容量范围通常在8MB至32MB之间，但在某些高端处理器中可能更大。L3缓存主要用于在L2缓存中未命中的数据和指令的存储，它可以在多个核之间共享。<br />这种分级存储的方式有效地将处理器的计算能力靠近主存储器的速度。当CPU需要访问数据或指令时，它首先检查L1缓存，然后是L2缓存，最后是L3缓存。如果三级缓存都未命中，CPU将从主存储器中获取数据。由于L1、L2和L3缓存的访问速度逐级降低，但存储容量逐级增加，因此它们一起建立了一个高效的层次结构，将最频繁使用的内容存储在越来越快的缓存中，从而提高处理速度。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234350571-75b183be-3153-4664-aaa3-c841032acea7.png#averageHue=%23e5e5e5&clientId=u294810c7-fb47-4&from=paste&height=135&id=u26a1a90a&originHeight=226&originWidth=1246&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35435&status=done&style=none&taskId=u35f7847f-ab8f-4446-9329-30b47597cde&title=&width=742" alt="image.png"><br><a name="zGraA"></a></p><h4 id="共享缓存带来的影响"><a href="#共享缓存带来的影响" class="headerlink" title="共享缓存带来的影响"></a>共享缓存带来的影响</h4><p>缓存由许多缓存行组成。通常情况下，每个缓存行包含64字节，它们有效地引用了主内存中的一系列地址。在这种情况下，一个Java的long类型变量占用8字节，所以一个缓存行可以容纳8个long类型的变量。<br />当CPU从主存中获取数据时，相邻的数据也会被存储到相同的缓存行中。<br />在访问一个long类型的数组时，如果数组中的一个值被加载到缓存中，相邻的7个值也会自动被加载。这使得你可以快速地遍历该数组。实际上，在连续的内存块中分配的任何数据结构都可以被快速遍历。<br />以下示例展示了利用缓存行特性与不利用缓存行特性之间效果的对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineEffect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//考虑一般缓存行大小是64字节，一个 long 类型占8字节</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">long</span>[][] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">                sum = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">1024</span> * <span class="number">1024</span>;j++)&#123;</span><br><span class="line">                sum = arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234667637-b701dcd8-2230-437d-8483-dd0adece47f8.png#averageHue=%23303030&clientId=u294810c7-fb47-4&from=paste&height=62&id=uc4c05076&originHeight=124&originWidth=622&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10940&status=done&style=none&taskId=u021fd135-9ce1-4a0c-a783-98314c511c7&title=&width=311" alt="image.png"><br><a name="NRlFb"></a></p><h4 id="那么缓存与ArrayBlockingQueue有什么关系呢？"><a href="#那么缓存与ArrayBlockingQueue有什么关系呢？" class="headerlink" title="那么缓存与ArrayBlockingQueue有什么关系呢？"></a><strong>那么缓存与ArrayBlockingQueue有什么关系呢？</strong></h4><p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量<br />这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689234428482-ef2034bb-27f7-41f5-a649-5ecfd622a3b3.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=327&id=u0f02d98d&originHeight=654&originWidth=1966&originalType=binary&ratio=2&rotation=0&showTitle=false&size=131679&status=done&style=none&taskId=u1010804e-920f-4f30-9e79-f63781197f8&title=&width=983" alt="3-modified.png"><br />如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。<br />这种无法充分使用缓存行特性的现象，称为伪共享。<br />对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。<br /><strong>不知道大家有没有看过《Java并发编程艺术》，那本书也写了有无共享缓存导致的区别</strong><br /><strong>而解决伪共享的最好方法，就是填充</strong><br />下面是一个验证程序，去表达有填充和无填充导致的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValueNoPadding[] longs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            runTest(i);</span><br><span class="line">            System.out.println(<span class="string">"Thread num "</span> + i + <span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        longs = <span class="keyword">new</span> ValueNoPadding[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> ValueNoPadding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235086298-b4fd3d05-611f-47b2-a3cf-ee5403674406.png#averageHue=%23383838&clientId=u294810c7-fb47-4&from=paste&height=236&id=uebb152fa&originHeight=472&originWidth=550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=51500&status=done&style=none&taskId=uafd42923-c20d-4e89-9d3a-492afc10140&title=&width=275" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235220121-d84e6b19-a9b3-426c-a382-4eca89265e03.png#averageHue=%23393939&clientId=u294810c7-fb47-4&from=paste&height=227&id=ua3371d3a&originHeight=454&originWidth=484&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46562&status=done&style=none&taskId=ud852761a-cefd-4547-9b5d-2fe30fbd767&title=&width=242" alt="image.png"><br />左边是ValueNoPadding，右边是ValuePadding。</p><p>由此可见，有无共享导致的区别还是挺大的。<br />那么这么明显的问题，他们都没有注意到吗？那当然不是，事实上，已经有一个注解@Contended去解决了这个问题：<br /><code>@Contended</code> 注解用于在Java类及其字段上提高内存访问性能。它可以显式地向JVM表示，被修饰的元素（通常是字段）可能会产生伪共享（false sharing）问题。<br />伪共享是指多个线程频繁访问不同变量，但这些变量位于同一个缓存行上。这会导致缓存行频繁失效和重载，从而降低多线程程序的性能。<br /><code>@Contended</code> 注解提示JVM在分配内存时为标注元素添加额外的内存填充，以确保它们分布在不同的缓存行上。这有助于消除伪共享，从而提高线程间的并发性能。<br />要注意的是，<code>@Contended</code> 支持并不是所有JVM版本都有。在Oracle的Hotspot JVM上，默认情况下仅在Java 9及以上版本可用。 若要在低于Java 9的JVM版本上使用<code>@Contended</code>, 需要启动JVM时添加 <code>-XX:-RestrictContended</code> 参数。<br />示例使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.vm.annotation.Contended;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value1 &amp; Value2 with padding to avoid False Sharing</span></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，<code>Foo</code> 类及其字段 <code>value1</code> 和 <code>value2</code> 使用了 <code>@Contended</code> 注解，以避免伪共享问题。</p><p><a name="e83UL"></a></p><h2 id="Disruptor的设计"><a href="#Disruptor的设计" class="headerlink" title="Disruptor的设计"></a>Disruptor的设计</h2><p><a name="aaV5Q"></a></p><h3 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h3><p>Disruptor是一个高性能、低延迟的并发框架，最初由LMAX公司开发。它用于解决在复杂多线程环境下数据共享和并发访问的问题。Disruptor的设计目标是使开发人员能够在高负载场景下编写出较低延迟和高吞吐量的应用程序。其的核心设计模式主要包括以下几个方面：</p><ol><li>Ring Buffer（环形缓冲区）：Disruptor框架的核心数据结构。Ring Buffer用于存储和共享数据。它是一个环形的数组，长度固定且是2的整数次幂。由于是环形，当写入到达计数器尾部时，将回到数组的开头覆盖旧数据。Ring Buffer提高了数据存储和访问效率，同时降低了并发冲突的可能性。并且，由于数组的特性对处理器的缓存机制更加友好。</li><li>Producer（生产者）：生产者将事件数据添加到Ring Buffer中。在Disruptor框架中，可以有多个生产者同时添加事件。</li><li>Sequence Barrier（序列屏障）：提供了一种协调机制，以确保生产者和消费者在并行执行时可以正确访问Ring Buffer。</li><li>Consumer（消费者）：消费者是处理Ring Buffer中事件的实际执行者。Disruptor支持多个消费者同时处理事件，可以为消费者定义依赖关系。当多个消费者同时访问Ring Buffer时，事件将根据消费者依赖关系顺序处理。</li><li>WaitStrategy（等待策略）：Disruptor提供了一组内置的等待策略，用于控制生产者和消费者在等待事件处理时的行为。例如，线程执行、空轮询、阻塞等待等。</li></ol><p>使用Disruptor可以高效地处理多线程的并发问题。相比传统的阻塞队列和锁，Disruptor通过这些设计模式实现了更低的延迟和更高的吞吐量，适用于高性能需求的场景。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689235832610-789e1be7-524d-4d8f-80c8-e187a86cd8ba.png#averageHue=%23f5f5f5&clientId=u294810c7-fb47-4&from=paste&height=719&id=ud1e82361&originHeight=1438&originWidth=1964&originalType=binary&ratio=2&rotation=0&showTitle=false&size=267070&status=done&style=none&taskId=u81cba5c1-7ebd-4d0e-9fa9-ce68b93ba42&title=&width=982" alt="image.png"><br><a name="yFUmD"></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Disruptor还具有元素位置定位和无锁这两个优势特点，它们可以进一步提高Disruptor的性能。接下来详细介绍这三个特点：</p><ol><li>元素位置定位：<br />在Disruptor的Ring Buffer中，每个元素（事件）的位置都是通过一个序列号（Sequence）来表示的。这个序列号对应于Ring Buffer数组的一个索引位置。根据序列号计算索引位置的公式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; sequence % bufferSize</span><br></pre></td></tr></table></figure><p>其中<code>sequence</code>表示元素的序列号（从0开始递增），<code>bufferSize</code>表示Ring Buffer的大小（长度）。<br />由于Ring Buffer的长度是2的整数次幂，这样的设计使得计算索引位置非常高效。只需要进行按位与（<code>sequence &amp; (bufferSize - 1)</code>）操作即可完成计算，避免了除法和取余运算，从而提高了性能。</p><ol start="2"><li>无锁：<br />Disruptor在设计时确保了多个生产者和消费者在操作Ring Buffer时都无需使用锁。利用了无锁数据结构的原子操作，例如CAS（Compare And Swap）等，确保了在高并发环境下正确、高效地访问共享数据。无锁设计相对于基于锁的同步方式减少了线程上下文切换的开销，降低了竞争冲突，从而大幅提高了应用程序的性能。</li><li>环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好（CPU加载空间局部性原则）。</li></ol><p>在Disruptor框架中，生产者和消费者都使用单调递增的序列号（Sequence）来表示所操作的元素。当生产者或消费者需要添加或处理事件时，它们会使用CAS操作更新相应的Sequence。因此，消费者之间即使在并行执行时，也能够正确地知道对方的处理进度，这样消费者之间可以互不干扰地处理事件。</p><p><a name="KDa9A"></a></p><h3 id="使用无锁的设计"><a href="#使用无锁的设计" class="headerlink" title="使用无锁的设计"></a>使用无锁的设计</h3><p>Disruptor中的主要无锁设计是通过RingBuffer来实现的。RingBuffer是Disruptor中一个循环的缓冲区，使用无锁技术实现高性能的并发访问。<br />在Disruptor中，生产者和消费者共同操作RingBuffer。生产者发布事件时(下面的demo有示例)，会通过<strong>next()</strong>方法申请序号，并一次性地预分配多个序列号。消费者根据序列号处理相应的事件，确保消费者事件间无锁、无阻塞地运行。<br />Disruptor通过使用设计如<strong>Sequence</strong>、<strong>Sequencer</strong>和<strong>Cursor</strong>等类和遵循一定的规则，在高并发环境下保证了生产者和消费者间的正确交互，实现了高性能的无锁设计。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239186747-7e49977c-3b81-43e7-bd05-adc3aa5de15f.png#averageHue=%233a3734&clientId=u294810c7-fb47-4&from=paste&height=331&id=udce0dff4&originHeight=662&originWidth=2358&originalType=binary&ratio=2&rotation=0&showTitle=false&size=223750&status=done&style=none&taskId=u1b7af166-361f-4a85-b8d1-4f7f7f12eb0&title=&width=1179" alt="image.png"></p><p><a name="xlu1z"></a></p><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>Disruptor的RingBuffer是一个环形缓冲区，它是Disruptor框架的核心组件。它采用环形数据结构使得生产者和消费者能够高效地在无锁的情况下共享数据。下面详细讲解RingBuffer的原理：</p><ol><li>数据结构：RingBuffer实际上是一个包含预定义大小的对象数组，这个数组的大小必须为2的幂。之所以使用2的幂，是因为这样可以优化某些计算，例如通过位运算取模运算，提高性能。数组中的每个元素对应一个事件（Event），生产者负责产生事件，消费者负责处理事件。 </li><li>序列号（Sequence）：在Disruptor中，生产者和消费者通过序列号（Sequence）来定位RingBuffer中的位置。序列号是一个单调递增的long值，用于表示事件的位置。生产者申请序列号时，序列号递增。消费者处理事件时，根据序列号在RingBuffer中找到相应的事件。 </li><li>环形缓冲区：由于RingBuffer是环形的，当数组的末尾已经用完时，生产者可以从数组的开头开始重用位置。这样，在RingBuffer不满的情况下，生产者总是可以写入事件而不会遇到阻塞。当然，在RingBuffer满的情况下，生产者可能需要等待消费者消费事件来释放空间。 </li><li>索引计算：由于RingBuffer的长度是2的幂，例如长度为8的RingBuffer，可以通过位运算得到索引：<code>index = sequence &amp; (bufferSize - 1)</code>。这比取模运算效率更高。 </li><li>生产者-消费者交互：在Disruptor中，生产者和消费者通过遵循一定的规则实现环形缓冲区的无锁访问，提高并发性能。主要有以下规则：a) 生产者只需要关心最慢的消费者，因为只有当所有消费者完成对当前事件的处理，才能确保生产者可以安全地覆盖之前的事件；b) 消费者之间可能存在依赖关系，可以通过屏障（Barrier）等方法确保消费者按照顺序处理事件。 </li></ol><p>下面通过一个过程示例，来表达Disruptor的解决思路：<br />启动时，将预先分配环形缓冲区的所有内存。环形缓冲区可以存储指向 entry 的指针数组，也可以存储表示 entry 的结构数组。这些 entry 中的每一个通常不是传递的数据本身，类似对象池机制，而是它的容器。这种 entry 的预分配消除了支持垃圾回收的语言中的问题，因为 entry 将被重用，并在整个 Disruptor 实例存活期间都有效。这些 entry 的内存是同时分配的。<br />一般的数据结构是像下面这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239747113-fa180ee3-e71d-44be-9b6c-ba59c58dff57.png#averageHue=%23f6f6f6&clientId=u294810c7-fb47-4&from=paste&height=518&id=u09798d04&originHeight=1426&originWidth=1536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=214415&status=done&style=none&taskId=u0a61dd2e-e675-4e3e-b624-e76156bbf00&title=&width=558" alt="5-modified.png"><br />我们可以使用一个环状的数组结构改进成下面这样：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239757886-48ce5b14-d7fa-4a54-a762-b2f41cff6647.png#averageHue=%23f0f0f0&clientId=u294810c7-fb47-4&from=paste&height=623&id=u749158d5&originHeight=1658&originWidth=958&originalType=binary&ratio=2&rotation=0&showTitle=false&size=203627&status=done&style=none&taskId=uaf451706-9b1e-4450-8a06-017678ed102&title=&width=360" alt="6-modified.png"><br />数组的连续多个元素会一并加载到 CPU Cache 里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。遍历访问时 CPU 层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。</p><p>在像 Java 这样的托管运行时环境中开发低延迟系统时，垃圾收集机制可能会带来问题。分配的内存越多，给垃圾收集器带来的负担就越大。当对象的寿命很短或实际上是常驻的时候，垃圾收集器工作得最好。在环形缓冲区中预先分配 entry 意味着它对于垃圾收集器来说是常驻内存的，垃圾回收的负担就很轻。同时，数组结构对处理器的缓存机制更加友好。数组长度 2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心 index 溢出的问题。index 是 long 类型，即使 100 万 QPS 的处理速度，也需要 30 万年才能用完。</p><p>一般的 Cache Line 大小在 64 字节左右，然后 Disruptor 在非常重要的字段前后加了很多额外的无用字段。可以让这一个字段占满一整个缓存行，这样就可以避免未共享导致的误杀。</p><p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。<br><a name="hIbfE"></a></p><h4 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h4><p>下面用非环形的结构模拟无锁读写：</p><ol><li>申请写入m个元素</li><li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素</li><li>若是返回的正确，则生产者开始写入元素</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689239966093-8f5b4adc-c6a0-43b7-8194-be501aa8c466.png#averageHue=%23f7f7f7&clientId=u294810c7-fb47-4&from=paste&height=555&id=ub77b53b5&originHeight=1550&originWidth=1108&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146321&status=done&style=none&taskId=u0824520d-67aa-42c3-897e-9eec115f60d&title=&width=397" alt="7-modified.png"><br><a name="CqVJN"></a></p><h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor 的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过 CAS 很容易达到。只需要在分配元素的时候，通过 CAS 判断一下这段空间是否已经分配出去即可。</p><p>但如何防止读取的时候，读到还未写的元素。Disruptor 在多个生产者的情况下，引入了一个与 Ring Buffer 大小相同的 buffer，Available Buffer。当某个位置写入成功的时候，便把 Availble Buffer 相应的位置置位，标记为写入成功。读取的时候，会遍历 Available Buffer，来判断元素是否已经就绪。<br><a name="XHwEt"></a></p><h5 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h5><p>生产者多线程写入的情况会复杂很多：</p><p>申请读取到序号n；<br />若 writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从 reader cursor 开始读取 available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；<br />消费者读取元素。<br />如下图所示，读线程读到下标为 2 的元素，三个线程 Writer1/Writer2/Writer3 正在向 RingBuffer 相应位置写数据，写线程被分配到的最大元素下标是 11。</p><p>读线程申请读取到下标从3到11的元素，判断 writer cursor&gt;=11。然后开始读取 availableBuffer，从 3 开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p><p>然后，消费者读取下标从 3 到 6 共计 4 个元素（多个生产者情况下，消费者消费过程示意图）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240468257-7e87656e-2609-4e11-892c-80c9499fcbfb.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=439&id=u20b89bf1&originHeight=1278&originWidth=1538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=186527&status=done&style=none&taskId=u6c6dc0d3-e25c-4be8-b703-9df811896ab&title=&width=528" alt="8-modified.png"></p><p><a name="H7wxf"></a></p><h5 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h5><p>多个生产者写入的时候：</p><ol><li>申请写入 m 个元素；</li><li>若是有 m 个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li><li>生产者写入元素，写入元素的同时设置 available Buffer 里面相应的位置，以标记自己哪些位置是已经写入成功的。</li></ol><p>如下图所示，Writer1 和 Writer2 两个线程写入数组，都申请可写的数组空间。Writer1 被分配了下标 3 到下表 5 的空间，Writer2 被分配了下标 6 到下标 9 的空间。<br />Writer1 写入下标 3 位置的元素，同时把 available Buffer 相应位置置位，标记已经写入成功，往后移一位，开始写下标 4 位置的元素。Writer2 同样的方式。最终都写入完成。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689240479384-12ad2519-4832-4a2f-b322-be738d75bd89.png#averageHue=%23f8f8f8&clientId=u294810c7-fb47-4&from=paste&height=454&id=ue940e65d&originHeight=1216&originWidth=1544&originalType=binary&ratio=2&rotation=0&showTitle=false&size=170725&status=done&style=none&taskId=uf080f650-c299-46f0-ab23-8b0a327bde7&title=&width=576" alt="9-modified.png"></p><p><a name="zLdit"></a></p><h3 id="解决伪共享的问题"><a href="#解决伪共享的问题" class="headerlink" title="解决伪共享的问题"></a>解决伪共享的问题</h3><p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可即缓存行填充（Padding），使一个对象占用的内存大小刚好为64bytes或它的整数倍，这样就保证了一个缓存行里不会有多个对象，这其实是一种以空间换时间的方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689237986676-153e1cdb-479e-47d0-9dba-e8146605e61a.png#averageHue=%232c2c2b&clientId=u294810c7-fb47-4&from=paste&height=433&id=ud05fae06&originHeight=866&originWidth=1384&originalType=binary&ratio=2&rotation=0&showTitle=false&size=90326&status=done&style=none&taskId=u010ab547-b40b-4b4e-a891-4c20e58822c&title=&width=692" alt="image.png"></p><p>而Sequence选择继承PhsPadding：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689238216429-1e66812a-2ce7-40f6-9ff1-9c858e9cec60.png#averageHue=%232c2b2b&clientId=u294810c7-fb47-4&from=paste&height=639&id=u129d6da7&originHeight=1278&originWidth=1688&originalType=binary&ratio=2&rotation=0&showTitle=false&size=180493&status=done&style=none&taskId=uc4925b8e-d6e1-4cf4-9dc3-ebbf22379c1&title=&width=844" alt="image.png"></p><p>Sequence实际value变量的左右均被填充了7个long型变量，其自身也是long型变量，一个long型变量占据8个字节，所以序号与他上一个/下一个序号之间的最小内存距离为：158=120byte，加上对象头的8个字节，可以确保sequence大小128byte=264byte（有的CPU缓存行是128byte）<br />这样直接的代价就是增大的15倍的内存消耗空间，这样的设计导致不可能有两个cursor出现在同一个cpu cache line中, 就解决了”伪共享”问题。</p><p><a name="b5l5B"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后，官网也提供了很多测试用例：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241111749-4f61900f-733d-42ca-9517-7d8816ab5e9b.png#averageHue=%23745e3e&clientId=u294810c7-fb47-4&from=paste&height=631&id=u2b078ad4&originHeight=1262&originWidth=2372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=354512&status=done&style=none&taskId=uc7f47b10-d568-47a6-a524-bfaaf2ab59b&title=&width=1186" alt="image.png"><br><a name="h9Ao1"></a></p><h2 id="延迟性能测试"><a href="#延迟性能测试" class="headerlink" title="延迟性能测试"></a>延迟性能测试</h2><blockquote><p>To measure latency we take the three stage pipeline and generate events at less than saturation. This is achieved by waiting 1 microsecond after injecting an event before injecting the next and repeating 50 million times. To time at this level of precision it is necessary to use time stamp counters from the CPU. We chose CPUs with an invariant TSC because older processors suffer from changing frequency due to power saving and sleep states. Intel Nehalem and later processors use an invariant TSC which can be accessed by the latest Oracle JVMs running on Ubuntu 11.04. No CPU binding has been employed for this test. For comparison we use the ArrayBlockingQueue once again. We could have used ConcurrentLinkedQueueviii which is likely to give better results but we want to use a bounded queue implementation to ensure producers do not outpace consumers by creating back pressure. The results below are for 2.2Ghz Core i7-2720QM running Java 1.6.0_25 64-bit on Ubuntu 11.04. Mean latency per hop for the Disruptor comes out at 52 nanoseconds compared to 32,757 nanoseconds for ArrayBlockingQueue. Profiling shows the use of locks and signalling via a condition variable are the main cause of latency for the ArrayBlockingQueue.</p></blockquote><p>为了测量延迟，我们采用三级管道并在低于饱和度的情况下生成事件。这是通过在注入一个事件之后等待 1 微秒，然后再注入下一个事件并重复 5000 万次来实现的。为了达到这种精度水平，必须使用 CPU 的时间戳计数器。我们选择具有不变 TSC 的 CPU，因为较旧的处理器会因省电和睡眠状态而发生频率变化。Intel Nehalem 及更高版本的处理器使用不变的 TSC，可由 Ubuntu 11.04 上运行的最新 Oracle JVM 访问。此测试未使用 CPU 绑定。为了进行比较，我们再次使用 ArrayBlockingQueue。我们本可以使用 ConcurrentLinkedQueueviii，它可能会提供更好的结果，但我们希望使用有界队列实现来确保生产者不会因产生背压而超过消费者。以下结果适用于在 Ubuntu 11.04 上运行 Java 1.6.0_25 64 位的 2.2Ghz Core i7-2720QM。Disruptor 的每跳平均延迟为 52 纳秒，而 ArrayBlockingQueue 的平均每跳延迟为 32,757 纳秒。分析显示，使用锁和通过条件变量发送信号是 ArrayBlockingQueue 延迟的主要原因。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689241005080-b62ef96a-8687-4c10-95b5-5cd418cf4500.png#averageHue=%23fafaf9&clientId=u294810c7-fb47-4&from=paste&height=315&id=ub74af72d&originHeight=630&originWidth=2000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=112876&status=done&style=none&taskId=u6f04c628-8884-4568-b617-d8c2d0d0ecc&title=&width=1000" alt="image.png"><br><a name="oXwBS"></a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Disruptor是一个高性能、低延迟的并发框架，源自LMAX公司，主要用于实现开发者在多线程程序中无锁队列的操作。ArrayBlockingQueue则是一个基于数组实现的有界阻塞队列，是Java标准库中的一个组件。两者各有优点和局限性，具体如下：</p><p>根据上面的分析，可以得出一个结论，Disruptor的性能远高于ArrayBlockingQueue。Disruptor采用一种基于环形数组的数据结构（RingBuffer），通过适当的同步策略和无锁优化技术，实现了非常高的并发性能。因此，在高并发、低延迟场景下，Disruptor的吞吐量和延迟表现显著优于ArrayBlockingQueue。相比之下，ArrayBlockingQueue基于传统的锁和条件变量机制，性能较低、延迟能力有限。<br />但是，相对而言，想要更高的性能吗，就不得不放弃易用。，Disruptor编写相对复杂，可读性较差。由于Disruptor采用了更为底层的原理并使用了许多高级优化技术，例如缓存行填充，预分配对象，内存屏障等，使得其代码实现较为复杂，不易上手。而ArrayBlockingQueue实现相对简单，开发者能更容易理解和使用其原理。<br />最后，Disruptor对依赖环境要求较高。Disruptor的优化策略需要在特定的运行环境下生效，例如，其环形数组的大小需要设置为2的次幂，以充分利用硬件缓存。此外，Disruptor优化适用于JAVA SE环境，在ANDROID等其他环境尚未被广泛验证。而ArrayBlockingQueue作为JDK内置组件，在不同平台环境下的兼容性和稳定性更优。<br />所以，可以得出一个结论，Disruptor与ArrayBlockingQueue在性能、易用性和兼容性方面存在差异。若应用场景追求极致的并发性能、低延迟并能承担较高的开发成本，应选择Disruptor。但若应用场景对性能要求较低，需要简单、易用且兼容性强的阻塞队列，ArrayBlockingQueue则是更好的选择。总之，开发者需要根据实际需求权衡两者的优势和劣势。<br />写到这里，我想起了计算机界的经典名言：*<em>没有银弹  *</em>。意思是没有什么东西是最好最有效而又没有任何缺点的。<br />在软件工程中也是一样，没有最好的技术，只有最合适的技术。面对不同的场景，应该使用更加适合这个场景的技术，这样才能使得效率提高。我想，如何将手中的知识掌握好，然后在合适的环境中发挥它的效果，不仅仅是技术中的艺术，也是软件的工程。</p><p><a name="p6ZMt"></a></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><blockquote><p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html#_getting_started</a></p></blockquote><p>结合用例写一个demo<br />事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"LongEvent&#123;"</span> + <span class="string">"value="</span> + value + <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.ringBuffer 事件队列 下一个槽</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        Long data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.取出空的事件队列</span></span><br><span class="line">            LongEvent longEvent = ringBuffer.get(sequence);</span><br><span class="line">            data = byteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//3.获取事件队列传递的数据</span></span><br><span class="line">            longEvent.setValue(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者准备发送数据："</span>);</span><br><span class="line">            <span class="comment">//4.发布事件</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LongEventMain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F; 2.创建工厂</span><br><span class="line">        EventFactory&lt;LongEvent&gt; eventFactory &#x3D; new LongEventFactory();</span><br><span class="line">        &#x2F;&#x2F; 3.创建ringBuffer 大小</span><br><span class="line">        int ringBufferSize &#x3D; 1024 * 1024; &#x2F;&#x2F; ringBufferSize大小一定要是2的N次方</span><br><span class="line">        &#x2F;&#x2F; 4.创建Disruptor</span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor &#x3D; new Disruptor&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,</span><br><span class="line">                ProducerType.SINGLE, new YieldingWaitStrategy());</span><br><span class="line">        &#x2F;&#x2F; 5.连接消费端方法</span><br><span class="line">        disruptor.handleEventsWith(new LongEventHandler());</span><br><span class="line">        &#x2F;&#x2F; 6.启动</span><br><span class="line">        disruptor.start();</span><br><span class="line">        &#x2F;&#x2F; 7.创建RingBuffer容器</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line">        &#x2F;&#x2F; 8.创建生产者</span><br><span class="line">        LongEventProducer producer &#x3D; new LongEventProducer(ringBuffer);</span><br><span class="line">        &#x2F;&#x2F; 9.指定缓冲区大小</span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(8);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;</span><br><span class="line">            byteBuffer.putLong(0, i);</span><br><span class="line">            producer.onData(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;10.关闭disruptor和executor</span><br><span class="line">        disruptor.shutdown();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1689236784814-f6573ce5-7ae5-4dbb-8ab5-23494429c7db.png#averageHue=%23313131&clientId=u294810c7-fb47-4&from=paste&height=219&id=uc5f85ba0&originHeight=438&originWidth=1228&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67544&status=done&style=none&taskId=u9e26cf5a-6617-4ad3-ac64-93a6fc72847&title=&width=614" alt="image.png"><br /></p><p><a name="Ohdad"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_memory_barriers" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/disruptor.html</a><br><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a><br><a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/</a><br><a href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a><br><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/18/disruptor.html</a><br><a href="https://zhuanlan.zhihu.com/p/229338771" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/229338771</a><br><a href="https://zhuanlan.zhihu.com/p/513468454" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/513468454</a><br><a href="https://qin.news/disruptor/" target="_blank" rel="noopener">https://qin.news/disruptor/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;oYoyt&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Disruptor 是一种高性能的、并发编程框架，最初是为了解决 LMAX 金融交易</summary>
      
    
    
    
    
    <category term="队列" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="Disruptor" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>实现Spring框架中的IOC和AOP</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2023/01/05/%E5%AE%9E%E7%8E%B0Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84IOC%E5%92%8CAOP/</id>
    <published>2023-01-05T05:59:20.000Z</published>
    <updated>2023-03-26T16:39:37.398Z</updated>
    
    <content type="html"><![CDATA[<p><a name="Bk5lF"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a><br /></h1><p><a name="vHThd"></a></p><h1 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h1><p><a name="GCsad"></a></p><h2 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h2><p>我们知道Java 是一门面向对象的语言，在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586204787-8e47e2aa-7ad0-4df8-8c02-ab5b48ccf51b.png#averageHue=%23fcfcfc&clientId=u426a4097-24c8-4&from=paste&height=271&id=u2625783a&name=image.png&originHeight=406&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62561&status=done&style=none&taskId=u59dd5fa3-6a83-4d1d-a27d-f26295c1a96&title=&width=388" alt="image.png"></p><p>这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679586265815-d527e12e-f00d-495f-ae51-7e3e8d3cdf8e.png#averageHue=%23fdfdfd&clientId=u426a4097-24c8-4&from=paste&height=265&id=ud4222345&name=image.png&originHeight=398&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48632&status=done&style=none&taskId=u1d036425-b7d4-4fd4-94b3-985ef332386&title=&width=400.6666666666667" alt="image.png"></p><p>这个时候我们发现，我们类之间的关系都由 IoC 框架负责维护类，同时将类注入到需要的类中。也就是类的使用者只负责使用，而不负责维护。把专业的事情交给专业的框架来完成。大大的减少开发的复杂度。<br><a name="KMNbL"></a></p><h2 id="IOC的实现步骤"><a href="#IOC的实现步骤" class="headerlink" title="IOC的实现步骤"></a>IOC的实现步骤</h2><ol><li>初始化 IoC 容器。</li><li>读取配置文件。</li><li>将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition</li><li>利用数据结构依次实例化相应的对象</li><li>注入对象之间的依赖关系</li></ol><p><a name="iZZUZ"></a></p><h2 id="bean-定义了框架的数据结构"><a href="#bean-定义了框架的数据结构" class="headerlink" title="bean 定义了框架的数据结构"></a>bean 定义了框架的数据结构</h2><p>定义了bean的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] interfaceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;PropertyArg&gt; propertyArgs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了对象的 name，class的名称。如果是接口的实现，还有该对象实现的接口。以及构造函数的传参的列表 constructorArgs 和需要注入的参数列表 propertyArgs</p><p><a name="rgpUm"></a></p><h2 id="Utils工具包"><a href="#Utils工具包" class="headerlink" title="Utils工具包"></a>Utils工具包</h2><p><a name="pETF3"></a></p><h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefultClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefultClassLoader().loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ClassUtils，提供了两个静态方法：</p><ol><li>getDefultClassLoader() 方法返回当前线程的上下文类加载器（Context Class Loader）；</li><li>loadClass(String className) 方法用于根据类名加载对应的 Class 对象，首先调用 getDefultClassLoader() 方法获取默认的类加载器，然后使用该类加载器加载指定的类。如果指定的类名不存在，该方法将会打印异常栈信息，并返回 null。</li></ol><p>这个工具类可以方便地加载任何类，尤其在使用反射技术时非常有用，因为你可以通过类名动态地获取 Class 对象。同时，由于使用了线程的上下文类加载器，也可以避免一些类加载器隔离的问题。<br><a name="Hd0uf"></a></p><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instanceByCglib</span><span class="params">(Class&lt;T&gt; clz,Constructor ctr,Object[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clz);</span><br><span class="line">        enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ctr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create(ctr.getParameterTypes(),args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 BeanUtils，提供了一个静态方法 instanceByCglib，用于创建对象。具体而言：</p><ol><li>Class<T> 参数表示要创建的对象的类；</li><li>Constructor 参数表示要使用的构造方法，可以为 null；</li><li>Object[] 参数表示构造方法的参数数组，如果 Constructor 参数为 null，则此参数也应为 null。</li></ol><p>该方法使用 CGLIB 库创建对象。首先创建一个 Enhancer 对象，并设置其父类为 clz，然后设置回调为 NoOp.INSTANCE，这意味着创建的对象不会被代理。如果 ctr 为 null，则直接通过 enhancer.create() 创建对象，否则通过 enhancer.create(ctr.getParameterTypes(), args) 使用指定的构造方法创建对象。</p><p>CGLIB 是一个基于 ASM 库的代码生成库，可以用于创建动态代理、增强类等。在本代码中，CGLIB 用于创建对象并调用构造方法。这种方式相对于使用 new 运算符创建对象，具有更高的灵活性和动态性。</p><p><a name="Ts732"></a></p><h4 id="用法举例：AOP"><a href="#用法举例：AOP" class="headerlink" title="用法举例：AOP"></a>用法举例：AOP</h4><p>这个也是aop的用法<br />在cglib包下，Enhancer这个类的作用是为指定的类创建代理类。具体来说，Enhancer类可以动态地生成一个指定类的子类，该子类可以用来拦截指定类中的方法调用，从而实现代理模式。<br />Enhancer类的使用方法类似于Java动态代理中的Proxy类。首先，需要创建一个Enhancer对象，并设置要代理的目标类和回调方法。然后，通过调用Enhancer对象的create方法，生成代理类的实例。这个代理类会继承目标类，同时实现回调方法，从而实现对目标类方法的拦截和处理。<br />Enhancer类的使用比较灵活，可以代理任意的类，包括没有实现任何接口的类。但是，由于Enhancer是通过生成目标类的子类来实现代理的，所以目标类必须有默认的构造函数，并且不能是final类。<br />假设我们有一个简单的UserService接口，其中定义了一个getUser方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">        <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想为该接口创建一个代理类，记录getUser方法的调用次数。我们可以使用cglib的Enhancer类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceProxy(target));</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getUser"</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个UserServiceProxy类，它实现了MethodInterceptor接口，用于拦截目标对象的方法调用。在构造方法中，我们传入了目标对象target，并使用Enhancer类生成一个UserService的代理对象。在intercept方法中，我们记录了getUser方法的调用次数，并使用MethodProxy类来调用目标对象的对应方法。<br />接下来，我们可以使用该代理类来调用getUser方法，并检查调用次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = UserServiceProxy.createProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">userService.getUser(<span class="number">1</span>);</span><br><span class="line">userService.getUser(<span class="number">2</span>);</span><br><span class="line">System.out.println(userService.getCount()); <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们首先使用createProxy方法创建了UserService的代理对象，并调用了getUser方法两次。最后，我们打印了代理对象的调用次数，发现它的确记录了两次getUser方法的调用。<br /><strong>它为什么要这么做呢，直接new难道不行吗？</strong><br />使用代理模式的一个主要目的是在不改变原有代码的情况下，为现有对象添加额外的行为或功能。在上面的例子中，我们通过使用cglib的Enhancer类创建了一个代理对象，使得我们可以在不修改原有UserServiceImpl类的情况下，为getUser方法添加了记录调用次数的功能。<br />如果直接new一个新的对象，虽然可以实现类似的功能，但是需要对原有代码进行修改，将原有的对象替换成新的对象，这样就不太符合“开闭原则”，即对扩展开放，对修改关闭的设计原则。同时，在某些情况下，我们可能无法直接访问到原有对象的构造函数，这就导致了不能直接创建新对象的限制。<br />使用代理模式，可以通过创建代理对象来扩展原有对象的行为，而不需要修改原有对象的代码。同时，代理对象还可以在原有对象的基础上增加额外的行为，提高代码的可扩展性和可维护性。</p><p><a name="uyyXf"></a></p><h3 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectField</span><span class="params">(Field field,Object obj,Object value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类 ReflectionUtils，提供了一个静态方法 injectField，用于设置某个对象的属性值。具体而言：</p><ol><li>Field 参数表示要设置的属性的字段；</li><li>Object 参数表示要设置属性值的对象；</li><li>Object 参数表示要设置的属性值。</li></ol><p>该方法首先判断 field 是否为空，如果不为空则将其设置为可访问，然后使用 field.set(obj, value) 方法设置对象的属性值。如果属性为 final 修饰的静态变量，则此方法将无法修改其值。</p><p>这个工具类可以方便地在代码中设置对象的属性值，尤其在使用反射技术时非常有用，因为你可以通过反射动态修改对象的属性。但是，使用反射技术也有一些缺点，例如性能较低、容易引起安全问题等，需要谨慎使用。<br><a name="UZCBE"></a></p><h3 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a>JsonUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*JsonUtils 的作用就是为了解析我们的json配置文件。代码比较长，与我们的 IoC 原理关系不大*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is,Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is,cls);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, cls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String json, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(json, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(<span class="keyword">byte</span>[] bytes, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(bytes, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream is, TypeReference valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(is, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">writeValue</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] writeByteValue(Object entity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsBytes(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line">        mapper.getDeserializationConfig().withoutFeatures(<span class="keyword">new</span> DeserializationFeature[]&#123;DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES&#125;);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_YAML_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个工具类，封装了基于Jackson库的Json序列化和反序列化功能。具体作用如下：</p><ul><li>定义了一个ObjectMapper对象，用于将Java对象转化为JSON格式，或将JSON格式转化为Java对象。</li><li>提供了多个readValue()和writeValue()方法，用于不同类型之间的转化。其中，readValue()方法支持将JSON格式的字符串、输入流或字节数组反序列化成Java对象，而writeValue()方法则将Java对象序列化成JSON格式的字符串或字节数组。</li><li>设置了一些序列化和反序列化的配置，如格式化输出、忽略空值、支持单引号、允许注释等。</li><li>如果反序列化失败，则返回null</li></ul><p><a name="fz6Ke"></a></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>先定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有对应的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryImpl</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefineMap= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//查找对象是否已经实例化过</span></span><br><span class="line">        Object bean = beanMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环依赖问题</span></span><br><span class="line">        Object earlyBean = earlySingletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span> (earlyBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生了循环依赖，提前返回尚未加载完成的bean:"</span> + name);</span><br><span class="line">            <span class="keyword">return</span> earlyBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有实例化，那就需要调用createBean来创建对象</span></span><br><span class="line">        BeanDefinition beanDefinition = beanDefineMap.get(name);</span><br><span class="line">        bean = createBean(beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为了解决循环依赖，先添加到早期单例中</span></span><br><span class="line">            earlySingletonObjects.put(name, bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对象创建成功以后，注入对象需要的参数</span></span><br><span class="line">            populateBean(bean,beanDefinition);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再吧对象存入Map中方便下次使用。</span></span><br><span class="line">            beanMap.put(name,bean);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从早期单例Map中移除</span></span><br><span class="line">            earlySingletonObjects.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束返回</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, BeanDefinition bd)</span></span>&#123;</span><br><span class="line">        beanDefineMap.put(name,bd);</span><br><span class="line">        beanNameSet.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String beanName = beanDefinition.getClassName();</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        Class&lt;?&gt; clz = ClassUtils.loadClass(beanName);</span><br><span class="line">        <span class="keyword">if</span>(clz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"can not find bean by beanName"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取构造器参数</span></span><br><span class="line">        List&lt;ConstructorArg&gt; constructorArgs = beanDefinition.getConstructorArgs();</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty())&#123;</span><br><span class="line">            List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConstructorArg constructorArg : constructorArgs) &#123;</span><br><span class="line">                <span class="comment">//放入Map</span></span><br><span class="line">                objects.add(getBean(constructorArg.getRef()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,clz.getConstructor(),objects.toArray());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instanceByCglib(clz,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(Object bean, BeanDefinition bd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;PropertyArg&gt; propertyArgs = bd.getPropertyArgs();</span><br><span class="line">        <span class="keyword">if</span> (propertyArgs != <span class="keyword">null</span> &amp;&amp; !propertyArgs.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历在json中配置的属性</span></span><br><span class="line">            <span class="keyword">for</span> (PropertyArg arg : propertyArgs) &#123;</span><br><span class="line">                String propertyName = arg.getName();</span><br><span class="line">                String value = arg.getValue();</span><br><span class="line">                String ref = arg.getRef();</span><br><span class="line">                Object injectValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接赋值</span></span><br><span class="line">                    injectValue = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(ref)) &#123;</span><br><span class="line">                    <span class="comment">//获取bean</span></span><br><span class="line">                    injectValue = getBean(ref);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">                method.invoke(bean, injectValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取具体某个属性的setter方法</span></span><br><span class="line"><span class="comment">     * 此处做法比较简单粗暴</span></span><br><span class="line"><span class="comment">     * 实际上Spring在读取配置文件时就已经将各属性，方法，getter/setter都读取好了。</span></span><br><span class="line"><span class="comment">     * 在这就只需要调用BeanWrapper的方法来为属性赋值就可以了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getPropertySetter</span><span class="params">(BeanDefinition bd, String propertyName, Object injectValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = Class.forName(bd.getClassName());</span><br><span class="line">        Class&lt;?&gt; injectClazz = injectValue.getClass();</span><br><span class="line">        Class&lt;?&gt; supClass = injectValue.getClass().getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (supClass != <span class="keyword">null</span> &amp;&amp; supClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            injectClazz = supClass;</span><br><span class="line">        &#125;</span><br><span class="line">        propertyName = propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">        Method setter = beanClass.getMethod(<span class="string">"set"</span> + propertyName, injectClazz);</span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了一个简单的Bean工厂，主要功能是通过Bean的名字获取Bean的实例，实现了Bean的创建、注入属性和循环依赖的处理。</p><p>其中，BeanFactoryImpl类实现了BeanFactory接口，定义了三个ConcurrentHashMap类型的变量，分别用来存储Bean实例、Bean定义和Bean名称集合。它还包含了一个earlySingletonObjects成员变量，用来处理循环依赖的问题。</p><p><a name="TT8Dj"></a></p><h3 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h3><p>getBean 方法是 Spring 框架中的一个核心方法，用于从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例。该方法接收一个参数 name，表示需要获取的 Bean 的名称。该方法会根据给定的名称先在 BeanFactory 中查找是否已经有该名称对应的 Bean 实例，如果没有找到，则尝试创建一个新的实例并将其注册到 BeanFactory 中。<br />在实现类 BeanFactoryImpl 中，该方法会先从 beanMap 中查找是否已经有该名称对应的 Bean 实例，如果找到了则直接返回该实例。如果没有找到，则需要通过 createBean 方法创建一个新的实例。在创建实例之前，该方法会检查 earlySingletonObjects 中是否已经有该名称对应的早期单例对象，如果有则说明存在循环依赖的问题，此时会返回早期单例对象，避免出现死锁的情况。<br />getBean 方法会调用 createBean 方法创建 Bean 实例，然后调用 populateBean 方法为实例注入需要的属性。在注入属性之后，该方法会将创建好的 Bean 实例注册到 beanMap 中，以备下次获取时直接返回。<br />总之，getBean 方法的作用是从 BeanFactory 或 ApplicationContext 中获取一个已经创建好的 Bean 实例，如果找不到则创建一个新的实例，并且可以解决循环依赖的问题。<br><a name="qkBoo"></a></p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>createBean 方法的作用是通过传入的 BeanDefinition 对象，使用反射来实例化一个 Java 对象，并返回该对象的实例。该方法首先通过 BeanDefinition 对象中的类名获取该类的 Class 对象，然后根据该对象获取相应的构造函数，如果有构造函数的参数，则递归调用 getBean 方法获取构造函数的参数，最后使用 CGLIB 库的 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果构造函数没有参数，则直接使用 BeanUtils.instanceByCglib 方法实例化一个 Java 对象并返回。如果获取 Class 对象失败，会抛出异常。<br><a name="kaiGR"></a></p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>populateBean方法的作用是为一个JavaBean对象注入它所依赖的其他对象或属性，这些对象或属性在BeanDefinition中被定义，并且在配置文件中被配置好。populateBean方法会根据BeanDefinition中的属性列表，将对应的属性值设置到JavaBean对象中。属性的值可能是简单类型的值，也可能是其他JavaBean对象的引用。<br />具体而言，populateBean方法会遍历BeanDefinition中的属性列表，对于每一个属性，它会根据属性的名称、值或引用，找到JavaBean对象中对应的setter方法，然后调用该方法将属性值设置到JavaBean对象中。需要注意的是，setter方法的名称是根据属性名生成的，例如，如果属性名是foo，那么setter方法的名称就是setFoo。<br />populateBean方法的实现比较简单粗暴，实际上，Spring框架在读取配置文件时已经将各属性、方法、getter/setter都读取好了，并且使用了更加高效和灵活的方式来为JavaBean对象注入属性值。</p><p>这两行代码的作用是为一个Java Bean对象的属性赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = getPropertySetter(bd, propertyName, injectValue);</span><br><span class="line">method.invoke(bean, injectValue);</span><br></pre></td></tr></table></figure><p>第一行代码使用getPropertySetter方法获取一个指定属性的Setter方法。getPropertySetter方法根据属性名称、注入值类型和Bean定义，动态地获取该属性的Setter方法。这里使用反射机制，构造出要调用的方法，以便在第二行代码中使用。<br />第二行代码使用反射机制调用Java Bean对象的Setter方法，并把该属性的值作为参数传入。这里的bean是要赋值的Java Bean对象，injectValue是要注入的值。<br><a name="E6WQy"></a></p><h3 id="getPropertySetter"><a href="#getPropertySetter" class="headerlink" title="getPropertySetter"></a>getPropertySetter</h3><p>getPropertySetter方法的作用是根据传入的BeanDefinition、属性名和属性值，获取对应的setter方法，并返回该方法。在populateBean方法中，会根据BeanDefinition中配置的属性名、属性值以及对应的setter方法，将属性值设置到对象中，实现对对象属性的注入。getPropertySetter方法通过反射获取类的setter方法，并根据属性值的类型确定setter方法的参数类型，最终返回setter方法，供populateBean方法调用。<br><a name="ptLbT"></a></p><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>这段代码实现了一个简单的 Bean 工厂。主要功能包括：</p><ol><li>实现了 BeanFactory 接口，提供了 getBean() 方法来获取指定名称的 Bean 实例。</li><li>实现了注册 BeanDefinition 的方法 registerBean()，用来将 BeanDefinition 存储到 Map 中。</li><li>使用 ConcurrentHashMap 来存储 Bean 实例对象和 BeanDefinition 对象。</li><li>支持循环依赖。通过使用 ConcurrentHashMap 存储早期的 Bean 实例对象，解决了循环依赖问题。</li><li>支持注入属性。通过在 BeanDefinition 中配置 PropertyArg 属性参数列表，来对 Bean 实例对象进行属性注入。</li><li>支持构造器注入。通过在 BeanDefinition 中配置 ConstructorArg 构造器参数列表，来对 Bean 实例对象进行构造器注入。</li><li>支持通过反射创建 Bean 实例对象，使用 CGLib 动态代理技术生成代理对象。</li></ol><p>总体来说，这段代码实现了一个简单的 IoC 容器，能够解决基本的 Bean 创建、管理和依赖注入的问题。但是这个容器还有一些限制，例如只支持单例模式、只支持 setter 注入、只能通过 BeanDefinition 来配置 Bean 等等。真正的 IoC 容器，例如 Spring，还有更多更复杂的功能和特性。</p><p><a name="zPI4R"></a></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        loadFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = JsonUtils.readValue(is,<span class="keyword">new</span> TypeReference&lt;List&lt;BeanDefinition&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(beanDefinitions != <span class="keyword">null</span> &amp;&amp; !beanDefinitions.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">                registerBean(beanDefinition.getName(), beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为JsonApplicationContext的类，继承了BeanFactoryImpl类。JsonApplicationContext类的作用是通过从Json文件中读取bean定义来初始化IoC容器。它包含了一个构造方法和两个私有方法：init()和loadFile()。<br />构造方法JsonApplicationContext(String fileName)接收Json文件的名称，并将其存储在fileName变量中。<br />方法init()用于初始化IoC容器，它调用了loadFile()方法从Json文件中加载bean定义。<br />方法loadFile()用于加载Json文件并注册bean定义到IoC容器中。它首先通过当前线程的类加载器获取Json文件的输入流，然后通过JsonUtils.readValue()方法将输入流转换成BeanDefinition对象列表。最后，它遍历BeanDefinition列表，并调用registerBean()方法注册bean定义到IoC容器中。<br />总之，这段代码是一个简单的IoC容器实现，它可以从Json文件中读取bean定义，并将其注册到容器中，以供应用程序使用。<br><a name="ADAO4"></a></p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679590784248-a8543b7e-dd3d-46b8-abdd-300c77964292.png#averageHue=%23f5f3f2&clientId=u426a4097-24c8-4&from=paste&height=209&id=u14ed6355&name=image.png&originHeight=313&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27393&status=done&style=none&taskId=u042025fc-fe77-4110-8479-550549e9f78&title=&width=651.3333333333334" alt="image.png"></p><p><a name="P6I4h"></a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br /></h2><p><a name="fFT0I"></a></p><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><br /></h1><p><a name="xvv2L"></a></p><h1 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h1><p><a name="lvOkY"></a></p><h2 id="Aop-是什么"><a href="#Aop-是什么" class="headerlink" title="Aop 是什么"></a>Aop 是什么</h2><p>面向切面的程序设计（aspect-oriented programming，AOP）。通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。</p><p><a name="rbIL5"></a></p><h2 id="为什么需要使用Aop"><a href="#为什么需要使用Aop" class="headerlink" title="为什么需要使用Aop"></a>为什么需要使用Aop</h2><p>面向切面编程，实际上就是通过预编译或者动态代理技术在不修改源代码的情况下给原来的程序统一添加功能的一种技术。我们看几个关键词，第一个是“动态代理技术”，这个就是Spring Aop实现底层技术。第二个“不修改源代码”，这个就是Aop最关键的地方，也就是我们平时所说的非入侵性。。第三个“添加功能”，不改变原有的源代码，为程序添加功能。</p><p>举个例子：如果某天你需要统计若干方法的执行时间，如果不是用Aop技术，你要做的就是为每一个方法开始的时候获取一个开始时间，在方法结束的时候获取结束时间。二者之差就是方法的执行时间。如果对每一个需要统计的方法都做如上的操作，那代码简直就是灾难。如果我们使用Aop技术，在不修改代码的情况下，添加一个统计方法执行时间的切面。代码就变得十分优雅。具体这个切面怎么实现？<br />Spring Aop实现的代码非常非常的绕。也就是说 Spring 为了灵活做了非常深层次的抽象。同时 Spring为了兼容 @AspectJ 的Aop协议，使用了很多 Adapter （适配器）模式又进一步的增加了代码的复杂程度。<br />Spring 的 Aop 实现主要以下几个步骤：</p><ol><li>初始化 Aop 容器。</li><li>读取配置文件。</li><li>将配置文件装换为 Aop 能够识别的数据结构 – Advisor。这里展开讲一讲这个advisor。Advisor对象中包又含了两个重要的数据结构，一个是 Advice，一个是 Pointcut。Advice的作用就是描述一个切面的行为，pointcut描述的是切面的位置。两个数据结的组合就是”在哪里，干什么“。这样 Advisor 就包含了”在哪里干什么“的信息，就能够全面的描述切面了。</li><li>Spring 将这个 Advisor 转换成自己能够识别的数据结构 – AdvicedSupport。Spirng 动态的将这些方法拦截器织入到对应的方法。</li><li>生成动态代理代理。</li><li>提供调用，在使用的时候，调用方调用的就是代理方法。也就是已经织入了增强方法的方法</li></ol><p><a name="acqJR"></a></p><h2 id="Invocation"><a href="#Invocation" class="headerlink" title="Invocation"></a>Invocation</h2><p>先定义好方法调用接口和代理方法调用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] getArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理方法的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyMethodInvocation</span> <span class="keyword">extends</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="AkGkM"></a></p><h3 id="CglibMethodInvocation"><a href="#CglibMethodInvocation" class="headerlink" title="CglibMethodInvocation"></a>CglibMethodInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title">ReflectioveMethodeInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibMethodInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(proxy, target, method, arguments, interceptorList);</span><br><span class="line">        <span class="keyword">this</span>.methodProxy = methodProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是定义了一个基于CGLIB动态代理的方法调用类CglibMethodInvocation，它继承了ReflectiveMethodeInvocation类，其中包含了目标对象、目标方法、方法参数以及一组方法拦截器，它们一起构成了一个完整的方法调用链。CglibMethodInvocation在父类的基础上增加了一个MethodProxy类型的属性methodProxy，并重写了invokeOriginal()方法，该方法使用methodProxy对象调用目标方法，实现了方法的调用。该类主要在AOP中使用，用于执行目标方法，并将方法拦截器应用于目标方法之前或之后的操作。</p><p><a name="G0Nbp"></a></p><h3 id="ReflectioveMethodeInvocation"><a href="#ReflectioveMethodeInvocation" class="headerlink" title="ReflectioveMethodeInvocation"></a>ReflectioveMethodeInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectioveMethodeInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectioveMethodeInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] arguments = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行完所有的拦截器后，执行目标方法</span></span><br><span class="line">        <span class="keyword">if</span>(currentInterceptorIndex == <span class="keyword">this</span>.interceptorList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeOriginal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代的执行拦截器。回顾上面的讲解，我们实现的拦击都会执行 im.proceed() 实际上就在调用这个方法。</span></span><br><span class="line">        AopMethodInterceptor interceptor = interceptorList.get(++currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeOriginal</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invokeMethodUseReflection(target,method,arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基础的反射方法调用的实现类 ReflectiveMethodInvocation，实现了 ProxyMethodInvocation 接口。在 Spring 的 AOP 中，每个被拦截的方法都会被包装成一个 MethodInvocation，这个包装类里包含了目标对象、方法、参数等信息，并提供了一个 proceed 方法用来执行下一个拦截器或目标方法。</p><p>ReflectiveMethodInvocation 中的 proceed 方法主要用于按照拦截器链依次执行 AopMethodInterceptor 的拦截逻辑。如果拦截器都执行完成，最后就会调用 invokeOriginal 方法来执行目标方法。另外，这个类也提供了获取代理对象、获取方法、获取参数等方法。</p><p><a name="osu7V"></a></p><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeMethodAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeforeMethodAdvice advice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeforeMethodAdviceInterceptor</span><span class="params">(BeforeMethodAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        advice.before(mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterRunningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">AopMethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AfterRunningAdvice advice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterRunningAdviceInterceptor</span><span class="params">(AfterRunningAdvice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnVal = mi.proceed();</span><br><span class="line">        advice.after(returnVal,mi.getMethod(),mi.getArguments(),mi);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <strong>mi.proceed()</strong>才是执行原有的方法。而advice我们上文就说过，是描述增强的方法”干什么“的数据结构，所以对于这个before拦截器，我们就把advice对应的增强方法放在了真正执行的方法前面。而对于after拦截器而言，就放在了真正执行的方法后面。<br />这里主要是定义拦截器，一个before，一个after。<br><a name="Kqika"></a></p><h2 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//干什么</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line">    <span class="comment">//在哪里</span></span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AopMethodInterceptor&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptor</span><span class="params">(AopMethodInterceptor interceptor)</span></span>&#123;</span><br><span class="line">        list.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAopMethodInterceptors</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptors)</span></span>&#123;</span><br><span class="line">        list.addAll(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个AdvisedSupport就是我们Aop框架能够理解的数据结构，这个时候问题就变成了<strong>对于哪个目标，增加哪些拦截器</strong>。这里的AopMethodInterceptor 是一个接口，before拦截器和after拦截器都实现了这个接口。都能够使用这个功能。<br><a name="a0X2d"></a></p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p><a name="yJ9IG"></a></p><h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] constructorArgTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; rootClass = advised.getTargetSource().getTagetClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)&#123;</span><br><span class="line">            classLoader = ClassUtils.getDefultClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(rootClass.getSuperclass());</span><br><span class="line">        <span class="comment">//增加拦截器的核心方法</span></span><br><span class="line">        Callback callbacks = getCallBack(advised);</span><br><span class="line">        enhancer.setCallback(callbacks);</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">if</span>(constructorArgs != <span class="keyword">null</span> &amp;&amp; constructorArgs.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> enhancer.create(constructorArgTypes,constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Callback <span class="title">getCallBack</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是实现 Cglib AOP 代理的核心逻辑。其中 CglibAopProxy 类实现了 AopProxy 接口，用于创建代理对象，而 AdvisedSupport 是 AOP 配置信息的载体。<br />具体来说，getProxy() 方法返回代理对象，getProxy(ClassLoader classLoader) 方法返回通过指定类加载器加载的代理对象。在这两个方法中，通过使用 CGLIB 提供的 Enhancer 类，实现代理对象的创建和设置拦截器。<br />在 getCallBack(AdvisedSupport advised) 方法中，通过将 AdvisedSupport 中的拦截器链和目标对象传递给 DynamicAdvisedInterceptor，最终得到一个 Callback 对象，它是 Enhancer 的回调函数。<br />回到 getProxy() 和 getProxy(ClassLoader classLoader) 方法，它们的核心是通过 Enhancer 的 setSuperclass 方法，设置代理对象的父类，然后通过 setCallback 方法，将 Callback 对象设置为拦截器。<br />在这个过程中，如果 constructorArgs 不为空，则使用带参数的 enhancer.create 方法创建代理对象。否则，使用不带参数的 enhancer.create 方法创建代理对象。<br />最后，通过调用 enhancer.create 方法返回代理对象。<br />看看核心方法：<br>:::info<br>//增加拦截器的核心方法<br />Callback callbacks = getCallBack(advised);<br>:::</p><blockquote><p>private Callback getCallBack(AdvisedSupport advised) {<br />    return new DynamicAdvisedInterceptor(advised.getList(),advised.getTargetSource());<br />}</p></blockquote><p><a name="xdGBY"></a></p><h3 id="DynamicAdvisedInterceptor"><a href="#DynamicAdvisedInterceptor" class="headerlink" title="DynamicAdvisedInterceptor"></a>DynamicAdvisedInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;AopMethodInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TargetSource targetSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(List&lt;AopMethodInterceptor&gt; interceptorList, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptorList = interceptorList;</span><br><span class="line">        <span class="keyword">this</span>.targetSource = targetSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了CGLib动态代理中的拦截器，它实现了MethodInterceptor接口。在intercept方法中，它接收了被代理的对象(obj)、目标方法(method)、方法参数(args)以及方法代理(proxy)，然后使用这些参数创建一个CglibMethodInvocation对象，然后调用该对象的proceed()方法，实现拦截器的链式执行。这个拦截器类将所有的AOP拦截器封装成了一个拦截器链，同时传入了目标对象的引用(TargetSource)，以便执行目标方法。在实际调用的时候，这个拦截器会按照拦截器列表依次调用所有的拦截器，并在最后调用目标方法，实现了AOP拦截器的动态织入。</p><p>而其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation = <span class="keyword">new</span> CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法正是：<strong>CglibMethodInvocation</strong></p><p><a name="IBgca"></a></p><h2 id="AopBeanFactoryImpl"><a href="#AopBeanFactoryImpl" class="headerlink" title="AopBeanFactoryImpl"></a>AopBeanFactoryImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopBeanFactoryImpl</span> <span class="keyword">extends</span> <span class="title">BeanFactoryImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AopBeanDefinition&gt; aopBeanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; aopBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object aopBean = aopBeanMap.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aopBeanDefinitionMap.containsKey(name))&#123;</span><br><span class="line">            AopBeanDefinition aopBeanDefinition = aopBeanDefinitionMap.get(name);</span><br><span class="line">            AdvisedSupport advisedSupport = getAdvisedSupport(aopBeanDefinition);</span><br><span class="line">            aopBean = <span class="keyword">new</span> CglibAopProxy(advisedSupport).getProxy();</span><br><span class="line">            aopBeanMap.put(name,aopBean);</span><br><span class="line">            <span class="keyword">return</span> aopBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, AopBeanDefinition aopBeanDefinition)</span></span>&#123;</span><br><span class="line">        aopBeanDefinitionMap.put(name,aopBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AdvisedSupport <span class="title">getAdvisedSupport</span><span class="params">(AopBeanDefinition aopBeanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">        List&lt;String&gt; interceptorNames = aopBeanDefinition.getInterceptorNames();</span><br><span class="line">        <span class="keyword">if</span>(interceptorNames != <span class="keyword">null</span> &amp;&amp; !interceptorNames.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (String interceptorName : interceptorNames) &#123;</span><br><span class="line"></span><br><span class="line">                Advice advice = (Advice) getBean(interceptorName);</span><br><span class="line"></span><br><span class="line">                Advisor advisor = <span class="keyword">new</span> Advisor();</span><br><span class="line">                advisor.setAdvice(advice);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> BeforeMethodAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = BeforeMethodAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(advice <span class="keyword">instanceof</span> AfterRunningAdvice)&#123;</span><br><span class="line">                    AopMethodInterceptor interceptor = AfterRunningAdviceAdapter.getInstants().getInterceptor(advisor);</span><br><span class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">new</span> TargetSource();</span><br><span class="line"></span><br><span class="line">        Object object = getBean(aopBeanDefinition.getTarget());</span><br><span class="line"></span><br><span class="line">        targetSource.setTagetClass(object.getClass());</span><br><span class="line">        targetSource.setTagetObject(object);</span><br><span class="line"></span><br><span class="line">        advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisedSupport;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个AOP Bean Factory，它是一个扩展了普通Bean Factory的类，用于创建和管理AOP bean。该类继承了BeanFactoryImpl，并重写了getBean方法，用于检查所请求的Bean是否已经是AOP bean，如果是则返回AOP bean。如果不是AOP bean，则继续通过调用父类的getBean方法获取普通bean。AopBeanFactoryImpl还有registerBean方法，用于将定义的AOP bean注册到AOP Bean Factory的aopBeanDefinitionMap中。</p><p>在getAdvisedSupport方法中，它会创建一个AdvisedSupport对象，将目标对象和增强器（Advice）封装到Advisor对象中，并根据Advice类型将它们转化为对应的AopMethodInterceptor对象，然后将所有的AopMethodInterceptor对象添加到AdvisedSupport对象中。最后将目标对象封装到TargetSource对象中，并设置到AdvisedSupport对象中。然后返回AdvisedSupport对象。</p><p>当getBean方法检测到所请求的Bean是AOP bean时，它会从aopBeanDefinitionMap中获取Bean的定义，并创建相应的AdvisedSupport对象。然后创建一个CglibAopProxy对象，并使用该对象创建代理对象，最后将代理对象添加到aopBeanMap中。最终返回代理对象。</p><p><a name="BIrI3"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a name="mlhhh"></a></p><h3 id="TestClass"><a href="#TestClass" class="headerlink" title="TestClass"></a>TestClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"开始计时"</span>);</span><br><span class="line">        ThreadLocalUtils.set(startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTimeBeforeMethod</span> <span class="keyword">implements</span> <span class="title">BeforeMethodAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印随机数值: "</span>+ UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndTimeAfterMethod</span> <span class="keyword">implements</span> <span class="title">AfterRunningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">after</span><span class="params">(Object returnVal, Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> startTime = ThreadLocalUtils.get();</span><br><span class="line">        ThreadLocalUtils.remove();</span><br><span class="line">        System.out.println(<span class="string">"方法耗时："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a test method"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JGPr2"></a></p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"beforeMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"StartTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"processMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"ProcessTimeBeforeMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"afterMethod"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"EndTimeAfterMethod"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"TestService"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"testServiceProxy"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"core.ProxyFactoryBean"</span>,</span><br><span class="line">    <span class="attr">"target"</span>:<span class="string">"testService"</span>,</span><br><span class="line">    <span class="attr">"interceptorNames"</span>:[</span><br><span class="line">      <span class="string">"beforeMethod"</span>,</span><br><span class="line">      <span class="string">"processMethod"</span>,</span><br><span class="line">      <span class="string">"afterMethod"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a name="Z3M5m"></a></p><h3 id="MainTest"><a href="#MainTest" class="headerlink" title="MainTest"></a>MainTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AopApplictionContext aopApplictionContext = <span class="keyword">new</span> AopApplictionContext(<span class="string">"application.json"</span>);</span><br><span class="line">        aopApplictionContext.init();</span><br><span class="line">        TestService testService = (TestService) aopApplictionContext.getBean(<span class="string">"testServiceProxy"</span>);</span><br><span class="line">        testService.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="hemjx"></a></p><h3 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1679659265097-017a1abd-1cbb-4840-9849-5c67b070dbed.png#averageHue=%23f7f6f5&clientId=u4abc7da4-0982-4&from=paste&height=171&id=u5b9f1a31&name=image.png&originHeight=256&originWidth=1143&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18875&status=done&style=none&taskId=ue6550e3c-a161-4300-b134-338c0010524&title=&width=762" alt="image.png"></p><p><a name="FXW4m"></a></p><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><a name="SO1vU"></a></p><h2 id="Jdk动态代理和Cglib动态代理什么关系"><a href="#Jdk动态代理和Cglib动态代理什么关系" class="headerlink" title="Jdk动态代理和Cglib动态代理什么关系"></a>Jdk动态代理和Cglib动态代理什么关系</h2><p>JDK动态代理和Cglib动态代理是两种常用的Java动态代理方式，它们都是用于在运行时动态地创建代理对象，实现对目标对象的增强功能。<br />JDK动态代理是通过Java反射机制来实现的，它只能为接口创建代理对象，而无法为类创建代理对象。JDK动态代理通过实现目标对象所实现的接口，在运行时生成一个代理类，代理类中包含了目标对象的引用以及拦截器对象的引用，从而可以在调用代理对象的方法时，将方法调用转发给拦截器对象进行处理。<br />Cglib动态代理则是通过生成目标对象的子类来实现的，它可以为类创建代理对象。Cglib动态代理在运行时通过生成目标对象的子类，重写目标对象的方法，并将目标对象的引用注入到代理对象中。当调用代理对象的方法时，代理对象会先调用目标对象的方法，然后再调用拦截器对象的方法进行增强处理。<br />虽然JDK动态代理和Cglib动态代理实现方式不同，但它们都可以实现对目标对象的增强功能，常用于实现AOP（面向切面编程）功能。在实际开发中，根据需要选择不同的动态代理方式，如果目标对象实现了接口，则可以使用JDK动态代理；如果目标对象没有实现接口，则可以使用Cglib动态代理。</p><p><a name="qRBPD"></a></p><h3 id="那是不是Cglib效率更高？为什么还需要JDK动态代理-？"><a href="#那是不是Cglib效率更高？为什么还需要JDK动态代理-？" class="headerlink" title="那是不是Cglib效率更高？为什么还需要JDK动态代理 ？"></a>那是不是Cglib效率更高？为什么还需要JDK动态代理 ？</h3><p>一般情况下，使用CGLIB生成代理类的效率确实比使用JDK动态代理更高，因为CGLIB是通过在编译时生成字节码来实现代理的，相对于JDK动态代理而言，不需要在运行时动态生成代理类。因此，在需要频繁生成代理类的场景下，使用CGLIB可能更适合。</p><p>然而，需要注意的是，CGLIB生成的代理类通常比原始类的大小要大，且CGLIB代理使用了更多的内存，这在创建大量代理对象的场景下可能会成为性能瓶颈。此外，由于CGLIB使用了底层字节码操作库，因此在某些环境下可能存在兼容性问题，需要额外考虑。</p><p>因此，在选择代理方式时，需要考虑实际场景和需求，并根据具体情况选择合适的代理方式。如果需要生成大量代理对象，并且不考虑内存占用问题，CGLIB可能更适合；如果需要更轻量级的代理方式，或者需要支持多态性、继承等特性，则JDK动态代理可能更合适。</p><p><a name="iHnyN"></a></p><h2 id="AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别"><a href="#AOP-举一个例子去说明在实现AOP功能上JDK和Cglib的区别" class="headerlink" title="(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别"></a>(AOP)举一个例子去说明在实现AOP功能上JDK和Cglib的区别</h2><p>假设我们有一个接口UserService和一个实现类UserServiceImpl，其中UserService提供了一个getUserById()方法用于获取用户信息。我们需要对getUserById()方法进行日志记录，以便监控用户信息查询情况。<br><a name="VA788"></a></p><h3 id="使用JDK动态代理实现AOP功能："><a href="#使用JDK动态代理实现AOP功能：" class="headerlink" title="使用JDK动态代理实现AOP功能："></a>使用JDK动态代理实现AOP功能：</h3><p>我们可以使用JDK动态代理来创建UserService接口的代理对象，并将一个实现了InvocationHandler接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的invoke()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(userService, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(UserService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class[]&#123;UserService.class&#125;, proxy);</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="uzJJw"></a></p><h3 id="使用Cglib动态代理实现AOP功能："><a href="#使用Cglib动态代理实现AOP功能：" class="headerlink" title="使用Cglib动态代理实现AOP功能："></a>使用Cglib动态代理实现AOP功能：</h3><p>我们可以使用Cglib动态代理来创建UserServiceImpl类的代理对象，并将一个实现了MethodInterceptor接口的拦截器对象注入到代理对象中。当调用代理对象的getUserById()方法时，代理对象会自动调用拦截器对象的intercept()方法，在该方法中实现日志记录功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// retrieve user information by userId</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getUserById() method is called with userId: "</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> UserServiceInterceptor());</span><br><span class="line"></span><br><span class="line">        UserServiceImpl userServiceProxy = (UserServiceImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">        User user = userServiceProxy.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述示例代码可以看出，使用JDK动态代理时，需要创建一个实现了InvocationHandler接口的拦截器对象，并将其注入到代理对象中；而使用Cglib动态代理时，需要创建一个实现了MethodInterceptor接口的拦截器对象，并将其注入到代理对象中。在JDK动态代理中，代理对象必须实现目标对象所实现的接口；而在Cglib动态代理中，代理对象</p><p><a name="lHuvV"></a></p><h2 id="IOC-使用反射、JDK、Cglib去实现依赖注入的区别"><a href="#IOC-使用反射、JDK、Cglib去实现依赖注入的区别" class="headerlink" title="(IOC)使用反射、JDK、Cglib去实现依赖注入的区别"></a>(IOC)使用反射、JDK、Cglib去实现依赖注入的区别</h2><p><a name="MOXbp"></a></p><h3 id="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用Cglib和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用Cglib和反射来完成依赖注入有什么区别？"></a>只使用反射与使用Cglib和反射来完成依赖注入有什么区别？</h3><p>在Spring中，依赖注入可以通过只使用反射或使用Cglib和反射来完成。下面是它们之间的一些区别：</p><ol><li>实现方式：只使用反射时，Spring通过反射机制来动态创建对象并设置属性值。而使用Cglib和反射时，Spring通过Cglib在运行时动态创建代理类，并在代理类中使用反射来设置属性值。</li><li>性能：只使用反射时，每次获取Bean时都需要通过反射机制来动态创建对象和设置属性值，因此在性能上可能存在一定的开销。而使用Cglib和反射时，Spring可以在第一次获取Bean时创建代理类，并缓存代理类实例，之后每次获取Bean时都可以直接使用代理类，从而提高了性能。</li><li>功能扩展：只使用反射时，Spring的功能扩展比较有限，因为只能使用Java反射机制来动态创建对象和设置属性值。而使用Cglib和反射时，Spring可以通过Cglib来实现更多的功能扩展，比如实现AOP切面等。</li></ol><p>总的来说，只使用反射相对于使用Cglib和反射来完成依赖注入，性能可能会稍差一些，但是在一些场景下可能会更加灵活，因为不需要引入Cglib这样的第三方库。而使用Cglib和反射来完成依赖注入则能够更好地支持一些功能扩展，比如实现AOP切面等。</p><p>举一个简单的例子，假设有一个名为UserService的服务类，它依赖于名为UserDao的DAO类。下面是使用只使用反射和使用Cglib和反射来实现依赖注入的代码示例：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring会通过反射来动态创建UserService和UserDao对象，并在运行时调用setUserDao方法来设置依赖关系。</p><p>使用Cglib和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDaoInterceptor拦截器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法执行前做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"Before method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="comment">// 在方法执行后做一些事情</span></span><br><span class="line">        System.out.println(<span class="string">"After method "</span> + method.getName() + <span class="string">" called"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Spring配置文件中进行配置</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserService"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"userDaoProxy"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoProxy"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.cglib.proxy.Enhancer"</span></span><br><span class="line">        factory-method=<span class="string">"create"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"com.example.UserDao"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"interceptor"</span></span><br><span class="line">        ref=<span class="string">"userDaoInterceptor"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userDaoInterceptor"</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.UserDaoInterceptor"</span>/&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring使用Cglib创建一个名为userDaoProxy的代理类，这个代理类继承自UserDao类，并在运行时动态生成。代理类中有一个拦截器UserDaoInterceptor，它会在UserDao类的方法执行前后做一些额外的处理，比如日志记录等。当Spring需要注入UserDao依赖时，会注入userDaoProxy代理类，代理类会使用反射来设置依赖关系。此外，当调用UserService的saveUser方法时，userDaoProxy代理类会通过反射调用UserDao的save方法，并在方法执行前后调用UserDaoInterceptor的相关方法。</p><p><a name="jlq4z"></a></p><h3 id="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"><a href="#只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？" class="headerlink" title="只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？"></a>只使用反射与使用JDk动态代理和反射来完成依赖注入有什么区别？</h3><p>使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象。<br />举个例子，假设有一个UserService接口和UserService实现类，实现类需要注入一个UserDao对象。下面分别使用反射和JDK动态代理来完成依赖注入：<br />使用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            userDao = (UserDao) constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用Class.forName方法获取UserDaoImpl类的Class对象，然后使用反射获取构造函数，并创建UserDaoImpl对象。</p><p>使用JDK动态代理和反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.example.UserDaoImpl"</span>);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">            Object dao = constructor.newInstance();</span><br><span class="line">            method.invoke(target, dao);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">this</span>);</span><br><span class="line">        ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">        userDao = (UserDao) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; UserDao<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">proxy</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个UserServiceProxy代理类，实现了InvocationHandler接口，并重写了invoke方法。在invoke方法中，如果是set方法，我们使用反射获取UserDaoImpl类的Class对象和构造函数，创建UserDaoImpl对象，并通过反射调用set方法来完成依赖注入。否则，我们通过反射调用目标对象的方法。</p><p>然后，在UserServiceImpl构造方法中，我们创建了UserServiceProxy代理对象，并使用Proxy.newProxyInstance方法创建了一个UserDao的代理对象。这个代理对象会拦截所有UserDao的方法调用，并通过InvocationHandler的invoke方法进行处理。</p><p>需要注意的是，由于代理对象实现了UserDao接口，因此在使用代理对象时，需要将其转换为UserDao类型。</p><p>总的来说，使用反射和使用JDK动态代理和反射来完成依赖注入的区别在于生成的代理对象不同。使用反射生成的对象是原始对象的副本，而使用JDK动态代理生成的对象是原始对象的代理对象，可以对其方法进行拦截和处理。</p><p><a name="j91gI"></a></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><a name="AQ3Uy"></a></p><h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3><p>Cglib是通过字节码生成技术来实现动态代理的，它会在运行时动态生成被代理类的子类，并在子类中覆盖被代理类的方法，从而实现方法拦截和增强。</p><p>在Spring中，当使用Cglib代理时，Spring会在运行时动态生成被代理类的子类，并在子类中实现依赖注入。Cglib会通过反射机制获取被代理类的构造函数和参数，然后通过Constructor.newInstance方法创建被代理类的实例。</p><p>具体来说，Spring会在运行时动态生成一个类，继承被代理类，并重写其中需要拦截和增强的方法。同时，它还会在生成的类中添加一个无参构造函数，并在其中通过反射机制实例化被代理类，并完成依赖注入。在这个过程中，Cglib会使用asm字节码操作库来生成字节码，完成类的定义和加载。</p><p>因此，使用Cglib代理时，它会通过字节码生成技术来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用JDK动态代理，不需要被代理类实现接口，可以拦截和增强非public方法，但是会比JDK动态代理更消耗内存和CPU资源。<br><a name="Mu6c3"></a></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过反射机制来实现动态代理的，它会在运行时动态生成一个实现了被代理接口的代理类，并在代理类中实现方法拦截和增强。</p><p>在Spring中，当使用JDK动态代理时，Spring会使用Java提供的Proxy类来生成代理类，并在代理类中实现依赖注入。具体来说，Spring会使用Proxy类的newProxyInstance方法来生成代理类，该方法需要传入一个ClassLoader对象、一组被代理的接口、和一个InvocationHandler对象。在生成代理类的过程中，JDK动态代理会通过反射机制获取被代理接口的方法，然后通过InvocationHandler对象的invoke方法来进行方法的拦截和增强。</p><p>因此，使用JDK动态代理时，它会通过反射机制来实例化Bean，并通过反射机制完成依赖注入。这种方式相对于使用Cglib代理，需要被代理类实现接口，不能拦截和增强非public方法，但是会比Cglib代理更节省内存和CPU资源。<br><a name="UrKkw"></a></p><h3 id="Cglib相对于JDK动态代理"><a href="#Cglib相对于JDK动态代理" class="headerlink" title="Cglib相对于JDK动态代理"></a>Cglib相对于JDK动态代理</h3><p>Cglib相对于JDK动态代理来说，有以下两个方面的优势，导致它在一些情况下可能比JDK动态代理更快：</p><ol><li><p>Cglib代理不需要被代理类实现接口，可以拦截和增强非public方法，而JDK动态代理只能代理实现了接口的类。因此，在需要拦截非public方法的情况下，Cglib代理可能比JDK动态代理更适合。</p></li><li><p>在拦截方法调用的时候，Cglib代理不需要调用被代理类的方法，而JDK动态代理需要通过反射调用被代理类的方法。因此，在需要进行大量方法调用的情况下，Cglib代理可能比JDK动态代理更快。</p></li></ol><p>总的来说，Cglib代理和JDK动态代理各有优缺点，在具体的应用场景中需要根据实际情况选择合适的代理方式。</p><p><a name="aSPZk"></a></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><a name="eXFA4"></a></p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理是基于继承来实现代理，它会在运行时动态生成目标对象的子类，并在子类中重写目标对象的非final方法，从而实现对目标对象的代理。这个子类会被当作代理类，被加载到JVM中，并用来完成方法调用。</p><p>具体来说，Cglib会使用ASM等字节码操作库生成代理类的字节码，然后通过ClassLoader将其加载到JVM中。生成的代理类会继承目标对象的类，并重写目标对象的非final方法。在生成代理类后，Cglib会创建代理对象，这个代理对象实际上就是生成的代理类的实例。当代理对象调用目标对象的方法时，实际上是调用了生成的代理类中重写的方法，从而实现了代理的功能。</p><p>因此，Cglib生成的子类会替代原始的目标对象，成为代理对象的实现。这个子类重写了目标对象的方法，从而实现了对目标对象方法的增强和拦截。<br><a name="r0cru"></a></p><h3 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是基于接口来实现代理的，它会在运行时动态生成一个代理接口的代理类，并将这个代理类实例化成代理对象。这个代理类会实现目标对象实现的接口，并且会拦截所有接口中定义的方法调用。</p><p>具体来说，JDK动态代理会在运行时使用Java反射机制动态生成代理类的字节码，并将其加载到JVM中。生成的代理类会实现目标对象实现的接口，并在代理类中实现对目标对象方法的拦截和增强。当代理对象调用目标对象的方法时，实际上是通过反射机制调用了代理类中的方法，从而实现了代理的功能。</p><p>因此，JDK动态代理实现了对接口的代理，可以通过实现一个代理接口来实现代理功能，而且可以在运行时动态生成代理类，并将其加载到JVM中，实现了对目标对象的动态代理。同时，由于是基于接口来实现代理的，所以在类型上更加灵活，但也因为这个原因，只能代理实现了接口的类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;Bk5lF&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;br /&gt;&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;vHThd&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现IOC&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于循环依赖的见解</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/12/18/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-12-18T12:20:46.000Z</published>
    <updated>2023-04-26T10:14:11.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于循环依赖的见解"><a href="#关于循环依赖的见解" class="headerlink" title="关于循环依赖的见解"></a>关于循环依赖的见解</h1><p>关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章（虽然很多是错误的）。</p><p>发现，<strong>其实二级缓存就能够解决循环依赖问题，根本不需要三级缓存</strong>。</p><p>首先，在单纯IOC的状态下，出现了循环依赖问题，在Bean不涉及代理对象的情况下，是只需要二级缓存的，但是很多文章说，因为涉及到AOP产生了代理对象，所以需要三级缓存，因为二级缓存和三级缓存存的对象不一样。但实际上，就算直接使用二级缓存，也是可以解决循环依赖问题，即使他们不一样。</p><p><strong>在任何状态下，二级缓存都能够完全的解决循环依赖问题，不管Bean有没有产生代理</strong>。</p><p>证明：(代补充)</p><p>但是Spring 为什么还是要使用三级缓存呢？因为设计者对于AOP一直都有一个原则：<strong>在对象初始化完毕后，再去创建代理对象</strong> </p><p>所以<strong>设计者一直在试图延迟代理对象的创建</strong>：</p><p>举例：</p><p>只有二级缓存：</p><p>1、发生了循环依赖，自然，在需要的时候就创建出来代理对象，放入缓存</p><p>2、没发生循环依赖，但是还是每一个对象在创建出原始对象后，就都会去创建代理对象</p><p>有三级缓存：</p><p>1、发生了循环依赖，在需要的时候就创建出来代理对象，放入二级缓存。</p><p>2、没发生循环依赖，正常的在初始化的后置处理器中创建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于循环依赖的见解&quot;&gt;&lt;a href=&quot;#关于循环依赖的见解&quot; class=&quot;headerlink&quot; title=&quot;关于循环依赖的见解&quot;&gt;&lt;/a&gt;关于循环依赖的见解&lt;/h1&gt;&lt;p&gt;关于循环依赖这一块，其实我一直充满着疑惑，因为我自己尝试着去实现了一下，看了很多文章</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Spring/"/>
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty+Nacos+Protobuf制作RPC框架</title>
    <link href="https://github.com/Pandalee99/pandalee99.github.io/2022/11/02/srpc/"/>
    <id>https://github.com/Pandalee99/pandalee99.github.io/2022/11/02/srpc/</id>
    <published>2022-11-02T06:39:27.000Z</published>
    <updated>2023-04-18T08:23:57.368Z</updated>
    
    <content type="html"><![CDATA[<p><a name="ly3F9"></a></p><h1 id="使用Netty-Nacos-Protobuf制作RPC框架"><a href="#使用Netty-Nacos-Protobuf制作RPC框架" class="headerlink" title="使用Netty+Nacos+Protobuf制作RPC框架"></a>使用Netty+Nacos+Protobuf制作RPC框架</h1><p><a name="KeQ2k"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a name="FQTT2"></a></p><h3 id="显现的功能"><a href="#显现的功能" class="headerlink" title="显现的功能"></a>显现的功能</h3><p>这个RPC实现了一些基本的功能：</p><ul><li>使用Netty来进行网络传输，效率比起传统的NIO要高很多。</li><li>使用单例模式，在Netty获取Channel的过程中，会有一个ChannelProvider去提供Channel单例。</li><li>使用Nacos作为服务的注册中心，用于管理注册的服务，当客户端请求发过来时，Nacos会寻找合适的服务返回给客户端消费。</li><li>实现了负载均衡的功能，，客户端对于Nacos返回的服务列表，会使用负载均衡算法，选择一个自己需要的服务加入，目前实现了轮询算法和随机选取算法。</li><li>加入了心跳检测机制，并不会发送完消息立即结束，而是保持的长连接，提高效率。</li><li>使用Potobuf作为对象的的序列化工具，实现Netty中的编/解码的功能，提高了效率。</li><li>实现了钩子函数，当服务端下线的时候会自动去Nacos注销服务。</li><li>使用CompletableFuture来接受客户端返回的结果。</li></ul><p><a name="UlREa"></a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>由于使用Nacos，调试比较简单：<br />下载好Nacos，无论是win版还是linux版，在官网都有，比较方便；<br />但是由于Nacos一般都要配置数据库，为了方便测试，可以使用命令先进行单机运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">114514</span>, <span class="string">"Client send a Message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> NettyServer(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后会有一个测试结果：<br />客户端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513541152-f58818bf-b30d-438c-bebd-3374cb6f6b3f.png#averageHue=%23f5ecea&clientId=ucfcf756b-0ecd-4&from=paste&height=400&id=uc9973f1d&name=image.png&originHeight=600&originWidth=2205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111506&status=done&style=none&taskId=ubbd01eee-67bf-4697-b872-6eef4c3b304&title=&width=1470" alt="image.png"><br />服务端收到信息<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/34531809/1678513584290-393ae7f9-f650-4a6d-b6a2-ad58cd7c2360.png#averageHue=%23f5ebe9&clientId=ucfcf756b-0ecd-4&from=paste&height=301&id=u72da898a&name=image.png&originHeight=452&originWidth=2307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88585&status=done&style=none&taskId=u57f54541-d548-4720-aca7-051e4b65050&title=&width=1538" alt="image.png"></p><p><a name="VFwOu"></a></p><h2 id="服务端分析"><a href="#服务端分析" class="headerlink" title="服务端分析"></a>服务端分析</h2><p>首先服务端都会实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.PROTOBUF_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口通常定义了默认的序列化方法，开始方法，和发布服务的方法。<br />接着会有一个抽象类去实现这个接口：<br><a name="DbRAB"></a></p><h3 id="AbstractRpcServer"><a href="#AbstractRpcServer" class="headerlink" title="AbstractRpcServer"></a>AbstractRpcServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"启动类缺少 @ServiceScan 注解"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"出现未知错误"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service<span class="class">.<span class="keyword">class</span>).<span class="title">name</span>()</span>;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"创建 "</span> + clazz + <span class="string">" 时有错误发生"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">""</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    这段代码是在判断 Service 注解中的 name 属性是否为空，如果为空，</span></span><br><span class="line"><span class="comment">                    则说明该服务实现类实现了多个接口，并且需要将每个接口都发布成一个独立的服务。</span></span><br><span class="line"><span class="comment">                    所以，代码通过获取该服务实现类的所有接口，然后将每个接口都作为一个独立的服务进行发布。</span></span><br><span class="line"><span class="comment">                    如果 name 属性不为空，则说明只需要将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                    此时，代码直接将该服务实现类作为一个服务进行发布。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanServices 的作用：这段代码是服务扫描的核心实现，它通过获取启动类的信息，获取服务扫描的基础包路径，然后扫描该路径下的所有类，判断是否有@Service注解，如果有，就将该服务发布到注册中心。<br />具体的实现流程如下：</p><ol><li>调用ReflectUtil.getStackTrace()方法获取当前方法调用的栈信息，得到启动类的全限定名。</li><li>使用Class.forName()方法加载启动类，判断启动类是否被@ServiceScan注解所标注，如果没有则抛出异常。</li><li>获取@ServiceScan注解的参数值，即基础包路径。</li><li>调用ReflectUtil.getClasses()方法获取指定包下的所有类，遍历这些类，判断是否被@Service注解所标注。</li><li>如果被@Service注解所标注，则获取@Service注解的参数值，即服务名称，如果未指定服务名称，则获取该服务实现类实现的所有接口，并将该服务发布到注册中心。</li><li>如果指定了服务名称，则直接将该服务发布到注册中心。</li></ol><p>该方法主要的功能就是扫描服务，将服务发布到注册中心，为后续的服务调用提供依据<br />接着我们来看看这个所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个服务提供类，用于远程接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务扫描的基包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上述提到的ReflectUtil这个类是一个比较常见的类，这个类是一个工具类，提供了两个静态方法：getStackTrace(): 返回当前调用栈顶部的类名。利用Java的反射机制，调用 new Throwable().getStackTrace() 方法获取当前调用栈信息，返回调用栈顶部的类名。<br />getClasses(String packageName): 获取指定包名下所有的类。该方法通过输入一个包名，然后通过反射机制查找该包下的所有类，返回一个 Set&lt;Class&lt;?&gt;&gt; 对象。该方法实现的过程比较复杂，具体过程为：</p><ol><li>通过 Thread.currentThread().getContextClassLoader().getResources(packageDirName) 获取指定包名下的所有资源。</li><li>遍历所有资源，如果是文件，则通过递归方式查找该文件夹下所有的类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li><li>如果是 Jar 包，则通过 JarFile 对象查找该 Jar 包中的所有类，并将类对象添加到 Set&lt;Class&lt;?&gt;&gt; 集合中。</li></ol><p>该工具类可以用于类加载器等需要动态加载类的场景，例如 Spring 框架中的 Bean 加载、RPC 框架中的服务注册等</p><p><a name="azGEB"></a></p><h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><p>接着便是这个RPC服务端的逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同时也继承了serviceRegistry和serviceProvider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 256)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"启动服务器时有错误发生: "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类实现了一个基于Netty框架的RPC服务器，它继承了抽象类AbstractRpcServer，并且拥有服务注册表（serviceRegistry）和服务提供者（serviceProvider）的实例。<br />在构造函数中，传入了服务器的主机名和端口号，以及序列化器（serializer）。在构造函数中还调用了扫描服务的方法scanServices()。<br />在start()方法中，创建了两个EventLoopGroup，用于处理连接和IO的事件。然后使用ServerBootstrap创建了一个服务端的引导类，通过设置一系列的选项和处理器来配置Netty服务器。其中，ChannelInitializer是一个特殊的处理器，用于在Channel被创建时执行一些初始化操作。在这个ChannelInitializer中，注册了一个IdleStateHandler用于处理空闲连接，以及自定义的编解码器和处理器。<br />最后，通过调用bind()方法绑定主机名和端口号，并且调用sync()方法等待服务器启动完成。当关闭服务器时，调用shutdownGracefully()方法优雅地关闭EventLoopGroup。<br />这就是这个类的大体流程，接下来，可以一个个分开来看<br />其中，NacosServiceRegistry会返回一个服务注册器实例，但是这个实例实际上会调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"注册服务时有错误发生:"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是NacosUtil去实现服务注册：<br><a name="Q2Adh"></a></p><h4 id="NacosUtil"><a href="#NacosUtil" class="headerlink" title="NacosUtil"></a>NacosUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">"127.0.0.1:8848"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接到Nacos时有错误发生: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"注销服务 &#123;&#125; 失败"</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个Nacos工具类，用于连接到Nacos服务注册中心并与之进行交互。主要包含以下几个方法：</p><ol><li>getNacosNamingService()方法用于获取NacosNamingService实例。</li><li>registerService(String serviceName, InetSocketAddress address)方法用于向Nacos注册服务实例，即将提供服务的服务地址和端口注册到Nacos中，以便客户端可以通过服务名称查找到该服务。</li><li>getAllInstance(String serviceName)方法用于获取指定服务名称下的所有服务实例，返回一个Instance列表。</li><li>clearRegistry()方法用于清空注册中心中注册的服务实例，即将服务注销。</li></ol><p>通过这个工具类，我们可以将服务注册到Nacos服务注册中心，并通过Nacos中心来查找并获取服务实例，以便客户端可以通过服务名称调用相应的服务。<br><a name="wIRIl"></a></p><h4 id="ServiceProviderImpl"><a href="#ServiceProviderImpl" class="headerlink" title="ServiceProviderImpl"></a>ServiceProviderImpl</h4><p>而ServiceProviderImpl默认的服务注册表，保存服务端本地服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">"向接口: &#123;&#125; 注册服务: &#123;&#125;"</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个服务提供者的默认实现类，它实现了 ServiceProvider 接口中的方法，可以将提供者实例添加到服务注册表中，提供了一种方便地访问服务的方式。在服务注册表中，服务名与服务实例之间的映射关系是使用 ConcurrentHashMap 实现的。它有两个主要方法：</p><ol><li>addServiceProvider(T service, String serviceName)：将服务提供者添加到服务注册表中，当服务名已经存在于注册表中时，则不进行任何操作。</li><li>getServiceProvider(String serviceName)：根据服务名从服务注册表中获取相应的服务实例。如果服务不存在，则抛出 RpcException 异常，表示未找到服务。</li></ol><p><a name="RA6ZR"></a></p><h4 id="ShutdownHook"><a href="#ShutdownHook" class="headerlink" title="ShutdownHook"></a>ShutdownHook</h4><p>当一个服务开启之后，也会开始一个钩子函数，它的Runtime类会使用getRuntime().addShutdownHook()方法，在服务结束前，注销掉所有的在Nacos的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"关闭后将自动注销所有服务"</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个单例，它提供了一个静态方法getShutdownHook()来获取一个实例。它注册了一个JVM shutdown hook，该hook会在JVM关闭前被执行，清除所有注册到Nacos服务注册中心上的服务和所有线程池。这个类的作用是确保在JVM关闭前执行清除操作，避免可能的资源泄漏和数据一致性问题。</p><p><a name="klHf5"></a></p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>这里在SocketChannel中加入了一个IdleStateHandler，使其具有心跳检测功能<br />在 Netty 中，IdleStateHandler 是一个用于处理空闲状态的处理器。它可以在 Channel 上检测特定类型的空闲时间，并在这些时间段内未发生读取、写入或读写事件时触发相应的事件。常用的空闲状态类型有三种：READER_IDLE，WRITER_IDLE 和 ALL_IDLE。<br />IdleStateHandler 可以用于实现心跳机制，可以通过配置空闲时间间隔和触发事件来判断是否需要发送心跳包。它可以被添加到 Netty 的 ChannelPipeline 中，以监视 Channel 上的空闲事件，以便可以采取适当的措施，例如关闭连接或发送心跳消息。</p><p><a name="fWDhA"></a></p><h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><p>这里也同时添加了一个NettyServerHandler去处理在Channel中发生的时间。<br />先拿上面的心跳检测为例子，如果收到了一个心跳包，便会打印一条日志，告诉服务端收到了。而在长时间没有收到心跳包后，则会关闭上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">"接收到客户端心跳包..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"服务器接收到请求: &#123;&#125;"</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"通道不可写"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"处理过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"长时间未收到心跳包，断开连接..."</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleChannelInboundHandler 是 Netty 中的一个基础类，实现了 ChannelInboundHandler 接口。它主要用于处理入站事件，即从对等端接收到的数据或状态更改事件，例如对等端连接或断开连接。与 ChannelInboundHandlerAdapter 不同的是，SimpleChannelInboundHandler 可以自动释放资源，因此不需要显示地调用 ReferenceCountUtil.release() 释放资源。<br />当数据从远程节点传入时，SimpleChannelInboundHandler 将自动将其转换为指定类型的对象，并在调用 channelRead0() 方法时向你提供该对象，你只需要处理传入的数据。可以使用这个类来构建各种应用程序，例如聊天应用程序、游戏服务器、文件传输应用程序等。<br />而这里的requestHandler是一个单例，表示全程都使用这个单例去处理请求，这样就不会浪费大量的资源去重复创建实例。<br><a name="MTSdN"></a></p><h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">"服务:&#123;&#125; 成功调用方法:&#123;&#125;"</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个RequestHandler使用的方法不多，最为主要的方法还是：<br>:::info<br>result = method.invoke(service, rpcRequest.getParameters());<br>:::<br>这个方法会调用Method实例的invoke方法，去执行相应的请求。<br />在Java中，Method类是反射机制的一部分，它代表一个类中的一个方法。可以使用Method类来获取关于方法的信息，如方法名、参数列表、返回类型、修饰符等，并且可以使用Method类来调用该方法。Method类提供了许多用于获取和调用方法的方法，如invoke()、getName()、getParameterTypes()、getReturnType()等。反射机制中的Method类可以使得在运行时动态地获取和调用类中的方法。</p><p><a name="Le2TA"></a></p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器可以说是整个RPC框架中最为重要的一部分，那么RPC为什么需要编解码器呢？<br />因为在RPC通信过程中，数据需要在网络中传输。在不同的计算机之间通信需要将对象序列化为字节流，传输完成后再反序列化为对象。编解码器的作用就是将对象序列化和反序列化的过程封装起来，让开发者可以更方便地进行通信。在Netty中，SimpleChannelInboundHandler类可以自动完成消息的解码和编码，大大简化了编解码器的编写过程。<br />那为什么不用直接用序列化？<br />虽然序列化可以将对象转换成字节流进行网络传输，但是它并不能满足RPC的需求。<br />RPC需要一个通用的方式来序列化和反序列化各种类型的消息，包括基本数据类型、复合数据类型和自定义类型等。而不同的序列化实现可能只支持特定的类型或数据格式，因此无法满足这个需求。<br />此外，RPC需要支持不同的编解码器，以便兼容不同的协议和框架。使用编解码器可以使得不同的实现之间相互兼容，也方便进行协议升级和兼容性处理。<br />因此，编解码器是RPC中必不可少的组件，它能够实现通用的序列化和反序列化，同时兼容不同的协议和框架，满足RPC的需求。</p><p><a name="BVL84"></a></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>MessageToByteEncoder 是 Netty 提供的编码器抽象类，用于将消息转换为字节流进行网络传输。在 Netty 应用中，可以使用它将自定义的消息对象编码为二进制数据，以便通过网络进行传输。<br />实现 MessageToByteEncoder 需要重写 encode() 方法，该方法会在消息被写入通道前被自动调用。在 encode() 方法中，我们需要将消息对象转换为字节流，并将字节流写入到 ByteBuf 中。写入到 ByteBuf 中的字节流会在后续的 ChannelHandler 中被传递，最终通过网络传输到远程节点。<br />MessageToByteEncoder 中还提供了一些辅助方法，如 writeXXX() 系列方法可以将不同类型的数据写入到 ByteBuf 中，以及提供了一些钩子方法，可以在编码过程中对消息进行处理，比如对消息进行压缩、加密等操作。<br />总之，MessageToByteEncoder 是 Netty 提供的编码器抽象类，通过继承它可以实现自定义的消息编码器。<br />CommonEncoder继承了MessageToByteEncoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 Netty 中的编码器类，用于将消息对象转换为二进制字节流，以便在网络上进行传输。在 RPC 中，消息通常是由客户端和服务端之间相互传递的。因为在不同的机器之间传递数据时，需要将数据序列化为二进制流，才能在网络中传输。但是，不同的序列化方式可能具有不同的数据格式和协议，所以需要使用编解码器来统一数据格式和协议。这个类实现了 Netty 中的 MessageToByteEncoder 类，并将消息对象编码为二进制流，遵循了一个特定的协议，包括一个魔数、消息类型、序列化方式、消息长度和消息内容。其中，魔数用于识别协议版本，消息类型用于标识消息是请求还是响应，序列化方式用于指定消息内容的序列化方式，消息长度用于指定消息内容的长度，消息内容就是序列化后的消息体。这个类是 RPC 通信中必不可少的一部分。</p><p><a name="Mudkb"></a></p><h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>ReplayingDecoder是Netty提供的一种特殊类型的解码器。与普通解码器不同，ReplayingDecoder可以在缓冲区数据不足时进行暂停，并在数据可用时恢复处理，而不是等待缓冲区填满。<br />具体来说，ReplayingDecoder类通过继承ByteToMessageDecoder类并使用状态机模式实现。状态机模式通过在每个状态中重写decode()方法来定义不同的处理行为。当状态更改时，它将转移到下一个状态，直到解码完成为止。<br />ReplayingDecoder的主要作用是简化解码器的实现，尤其是对于一些不确定数据长度的解码器。通过使用ReplayingDecoder，可以避免手动跟踪缓冲区中的字节数，从而减少出错的可能性。同时，ReplayingDecoder还可以提供更好的性能，因为它只需要处理缓冲区中实际可用的数据，而不是缓冲区中的所有数据<br />CommonDecoder继承了ReplayingDecoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的协议包: &#123;&#125;"</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的数据包: &#123;&#125;"</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"不识别的反序列化器: &#123;&#125;"</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是一个Netty解码器，用于将字节流转换为对象。具体来说，它的作用是将从网络中接收到的字节流解码为指定的Java对象，以供后续处理。<br />在方法decode()中，它首先读取一个整数值，如果它不等于预定义的一个常量值，就会抛出一个RpcException异常，这表示该字节流不是正确的RPC协议包。接下来，它读取协议包类型和序列化器类型，并检查它们是否为预期值，否则将抛出异常。然后，它读取字节流的长度，并将剩余的字节读入到字节数组中。最后，它使用指定的序列化器将字节流反序列化为预期的Java对象，并将其添加到输出列表中</p><p><a name="y5CbI"></a></p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protocol Buffers（简称protobuf）是一种轻便高效的数据序列化格式，由Google开发。它与XML和JSON等格式相比，具有更小的数据体积和更快的解析速度，同时也可以生成各种编程语言的代码，从而方便了跨语言的数据交换和通信。在Java中，我们可以通过使用Protobuf库来实现Protobuf的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; schemaCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        Class clazz = obj.getClass();</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = getSchema(clazz);</span><br><span class="line">        Object obj = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">"PROTOBUF"</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Schema <span class="title">getSchema</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        Schema schema = schemaCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(schema)) &#123;</span><br><span class="line">            <span class="comment">// 这个schema通过RuntimeSchema进行懒创建并缓存</span></span><br><span class="line">            <span class="comment">// 所以可以一直调用RuntimeSchema.getSchema(),这个方法是线程安全的</span></span><br><span class="line">            schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(schema)) &#123;</span><br><span class="line">                schemaCache.put(clazz, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个实现了CommonSerializer接口的类，用于将Java对象序列化为Protobuf格式的字节数组，或者将字节数组反序列化为Java对象。<br />具体来说，该类中的serialize方法将一个Java对象序列化为Protobuf格式的字节数组，实现过程如下：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>使用该Schema对象和LinkedBuffer对象调用ProtostuffIOUtil.toByteArray方法将Java对象序列化为字节数组。</li><li>最后清空LinkedBuffer对象并返回序列化后的字节数组。</li></ol><p>而deserialize方法则是将字节数组反序列化为Java对象：</p><ol><li>获取对象的类类型Class clazz。</li><li>通过getSchema方法获取该类对应的Schema对象。</li><li>调用schema.newMessage()创建一个该类的空对象。</li><li>使用字节数组和Schema对象调用ProtostuffIOUtil.mergeFrom方法将字节数组反序列化为Java对象并返回。</li></ol><p>同时，为了提高性能，该类中使用了缓存机制，通过ConcurrentHashMap缓存Schema对象，以便在下次序列化或反序列化时能够更快地获取Schema对象，避免了重复创建的开销。</p><p>在具体的分析下面类的作用：<br><a name="RoCQJ"></a></p><h4 id="LinkedBuffer"><a href="#LinkedBuffer" class="headerlink" title="LinkedBuffer"></a>LinkedBuffer</h4><p>LinkedBuffer是Protostuff序列化库中的一个类，用于在序列化过程中存储数据。它是一个基于链表的动态缓存区，它会自动根据当前写入数据的大小来调整缓存区的大小。<br />具体来说，LinkedBuffer维护了一个字节数组（即缓存区），一个指向缓存区首部的指针和一个指向缓存区尾部的指针。当我们往缓存区写入数据时，LinkedBuffer会先检查当前剩余的空间是否足够，如果不够则会自动扩展缓存区。扩展时会新建一个更大的缓存区，并将当前缓存区中的数据复制到新缓存区中，然后将新缓存区设置为当前缓存区。<br />LinkedBuffer使用链表来管理多个缓存区，每次扩展时都会新建一个缓存区并添加到链表尾部。这样做的好处是可以避免频繁的内存分配和拷贝，从而提高序列化性能。<br />在上面的代码中，LinkedBuffer被用于在ProtobufSerializer类中序列化对象时存储数据。当我们调用ProtostuffIOUtil.toByteArray()方法将一个对象序列化为字节数组时，需要传入一个LinkedBuffer对象作为参数，这个对象会在序列化过程中被自动扩展。当序列化完成后，我们需要手动调用LinkedBuffer.clear()方法清空缓存区，以便下次使用。<br><a name="I3nN9"></a></p><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>在 Protobuf 序列化中，Schema 是一个用于描述消息结构的类，类似于 Java 对象中的 Class。Schema 类的实例提供了一些方法来获取消息的字段和类型信息，从而可以将消息序列化和反序列化为二进制数据。<br />在使用 Protobuf 进行序列化时，我们需要为每个消息类创建一个 Schema 对象，并将其缓存起来以供重复使用。这样可以提高序列化和反序列化的效率，避免重复创建和解析 Schema 对象。<br />在上面提供的 ProtobufSerializer 类中，getSchema 方法用于获取指定类型的 Schema 对象。如果缓存中已经存在该类型的 Schema 对象，则直接返回；否则，使用 RuntimeSchema.getSchema 方法创建一个新的 Schema 对象，并将其存入缓存中。这样，在序列化和反序列化时，就可以直接使用缓存中的 Schema 对象，提高了性能。<br><a name="FAUkt"></a></p><h4 id="ProtostuffIOUtil"><a href="#ProtostuffIOUtil" class="headerlink" title="ProtostuffIOUtil"></a>ProtostuffIOUtil</h4><p>ProtostuffIOUtil是Protostuff序列化框架中的一个工具类，主要提供了将Java对象序列化成byte数组和将byte数组反序列化成Java对象的功能。<br />它提供了以下主要的静态方法：</p><ul><li>toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)：将一个Java对象序列化成byte数组。</li><li>fromByteArray(byte[] data, T message, Schema<T> schema)：将一个byte数组反序列化成Java对象。</li><li>mergeFrom(byte[] data, T message, Schema<T> schema)：将一个byte数组中的数据合并到一个Java对象中。</li></ul><p>其中，Schema是Protostuff序列化框架中的一个关键接口，用于描述Java对象的序列化格式。而LinkedBuffer则是一个可扩容的缓冲区，用于存储序列化后的数据。在使用Protostuff进行序列化时，可以通过LinkedBuffer.allocate()方法创建一个缓冲区，用于存储序列化后的数据。<br><a name="S4KTX"></a></p><h4 id="RuntimeSchema"><a href="#RuntimeSchema" class="headerlink" title="RuntimeSchema"></a>RuntimeSchema</h4><p>RuntimeSchema是Protostuff库的一个类，它提供了将Java类转换为Protobuf格式的Schema的功能。在使用Protobuf进行序列化和反序列化时，需要提供一个Schema来指定序列化的字段、类型等信息。RuntimeSchema的作用就是根据Java类的结构生成一个对应的Schema。<br />通常情况下，使用Protobuf进行序列化和反序列化时，需要手动定义一个Proto文件来描述消息的结构。而使用RuntimeSchema，可以将Java类当作Proto文件来使用，它会自动生成一个对应的Schema。<br />需要注意的是，由于RuntimeSchema是在运行时生成的，因此会对性能产生一定影响。在高性能场景中，建议使用预编译的Proto文件来进行序列化和反序列化。</p><p><a name="njTxV"></a></p><h2 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a>客户端分析</h2><p>要实现客户端的逻辑，最基本的就是要实现动态代理：<br />InvocationHandler 是 Java 标准库中的一个接口，它用于实现动态代理。<br />动态代理是一种运行时生成代理对象的技术。使用动态代理可以在运行时动态地创建一个实现特定接口的代理类，这个代理类可以将所有方法调用委托给指定的对象或方法。在委托调用前或调用后，代理类可以执行额外的逻辑，例如统计方法调用次数、记录方法调用日志等。<br />InvocationHandler 接口定义了一个方法 invoke，该方法会在代理类每次调用方法时被调用。该方法有三个参数：</p><ol><li>proxy：代理对象</li><li>method：被调用的方法</li><li>args：被调用方法的参数列表</li></ol><p>invoke 方法的返回值是 Object 类型，它表示被调用方法的返回值。因此，当我们想要使用动态代理技术时，需要实现 InvocationHandler 接口并重写 invoke 方法，来控制代理类如何处理方法调用<br><a name="mEV6K"></a></p><h3 id="RpcClientProxy"><a href="#RpcClientProxy" class="headerlink" title="RpcClientProxy"></a>RpcClientProxy</h3><p>RpcClientProxy 将实现 InvocationHandler 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用方法: &#123;&#125;#&#123;&#125;"</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"方法调用请求发送失败"</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个远程调用的客户端代理类RpcClientProxy，实现了InvocationHandler接口，用于生成一个远程服务接口的代理对象。其中，RpcClient是一个抽象类，NettyClient和SocketClient分别是其子类，用于不同的网络传输方式进行远程调用。<br />该类中的getProxy方法，使用了Java动态代理技术，生成了一个实现了远程服务接口的代理对象，该代理对象的所有方法调用都会被拦截并转化为远程调用，从而实现了RPC远程调用的透明化。<br />在invoke方法中，通过封装一个RpcRequest对象来表示对远程服务的调用，并通过客户端发送请求获取到返回结果RpcResponse，最后将返回结果中的数据返回给调用方。在发送远程调用请求之前，还进行了一些简单的参数检查，确保请求的正确性和完整性。<br><a name="Jo1Tm"></a></p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机轮询策略来进行负载均衡</span></span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//另一个构造方法，表示自定义负载均衡策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注入服务发现</span></span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="comment">//序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="comment">//保留意见</span></span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"未设置序列化器"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"客户端发送消息: %s"</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">"发送消息时有错误发生: "</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个基于Netty的RPC客户端，实现了RpcClient接口，并且封装了发送请求的具体细节。<br />在类的静态代码块中，创建了一个EventLoopGroup和一个Bootstrap对象，用于配置Netty客户端。EventLoopGroup是处理事件循环的抽象类，Bootstrap则是用于客户端引导的类。在其中使用了NioEventLoopGroup和NioSocketChannel类来实现NIO客户端，这里用到了Netty的API。<br />接着在类的构造方法中，初始化了一个服务发现对象和一个序列化器对象。服务发现对象是用于从服务注册中心获取服务地址的。序列化器对象是用于将请求和响应对象序列化和反序列化的，该类的序列化器可以通过传入参数来选择使用哪种类型的序列化器。<br />在sendRequest方法中，首先判断序列化器是否为空，如果为空则抛出异常。然后通过服务发现对象获取到远程服务的地址，根据地址获取一个Channel对象，ChannelProvider.get方法会返回一个新的Channel或者已有的Channel，如果没有就会创建一个新的Channel。在获取到Channel对象后，使用Netty的writeAndFlush方法将请求对象发送到服务端，使用addListener添加一个ChannelFutureListener监听器，可以在发送成功或失败时执行相应的操作，如打印日志或者回调。发送请求时还将该请求的请求ID和响应结果对应的CompletableFuture对象存储到一个全局的UnprocessedRequests对象中。<br />最后，sendRequest方法返回一个CompletableFuture对象，用于异步等待响应结果。在响应结果到达时，UnprocessedRequests对象会将响应结果的CompletableFuture对象取出并使用complete方法设置结果。而调用sendRequest方法的线程会在CompletableFuture对象的get方法上阻塞，直到CompletableFuture对象的complete方法被调用为止，然后会返回响应结果。<br />接着我们一步步看这个客户端有哪些用到的类：</p><p><a name="Fzlss"></a></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡会共用一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有着其对应的实现。<br />随机策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮询策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以看到，无论是哪一种策略，都是要先获取到Instance实例，然后使用相应的负载均衡策略，那么这个实例，则是Nacos包提供的一个类，那么我们也自然需要一个Nacos方法来提供。</p><p><a name="fLeqg"></a></p><h3 id="NacosServiceDiscovery"><a href="#NacosServiceDiscovery" class="headerlink" title="NacosServiceDiscovery"></a>NacosServiceDiscovery</h3><p>服务发现类，同时也对上述的负载均衡做出了解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"找不到对应的服务: "</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"获取服务时有错误发生:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个 NacosServiceDiscovery 类，实现了 ServiceDiscovery 接口，主要用于在基于 Nacos 注册中心的服务发现中获取服务地址。具体作用如下：</p><ol><li>NacosServiceDiscovery 类有一个构造方法，用于初始化负载均衡策略，如果未指定，则默认使用随机负载均衡策略。</li><li>lookupService 方法用于获取指定服务名对应的 InetSocketAddress，通过调用 NacosUtil 工具类获取所有的服务实例，然后使用负载均衡策略选择一个实例，最终返回该实例的地址信息。</li><li>如果找不到对应的服务，则会抛出 RpcException 异常，并记录错误日志。</li></ol><p>总之，该类用于实现基于 Nacos 注册中心的服务发现功能，可以根据服务名从注册中心获取服务实例并进行负载均衡选择，返回可用的服务地址。</p><p><a name="XrnMt"></a></p><h3 id="UnprocessedRequests"><a href="#UnprocessedRequests" class="headerlink" title="UnprocessedRequests"></a>UnprocessedRequests</h3><p>这个类名为 UnprocessedRequests，用于处理未处理的RPC请求。同时也是更好的控制数据的获取，因为如果使用Netty自带的阻塞获取方法，太过于复杂了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中，使用了一个静态的 ConcurrentHashMap 对象，用于存储未处理的RPC请求。<br />其中，Key 值为请求的ID，Value 值为一个 CompletableFuture<RpcResponse> 对象，用于异步获取 RPC 响应结果。<br />这可以用来记录客户端发送的请求并等待响应。主要包含以下方法：</p><ol><li>put(String requestId, CompletableFuture<RpcResponse> future)：将请求 ID 和对应的 CompletableFuture 存储到 ConcurrentHashMap 中。</li><li>remove(String requestId)：从 ConcurrentHashMap 中删除指定的请求 ID。</li><li>complete(RpcResponse rpcResponse)：根据响应中的请求 ID 找到对应的 CompletableFuture 并将响应数据传递给它。如果没有找到对应的 CompletableFuture，则抛出 IllegalStateException 异常。</li></ol><p>这个类的作用是确保客户端发送的每个请求都有一个对应的 CompletableFuture 实例，用来等待服务器响应。在客户端收到服务器响应后，可以使用 UnprocessedRequests.complete() 方法将响应数据传递给对应的 CompletableFuture。这种机制使得客户端可以异步发送请求并等待响应，而不需要阻塞线程。<br><a name="rkJoD"></a></p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture类是Java8引入的一个异步编程工具，用于处理异步操作的结果。它提供了一些方法来处理异步任务的结果，例如将结果传递给下一个任务，等待任务完成，组合多个任务等。<br />在异步编程中，通常会使用回调函数来处理异步任务的结果，但这种方式会使代码变得冗长且难以维护。CompletableFuture类的出现，使得异步编程变得更加简单和可读。<br />CompletableFuture类有以下几个主要特点：</p><ol><li>可以将一个异步操作的结果传递给下一个操作，这种操作被称为”组合”。</li><li>可以等待一个异步操作的结果，并在操作完成后执行一些操作，例如打印日志、释放资源等。</li><li>可以在多个异步操作完成后执行一些操作，例如将它们的结果组合起来，计算它们的平均值等。</li><li>可以通过异常处理机制来处理异步操作中的异常。</li></ol><p>使用CompletableFuture类，可以更加方便地处理异步任务，提高代码的可读性和可维护性。同时，它也是Java并发编程中非常有用的工具之一。<br><a name="PP3yo"></a></p><h3 id="ChannelProvider"><a href="#ChannelProvider" class="headerlink" title="ChannelProvider"></a>ChannelProvider</h3><p>这段代码实现了一个用于获取客户端 Channel 的工具类 ChannelProvider。它维护了一个 Map 类型的 channels 成员变量，用于缓存已经连接的 Channel 对象，通过 get 方法获取指定地址的 Channel 对象。</p><ol><li>在 get 方法中，首先根据地址和序列化器生成 key，从 channels 缓存中查找是否已有对应的 Channel 对象。如果有，就返回已有的 Channel 对象；如果没有，就通过 bootstrap 进行连接。在连接成功后，将新建的 Channel 对象存入 channels 缓存，并返回该对象。如果连接失败，返回 null。</li><li>在 connect 方法中，通过 CompletableFuture 异步获取连接结果。在连接成功后，将 Channel 对象作为 CompletableFuture 的返回值。</li><li>initializeBootstrap 方法则初始化 Bootstrap 对象，并设置一些常用的参数，如连接超时时间、是否启用 TCP 底层心跳机制等。</li></ol><p>ChannelProvider 为客户端连接提供了一个通用的方法，简化了客户端连接的过程，提高了代码的复用性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接客户端时有错误发生"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"客户端连接成功!"</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, 5000)</span></span><br><span class="line"><span class="class">                //是否开启 <span class="title">TCP</span> 底层心跳机制</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                //<span class="title">TCP</span>默认开启了 <span class="title">Nagle</span> 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。<span class="title">TCP_NODELAY</span> 参数的作用就是控制是否启用 <span class="title">Nagle</span> 算法。</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细一点的说：<br />这段代码实现了一个用于获取Netty客户端Channel的工具类ChannelProvider。它提供了一个get方法，该方法接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取与指定服务提供者（IP地址和端口号）之间的连接。该方法首先将InetSocketAddress和序列化器的编码方式作为key，从Map中查找已有的Channel。如果找到的Channel是可用的，那么直接返回这个Channel。如果找到的Channel不可用，那么将它从Map中删除。接下来创建一个新的Channel，该Channel使用了上述编码方式进行了初始化，并且连接到了指定的服务提供者，最后将新创建的Channel保存到Map中。<br />在ChannelProvider类中，包含了一个静态的EventLoopGroup类型的变量eventLoopGroup和一个静态的Bootstrap类型的变量bootstrap。在类初始化时，这些变量被初始化为一个NioEventLoopGroup和一个Bootstrap实例。Bootstrap实例会初始化连接到远程服务提供者的客户端的参数，包括TCP连接、超时时间、TCP底层心跳机制等。这就是Channel的模板，创建一次就好了，不用每次都创建一次，这样可以很好的减少代码冗余和提高复用性。</p><ul><li>get()方法是ChannelProvider的主要方法。它接收一个InetSocketAddress类型的参数和一个序列化器CommonSerializer，用于获取连接到指定服务提供者的Channel。首先，根据传入的参数，生成一个唯一的key，用于从Map中查找是否已经存在一个可用的Channel。如果找到的Channel是可用的，直接返回这个Channel对象。否则，创建一个新的Channel，并且将它保存到Map中。最后，返回新创建的Channel对象。</li><li>initChannel()方法用于初始化客户端Channel的pipeline。在这里，我们首先添加了一个自定义的序列化编解码器，然后添加了一个心跳检测处理器IdleStateHandler、一个通用解码器CommonDecoder和一个客户端处理器NettyClientHandler。这些处理器将按照顺序添加到客户端Channel的pipeline中。</li><li>connect()方法用于创建连接到指定服务提供者的Channel，并返回连接成功后的Channel对象。为了处理异步连接的结果，它使用了一个CompletableFuture对象completableFuture，该对象用于接收连接结果。当连接成功时，completableFuture将被设置为连接成功的Channel对象；当连接失败时，completableFuture将抛出异常。</li></ul><p>这个Channel包含的一个NettyClientHandler，有相应对收到请求的处理：<br><a name="ie8Yn"></a></p><h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">"客户端接收到消息: %s"</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"过程调用时有错误发生:"</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">"发送心跳包 [&#123;&#125;]"</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个 Netty 客户端处理器，用于处理服务器发送的响应消息。它继承了 Netty 的 SimpleChannelInboundHandler 类，实现了其中的 channelRead0() 方法和 exceptionCaught() 方法。<br />在channelRead0()方法中，通过UnprocessedRequests对象的complete()方法处理返回的RpcResponse对象。在此方法中，使用logger打印接收到的消息，然后调用UnprocessedRequests.complete()方法，将对应的CompletableFuture对象标记为完成，并将RpcResponse对象作为结果<br />在 exceptionCaught() 方法中，发生异常时，会先记录日志，然后关闭客户端通道。<br />另外，该类还重写了 userEventTriggered() 方法，用于发送心跳包。如果客户端在一段时间内没有发送数据，则会自动触发该方法，并向服务器发送一个心跳包。当客户端发送心跳包时，会调用 ChannelProvider 类的 get() 方法获取一个 Channel 对象，并向该 Channel 对象写入一个标记了心跳标志的 RpcRequest 对象，最后调用 close() 方法关闭该 Channel。</p><p><a name="RGhhY"></a></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;ly3F9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用Netty-Nacos-Protobuf制作RPC框架&quot;&gt;&lt;a href=&quot;#使用Netty-Nacos-Protobuf制作RPC框架&quot; class=&quot;headerlink&quot; title=&quot;使用Nett</summary>
      
    
    
    
    
    <category term="Java" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/Java/"/>
    
    <category term="RPC" scheme="https://github.com/Pandalee99/pandalee99.github.io/tags/RPC/"/>
    
  </entry>
  
</feed>
